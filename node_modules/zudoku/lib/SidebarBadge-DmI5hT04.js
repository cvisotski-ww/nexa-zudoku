import * as s from "react";
import { d as T, e as $, f as be, g as De, h as Ie, u as V, i as Ce, P as y, b as R, a as _, c as Ne, R as Ee, S as ye, j as he, k as Te, F as Ae, D as _e, l as Fe, m as we } from "./index-Do_BBSIs.js";
import { j as i } from "./jsx-runtime-B6kdoens.js";
import { a as Oe } from "./Markdown-CWI6lU11.js";
function Pe(e, t) {
  return s.useReducer((o, n) => t[o][n] ?? o, e);
}
var w = (e) => {
  const { present: t, children: o } = e, n = Se(t), r = typeof o == "function" ? o({ present: n.isPresent }) : s.Children.only(o), a = T(n.ref, Me(r));
  return typeof o == "function" || n.isPresent ? s.cloneElement(r, { ref: a }) : null;
};
w.displayName = "Presence";
function Se(e) {
  const [t, o] = s.useState(), n = s.useRef({}), r = s.useRef(e), a = s.useRef("none"), u = e ? "mounted" : "unmounted", [d, l] = Pe(u, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return s.useEffect(() => {
    const c = A(n.current);
    a.current = d === "mounted" ? c : "none";
  }, [d]), $(() => {
    const c = n.current, g = r.current;
    if (g !== e) {
      const b = a.current, m = A(c);
      e ? l("MOUNT") : m === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(g && b !== m ? "ANIMATION_OUT" : "UNMOUNT"), r.current = e;
    }
  }, [e, l]), $(() => {
    if (t) {
      let c;
      const g = t.ownerDocument.defaultView ?? window, v = (m) => {
        const D = A(n.current).includes(m.animationName);
        if (m.target === t && D && (l("ANIMATION_END"), !r.current)) {
          const h = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", c = g.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = h);
          });
        }
      }, b = (m) => {
        m.target === t && (a.current = A(n.current));
      };
      return t.addEventListener("animationstart", b), t.addEventListener("animationcancel", v), t.addEventListener("animationend", v), () => {
        g.clearTimeout(c), t.removeEventListener("animationstart", b), t.removeEventListener("animationcancel", v), t.removeEventListener("animationend", v);
      };
    } else
      l("ANIMATION_END");
  }, [t, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(d),
    ref: s.useCallback((c) => {
      c && (n.current = getComputedStyle(c)), o(c);
    }, [])
  };
}
function A(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function Me(e) {
  var n, r;
  let t = (n = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : n.get, o = t && "isReactWarning" in t && t.isReactWarning;
  return o ? e.ref : (t = (r = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : r.get, o = t && "isReactWarning" in t && t.isReactWarning, o ? e.props.ref : e.props.ref || e.ref);
}
var j = "rovingFocusGroup.onEntryFocus", je = { bubbles: !1, cancelable: !0 }, O = "RovingFocusGroup", [k, Y, ke] = be(O), [Le, at] = De(
  O,
  [ke]
), [Ge, Ue] = Le(O), H = s.forwardRef(
  (e, t) => /* @__PURE__ */ i.jsx(k.Provider, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ i.jsx(k.Slot, { scope: e.__scopeRovingFocusGroup, children: /* @__PURE__ */ i.jsx(We, { ...e, ref: t }) }) })
);
H.displayName = O;
var We = s.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: o,
    orientation: n,
    loop: r = !1,
    dir: a,
    currentTabStopId: u,
    defaultCurrentTabStopId: d,
    onCurrentTabStopIdChange: l,
    onEntryFocus: c,
    preventScrollOnEntryFocus: g = !1,
    ...v
  } = e, b = s.useRef(null), m = T(t, b), f = Ie(a), [D = null, h] = V({
    prop: u,
    defaultProp: d,
    onChange: l
  }), [I, C] = s.useState(!1), P = Ce(c), ge = Y(o), S = s.useRef(!1), [pe, K] = s.useState(0);
  return s.useEffect(() => {
    const p = b.current;
    if (p)
      return p.addEventListener(j, P), () => p.removeEventListener(j, P);
  }, [P]), /* @__PURE__ */ i.jsx(
    Ge,
    {
      scope: o,
      orientation: n,
      dir: f,
      loop: r,
      currentTabStopId: D,
      onItemFocus: s.useCallback(
        (p) => h(p),
        [h]
      ),
      onItemShiftTab: s.useCallback(() => C(!0), []),
      onFocusableItemAdd: s.useCallback(
        () => K((p) => p + 1),
        []
      ),
      onFocusableItemRemove: s.useCallback(
        () => K((p) => p - 1),
        []
      ),
      children: /* @__PURE__ */ i.jsx(
        y.div,
        {
          tabIndex: I || pe === 0 ? -1 : 0,
          "data-orientation": n,
          ...v,
          ref: m,
          style: { outline: "none", ...e.style },
          onMouseDown: R(e.onMouseDown, () => {
            S.current = !0;
          }),
          onFocus: R(e.onFocus, (p) => {
            const me = !S.current;
            if (p.target === p.currentTarget && me && !I) {
              const B = new CustomEvent(j, je);
              if (p.currentTarget.dispatchEvent(B), !B.defaultPrevented) {
                const M = ge().filter((N) => N.focusable), ve = M.find((N) => N.active), Re = M.find((N) => N.id === D), xe = [ve, Re, ...M].filter(
                  Boolean
                ).map((N) => N.ref.current);
                Z(xe, g);
              }
            }
            S.current = !1;
          }),
          onBlur: R(e.onBlur, () => C(!1))
        }
      )
    }
  );
}), z = "RovingFocusGroupItem", q = s.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: o,
      focusable: n = !0,
      active: r = !1,
      tabStopId: a,
      ...u
    } = e, d = _(), l = a || d, c = Ue(z, o), g = c.currentTabStopId === l, v = Y(o), { onFocusableItemAdd: b, onFocusableItemRemove: m } = c;
    return s.useEffect(() => {
      if (n)
        return b(), () => m();
    }, [n, b, m]), /* @__PURE__ */ i.jsx(
      k.ItemSlot,
      {
        scope: o,
        id: l,
        focusable: n,
        active: r,
        children: /* @__PURE__ */ i.jsx(
          y.span,
          {
            tabIndex: g ? 0 : -1,
            "data-orientation": c.orientation,
            ...u,
            ref: t,
            onMouseDown: R(e.onMouseDown, (f) => {
              n ? c.onItemFocus(l) : f.preventDefault();
            }),
            onFocus: R(e.onFocus, () => c.onItemFocus(l)),
            onKeyDown: R(e.onKeyDown, (f) => {
              if (f.key === "Tab" && f.shiftKey) {
                c.onItemShiftTab();
                return;
              }
              if (f.target !== f.currentTarget) return;
              const D = $e(f, c.orientation, c.dir);
              if (D !== void 0) {
                if (f.metaKey || f.ctrlKey || f.altKey || f.shiftKey) return;
                f.preventDefault();
                let I = v().filter((C) => C.focusable).map((C) => C.ref.current);
                if (D === "last") I.reverse();
                else if (D === "prev" || D === "next") {
                  D === "prev" && I.reverse();
                  const C = I.indexOf(f.currentTarget);
                  I = c.loop ? Ve(I, C + 1) : I.slice(C + 1);
                }
                setTimeout(() => Z(I));
              }
            })
          }
        )
      }
    );
  }
);
q.displayName = z;
var Ke = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Be(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function $e(e, t, o) {
  const n = Be(e.key, o);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(n)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(n)))
    return Ke[n];
}
function Z(e, t = !1) {
  const o = document.activeElement;
  for (const n of e)
    if (n === o || (n.focus({ preventScroll: t }), document.activeElement !== o)) return;
}
function Ve(e, t) {
  return e.map((o, n) => e[(t + n) % e.length]);
}
var st = H, it = q, L = "Dialog", [J, ct] = Ne(L), [Ye, x] = J(L), Q = (e) => {
  const {
    __scopeDialog: t,
    children: o,
    open: n,
    defaultOpen: r,
    onOpenChange: a,
    modal: u = !0
  } = e, d = s.useRef(null), l = s.useRef(null), [c = !1, g] = V({
    prop: n,
    defaultProp: r,
    onChange: a
  });
  return /* @__PURE__ */ i.jsx(
    Ye,
    {
      scope: t,
      triggerRef: d,
      contentRef: l,
      contentId: _(),
      titleId: _(),
      descriptionId: _(),
      open: c,
      onOpenChange: g,
      onOpenToggle: s.useCallback(() => g((v) => !v), [g]),
      modal: u,
      children: o
    }
  );
};
Q.displayName = L;
var X = "DialogTrigger", ee = s.forwardRef(
  (e, t) => {
    const { __scopeDialog: o, ...n } = e, r = x(X, o), a = T(t, r.triggerRef);
    return /* @__PURE__ */ i.jsx(
      y.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": r.open,
        "aria-controls": r.contentId,
        "data-state": W(r.open),
        ...n,
        ref: a,
        onClick: R(e.onClick, r.onOpenToggle)
      }
    );
  }
);
ee.displayName = X;
var G = "DialogPortal", [He, te] = J(G, {
  forceMount: void 0
}), ne = (e) => {
  const { __scopeDialog: t, forceMount: o, children: n, container: r } = e, a = x(G, t);
  return /* @__PURE__ */ i.jsx(He, { scope: t, forceMount: o, children: s.Children.map(n, (u) => /* @__PURE__ */ i.jsx(w, { present: o || a.open, children: /* @__PURE__ */ i.jsx(we, { asChild: !0, container: r, children: u }) })) });
};
ne.displayName = G;
var F = "DialogOverlay", oe = s.forwardRef(
  (e, t) => {
    const o = te(F, e.__scopeDialog), { forceMount: n = o.forceMount, ...r } = e, a = x(F, e.__scopeDialog);
    return a.modal ? /* @__PURE__ */ i.jsx(w, { present: n || a.open, children: /* @__PURE__ */ i.jsx(ze, { ...r, ref: t }) }) : null;
  }
);
oe.displayName = F;
var ze = s.forwardRef(
  (e, t) => {
    const { __scopeDialog: o, ...n } = e, r = x(F, o);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ i.jsx(Ee, { as: ye, allowPinchZoom: !0, shards: [r.contentRef], children: /* @__PURE__ */ i.jsx(
        y.div,
        {
          "data-state": W(r.open),
          ...n,
          ref: t,
          style: { pointerEvents: "auto", ...n.style }
        }
      ) })
    );
  }
), E = "DialogContent", re = s.forwardRef(
  (e, t) => {
    const o = te(E, e.__scopeDialog), { forceMount: n = o.forceMount, ...r } = e, a = x(E, e.__scopeDialog);
    return /* @__PURE__ */ i.jsx(w, { present: n || a.open, children: a.modal ? /* @__PURE__ */ i.jsx(qe, { ...r, ref: t }) : /* @__PURE__ */ i.jsx(Ze, { ...r, ref: t }) });
  }
);
re.displayName = E;
var qe = s.forwardRef(
  (e, t) => {
    const o = x(E, e.__scopeDialog), n = s.useRef(null), r = T(t, o.contentRef, n);
    return s.useEffect(() => {
      const a = n.current;
      if (a) return he(a);
    }, []), /* @__PURE__ */ i.jsx(
      ae,
      {
        ...e,
        ref: r,
        trapFocus: o.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: R(e.onCloseAutoFocus, (a) => {
          var u;
          a.preventDefault(), (u = o.triggerRef.current) == null || u.focus();
        }),
        onPointerDownOutside: R(e.onPointerDownOutside, (a) => {
          const u = a.detail.originalEvent, d = u.button === 0 && u.ctrlKey === !0;
          (u.button === 2 || d) && a.preventDefault();
        }),
        onFocusOutside: R(
          e.onFocusOutside,
          (a) => a.preventDefault()
        )
      }
    );
  }
), Ze = s.forwardRef(
  (e, t) => {
    const o = x(E, e.__scopeDialog), n = s.useRef(!1), r = s.useRef(!1);
    return /* @__PURE__ */ i.jsx(
      ae,
      {
        ...e,
        ref: t,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (a) => {
          var u, d;
          (u = e.onCloseAutoFocus) == null || u.call(e, a), a.defaultPrevented || (n.current || (d = o.triggerRef.current) == null || d.focus(), a.preventDefault()), n.current = !1, r.current = !1;
        },
        onInteractOutside: (a) => {
          var l, c;
          (l = e.onInteractOutside) == null || l.call(e, a), a.defaultPrevented || (n.current = !0, a.detail.originalEvent.type === "pointerdown" && (r.current = !0));
          const u = a.target;
          ((c = o.triggerRef.current) == null ? void 0 : c.contains(u)) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && r.current && a.preventDefault();
        }
      }
    );
  }
), ae = s.forwardRef(
  (e, t) => {
    const { __scopeDialog: o, trapFocus: n, onOpenAutoFocus: r, onCloseAutoFocus: a, ...u } = e, d = x(E, o), l = s.useRef(null), c = T(t, l);
    return Te(), /* @__PURE__ */ i.jsxs(i.Fragment, { children: [
      /* @__PURE__ */ i.jsx(
        Ae,
        {
          asChild: !0,
          loop: !0,
          trapped: n,
          onMountAutoFocus: r,
          onUnmountAutoFocus: a,
          children: /* @__PURE__ */ i.jsx(
            _e,
            {
              role: "dialog",
              id: d.contentId,
              "aria-describedby": d.descriptionId,
              "aria-labelledby": d.titleId,
              "data-state": W(d.open),
              ...u,
              ref: c,
              onDismiss: () => d.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ i.jsxs(i.Fragment, { children: [
        /* @__PURE__ */ i.jsx(Je, { titleId: d.titleId }),
        /* @__PURE__ */ i.jsx(Xe, { contentRef: l, descriptionId: d.descriptionId })
      ] })
    ] });
  }
), U = "DialogTitle", se = s.forwardRef(
  (e, t) => {
    const { __scopeDialog: o, ...n } = e, r = x(U, o);
    return /* @__PURE__ */ i.jsx(y.h2, { id: r.titleId, ...n, ref: t });
  }
);
se.displayName = U;
var ie = "DialogDescription", ce = s.forwardRef(
  (e, t) => {
    const { __scopeDialog: o, ...n } = e, r = x(ie, o);
    return /* @__PURE__ */ i.jsx(y.p, { id: r.descriptionId, ...n, ref: t });
  }
);
ce.displayName = ie;
var ue = "DialogClose", le = s.forwardRef(
  (e, t) => {
    const { __scopeDialog: o, ...n } = e, r = x(ue, o);
    return /* @__PURE__ */ i.jsx(
      y.button,
      {
        type: "button",
        ...n,
        ref: t,
        onClick: R(e.onClick, () => r.onOpenChange(!1))
      }
    );
  }
);
le.displayName = ue;
function W(e) {
  return e ? "open" : "closed";
}
var de = "DialogTitleWarning", [ut, fe] = Fe(de, {
  contentName: E,
  titleName: U,
  docsSlug: "dialog"
}), Je = ({ titleId: e }) => {
  const t = fe(de), o = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return s.useEffect(() => {
    e && (document.getElementById(e) || console.error(o));
  }, [o, e]), null;
}, Qe = "DialogDescriptionWarning", Xe = ({ contentRef: e, descriptionId: t }) => {
  const n = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${fe(Qe).contentName}}.`;
  return s.useEffect(() => {
    var a;
    const r = (a = e.current) == null ? void 0 : a.getAttribute("aria-describedby");
    t && r && (document.getElementById(t) || console.warn(n));
  }, [n, e, t]), null;
}, lt = Q, dt = ee, ft = ne, gt = oe, pt = re, mt = se, vt = ce, Rt = le;
const xt = {
  green: "text-green-600",
  blue: "text-sky-600",
  yellow: "text-yellow-600",
  red: "text-red-600",
  purple: "text-purple-600",
  indigo: "text-indigo-600",
  gray: "text-gray-600"
}, et = {
  green: "bg-green-400 dark:bg-green-800",
  blue: "bg-sky-400 dark:bg-sky-800",
  yellow: "bg-yellow-400 dark:bg-yellow-800",
  red: "bg-red-400 dark:bg-red-800",
  purple: "bg-purple-400 dark:bg-purple-600",
  indigo: "bg-indigo-400 dark:bg-indigo-600",
  gray: "bg-gray-400 dark:bg-gray-600"
}, bt = ({
  color: e,
  label: t,
  className: o
}) => /* @__PURE__ */ i.jsx(
  "span",
  {
    className: Oe(
      "mt-0.5 flex items-center duration-200 transition-opacity text-center uppercase font-mono text-[0.65rem] font-bold rounded text-background dark:text-zinc-50 h-4 px-1",
      et[e],
      o
    ),
    children: t
  }
);
export {
  pt as C,
  vt as D,
  it as I,
  gt as O,
  w as P,
  st as R,
  bt as S,
  dt as T,
  Rt as a,
  mt as b,
  at as c,
  lt as d,
  ft as e,
  xt as f
};
//# sourceMappingURL=SidebarBadge-DmI5hT04.js.map
