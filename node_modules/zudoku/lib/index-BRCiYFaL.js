import * as n from "react";
import * as Bt from "react-dom";
import { i as m, j as G, g as be, w as C, a as Re, m as we, A as de, p as fe, s as T, b as Ce, c as X, d as Mt, e as jt, I as Ht, f as qe, h as Se, k as _e, l as Q, n as Ge, o as Xe, q as Qe, r as Ze, t as et, u as tt, v as rt, x as nt, y as ot, E as at, z as Kt } from "./router-Oe6YmY6B.js";
/**
 * React Router v6.27.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function I() {
  return I = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var o in r)
        Object.prototype.hasOwnProperty.call(r, o) && (e[o] = r[o]);
    }
    return e;
  }, I.apply(this, arguments);
}
const U = /* @__PURE__ */ n.createContext(null);
process.env.NODE_ENV !== "production" && (U.displayName = "DataRouter");
const B = /* @__PURE__ */ n.createContext(null);
process.env.NODE_ENV !== "production" && (B.displayName = "DataRouterState");
const Z = /* @__PURE__ */ n.createContext(null);
process.env.NODE_ENV !== "production" && (Z.displayName = "Await");
const S = /* @__PURE__ */ n.createContext(null);
process.env.NODE_ENV !== "production" && (S.displayName = "Navigation");
const M = /* @__PURE__ */ n.createContext(null);
process.env.NODE_ENV !== "production" && (M.displayName = "Location");
const _ = /* @__PURE__ */ n.createContext({
  outlet: null,
  matches: [],
  isDataRoute: !1
});
process.env.NODE_ENV !== "production" && (_.displayName = "Route");
const xe = /* @__PURE__ */ n.createContext(null);
process.env.NODE_ENV !== "production" && (xe.displayName = "RouteError");
function De(e, t) {
  let {
    relative: r
  } = t === void 0 ? {} : t;
  V() || (process.env.NODE_ENV !== "production" ? m(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : m(!1));
  let {
    basename: o,
    navigator: a
  } = n.useContext(S), {
    hash: l,
    pathname: i,
    search: u
  } = Y(e, {
    relative: r
  }), f = i;
  return o !== "/" && (f = i === "/" ? o : G([o, i])), a.createHref({
    pathname: f,
    search: u,
    hash: l
  });
}
function V() {
  return n.useContext(M) != null;
}
function L() {
  return V() || (process.env.NODE_ENV !== "production" ? m(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : m(!1)), n.useContext(M).location;
}
function it() {
  return n.useContext(M).navigationType;
}
function lt(e) {
  V() || (process.env.NODE_ENV !== "production" ? m(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useMatch() may be used only in the context of a <Router> component."
  ) : m(!1));
  let {
    pathname: t
  } = L();
  return n.useMemo(() => X(e, Mt(t)), [t, e]);
}
const st = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function ut(e) {
  n.useContext(S).static || n.useLayoutEffect(e);
}
function te() {
  let {
    isDataRoute: e
  } = n.useContext(_);
  return e ? Xt() : zt();
}
function zt() {
  V() || (process.env.NODE_ENV !== "production" ? m(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : m(!1));
  let e = n.useContext(U), {
    basename: t,
    future: r,
    navigator: o
  } = n.useContext(S), {
    matches: a
  } = n.useContext(_), {
    pathname: l
  } = L(), i = JSON.stringify(be(a, r.v7_relativeSplatPath)), u = n.useRef(!1);
  return ut(() => {
    u.current = !0;
  }), n.useCallback(function(s, c) {
    if (c === void 0 && (c = {}), process.env.NODE_ENV !== "production" && C(u.current, st), !u.current) return;
    if (typeof s == "number") {
      o.go(s);
      return;
    }
    let d = Re(s, JSON.parse(i), l, c.relative === "path");
    e == null && t !== "/" && (d.pathname = d.pathname === "/" ? t : G([t, d.pathname])), (c.replace ? o.replace : o.push)(d, c.state, c);
  }, [t, o, i, l, e]);
}
const ct = /* @__PURE__ */ n.createContext(null);
function dt() {
  return n.useContext(ct);
}
function Oe(e) {
  let t = n.useContext(_).outlet;
  return t && /* @__PURE__ */ n.createElement(ct.Provider, {
    value: e
  }, t);
}
function ft() {
  let {
    matches: e
  } = n.useContext(_), t = e[e.length - 1];
  return t ? t.params : {};
}
function Y(e, t) {
  let {
    relative: r
  } = t === void 0 ? {} : t, {
    future: o
  } = n.useContext(S), {
    matches: a
  } = n.useContext(_), {
    pathname: l
  } = L(), i = JSON.stringify(be(a, o.v7_relativeSplatPath));
  return n.useMemo(() => Re(e, JSON.parse(i), l, r === "path"), [e, i, l, r]);
}
function Pe(e, t) {
  return pe(e, t);
}
function pe(e, t, r, o) {
  V() || (process.env.NODE_ENV !== "production" ? m(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  ) : m(!1));
  let {
    navigator: a
  } = n.useContext(S), {
    matches: l
  } = n.useContext(_), i = l[l.length - 1], u = i ? i.params : {}, f = i ? i.pathname : "/", s = i ? i.pathnameBase : "/", c = i && i.route;
  if (process.env.NODE_ENV !== "production") {
    let h = c && c.path || "";
    gt(f, !c || h.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + f + '" (under <Route path="' + h + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + h + '"> to <Route ') + ('path="' + (h === "/" ? "*" : h + "/*") + '">.'));
  }
  let d = L(), p;
  if (t) {
    var v;
    let h = typeof t == "string" ? fe(t) : t;
    s === "/" || (v = h.pathname) != null && v.startsWith(s) || (process.env.NODE_ENV !== "production" ? m(!1, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + s + '" ') + ('but pathname "' + h.pathname + '" was given in the `location` prop.')) : m(!1)), p = h;
  } else
    p = d;
  let g = p.pathname || "/", N = g;
  if (s !== "/") {
    let h = s.replace(/^\//, "").split("/");
    N = "/" + g.replace(/^\//, "").split("/").slice(h.length).join("/");
  }
  let y = we(e, {
    pathname: N
  });
  process.env.NODE_ENV !== "production" && (process.env.NODE_ENV !== "production" && C(c || y != null, 'No routes matched location "' + p.pathname + p.search + p.hash + '" '), process.env.NODE_ENV !== "production" && C(y == null || y[y.length - 1].route.element !== void 0 || y[y.length - 1].route.Component !== void 0 || y[y.length - 1].route.lazy !== void 0, 'Matched leaf route at location "' + p.pathname + p.search + p.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.'));
  let w = pt(y && y.map((h) => Object.assign({}, h, {
    params: Object.assign({}, u, h.params),
    pathname: G([
      s,
      // Re-encode pathnames that were decoded inside matchRoutes
      a.encodeLocation ? a.encodeLocation(h.pathname).pathname : h.pathname
    ]),
    pathnameBase: h.pathnameBase === "/" ? s : G([
      s,
      // Re-encode pathnames that were decoded inside matchRoutes
      a.encodeLocation ? a.encodeLocation(h.pathnameBase).pathname : h.pathnameBase
    ])
  })), l, r, o);
  return t && w ? /* @__PURE__ */ n.createElement(M.Provider, {
    value: {
      location: I({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, p),
      navigationType: de.Pop
    }
  }, w) : w;
}
function Wt() {
  let e = ke(), t = Ce(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), r = e instanceof Error ? e.stack : null, o = "rgba(200,200,200, 0.5)", a = {
    padding: "0.5rem",
    backgroundColor: o
  }, l = {
    padding: "2px 4px",
    backgroundColor: o
  }, i = null;
  return process.env.NODE_ENV !== "production" && (console.error("Error handled by React Router default ErrorBoundary:", e), i = /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("p", null, "ðŸ’¿ Hey developer ðŸ‘‹"), /* @__PURE__ */ n.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", /* @__PURE__ */ n.createElement("code", {
    style: l
  }, "ErrorBoundary"), " or", " ", /* @__PURE__ */ n.createElement("code", {
    style: l
  }, "errorElement"), " prop on your route."))), /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement("h2", null, "Unexpected Application Error!"), /* @__PURE__ */ n.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, t), r ? /* @__PURE__ */ n.createElement("pre", {
    style: a
  }, r) : null, i);
}
const Yt = /* @__PURE__ */ n.createElement(Wt, null);
class $t extends n.Component {
  constructor(t) {
    super(t), this.state = {
      location: t.location,
      revalidation: t.revalidation,
      error: t.error
    };
  }
  static getDerivedStateFromError(t) {
    return {
      error: t
    };
  }
  static getDerivedStateFromProps(t, r) {
    return r.location !== t.location || r.revalidation !== "idle" && t.revalidation === "idle" ? {
      error: t.error,
      location: t.location,
      revalidation: t.revalidation
    } : {
      error: t.error !== void 0 ? t.error : r.error,
      location: r.location,
      revalidation: t.revalidation || r.revalidation
    };
  }
  componentDidCatch(t, r) {
    console.error("React Router caught the following error during render", t, r);
  }
  render() {
    return this.state.error !== void 0 ? /* @__PURE__ */ n.createElement(_.Provider, {
      value: this.props.routeContext
    }, /* @__PURE__ */ n.createElement(xe.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
}
function Jt(e) {
  let {
    routeContext: t,
    match: r,
    children: o
  } = e, a = n.useContext(U);
  return a && a.static && a.staticContext && (r.route.errorElement || r.route.ErrorBoundary) && (a.staticContext._deepestRenderedBoundaryId = r.route.id), /* @__PURE__ */ n.createElement(_.Provider, {
    value: t
  }, o);
}
function pt(e, t, r, o) {
  var a;
  if (t === void 0 && (t = []), r === void 0 && (r = null), o === void 0 && (o = null), e == null) {
    var l;
    if (!r)
      return null;
    if (r.errors)
      e = r.matches;
    else if ((l = o) != null && l.v7_partialHydration && t.length === 0 && !r.initialized && r.matches.length > 0)
      e = r.matches;
    else
      return null;
  }
  let i = e, u = (a = r) == null ? void 0 : a.errors;
  if (u != null) {
    let c = i.findIndex((d) => d.route.id && (u == null ? void 0 : u[d.route.id]) !== void 0);
    c >= 0 || (process.env.NODE_ENV !== "production" ? m(!1, "Could not find a matching route for errors on route IDs: " + Object.keys(u).join(",")) : m(!1)), i = i.slice(0, Math.min(i.length, c + 1));
  }
  let f = !1, s = -1;
  if (r && o && o.v7_partialHydration)
    for (let c = 0; c < i.length; c++) {
      let d = i[c];
      if ((d.route.HydrateFallback || d.route.hydrateFallbackElement) && (s = c), d.route.id) {
        let {
          loaderData: p,
          errors: v
        } = r, g = d.route.loader && p[d.route.id] === void 0 && (!v || v[d.route.id] === void 0);
        if (d.route.lazy || g) {
          f = !0, s >= 0 ? i = i.slice(0, s + 1) : i = [i[0]];
          break;
        }
      }
    }
  return i.reduceRight((c, d, p) => {
    let v, g = !1, N = null, y = null;
    r && (v = u && d.route.id ? u[d.route.id] : void 0, N = d.route.errorElement || Yt, f && (s < 0 && p === 0 ? (gt("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), g = !0, y = null) : s === p && (g = !0, y = d.route.hydrateFallbackElement || null)));
    let w = t.concat(i.slice(0, p + 1)), h = () => {
      let E;
      return v ? E = N : g ? E = y : d.route.Component ? E = /* @__PURE__ */ n.createElement(d.route.Component, null) : d.route.element ? E = d.route.element : E = c, /* @__PURE__ */ n.createElement(Jt, {
        match: d,
        routeContext: {
          outlet: c,
          matches: w,
          isDataRoute: r != null
        },
        children: E
      });
    };
    return r && (d.route.ErrorBoundary || d.route.errorElement || p === 0) ? /* @__PURE__ */ n.createElement($t, {
      location: r.location,
      revalidation: r.revalidation,
      component: N,
      error: v,
      children: h(),
      routeContext: {
        outlet: null,
        matches: w,
        isDataRoute: !0
      }
    }) : h();
  }, null);
}
var he = /* @__PURE__ */ function(e) {
  return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e;
}(he || {}), O = /* @__PURE__ */ function(e) {
  return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e;
}(O || {});
function Le(e) {
  return e + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function Te(e) {
  let t = n.useContext(U);
  return t || (process.env.NODE_ENV !== "production" ? m(!1, Le(e)) : m(!1)), t;
}
function j(e) {
  let t = n.useContext(B);
  return t || (process.env.NODE_ENV !== "production" ? m(!1, Le(e)) : m(!1)), t;
}
function qt(e) {
  let t = n.useContext(_);
  return t || (process.env.NODE_ENV !== "production" ? m(!1, Le(e)) : m(!1)), t;
}
function re(e) {
  let t = qt(e), r = t.matches[t.matches.length - 1];
  return r.route.id || (process.env.NODE_ENV !== "production" ? m(!1, e + ' can only be used on routes that contain a unique "id"') : m(!1)), r.route.id;
}
function Fe() {
  return re(O.UseRouteId);
}
function Ue() {
  return j(O.UseNavigation).navigation;
}
function ht() {
  let e = Te(he.UseRevalidator), t = j(O.UseRevalidator);
  return n.useMemo(() => ({
    revalidate: e.router.revalidate,
    state: t.revalidation
  }), [e.router.revalidate, t.revalidation]);
}
function Ve() {
  let {
    matches: e,
    loaderData: t
  } = j(O.UseMatches);
  return n.useMemo(() => e.map((r) => jt(r, t)), [e, t]);
}
function mt() {
  let e = j(O.UseLoaderData), t = re(O.UseLoaderData);
  if (e.errors && e.errors[t] != null) {
    console.error("You cannot `useLoaderData` in an errorElement (routeId: " + t + ")");
    return;
  }
  return e.loaderData[t];
}
function vt(e) {
  return j(O.UseRouteLoaderData).loaderData[e];
}
function Et() {
  let e = j(O.UseActionData), t = re(O.UseLoaderData);
  return e.actionData ? e.actionData[t] : void 0;
}
function ke() {
  var e;
  let t = n.useContext(xe), r = j(O.UseRouteError), o = re(O.UseRouteError);
  return t !== void 0 ? t : (e = r.errors) == null ? void 0 : e[o];
}
function Ie() {
  let e = n.useContext(Z);
  return e == null ? void 0 : e._data;
}
function yt() {
  let e = n.useContext(Z);
  return e == null ? void 0 : e._error;
}
let Gt = 0;
function Ae(e) {
  let {
    router: t,
    basename: r
  } = Te(he.UseBlocker), o = j(O.UseBlocker), [a, l] = n.useState(""), i = n.useCallback((u) => {
    if (typeof e != "function")
      return !!e;
    if (r === "/")
      return e(u);
    let {
      currentLocation: f,
      nextLocation: s,
      historyAction: c
    } = u;
    return e({
      currentLocation: I({}, f, {
        pathname: T(f.pathname, r) || f.pathname
      }),
      nextLocation: I({}, s, {
        pathname: T(s.pathname, r) || s.pathname
      }),
      historyAction: c
    });
  }, [r, e]);
  return n.useEffect(() => {
    let u = String(++Gt);
    return l(u), () => t.deleteBlocker(u);
  }, [t]), n.useEffect(() => {
    a !== "" && t.getBlocker(a, i);
  }, [t, a, i]), a && o.blockers.has(a) ? o.blockers.get(a) : Ht;
}
function Xt() {
  let {
    router: e
  } = Te(he.UseNavigateStable), t = re(O.UseNavigateStable), r = n.useRef(!1);
  return ut(() => {
    r.current = !0;
  }), n.useCallback(function(a, l) {
    l === void 0 && (l = {}), process.env.NODE_ENV !== "production" && C(r.current, st), r.current && (typeof a == "number" ? e.navigate(a) : e.navigate(a, I({
      fromRouteId: t
    }, l)));
  }, [e, t]);
}
const We = {};
function gt(e, t, r) {
  !t && !We[e] && (We[e] = !0, process.env.NODE_ENV !== "production" && C(!1, r));
}
const Qt = "startTransition", ue = n[Qt];
function Zt(e) {
  let {
    fallbackElement: t,
    router: r,
    future: o
  } = e, [a, l] = n.useState(r.state), {
    v7_startTransition: i
  } = o || {}, u = n.useCallback((d) => {
    i && ue ? ue(() => l(d)) : l(d);
  }, [l, i]);
  n.useLayoutEffect(() => r.subscribe(u), [r, u]), n.useEffect(() => {
    process.env.NODE_ENV !== "production" && C(t == null || !r.future.v7_partialHydration, "`<RouterProvider fallbackElement>` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead");
  }, []);
  let f = n.useMemo(() => ({
    createHref: r.createHref,
    encodeLocation: r.encodeLocation,
    go: (d) => r.navigate(d),
    push: (d, p, v) => r.navigate(d, {
      state: p,
      preventScrollReset: v == null ? void 0 : v.preventScrollReset
    }),
    replace: (d, p, v) => r.navigate(d, {
      replace: !0,
      state: p,
      preventScrollReset: v == null ? void 0 : v.preventScrollReset
    })
  }), [r]), s = r.basename || "/", c = n.useMemo(() => ({
    router: r,
    navigator: f,
    static: !1,
    basename: s
  }), [r, f, s]);
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(U.Provider, {
    value: c
  }, /* @__PURE__ */ n.createElement(B.Provider, {
    value: a
  }, /* @__PURE__ */ n.createElement(H, {
    basename: s,
    location: a.location,
    navigationType: a.historyAction,
    navigator: f,
    future: {
      v7_relativeSplatPath: r.future.v7_relativeSplatPath
    }
  }, a.initialized || r.future.v7_partialHydration ? /* @__PURE__ */ n.createElement(er, {
    routes: r.routes,
    future: r.future,
    state: a
  }) : t))), null);
}
function er(e) {
  let {
    routes: t,
    future: r,
    state: o
  } = e;
  return pe(t, void 0, o, r);
}
function Nt(e) {
  let {
    basename: t,
    children: r,
    initialEntries: o,
    initialIndex: a,
    future: l
  } = e, i = n.useRef();
  i.current == null && (i.current = qe({
    initialEntries: o,
    initialIndex: a,
    v5Compat: !0
  }));
  let u = i.current, [f, s] = n.useState({
    action: u.action,
    location: u.location
  }), {
    v7_startTransition: c
  } = l || {}, d = n.useCallback((p) => {
    c && ue ? ue(() => s(p)) : s(p);
  }, [s, c]);
  return n.useLayoutEffect(() => u.listen(d), [u, d]), /* @__PURE__ */ n.createElement(H, {
    basename: t,
    children: r,
    location: f.location,
    navigationType: f.action,
    navigator: u,
    future: l
  });
}
function bt(e) {
  let {
    to: t,
    replace: r,
    state: o,
    relative: a
  } = e;
  V() || (process.env.NODE_ENV !== "production" ? m(
    !1,
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component."
  ) : m(!1));
  let {
    future: l,
    static: i
  } = n.useContext(S);
  process.env.NODE_ENV !== "production" && C(!i, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");
  let {
    matches: u
  } = n.useContext(_), {
    pathname: f
  } = L(), s = te(), c = Re(t, be(u, l.v7_relativeSplatPath), f, a === "path"), d = JSON.stringify(c);
  return n.useEffect(() => s(JSON.parse(d), {
    replace: r,
    state: o,
    relative: a
  }), [s, d, a, r, o]), null;
}
function Rt(e) {
  return Oe(e.context);
}
function Be(e) {
  process.env.NODE_ENV !== "production" ? m(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : m(!1);
}
function H(e) {
  let {
    basename: t = "/",
    children: r = null,
    location: o,
    navigationType: a = de.Pop,
    navigator: l,
    static: i = !1,
    future: u
  } = e;
  V() && (process.env.NODE_ENV !== "production" ? m(!1, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : m(!1));
  let f = t.replace(/^\/*/, "/"), s = n.useMemo(() => ({
    basename: f,
    navigator: l,
    static: i,
    future: I({
      v7_relativeSplatPath: !1
    }, u)
  }), [f, u, l, i]);
  typeof o == "string" && (o = fe(o));
  let {
    pathname: c = "/",
    search: d = "",
    hash: p = "",
    state: v = null,
    key: g = "default"
  } = o, N = n.useMemo(() => {
    let y = T(c, f);
    return y == null ? null : {
      location: {
        pathname: y,
        search: d,
        hash: p,
        state: v,
        key: g
      },
      navigationType: a
    };
  }, [f, c, d, p, v, g, a]);
  return process.env.NODE_ENV !== "production" && C(N != null, '<Router basename="' + f + '"> is not able to match the URL ' + ('"' + c + d + p + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), N == null ? null : /* @__PURE__ */ n.createElement(S.Provider, {
    value: s
  }, /* @__PURE__ */ n.createElement(M.Provider, {
    children: r,
    value: N
  }));
}
function wt(e) {
  let {
    children: t,
    location: r
  } = e;
  return Pe(W(t), r);
}
function Ct(e) {
  let {
    children: t,
    errorElement: r,
    resolve: o
  } = e;
  return /* @__PURE__ */ n.createElement(rr, {
    resolve: o,
    errorElement: r
  }, /* @__PURE__ */ n.createElement(nr, null, t));
}
var P = /* @__PURE__ */ function(e) {
  return e[e.pending = 0] = "pending", e[e.success = 1] = "success", e[e.error = 2] = "error", e;
}(P || {});
const tr = new Promise(() => {
});
class rr extends n.Component {
  constructor(t) {
    super(t), this.state = {
      error: null
    };
  }
  static getDerivedStateFromError(t) {
    return {
      error: t
    };
  }
  componentDidCatch(t, r) {
    console.error("<Await> caught the following error during render", t, r);
  }
  render() {
    let {
      children: t,
      errorElement: r,
      resolve: o
    } = this.props, a = null, l = P.pending;
    if (!(o instanceof Promise))
      l = P.success, a = Promise.resolve(), Object.defineProperty(a, "_tracked", {
        get: () => !0
      }), Object.defineProperty(a, "_data", {
        get: () => o
      });
    else if (this.state.error) {
      l = P.error;
      let i = this.state.error;
      a = Promise.reject().catch(() => {
      }), Object.defineProperty(a, "_tracked", {
        get: () => !0
      }), Object.defineProperty(a, "_error", {
        get: () => i
      });
    } else o._tracked ? (a = o, l = "_error" in a ? P.error : "_data" in a ? P.success : P.pending) : (l = P.pending, Object.defineProperty(o, "_tracked", {
      get: () => !0
    }), a = o.then((i) => Object.defineProperty(o, "_data", {
      get: () => i
    }), (i) => Object.defineProperty(o, "_error", {
      get: () => i
    })));
    if (l === P.error && a._error instanceof Se)
      throw tr;
    if (l === P.error && !r)
      throw a._error;
    if (l === P.error)
      return /* @__PURE__ */ n.createElement(Z.Provider, {
        value: a,
        children: r
      });
    if (l === P.success)
      return /* @__PURE__ */ n.createElement(Z.Provider, {
        value: a,
        children: t
      });
    throw a;
  }
}
function nr(e) {
  let {
    children: t
  } = e, r = Ie(), o = typeof t == "function" ? t(r) : t;
  return /* @__PURE__ */ n.createElement(n.Fragment, null, o);
}
function W(e, t) {
  t === void 0 && (t = []);
  let r = [];
  return n.Children.forEach(e, (o, a) => {
    if (!/* @__PURE__ */ n.isValidElement(o))
      return;
    let l = [...t, a];
    if (o.type === n.Fragment) {
      r.push.apply(r, W(o.props.children, l));
      return;
    }
    o.type !== Be && (process.env.NODE_ENV !== "production" ? m(!1, "[" + (typeof o.type == "string" ? o.type : o.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : m(!1)), !o.props.index || !o.props.children || (process.env.NODE_ENV !== "production" ? m(!1, "An index route cannot have child routes.") : m(!1));
    let i = {
      id: o.props.id || l.join("-"),
      caseSensitive: o.props.caseSensitive,
      element: o.props.element,
      Component: o.props.Component,
      index: o.props.index,
      path: o.props.path,
      loader: o.props.loader,
      action: o.props.action,
      errorElement: o.props.errorElement,
      ErrorBoundary: o.props.ErrorBoundary,
      hasErrorBoundary: o.props.ErrorBoundary != null || o.props.errorElement != null,
      shouldRevalidate: o.props.shouldRevalidate,
      handle: o.props.handle,
      lazy: o.props.lazy
    };
    o.props.children && (i.children = W(o.props.children, l)), r.push(i);
  }), r;
}
function St(e) {
  return pt(e);
}
function me(e) {
  let t = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: e.ErrorBoundary != null || e.errorElement != null
  };
  return e.Component && (process.env.NODE_ENV !== "production" && e.element && process.env.NODE_ENV !== "production" && C(!1, "You should not include both `Component` and `element` on your route - `Component` will be used."), Object.assign(t, {
    element: /* @__PURE__ */ n.createElement(e.Component),
    Component: void 0
  })), e.HydrateFallback && (process.env.NODE_ENV !== "production" && e.hydrateFallbackElement && process.env.NODE_ENV !== "production" && C(!1, "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."), Object.assign(t, {
    hydrateFallbackElement: /* @__PURE__ */ n.createElement(e.HydrateFallback),
    HydrateFallback: void 0
  })), e.ErrorBoundary && (process.env.NODE_ENV !== "production" && e.errorElement && process.env.NODE_ENV !== "production" && C(!1, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."), Object.assign(t, {
    errorElement: /* @__PURE__ */ n.createElement(e.ErrorBoundary),
    ErrorBoundary: void 0
  })), t;
}
function _t(e, t) {
  return _e({
    basename: t == null ? void 0 : t.basename,
    future: I({}, t == null ? void 0 : t.future, {
      v7_prependBasename: !0
    }),
    history: qe({
      initialEntries: t == null ? void 0 : t.initialEntries,
      initialIndex: t == null ? void 0 : t.initialIndex
    }),
    hydrationData: t == null ? void 0 : t.hydrationData,
    routes: e,
    mapRouteProperties: me,
    dataStrategy: t == null ? void 0 : t.dataStrategy,
    patchRoutesOnNavigation: t == null ? void 0 : t.patchRoutesOnNavigation
  }).initialize();
}
const jr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortedDeferredError: Se,
  Await: Ct,
  MemoryRouter: Nt,
  Navigate: bt,
  get NavigationType() {
    return de;
  },
  Outlet: Rt,
  Route: Be,
  Router: H,
  RouterProvider: Zt,
  Routes: wt,
  UNSAFE_DataRouterContext: U,
  UNSAFE_DataRouterStateContext: B,
  UNSAFE_LocationContext: M,
  UNSAFE_NavigationContext: S,
  UNSAFE_RouteContext: _,
  UNSAFE_mapRouteProperties: me,
  UNSAFE_useRouteId: Fe,
  UNSAFE_useRoutesImpl: pe,
  createMemoryRouter: _t,
  createPath: Q,
  createRoutesFromChildren: W,
  createRoutesFromElements: W,
  defer: Ge,
  generatePath: Xe,
  isRouteErrorResponse: Ce,
  json: Qe,
  matchPath: X,
  matchRoutes: we,
  parsePath: fe,
  redirect: Ze,
  redirectDocument: et,
  renderMatches: St,
  replace: tt,
  resolvePath: rt,
  useActionData: Et,
  useAsyncError: yt,
  useAsyncValue: Ie,
  useBlocker: Ae,
  useHref: De,
  useInRouterContext: V,
  useLoaderData: mt,
  useLocation: L,
  useMatch: lt,
  useMatches: Ve,
  useNavigate: te,
  useNavigation: Ue,
  useNavigationType: it,
  useOutlet: Oe,
  useOutletContext: dt,
  useParams: ft,
  useResolvedPath: Y,
  useRevalidator: ht,
  useRouteError: ke,
  useRouteLoaderData: vt,
  useRoutes: Pe
}, Symbol.toStringTag, { value: "Module" }));
/**
 * React Router DOM v6.27.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function D() {
  return D = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var o in r)
        Object.prototype.hasOwnProperty.call(r, o) && (e[o] = r[o]);
    }
    return e;
  }, D.apply(this, arguments);
}
function Me(e, t) {
  if (e == null) return {};
  var r = {}, o = Object.keys(e), a, l;
  for (l = 0; l < o.length; l++)
    a = o[l], !(t.indexOf(a) >= 0) && (r[a] = e[a]);
  return r;
}
const le = "get", se = "application/x-www-form-urlencoded";
function ve(e) {
  return e != null && typeof e.tagName == "string";
}
function or(e) {
  return ve(e) && e.tagName.toLowerCase() === "button";
}
function ar(e) {
  return ve(e) && e.tagName.toLowerCase() === "form";
}
function ir(e) {
  return ve(e) && e.tagName.toLowerCase() === "input";
}
function lr(e) {
  return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey);
}
function sr(e, t) {
  return e.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !lr(e);
}
function ce(e) {
  return e === void 0 && (e = ""), new URLSearchParams(typeof e == "string" || Array.isArray(e) || e instanceof URLSearchParams ? e : Object.keys(e).reduce((t, r) => {
    let o = e[r];
    return t.concat(Array.isArray(o) ? o.map((a) => [r, a]) : [[r, o]]);
  }, []));
}
function ur(e, t) {
  let r = ce(e);
  return t && t.forEach((o, a) => {
    r.has(a) || t.getAll(a).forEach((l) => {
      r.append(a, l);
    });
  }), r;
}
let ae = null;
function cr() {
  if (ae === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), ae = !1;
    } catch {
      ae = !0;
    }
  return ae;
}
const dr = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function Ne(e) {
  return e != null && !dr.has(e) ? (process.env.NODE_ENV !== "production" && C(!1, '"' + e + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + se + '"')), null) : e;
}
function fr(e, t) {
  let r, o, a, l, i;
  if (ar(e)) {
    let u = e.getAttribute("action");
    o = u ? T(u, t) : null, r = e.getAttribute("method") || le, a = Ne(e.getAttribute("enctype")) || se, l = new FormData(e);
  } else if (or(e) || ir(e) && (e.type === "submit" || e.type === "image")) {
    let u = e.form;
    if (u == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    let f = e.getAttribute("formaction") || u.getAttribute("action");
    if (o = f ? T(f, t) : null, r = e.getAttribute("formmethod") || u.getAttribute("method") || le, a = Ne(e.getAttribute("formenctype")) || Ne(u.getAttribute("enctype")) || se, l = new FormData(u, e), !cr()) {
      let {
        name: s,
        type: c,
        value: d
      } = e;
      if (c === "image") {
        let p = s ? s + "." : "";
        l.append(p + "x", "0"), l.append(p + "y", "0");
      } else s && l.append(s, d);
    }
  } else {
    if (ve(e))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    r = le, o = null, a = se, i = e;
  }
  return l && a === "text/plain" && (i = l, l = void 0), {
    action: o,
    method: r.toLowerCase(),
    encType: a,
    formData: l,
    body: i
  };
}
const pr = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], hr = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"], mr = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "viewTransition"], vr = "6";
try {
  window.__reactRouterVersion = vr;
} catch {
}
function Er(e, t) {
  return _e({
    basename: t == null ? void 0 : t.basename,
    future: D({}, t == null ? void 0 : t.future, {
      v7_prependBasename: !0
    }),
    history: nt({
      window: t == null ? void 0 : t.window
    }),
    hydrationData: (t == null ? void 0 : t.hydrationData) || xt(),
    routes: e,
    mapRouteProperties: me,
    dataStrategy: t == null ? void 0 : t.dataStrategy,
    patchRoutesOnNavigation: t == null ? void 0 : t.patchRoutesOnNavigation,
    window: t == null ? void 0 : t.window
  }).initialize();
}
function yr(e, t) {
  return _e({
    basename: t == null ? void 0 : t.basename,
    future: D({}, t == null ? void 0 : t.future, {
      v7_prependBasename: !0
    }),
    history: ot({
      window: t == null ? void 0 : t.window
    }),
    hydrationData: (t == null ? void 0 : t.hydrationData) || xt(),
    routes: e,
    mapRouteProperties: me,
    dataStrategy: t == null ? void 0 : t.dataStrategy,
    patchRoutesOnNavigation: t == null ? void 0 : t.patchRoutesOnNavigation,
    window: t == null ? void 0 : t.window
  }).initialize();
}
function xt() {
  var e;
  let t = (e = window) == null ? void 0 : e.__staticRouterHydrationData;
  return t && t.errors && (t = D({}, t, {
    errors: gr(t.errors)
  })), t;
}
function gr(e) {
  if (!e) return null;
  let t = Object.entries(e), r = {};
  for (let [o, a] of t)
    if (a && a.__type === "RouteErrorResponse")
      r[o] = new at(a.status, a.statusText, a.data, a.internal === !0);
    else if (a && a.__type === "Error") {
      if (a.__subType) {
        let l = window[a.__subType];
        if (typeof l == "function")
          try {
            let i = new l(a.message);
            i.stack = "", r[o] = i;
          } catch {
          }
      }
      if (r[o] == null) {
        let l = new Error(a.message);
        l.stack = "", r[o] = l;
      }
    } else
      r[o] = a;
  return r;
}
const Ee = /* @__PURE__ */ n.createContext({
  isTransitioning: !1
});
process.env.NODE_ENV !== "production" && (Ee.displayName = "ViewTransition");
const ye = /* @__PURE__ */ n.createContext(/* @__PURE__ */ new Map());
process.env.NODE_ENV !== "production" && (ye.displayName = "Fetchers");
const Nr = "startTransition", A = n[Nr], br = "flushSync", Ye = Bt[br], Rr = "useId", $e = n[Rr];
function wr(e) {
  A ? A(e) : e();
}
function q(e) {
  Ye ? Ye(e) : e();
}
class Cr {
  constructor() {
    this.status = "pending", this.promise = new Promise((t, r) => {
      this.resolve = (o) => {
        this.status === "pending" && (this.status = "resolved", t(o));
      }, this.reject = (o) => {
        this.status === "pending" && (this.status = "rejected", r(o));
      };
    });
  }
}
function Sr(e) {
  let {
    fallbackElement: t,
    router: r,
    future: o
  } = e, [a, l] = n.useState(r.state), [i, u] = n.useState(), [f, s] = n.useState({
    isTransitioning: !1
  }), [c, d] = n.useState(), [p, v] = n.useState(), [g, N] = n.useState(), y = n.useRef(/* @__PURE__ */ new Map()), {
    v7_startTransition: w
  } = o || {}, h = n.useCallback((R) => {
    w ? wr(R) : R();
  }, [w]), E = n.useCallback((R, F) => {
    let {
      deletedFetchers: x,
      flushSync: oe,
      viewTransitionOpts: K
    } = F;
    x.forEach((z) => y.current.delete(z)), R.fetchers.forEach((z, At) => {
      z.data !== void 0 && y.current.set(At, z.data);
    });
    let It = r.window == null || r.window.document == null || typeof r.window.document.startViewTransition != "function";
    if (!K || It) {
      oe ? q(() => l(R)) : h(() => l(R));
      return;
    }
    if (oe) {
      q(() => {
        p && (c && c.resolve(), p.skipTransition()), s({
          isTransitioning: !0,
          flushSync: !0,
          currentLocation: K.currentLocation,
          nextLocation: K.nextLocation
        });
      });
      let z = r.window.document.startViewTransition(() => {
        q(() => l(R));
      });
      z.finished.finally(() => {
        q(() => {
          d(void 0), v(void 0), u(void 0), s({
            isTransitioning: !1
          });
        });
      }), q(() => v(z));
      return;
    }
    p ? (c && c.resolve(), p.skipTransition(), N({
      state: R,
      currentLocation: K.currentLocation,
      nextLocation: K.nextLocation
    })) : (u(R), s({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: K.currentLocation,
      nextLocation: K.nextLocation
    }));
  }, [r.window, p, c, y, h]);
  n.useLayoutEffect(() => r.subscribe(E), [r, E]), n.useEffect(() => {
    f.isTransitioning && !f.flushSync && d(new Cr());
  }, [f]), n.useEffect(() => {
    if (c && i && r.window) {
      let R = i, F = c.promise, x = r.window.document.startViewTransition(async () => {
        h(() => l(R)), await F;
      });
      x.finished.finally(() => {
        d(void 0), v(void 0), u(void 0), s({
          isTransitioning: !1
        });
      }), v(x);
    }
  }, [h, i, c, r.window]), n.useEffect(() => {
    c && i && a.location.key === i.location.key && c.resolve();
  }, [c, p, a.location, i]), n.useEffect(() => {
    !f.isTransitioning && g && (u(g.state), s({
      isTransitioning: !0,
      flushSync: !1,
      currentLocation: g.currentLocation,
      nextLocation: g.nextLocation
    }), N(void 0));
  }, [f.isTransitioning, g]), n.useEffect(() => {
    process.env.NODE_ENV !== "production" && C(t == null || !r.future.v7_partialHydration, "`<RouterProvider fallbackElement>` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead");
  }, []);
  let b = n.useMemo(() => ({
    createHref: r.createHref,
    encodeLocation: r.encodeLocation,
    go: (R) => r.navigate(R),
    push: (R, F, x) => r.navigate(R, {
      state: F,
      preventScrollReset: x == null ? void 0 : x.preventScrollReset
    }),
    replace: (R, F, x) => r.navigate(R, {
      replace: !0,
      state: F,
      preventScrollReset: x == null ? void 0 : x.preventScrollReset
    })
  }), [r]), k = r.basename || "/", J = n.useMemo(() => ({
    router: r,
    navigator: b,
    static: !1,
    basename: k
  }), [r, b, k]), ne = n.useMemo(() => ({
    v7_relativeSplatPath: r.future.v7_relativeSplatPath
  }), [r.future.v7_relativeSplatPath]);
  return /* @__PURE__ */ n.createElement(n.Fragment, null, /* @__PURE__ */ n.createElement(U.Provider, {
    value: J
  }, /* @__PURE__ */ n.createElement(B.Provider, {
    value: a
  }, /* @__PURE__ */ n.createElement(ye.Provider, {
    value: y.current
  }, /* @__PURE__ */ n.createElement(Ee.Provider, {
    value: f
  }, /* @__PURE__ */ n.createElement(H, {
    basename: k,
    location: a.location,
    navigationType: a.historyAction,
    navigator: b,
    future: ne
  }, a.initialized || r.future.v7_partialHydration ? /* @__PURE__ */ n.createElement(_r, {
    routes: r.routes,
    future: r.future,
    state: a
  }) : t))))), null);
}
const _r = /* @__PURE__ */ n.memo(xr);
function xr(e) {
  let {
    routes: t,
    future: r,
    state: o
  } = e;
  return pe(t, void 0, o, r);
}
function Dr(e) {
  let {
    basename: t,
    children: r,
    future: o,
    window: a
  } = e, l = n.useRef();
  l.current == null && (l.current = nt({
    window: a,
    v5Compat: !0
  }));
  let i = l.current, [u, f] = n.useState({
    action: i.action,
    location: i.location
  }), {
    v7_startTransition: s
  } = o || {}, c = n.useCallback((d) => {
    s && A ? A(() => f(d)) : f(d);
  }, [f, s]);
  return n.useLayoutEffect(() => i.listen(c), [i, c]), /* @__PURE__ */ n.createElement(H, {
    basename: t,
    children: r,
    location: u.location,
    navigationType: u.action,
    navigator: i,
    future: o
  });
}
function Or(e) {
  let {
    basename: t,
    children: r,
    future: o,
    window: a
  } = e, l = n.useRef();
  l.current == null && (l.current = ot({
    window: a,
    v5Compat: !0
  }));
  let i = l.current, [u, f] = n.useState({
    action: i.action,
    location: i.location
  }), {
    v7_startTransition: s
  } = o || {}, c = n.useCallback((d) => {
    s && A ? A(() => f(d)) : f(d);
  }, [f, s]);
  return n.useLayoutEffect(() => i.listen(c), [i, c]), /* @__PURE__ */ n.createElement(H, {
    basename: t,
    children: r,
    location: u.location,
    navigationType: u.action,
    navigator: i,
    future: o
  });
}
function Dt(e) {
  let {
    basename: t,
    children: r,
    future: o,
    history: a
  } = e, [l, i] = n.useState({
    action: a.action,
    location: a.location
  }), {
    v7_startTransition: u
  } = o || {}, f = n.useCallback((s) => {
    u && A ? A(() => i(s)) : i(s);
  }, [i, u]);
  return n.useLayoutEffect(() => a.listen(f), [a, f]), /* @__PURE__ */ n.createElement(H, {
    basename: t,
    children: r,
    location: l.location,
    navigationType: l.action,
    navigator: a,
    future: o
  });
}
process.env.NODE_ENV !== "production" && (Dt.displayName = "unstable_HistoryRouter");
const Pr = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Lr = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, je = /* @__PURE__ */ n.forwardRef(function(t, r) {
  let {
    onClick: o,
    relative: a,
    reloadDocument: l,
    replace: i,
    state: u,
    target: f,
    to: s,
    preventScrollReset: c,
    viewTransition: d
  } = t, p = Me(t, pr), {
    basename: v
  } = n.useContext(S), g, N = !1;
  if (typeof s == "string" && Lr.test(s) && (g = s, Pr))
    try {
      let E = new URL(window.location.href), b = s.startsWith("//") ? new URL(E.protocol + s) : new URL(s), k = T(b.pathname, v);
      b.origin === E.origin && k != null ? s = k + b.search + b.hash : N = !0;
    } catch {
      process.env.NODE_ENV !== "production" && C(!1, '<Link to="' + s + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
    }
  let y = De(s, {
    relative: a
  }), w = Tt(s, {
    replace: i,
    state: u,
    target: f,
    preventScrollReset: c,
    relative: a,
    viewTransition: d
  });
  function h(E) {
    o && o(E), E.defaultPrevented || w(E);
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    /* @__PURE__ */ n.createElement("a", D({}, p, {
      href: g || y,
      onClick: N || l ? o : h,
      ref: r,
      target: f
    }))
  );
});
process.env.NODE_ENV !== "production" && (je.displayName = "Link");
const Ot = /* @__PURE__ */ n.forwardRef(function(t, r) {
  let {
    "aria-current": o = "page",
    caseSensitive: a = !1,
    className: l = "",
    end: i = !1,
    style: u,
    to: f,
    viewTransition: s,
    children: c
  } = t, d = Me(t, hr), p = Y(f, {
    relative: d.relative
  }), v = L(), g = n.useContext(B), {
    navigator: N,
    basename: y
  } = n.useContext(S), w = g != null && // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  kt(p) && s === !0, h = N.encodeLocation ? N.encodeLocation(p).pathname : p.pathname, E = v.pathname, b = g && g.navigation && g.navigation.location ? g.navigation.location.pathname : null;
  a || (E = E.toLowerCase(), b = b ? b.toLowerCase() : null, h = h.toLowerCase()), b && y && (b = T(b, y) || b);
  const k = h !== "/" && h.endsWith("/") ? h.length - 1 : h.length;
  let J = E === h || !i && E.startsWith(h) && E.charAt(k) === "/", ne = b != null && (b === h || !i && b.startsWith(h) && b.charAt(h.length) === "/"), R = {
    isActive: J,
    isPending: ne,
    isTransitioning: w
  }, F = J ? o : void 0, x;
  typeof l == "function" ? x = l(R) : x = [l, J ? "active" : null, ne ? "pending" : null, w ? "transitioning" : null].filter(Boolean).join(" ");
  let oe = typeof u == "function" ? u(R) : u;
  return /* @__PURE__ */ n.createElement(je, D({}, d, {
    "aria-current": F,
    className: x,
    ref: r,
    style: oe,
    to: f,
    viewTransition: s
  }), typeof c == "function" ? c(R) : c);
});
process.env.NODE_ENV !== "production" && (Ot.displayName = "NavLink");
const He = /* @__PURE__ */ n.forwardRef((e, t) => {
  let {
    fetcherKey: r,
    navigate: o,
    reloadDocument: a,
    replace: l,
    state: i,
    method: u = le,
    action: f,
    onSubmit: s,
    relative: c,
    preventScrollReset: d,
    viewTransition: p
  } = e, v = Me(e, mr), g = ze(), N = Ut(f, {
    relative: c
  }), y = u.toLowerCase() === "get" ? "get" : "post", w = (h) => {
    if (s && s(h), h.defaultPrevented) return;
    h.preventDefault();
    let E = h.nativeEvent.submitter, b = (E == null ? void 0 : E.getAttribute("formmethod")) || u;
    g(E || h.currentTarget, {
      fetcherKey: r,
      method: b,
      navigate: o,
      replace: l,
      state: i,
      relative: c,
      preventScrollReset: d,
      viewTransition: p
    });
  };
  return /* @__PURE__ */ n.createElement("form", D({
    ref: t,
    method: y,
    action: N,
    onSubmit: a ? s : w
  }, v));
});
process.env.NODE_ENV !== "production" && (He.displayName = "Form");
function Pt(e) {
  let {
    getKey: t,
    storageKey: r
  } = e;
  return Vt({
    getKey: t,
    storageKey: r
  }), null;
}
process.env.NODE_ENV !== "production" && (Pt.displayName = "ScrollRestoration");
var $;
(function(e) {
  e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState";
})($ || ($ = {}));
var ee;
(function(e) {
  e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration";
})(ee || (ee = {}));
function Lt(e) {
  return e + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function ge(e) {
  let t = n.useContext(U);
  return t || (process.env.NODE_ENV !== "production" ? m(!1, Lt(e)) : m(!1)), t;
}
function Ke(e) {
  let t = n.useContext(B);
  return t || (process.env.NODE_ENV !== "production" ? m(!1, Lt(e)) : m(!1)), t;
}
function Tt(e, t) {
  let {
    target: r,
    replace: o,
    state: a,
    preventScrollReset: l,
    relative: i,
    viewTransition: u
  } = t === void 0 ? {} : t, f = te(), s = L(), c = Y(e, {
    relative: i
  });
  return n.useCallback((d) => {
    if (sr(d, r)) {
      d.preventDefault();
      let p = o !== void 0 ? o : Q(s) === Q(c);
      f(e, {
        replace: p,
        state: a,
        preventScrollReset: l,
        relative: i,
        viewTransition: u
      });
    }
  }, [s, f, c, o, a, r, e, l, i, u]);
}
function Tr(e) {
  process.env.NODE_ENV !== "production" && C(typeof URLSearchParams < "u", "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.");
  let t = n.useRef(ce(e)), r = n.useRef(!1), o = L(), a = n.useMemo(() => (
    // Only merge in the defaults if we haven't yet called setSearchParams.
    // Once we call that we want those to take precedence, otherwise you can't
    // remove a param with setSearchParams({}) if it has an initial value
    ur(o.search, r.current ? null : t.current)
  ), [o.search]), l = te(), i = n.useCallback((u, f) => {
    const s = ce(typeof u == "function" ? u(a) : u);
    r.current = !0, l("?" + s, f);
  }, [l, a]);
  return [a, i];
}
function Fr() {
  if (typeof document > "u")
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
}
let Ur = 0, Ft = () => "__" + String(++Ur) + "__";
function ze() {
  let {
    router: e
  } = ge($.UseSubmit), {
    basename: t
  } = n.useContext(S), r = Fe();
  return n.useCallback(function(o, a) {
    a === void 0 && (a = {}), Fr();
    let {
      action: l,
      method: i,
      encType: u,
      formData: f,
      body: s
    } = fr(o, t);
    if (a.navigate === !1) {
      let c = a.fetcherKey || Ft();
      e.fetch(c, r, a.action || l, {
        preventScrollReset: a.preventScrollReset,
        formData: f,
        body: s,
        formMethod: a.method || i,
        formEncType: a.encType || u,
        flushSync: a.flushSync
      });
    } else
      e.navigate(a.action || l, {
        preventScrollReset: a.preventScrollReset,
        formData: f,
        body: s,
        formMethod: a.method || i,
        formEncType: a.encType || u,
        replace: a.replace,
        state: a.state,
        fromRouteId: r,
        flushSync: a.flushSync,
        viewTransition: a.viewTransition
      });
  }, [e, t, r]);
}
function Ut(e, t) {
  let {
    relative: r
  } = t === void 0 ? {} : t, {
    basename: o
  } = n.useContext(S), a = n.useContext(_);
  a || (process.env.NODE_ENV !== "production" ? m(!1, "useFormAction must be used inside a RouteContext") : m(!1));
  let [l] = a.matches.slice(-1), i = D({}, Y(e || ".", {
    relative: r
  })), u = L();
  if (e == null) {
    i.search = u.search;
    let f = new URLSearchParams(i.search), s = f.getAll("index");
    if (s.some((d) => d === "")) {
      f.delete("index"), s.filter((p) => p).forEach((p) => f.append("index", p));
      let d = f.toString();
      i.search = d ? "?" + d : "";
    }
  }
  return (!e || e === ".") && l.route.index && (i.search = i.search ? i.search.replace(/^\?/, "?index&") : "?index"), o !== "/" && (i.pathname = i.pathname === "/" ? o : G([o, i.pathname])), Q(i);
}
function Vr(e) {
  var t;
  let {
    key: r
  } = e === void 0 ? {} : e, {
    router: o
  } = ge($.UseFetcher), a = Ke(ee.UseFetcher), l = n.useContext(ye), i = n.useContext(_), u = (t = i.matches[i.matches.length - 1]) == null ? void 0 : t.route.id;
  l || (process.env.NODE_ENV !== "production" ? m(!1, "useFetcher must be used inside a FetchersContext") : m(!1)), i || (process.env.NODE_ENV !== "production" ? m(!1, "useFetcher must be used inside a RouteContext") : m(!1)), u == null && (process.env.NODE_ENV !== "production" ? m(!1, 'useFetcher can only be used on routes that contain a unique "id"') : m(!1));
  let f = $e ? $e() : "", [s, c] = n.useState(r || f);
  r && r !== s ? c(r) : s || c(Ft()), n.useEffect(() => (o.getFetcher(s), () => {
    o.deleteFetcher(s);
  }), [o, s]);
  let d = n.useCallback((h, E) => {
    u || (process.env.NODE_ENV !== "production" ? m(!1, "No routeId available for fetcher.load()") : m(!1)), o.fetch(s, u, h, E);
  }, [s, u, o]), p = ze(), v = n.useCallback((h, E) => {
    p(h, D({}, E, {
      navigate: !1,
      fetcherKey: s
    }));
  }, [s, p]), g = n.useMemo(() => {
    let h = /* @__PURE__ */ n.forwardRef((E, b) => /* @__PURE__ */ n.createElement(He, D({}, E, {
      navigate: !1,
      fetcherKey: s,
      ref: b
    })));
    return process.env.NODE_ENV !== "production" && (h.displayName = "fetcher.Form"), h;
  }, [s]), N = a.fetchers.get(s) || Kt, y = l.get(s);
  return n.useMemo(() => D({
    Form: g,
    submit: v,
    load: d
  }, N, {
    data: y
  }), [g, v, d, N, y]);
}
function kr() {
  let e = Ke(ee.UseFetchers);
  return Array.from(e.fetchers.entries()).map((t) => {
    let [r, o] = t;
    return D({}, o, {
      key: r
    });
  });
}
const Je = "react-router-scroll-positions";
let ie = {};
function Vt(e) {
  let {
    getKey: t,
    storageKey: r
  } = e === void 0 ? {} : e, {
    router: o
  } = ge($.UseScrollRestoration), {
    restoreScrollPosition: a,
    preventScrollReset: l
  } = Ke(ee.UseScrollRestoration), {
    basename: i
  } = n.useContext(S), u = L(), f = Ve(), s = Ue();
  n.useEffect(() => (window.history.scrollRestoration = "manual", () => {
    window.history.scrollRestoration = "auto";
  }), []), Ar(n.useCallback(() => {
    if (s.state === "idle") {
      let c = (t ? t(u, f) : null) || u.key;
      ie[c] = window.scrollY;
    }
    try {
      sessionStorage.setItem(r || Je, JSON.stringify(ie));
    } catch (c) {
      process.env.NODE_ENV !== "production" && C(!1, "Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (" + c + ").");
    }
    window.history.scrollRestoration = "auto";
  }, [r, t, s.state, u, f])), typeof document < "u" && (n.useLayoutEffect(() => {
    try {
      let c = sessionStorage.getItem(r || Je);
      c && (ie = JSON.parse(c));
    } catch {
    }
  }, [r]), n.useLayoutEffect(() => {
    let c = t && i !== "/" ? (p, v) => t(
      // Strip the basename to match useLocation()
      D({}, p, {
        pathname: T(p.pathname, i) || p.pathname
      }),
      v
    ) : t, d = o == null ? void 0 : o.enableScrollRestoration(ie, () => window.scrollY, c);
    return () => d && d();
  }, [o, i, t]), n.useLayoutEffect(() => {
    if (a !== !1) {
      if (typeof a == "number") {
        window.scrollTo(0, a);
        return;
      }
      if (u.hash) {
        let c = document.getElementById(decodeURIComponent(u.hash.slice(1)));
        if (c) {
          c.scrollIntoView();
          return;
        }
      }
      l !== !0 && window.scrollTo(0, 0);
    }
  }, [u, a, l]));
}
function Ir(e, t) {
  let {
    capture: r
  } = t || {};
  n.useEffect(() => {
    let o = r != null ? {
      capture: r
    } : void 0;
    return window.addEventListener("beforeunload", e, o), () => {
      window.removeEventListener("beforeunload", e, o);
    };
  }, [e, r]);
}
function Ar(e, t) {
  let {
    capture: r
  } = {};
  n.useEffect(() => {
    let o = r != null ? {
      capture: r
    } : void 0;
    return window.addEventListener("pagehide", e, o), () => {
      window.removeEventListener("pagehide", e, o);
    };
  }, [e, r]);
}
function Br(e) {
  let {
    when: t,
    message: r
  } = e, o = Ae(t);
  n.useEffect(() => {
    o.state === "blocked" && (window.confirm(r) ? setTimeout(o.proceed, 0) : o.reset());
  }, [o, r]), n.useEffect(() => {
    o.state === "blocked" && !t && o.reset();
  }, [o, t]);
}
function kt(e, t) {
  t === void 0 && (t = {});
  let r = n.useContext(Ee);
  r == null && (process.env.NODE_ENV !== "production" ? m(!1, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?") : m(!1));
  let {
    basename: o
  } = ge($.useViewTransitionState), a = Y(e, {
    relative: t.relative
  });
  if (!r.isTransitioning)
    return !1;
  let l = T(r.currentLocation.pathname, o) || r.currentLocation.pathname, i = T(r.nextLocation.pathname, o) || r.nextLocation.pathname;
  return X(a.pathname, i) != null || X(a.pathname, l) != null;
}
const Hr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortedDeferredError: Se,
  Await: Ct,
  BrowserRouter: Dr,
  Form: He,
  HashRouter: Or,
  Link: je,
  MemoryRouter: Nt,
  NavLink: Ot,
  Navigate: bt,
  get NavigationType() {
    return de;
  },
  Outlet: Rt,
  Route: Be,
  Router: H,
  RouterProvider: Sr,
  Routes: wt,
  ScrollRestoration: Pt,
  UNSAFE_DataRouterContext: U,
  UNSAFE_DataRouterStateContext: B,
  UNSAFE_ErrorResponseImpl: at,
  UNSAFE_FetchersContext: ye,
  UNSAFE_LocationContext: M,
  UNSAFE_NavigationContext: S,
  UNSAFE_RouteContext: _,
  UNSAFE_ViewTransitionContext: Ee,
  UNSAFE_useRouteId: Fe,
  UNSAFE_useScrollRestoration: Vt,
  createBrowserRouter: Er,
  createHashRouter: yr,
  createMemoryRouter: _t,
  createPath: Q,
  createRoutesFromChildren: W,
  createRoutesFromElements: W,
  createSearchParams: ce,
  defer: Ge,
  generatePath: Xe,
  isRouteErrorResponse: Ce,
  json: Qe,
  matchPath: X,
  matchRoutes: we,
  parsePath: fe,
  redirect: Ze,
  redirectDocument: et,
  renderMatches: St,
  replace: tt,
  resolvePath: rt,
  unstable_HistoryRouter: Dt,
  unstable_usePrompt: Br,
  useActionData: Et,
  useAsyncError: yt,
  useAsyncValue: Ie,
  useBeforeUnload: Ir,
  useBlocker: Ae,
  useFetcher: Vr,
  useFetchers: kr,
  useFormAction: Ut,
  useHref: De,
  useInRouterContext: V,
  useLinkClickHandler: Tt,
  useLoaderData: mt,
  useLocation: L,
  useMatch: lt,
  useMatches: Ve,
  useNavigate: te,
  useNavigation: Ue,
  useNavigationType: it,
  useOutlet: Oe,
  useOutletContext: dt,
  useParams: ft,
  useResolvedPath: Y,
  useRevalidator: ht,
  useRouteError: ke,
  useRouteLoaderData: vt,
  useRoutes: Pe,
  useSearchParams: Tr,
  useSubmit: ze,
  useViewTransitionState: kt
}, Symbol.toStringTag, { value: "Module" }));
export {
  je as L,
  Ot as N,
  Rt as O,
  Sr as R,
  te as a,
  Tr as b,
  ft as c,
  ke as d,
  jr as e,
  Hr as f,
  Ue as g,
  L as u
};
//# sourceMappingURL=index-BRCiYFaL.js.map
