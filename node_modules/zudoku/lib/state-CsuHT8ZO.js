import I from "react";
const _ = (t) => {
  let s;
  const e = /* @__PURE__ */ new Set(), o = (i, S) => {
    const v = typeof i == "function" ? i(s) : i;
    if (!Object.is(v, s)) {
      const f = s;
      s = S ?? (typeof v != "object" || v === null) ? v : Object.assign({}, s, v), e.forEach((d) => d(s, f));
    }
  }, a = () => s, u = { setState: o, getState: a, getInitialState: () => l, subscribe: (i) => (e.add(i), () => e.delete(i)) }, l = s = t(o, a, u);
  return u;
}, w = (t) => t ? _(t) : _, E = (t) => t;
function k(t, s = E) {
  const e = I.useSyncExternalStore(
    t.subscribe,
    () => s(t.getState()),
    () => s(t.getInitialState())
  );
  return I.useDebugValue(e), e;
}
const H = (t) => {
  const s = w(t), e = (o) => k(s, o);
  return Object.assign(e, s), e;
}, O = (t) => t ? H(t) : H;
function x(t, s) {
  let e;
  try {
    e = t();
  } catch {
    return;
  }
  return {
    getItem: (a) => {
      var n;
      const m = (l) => l === null ? null : JSON.parse(l, void 0), u = (n = e.getItem(a)) != null ? n : null;
      return u instanceof Promise ? u.then(m) : m(u);
    },
    setItem: (a, n) => e.setItem(
      a,
      JSON.stringify(n, void 0)
    ),
    removeItem: (a) => e.removeItem(a)
  };
}
const b = (t) => (s) => {
  try {
    const e = t(s);
    return e instanceof Promise ? e : {
      then(o) {
        return b(o)(e);
      },
      catch(o) {
        return this;
      }
    };
  } catch (e) {
    return {
      then(o) {
        return this;
      },
      catch(o) {
        return b(o)(e);
      }
    };
  }
}, F = (t, s) => (e, o, a) => {
  let n = {
    storage: x(() => localStorage),
    partialize: (r) => r,
    version: 0,
    merge: (r, h) => ({
      ...h,
      ...r
    }),
    ...s
  }, m = !1;
  const u = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  let i = n.storage;
  if (!i)
    return t(
      (...r) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${n.name}', the given storage is currently unavailable.`
        ), e(...r);
      },
      o,
      a
    );
  const S = () => {
    const r = n.partialize({ ...o() });
    return i.setItem(n.name, {
      state: r,
      version: n.version
    });
  }, v = a.setState;
  a.setState = (r, h) => {
    v(r, h), S();
  };
  const f = t(
    (...r) => {
      e(...r), S();
    },
    o,
    a
  );
  a.getInitialState = () => f;
  let d;
  const p = () => {
    var r, h;
    if (!i) return;
    m = !1, u.forEach((c) => {
      var g;
      return c((g = o()) != null ? g : f);
    });
    const y = ((h = n.onRehydrateStorage) == null ? void 0 : h.call(n, (r = o()) != null ? r : f)) || void 0;
    return b(i.getItem.bind(i))(n.name).then((c) => {
      if (c)
        if (typeof c.version == "number" && c.version !== n.version) {
          if (n.migrate)
            return [
              !0,
              n.migrate(
                c.state,
                c.version
              )
            ];
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [!1, c.state];
      return [!1, void 0];
    }).then((c) => {
      var g;
      const [j, R] = c;
      if (d = n.merge(
        R,
        (g = o()) != null ? g : f
      ), e(d, !0), j)
        return S();
    }).then(() => {
      y == null || y(d, void 0), d = o(), m = !0, l.forEach((c) => c(d));
    }).catch((c) => {
      y == null || y(void 0, c);
    });
  };
  return a.persist = {
    setOptions: (r) => {
      n = {
        ...n,
        ...r
      }, r.storage && (i = r.storage);
    },
    clearStorage: () => {
      i == null || i.removeItem(n.name);
    },
    getOptions: () => n,
    rehydrate: () => p(),
    hasHydrated: () => m,
    onHydrate: (r) => (u.add(r), () => {
      u.delete(r);
    }),
    onFinishHydration: (r) => (l.add(r), () => {
      l.delete(r);
    })
  }, n.skipHydration || p(), d || f;
}, J = F, P = O(() => ({
  isPending: !1,
  isAuthenticated: !1
})), A = O()(
  J(
    (t) => ({
      selectedServer: void 0,
      setSelectedServer: (s) => t({ selectedServer: s })
    }),
    { name: "zudoku-selected-server" }
  )
);
export {
  A as a,
  P as u
};
//# sourceMappingURL=state-CsuHT8ZO.js.map
