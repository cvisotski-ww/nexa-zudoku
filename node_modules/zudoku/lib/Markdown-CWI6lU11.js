import { j as Q } from "./jsx-runtime-B6kdoens.js";
import { L as Ms } from "./index-BRCiYFaL.js";
import { createContext as Ti, useState as Tr, useRef as At, useEffect as hn, useMemo as tr, useContext as yi, useCallback as pn, createElement as Fs } from "react";
import { InfoIcon as Qr, LightbulbIcon as Bs, AlertTriangleIcon as vs, ShieldAlertIcon as Hs, CheckIcon as Us, CopyIcon as zs } from "lucide-react";
import { c as Xr, g as Ys, e as js } from "./index-DJqnphbT.js";
function Ai(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (n = Ai(e[t])) && (r && (r += " "), r += n);
  else for (t in e) e[t] && (r && (r += " "), r += t);
  return r;
}
function Gs() {
  for (var e, t, n = 0, r = ""; n < arguments.length; ) (e = arguments[n++]) && (t = Ai(e)) && (r && (r += " "), r += t);
  return r;
}
const Kr = (e) => typeof e == "boolean" ? "".concat(e) : e === 0 ? "0" : e, Zr = Gs, qs = (e, t) => (n) => {
  var r;
  if ((t == null ? void 0 : t.variants) == null) return Zr(e, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
  const { variants: a, defaultVariants: u } = t, i = Object.keys(a).map((c) => {
    const f = n == null ? void 0 : n[c], d = u == null ? void 0 : u[c];
    if (f === null) return null;
    const b = Kr(f) || Kr(d);
    return a[c][b];
  }), o = n && Object.entries(n).reduce((c, f) => {
    let [d, b] = f;
    return b === void 0 || (c[d] = b), c;
  }, {}), l = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((c, f) => {
    let { class: d, className: b, ...m } = f;
    return Object.entries(m).every((h) => {
      let [E, y] = h;
      return Array.isArray(y) ? y.includes({
        ...u,
        ...o
      }[E]) : {
        ...u,
        ...o
      }[E] === y;
    }) ? [
      ...c,
      d,
      b
    ] : c;
  }, []);
  return Zr(e, i, l, n == null ? void 0 : n.class, n == null ? void 0 : n.className);
};
function _i(e) {
  var t, n, r = "";
  if (typeof e == "string" || typeof e == "number") r += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var a = e.length;
    for (t = 0; t < a; t++) e[t] && (n = _i(e[t])) && (r && (r += " "), r += n);
  } else for (n in e) e[n] && (r && (r += " "), r += n);
  return r;
}
function yr() {
  for (var e, t, n = 0, r = "", a = arguments.length; n < a; n++) (e = arguments[n]) && (t = _i(e)) && (r && (r += " "), r += t);
  return r;
}
const Ar = "-", $s = (e) => {
  const t = Vs(e), {
    conflictingClassGroups: n,
    conflictingClassGroupModifiers: r
  } = e;
  return {
    getClassGroupId: (i) => {
      const o = i.split(Ar);
      return o[0] === "" && o.length !== 1 && o.shift(), Ci(o, t) || Ws(i);
    },
    getConflictingClassGroupIds: (i, o) => {
      const l = n[i] || [];
      return o && r[i] ? [...l, ...r[i]] : l;
    }
  };
}, Ci = (e, t) => {
  var i;
  if (e.length === 0)
    return t.classGroupId;
  const n = e[0], r = t.nextPart.get(n), a = r ? Ci(e.slice(1), r) : void 0;
  if (a)
    return a;
  if (t.validators.length === 0)
    return;
  const u = e.join(Ar);
  return (i = t.validators.find(({
    validator: o
  }) => o(u))) == null ? void 0 : i.classGroupId;
}, Jr = /^\[(.+)\]$/, Ws = (e) => {
  if (Jr.test(e)) {
    const t = Jr.exec(e)[1], n = t == null ? void 0 : t.substring(0, t.indexOf(":"));
    if (n)
      return "arbitrary.." + n;
  }
}, Vs = (e) => {
  const {
    theme: t,
    prefix: n
  } = e, r = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return Xs(Object.entries(e.classGroups), n).forEach(([u, i]) => {
    nr(i, r, u, t);
  }), r;
}, nr = (e, t, n, r) => {
  e.forEach((a) => {
    if (typeof a == "string") {
      const u = a === "" ? t : ea(t, a);
      u.classGroupId = n;
      return;
    }
    if (typeof a == "function") {
      if (Qs(a)) {
        nr(a(r), t, n, r);
        return;
      }
      t.validators.push({
        validator: a,
        classGroupId: n
      });
      return;
    }
    Object.entries(a).forEach(([u, i]) => {
      nr(i, ea(t, u), n, r);
    });
  });
}, ea = (e, t) => {
  let n = e;
  return t.split(Ar).forEach((r) => {
    n.nextPart.has(r) || n.nextPart.set(r, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n = n.nextPart.get(r);
  }), n;
}, Qs = (e) => e.isThemeGetter, Xs = (e, t) => t ? e.map(([n, r]) => {
  const a = r.map((u) => typeof u == "string" ? t + u : typeof u == "object" ? Object.fromEntries(Object.entries(u).map(([i, o]) => [t + i, o])) : u);
  return [n, a];
}) : e, Ks = (e) => {
  if (e < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  const a = (u, i) => {
    n.set(u, i), t++, t > e && (t = 0, r = n, n = /* @__PURE__ */ new Map());
  };
  return {
    get(u) {
      let i = n.get(u);
      if (i !== void 0)
        return i;
      if ((i = r.get(u)) !== void 0)
        return a(u, i), i;
    },
    set(u, i) {
      n.has(u) ? n.set(u, i) : a(u, i);
    }
  };
}, xi = "!", Zs = (e) => {
  const {
    separator: t,
    experimentalParseClassName: n
  } = e, r = t.length === 1, a = t[0], u = t.length, i = (o) => {
    const l = [];
    let c = 0, f = 0, d;
    for (let y = 0; y < o.length; y++) {
      let _ = o[y];
      if (c === 0) {
        if (_ === a && (r || o.slice(y, y + u) === t)) {
          l.push(o.slice(f, y)), f = y + u;
          continue;
        }
        if (_ === "/") {
          d = y;
          continue;
        }
      }
      _ === "[" ? c++ : _ === "]" && c--;
    }
    const b = l.length === 0 ? o : o.substring(f), m = b.startsWith(xi), h = m ? b.substring(1) : b, E = d && d > f ? d - f : void 0;
    return {
      modifiers: l,
      hasImportantModifier: m,
      baseClassName: h,
      maybePostfixModifierPosition: E
    };
  };
  return n ? (o) => n({
    className: o,
    parseClassName: i
  }) : i;
}, Js = (e) => {
  if (e.length <= 1)
    return e;
  const t = [];
  let n = [];
  return e.forEach((r) => {
    r[0] === "[" ? (t.push(...n.sort(), r), n = []) : n.push(r);
  }), t.push(...n.sort()), t;
}, eo = (e) => ({
  cache: Ks(e.cacheSize),
  parseClassName: Zs(e),
  ...$s(e)
}), to = /\s+/, no = (e, t) => {
  const {
    parseClassName: n,
    getClassGroupId: r,
    getConflictingClassGroupIds: a
  } = t, u = [], i = e.trim().split(to);
  let o = "";
  for (let l = i.length - 1; l >= 0; l -= 1) {
    const c = i[l], {
      modifiers: f,
      hasImportantModifier: d,
      baseClassName: b,
      maybePostfixModifierPosition: m
    } = n(c);
    let h = !!m, E = r(h ? b.substring(0, m) : b);
    if (!E) {
      if (!h) {
        o = c + (o.length > 0 ? " " + o : o);
        continue;
      }
      if (E = r(b), !E) {
        o = c + (o.length > 0 ? " " + o : o);
        continue;
      }
      h = !1;
    }
    const y = Js(f).join(":"), _ = d ? y + xi : y, x = _ + E;
    if (u.includes(x))
      continue;
    u.push(x);
    const I = a(E, h);
    for (let M = 0; M < I.length; ++M) {
      const B = I[M];
      u.push(_ + B);
    }
    o = c + (o.length > 0 ? " " + o : o);
  }
  return o;
};
function ro() {
  let e = 0, t, n, r = "";
  for (; e < arguments.length; )
    (t = arguments[e++]) && (n = ki(t)) && (r && (r += " "), r += n);
  return r;
}
const ki = (e) => {
  if (typeof e == "string")
    return e;
  let t, n = "";
  for (let r = 0; r < e.length; r++)
    e[r] && (t = ki(e[r])) && (n && (n += " "), n += t);
  return n;
};
function ao(e, ...t) {
  let n, r, a, u = i;
  function i(l) {
    const c = t.reduce((f, d) => d(f), e());
    return n = eo(c), r = n.cache.get, a = n.cache.set, u = o, o(l);
  }
  function o(l) {
    const c = r(l);
    if (c)
      return c;
    const f = no(l, n);
    return a(l, f), f;
  }
  return function() {
    return u(ro.apply(null, arguments));
  };
}
const oe = (e) => {
  const t = (n) => n[e] || [];
  return t.isThemeGetter = !0, t;
}, Ii = /^\[(?:([a-z-]+):)?(.+)\]$/i, io = /^\d+\/\d+$/, uo = /* @__PURE__ */ new Set(["px", "full", "screen"]), so = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, oo = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, lo = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/, co = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, fo = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, $e = (e) => Tt(e) || uo.has(e) || io.test(e), Ve = (e) => xt(e, "length", yo), Tt = (e) => !!e && !Number.isNaN(Number(e)), Fn = (e) => xt(e, "number", Tt), wt = (e) => !!e && Number.isInteger(Number(e)), ho = (e) => e.endsWith("%") && Tt(e.slice(0, -1)), V = (e) => Ii.test(e), Qe = (e) => so.test(e), po = /* @__PURE__ */ new Set(["length", "size", "percentage"]), mo = (e) => xt(e, po, Si), go = (e) => xt(e, "position", Si), bo = /* @__PURE__ */ new Set(["image", "url"]), Eo = (e) => xt(e, bo, _o), To = (e) => xt(e, "", Ao), Dt = () => !0, xt = (e, t, n) => {
  const r = Ii.exec(e);
  return r ? r[1] ? typeof t == "string" ? r[1] === t : t.has(r[1]) : n(r[2]) : !1;
}, yo = (e) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  oo.test(e) && !lo.test(e)
), Si = () => !1, Ao = (e) => co.test(e), _o = (e) => fo.test(e), Co = () => {
  const e = oe("colors"), t = oe("spacing"), n = oe("blur"), r = oe("brightness"), a = oe("borderColor"), u = oe("borderRadius"), i = oe("borderSpacing"), o = oe("borderWidth"), l = oe("contrast"), c = oe("grayscale"), f = oe("hueRotate"), d = oe("invert"), b = oe("gap"), m = oe("gradientColorStops"), h = oe("gradientColorStopPositions"), E = oe("inset"), y = oe("margin"), _ = oe("opacity"), x = oe("padding"), I = oe("saturate"), M = oe("scale"), B = oe("sepia"), R = oe("skew"), U = oe("space"), q = oe("translate"), Y = () => ["auto", "contain", "none"], S = () => ["auto", "hidden", "clip", "visible", "scroll"], H = () => ["auto", V, t], F = () => [V, t], ee = () => ["", $e, Ve], G = () => ["auto", Tt, V], j = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], te = () => ["solid", "dashed", "dotted", "double", "none"], se = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], re = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], me = () => ["", "0", V], A = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], ae = () => [Tt, V];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Dt],
      spacing: [$e, Ve],
      blur: ["none", "", Qe, V],
      brightness: ae(),
      borderColor: [e],
      borderRadius: ["none", "", "full", Qe, V],
      borderSpacing: F(),
      borderWidth: ee(),
      contrast: ae(),
      grayscale: me(),
      hueRotate: ae(),
      invert: me(),
      gap: F(),
      gradientColorStops: [e],
      gradientColorStopPositions: [ho, Ve],
      inset: H(),
      margin: H(),
      opacity: ae(),
      padding: F(),
      saturate: ae(),
      scale: ae(),
      sepia: me(),
      skew: ae(),
      space: F(),
      translate: F()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", V]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Qe]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": A()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": A()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...j(), V]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: S()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": S()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": S()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: Y()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": Y()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": Y()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [E]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [E]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [E]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [E]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [E]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [E]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [E]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [E]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [E]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", wt, V]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: H()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", V]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: me()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: me()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", wt, V]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Dt]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", wt, V]
        }, V]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": G()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": G()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Dt]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [wt, V]
        }, V]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": G()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": G()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", V]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", V]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [b]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [b]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [b]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...re()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...re(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...re(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [x]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [x]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [x]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [x]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [x]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [x]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [x]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [x]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [x]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [y]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [y]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [y]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [y]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [y]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [y]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [y]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [y]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [y]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [U]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [U]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", V, t]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [V, t, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [V, t, "none", "full", "min", "max", "fit", "prose", {
          screen: [Qe]
        }, Qe]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [V, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [V, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [V, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [V, t, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", Qe, Ve]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Fn]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Dt]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", V]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Tt, Fn]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", $e, V]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", V]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", V]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [_]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [_]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...te(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", $e, Ve]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", $e, V]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: F()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", V]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", V]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [_]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...j(), go]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", mo]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, Eo]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [h]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [m]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [m]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [m]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [u]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [u]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [u]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [u]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [u]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [u]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [u]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [u]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [u]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [u]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [u]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [u]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [u]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [u]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [u]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [o]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [o]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [o]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [o]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [o]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [o]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [o]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [o]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [o]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [_]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...te(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [o]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [o]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [_]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: te()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [a]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [a]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [a]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [a]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [a]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [a]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [a]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [a]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [a]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [a]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...te()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [$e, V]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [$e, Ve]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: ee()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [_]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [$e, Ve]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", Qe, To]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Dt]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [_]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...se(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": se()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [n]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [r]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", Qe, V]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [c]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [f]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [d]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [I]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [B]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [n]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [r]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [c]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [f]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [d]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [_]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [I]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [B]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [i]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [i]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [i]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", V]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: ae()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", V]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: ae()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", V]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [M]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [M]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [M]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [wt, V]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [q]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [q]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [R]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [R]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", V]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", V]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": F()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": F()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": F()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": F()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": F()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": F()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": F()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": F()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": F()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": F()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": F()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": F()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": F()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": F()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": F()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": F()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": F()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": F()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", V]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [$e, Ve, Fn]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
}, xo = /* @__PURE__ */ ao(Co);
function bt(...e) {
  return xo(yr(e));
}
const ko = {
  note: {
    border: "border-gray-300 dark:border-zinc-800",
    bg: "bg-gray-100 dark:bg-zinc-800/50",
    iconColor: "text-gray-600 dark:text-zinc-300",
    titleColor: "text-gray-600 dark:text-zinc-300",
    textColor: "text-gray-600 dark:text-zinc-300",
    Icon: Qr
  },
  tip: {
    border: "border-green-500 dark:border-green-800",
    bg: "bg-green-200/25 dark:bg-green-950/70",
    iconColor: "text-green-600 dark:text-green-200",
    titleColor: "text-green-700 dark:text-green-200",
    textColor: "text-green-600 dark:text-green-50",
    Icon: Bs
  },
  info: {
    border: "border-blue-400 dark:border-blue-900/60",
    bg: "bg-blue-50 dark:bg-blue-950/40",
    iconColor: "text-blue-400 dark:text-blue-200",
    titleColor: "text-blue-700 dark:text-blue-200",
    textColor: "text-blue-600 dark:text-blue-100",
    Icon: Qr
  },
  caution: {
    border: "border-yellow-400 dark:border-yellow-400/25",
    bg: "bg-yellow-100/60 dark:bg-yellow-400/10",
    iconColor: "text-yellow-500 dark:text-yellow-300",
    titleColor: "text-yellow-600 dark:text-yellow-300",
    textColor: "text-yellow-700 dark:text-yellow-200",
    Icon: vs
  },
  danger: {
    border: "border-rose-400 dark:border-rose-800",
    bg: "bg-rose-50 dark:bg-rose-950/40",
    iconColor: "text-rose-400 dark:text-rose-300",
    titleColor: "text-rose-800 dark:text-rose-300",
    textColor: "text-rose-700 dark:text-rose-100",
    Icon: Hs
  }
}, at = ({ type: e, children: t, title: n, className: r }) => {
  const { border: a, bg: u, iconColor: i, titleColor: o, textColor: l, Icon: c } = ko[e];
  return /* @__PURE__ */ Q.jsxs(
    "div",
    {
      className: bt(
        "not-prose grid grid-cols-[min-content_1fr] grid-rows-[fit-content_1fr] gap-x-4 gap-y-2 text-md rounded-md border p-4",
        "[&_a]:underline [&_a]:decoration-current [&_a]:decoration-from-font [&_a]:underline-offset-4 hover:[&_a]:decoration-1",
        "[&_code]:!bg-gray-50 [&_code]:dark:!bg-gray-800 [&_code]:!border-none my-2",
        n && "items-center",
        a,
        u,
        r
      ),
      children: [
        /* @__PURE__ */ Q.jsx(
          c,
          {
            className: bt(!n && "translate-y-px", i),
            size: 20,
            "aria-hidden": "true"
          }
        ),
        n && /* @__PURE__ */ Q.jsx("h3", { className: bt("font-medium", o), children: n }),
        /* @__PURE__ */ Q.jsx("div", { className: bt("col-start-2", !n && "row-start-1", l), children: t })
      ]
    }
  );
}, Ni = Ti(
  void 0
), Io = () => {
  const e = yi(Ni);
  if (!e)
    throw new Error(
      "useViewportAnchor must be used within a CurrentAnchorProvider"
    );
  return e;
}, So = () => {
  const e = At(null), { observe: t, unobserve: n } = Io();
  return hn(() => {
    const a = e.current;
    if (a)
      return t(a), () => n(a);
  }, [t, n]), { ref: pn((a) => {
    a && (e.current = a);
  }, []) };
}, Db = ({
  children: e
}) => {
  const [t, n] = Tr(""), r = At(null), a = At(/* @__PURE__ */ new Set());
  hn(() => (r.current = new IntersectionObserver(
    (o) => {
      for (const l of o)
        l.isIntersecting && l.target.id && n(l.target.id);
    },
    {
      // 115px is the height of the sticky header
      // see --header-height in `main.css`
      rootMargin: "115px 0px -80% 0px",
      threshold: 0.75
    }
  ), () => {
    var o;
    return (o = r.current) == null ? void 0 : o.disconnect();
  }), []), hn(() => {
    const o = a.current, l = () => {
      const c = window.scrollY === 0, f = window.innerHeight + window.scrollY >= document.body.scrollHeight;
      c ? n("") : f && requestIdleCallback(() => {
        const d = Array.from(o).pop();
        n((d == null ? void 0 : d.id) ?? "");
      });
    };
    return document.addEventListener("scroll", l), () => {
      o.clear(), document.removeEventListener("scroll", l);
    };
  }, []);
  const u = tr(() => ({
    observe: (o) => {
      !o || !r.current || (a.current.add(o), r.current.observe(o));
    },
    unobserve: (o) => {
      !o || !r.current || (a.current.delete(o), r.current.unobserve(o));
    }
  }), []), i = tr(
    () => ({ activeAnchor: t, setActiveAnchor: n, ...u }),
    [t, n, u]
  );
  return /* @__PURE__ */ Q.jsx(Ni.Provider, { value: i, children: e });
}, No = qs("group relative", {
  variants: {
    level: {
      6: "text-md",
      5: "text-lg",
      4: "text-xl",
      3: "text-xl font-semibold",
      2: "text-2xl font-bold",
      1: "text-4xl font-extrabold"
    }
  },
  defaultVariants: {
    level: 1
  }
}), Ro = (e) => {
  switch (e) {
    case 1:
      return "h1";
    case 2:
      return "h2";
    case 3:
      return "h3";
    case 4:
      return "h4";
    case 5:
      return "h5";
    case 6:
      return "h6";
    default:
      return "h1";
  }
}, ht = ({
  level: e,
  children: t,
  id: n,
  className: r,
  registerSidebarAnchor: a
}) => {
  const u = Ro(e ?? 1), { ref: i } = So();
  return /* @__PURE__ */ Q.jsxs(
    u,
    {
      className: No({ className: r, level: e }),
      ref: a ? i : void 0,
      id: n,
      children: [
        n && /* @__PURE__ */ Q.jsx(
          "a",
          {
            href: `#${n}`,
            className: "no-underline absolute text-primary -left-[0.8em] pr-2.5 opacity-0 group-hover:opacity-50 hover:!opacity-100 transition-opacity duration-200",
            "aria-label": `Link to ${n}`,
            children: "#"
          }
        ),
        t
      ]
    }
  );
};
function ta(e) {
  const t = [], n = String(e || "");
  let r = n.indexOf(","), a = 0, u = !1;
  for (; !u; ) {
    r === -1 && (r = n.length, u = !0);
    const i = n.slice(a, r).trim();
    (i || !u) && t.push(i), a = r + 1, r = n.indexOf(",", a);
  }
  return t;
}
function Ri(e, t) {
  const n = {};
  return (e[e.length - 1] === "" ? [...e, ""] : e).join(
    (n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")
  ).trim();
}
const Lo = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Oo = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, wo = {};
function na(e, t) {
  return (wo.jsx ? Oo : Lo).test(e);
}
const Do = /[ \t\n\f\r]/g;
function Po(e) {
  return typeof e == "object" ? e.type === "text" ? ra(e.value) : !1 : ra(e);
}
function ra(e) {
  return e.replace(Do, "") === "";
}
class Qt {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, n, r) {
    this.property = t, this.normal = n, r && (this.space = r);
  }
}
Qt.prototype.property = {};
Qt.prototype.normal = {};
Qt.prototype.space = null;
function Li(e, t) {
  const n = {}, r = {};
  let a = -1;
  for (; ++a < e.length; )
    Object.assign(n, e[a].property), Object.assign(r, e[a].normal);
  return new Qt(n, r, t);
}
function $t(e) {
  return e.toLowerCase();
}
class Le {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, n) {
    this.property = t, this.attribute = n;
  }
}
Le.prototype.space = null;
Le.prototype.boolean = !1;
Le.prototype.booleanish = !1;
Le.prototype.overloadedBoolean = !1;
Le.prototype.number = !1;
Le.prototype.commaSeparated = !1;
Le.prototype.spaceSeparated = !1;
Le.prototype.commaOrSpaceSeparated = !1;
Le.prototype.mustUseProperty = !1;
Le.prototype.defined = !1;
let Mo = 0;
const W = ct(), fe = ct(), Oi = ct(), P = ct(), ue = ct(), yt = ct(), Ie = ct();
function ct() {
  return 2 ** ++Mo;
}
const rr = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean: W,
  booleanish: fe,
  commaOrSpaceSeparated: Ie,
  commaSeparated: yt,
  number: P,
  overloadedBoolean: Oi,
  spaceSeparated: ue
}, Symbol.toStringTag, { value: "Module" })), Bn = Object.keys(rr);
class _r extends Le {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, n, r, a) {
    let u = -1;
    if (super(t, n), aa(this, "space", a), typeof r == "number")
      for (; ++u < Bn.length; ) {
        const i = Bn[u];
        aa(this, Bn[u], (r & rr[i]) === rr[i]);
      }
  }
}
_r.prototype.defined = !0;
function aa(e, t, n) {
  n && (e[t] = n);
}
const Fo = {}.hasOwnProperty;
function kt(e) {
  const t = {}, n = {};
  let r;
  for (r in e.properties)
    if (Fo.call(e.properties, r)) {
      const a = e.properties[r], u = new _r(
        r,
        e.transform(e.attributes || {}, r),
        a,
        e.space
      );
      e.mustUseProperty && e.mustUseProperty.includes(r) && (u.mustUseProperty = !0), t[r] = u, n[$t(r)] = r, n[$t(u.attribute)] = r;
    }
  return new Qt(t, n, e.space);
}
const wi = kt({
  space: "xlink",
  transform(e, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), Di = kt({
  space: "xml",
  transform(e, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Pi(e, t) {
  return t in e ? e[t] : t;
}
function Mi(e, t) {
  return Pi(e, t.toLowerCase());
}
const Fi = kt({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: Mi,
  properties: { xmlns: null, xmlnsXLink: null }
}), Bi = kt({
  transform(e, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: fe,
    ariaAutoComplete: null,
    ariaBusy: fe,
    ariaChecked: fe,
    ariaColCount: P,
    ariaColIndex: P,
    ariaColSpan: P,
    ariaControls: ue,
    ariaCurrent: null,
    ariaDescribedBy: ue,
    ariaDetails: null,
    ariaDisabled: fe,
    ariaDropEffect: ue,
    ariaErrorMessage: null,
    ariaExpanded: fe,
    ariaFlowTo: ue,
    ariaGrabbed: fe,
    ariaHasPopup: null,
    ariaHidden: fe,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: ue,
    ariaLevel: P,
    ariaLive: null,
    ariaModal: fe,
    ariaMultiLine: fe,
    ariaMultiSelectable: fe,
    ariaOrientation: null,
    ariaOwns: ue,
    ariaPlaceholder: null,
    ariaPosInSet: P,
    ariaPressed: fe,
    ariaReadOnly: fe,
    ariaRelevant: null,
    ariaRequired: fe,
    ariaRoleDescription: ue,
    ariaRowCount: P,
    ariaRowIndex: P,
    ariaRowSpan: P,
    ariaSelected: fe,
    ariaSetSize: P,
    ariaSort: null,
    ariaValueMax: P,
    ariaValueMin: P,
    ariaValueNow: P,
    ariaValueText: null,
    role: null
  }
}), Bo = kt({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: Mi,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: yt,
    acceptCharset: ue,
    accessKey: ue,
    action: null,
    allow: null,
    allowFullScreen: W,
    allowPaymentRequest: W,
    allowUserMedia: W,
    alt: null,
    as: null,
    async: W,
    autoCapitalize: null,
    autoComplete: ue,
    autoFocus: W,
    autoPlay: W,
    blocking: ue,
    capture: null,
    charSet: null,
    checked: W,
    cite: null,
    className: ue,
    cols: P,
    colSpan: null,
    content: null,
    contentEditable: fe,
    controls: W,
    controlsList: ue,
    coords: P | yt,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: W,
    defer: W,
    dir: null,
    dirName: null,
    disabled: W,
    download: Oi,
    draggable: fe,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: W,
    formTarget: null,
    headers: ue,
    height: P,
    hidden: W,
    high: P,
    href: null,
    hrefLang: null,
    htmlFor: ue,
    httpEquiv: ue,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: W,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: W,
    itemId: null,
    itemProp: ue,
    itemRef: ue,
    itemScope: W,
    itemType: ue,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: W,
    low: P,
    manifest: null,
    max: null,
    maxLength: P,
    media: null,
    method: null,
    min: null,
    minLength: P,
    multiple: W,
    muted: W,
    name: null,
    nonce: null,
    noModule: W,
    noValidate: W,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: W,
    optimum: P,
    pattern: null,
    ping: ue,
    placeholder: null,
    playsInline: W,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: W,
    referrerPolicy: null,
    rel: ue,
    required: W,
    reversed: W,
    rows: P,
    rowSpan: P,
    sandbox: ue,
    scope: null,
    scoped: W,
    seamless: W,
    selected: W,
    shadowRootClonable: W,
    shadowRootDelegatesFocus: W,
    shadowRootMode: null,
    shape: null,
    size: P,
    sizes: null,
    slot: null,
    span: P,
    spellCheck: fe,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: P,
    step: null,
    style: null,
    tabIndex: P,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: W,
    useMap: null,
    value: fe,
    width: P,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: ue,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: P,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: P,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: W,
    // Lists. Use CSS to reduce space between items instead
    declare: W,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: P,
    // `<img>` and `<object>`
    leftMargin: P,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: P,
    // `<body>`
    marginWidth: P,
    // `<body>`
    noResize: W,
    // `<frame>`
    noHref: W,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: W,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: W,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: P,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: fe,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: P,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: P,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: W,
    disableRemotePlayback: W,
    prefix: null,
    property: null,
    results: P,
    security: null,
    unselectable: null
  }
}), vo = kt({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Pi,
  properties: {
    about: Ie,
    accentHeight: P,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: P,
    amplitude: P,
    arabicForm: null,
    ascent: P,
    attributeName: null,
    attributeType: null,
    azimuth: P,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: P,
    by: null,
    calcMode: null,
    capHeight: P,
    className: ue,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: P,
    diffuseConstant: P,
    direction: null,
    display: null,
    dur: null,
    divisor: P,
    dominantBaseline: null,
    download: W,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: P,
    enableBackground: null,
    end: null,
    event: null,
    exponent: P,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: P,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: yt,
    g2: yt,
    glyphName: yt,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: P,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: P,
    horizOriginX: P,
    horizOriginY: P,
    id: null,
    ideographic: P,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: P,
    k: P,
    k1: P,
    k2: P,
    k3: P,
    k4: P,
    kernelMatrix: Ie,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: P,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: P,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: P,
    overlineThickness: P,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: P,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: ue,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: P,
    pointsAtY: P,
    pointsAtZ: P,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Ie,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Ie,
    rev: Ie,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Ie,
    requiredFeatures: Ie,
    requiredFonts: Ie,
    requiredFormats: Ie,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: P,
    specularExponent: P,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: P,
    strikethroughThickness: P,
    string: null,
    stroke: null,
    strokeDashArray: Ie,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: P,
    strokeOpacity: P,
    strokeWidth: null,
    style: null,
    surfaceScale: P,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Ie,
    tabIndex: P,
    tableValues: null,
    target: null,
    targetX: P,
    targetY: P,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Ie,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: P,
    underlineThickness: P,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: P,
    values: null,
    vAlphabetic: P,
    vMathematical: P,
    vectorEffect: null,
    vHanging: P,
    vIdeographic: P,
    version: null,
    vertAdvY: P,
    vertOriginX: P,
    vertOriginY: P,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: P,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), Ho = /^data[-\w.:]+$/i, ia = /-[a-z]/g, Uo = /[A-Z]/g;
function _n(e, t) {
  const n = $t(t);
  let r = t, a = Le;
  if (n in e.normal)
    return e.property[e.normal[n]];
  if (n.length > 4 && n.slice(0, 4) === "data" && Ho.test(t)) {
    if (t.charAt(4) === "-") {
      const u = t.slice(5).replace(ia, Yo);
      r = "data" + u.charAt(0).toUpperCase() + u.slice(1);
    } else {
      const u = t.slice(4);
      if (!ia.test(u)) {
        let i = u.replace(Uo, zo);
        i.charAt(0) !== "-" && (i = "-" + i), t = "data" + i;
      }
    }
    a = _r;
  }
  return new a(r, t);
}
function zo(e) {
  return "-" + e.toLowerCase();
}
function Yo(e) {
  return e.charAt(1).toUpperCase();
}
const jo = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, Xt = Li([Di, wi, Fi, Bi, Bo], "html"), et = Li([Di, wi, Fi, Bi, vo], "svg");
function ua(e) {
  const t = String(e || "").trim();
  return t ? t.split(/[ \t\n\r\f]+/g) : [];
}
function vi(e) {
  return e.join(" ").trim();
}
var Hi = {}, sa = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Go = /\n/g, qo = /^\s*/, $o = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Wo = /^:\s*/, Vo = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Qo = /^[;\s]*/, Xo = /^\s+|\s+$/g, Ko = `
`, oa = "/", la = "*", ut = "", Zo = "comment", Jo = "declaration", el = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function a(h) {
    var E = h.match(Go);
    E && (n += E.length);
    var y = h.lastIndexOf(Ko);
    r = ~y ? h.length - y : r + h.length;
  }
  function u() {
    var h = { line: n, column: r };
    return function(E) {
      return E.position = new i(h), c(), E;
    };
  }
  function i(h) {
    this.start = h, this.end = { line: n, column: r }, this.source = t.source;
  }
  i.prototype.content = e;
  function o(h) {
    var E = new Error(
      t.source + ":" + n + ":" + r + ": " + h
    );
    if (E.reason = h, E.filename = t.source, E.line = n, E.column = r, E.source = e, !t.silent) throw E;
  }
  function l(h) {
    var E = h.exec(e);
    if (E) {
      var y = E[0];
      return a(y), e = e.slice(y.length), E;
    }
  }
  function c() {
    l(qo);
  }
  function f(h) {
    var E;
    for (h = h || []; E = d(); )
      E !== !1 && h.push(E);
    return h;
  }
  function d() {
    var h = u();
    if (!(oa != e.charAt(0) || la != e.charAt(1))) {
      for (var E = 2; ut != e.charAt(E) && (la != e.charAt(E) || oa != e.charAt(E + 1)); )
        ++E;
      if (E += 2, ut === e.charAt(E - 1))
        return o("End of comment missing");
      var y = e.slice(2, E - 2);
      return r += 2, a(y), e = e.slice(E), r += 2, h({
        type: Zo,
        comment: y
      });
    }
  }
  function b() {
    var h = u(), E = l($o);
    if (E) {
      if (d(), !l(Wo)) return o("property missing ':'");
      var y = l(Vo), _ = h({
        type: Jo,
        property: ca(E[0].replace(sa, ut)),
        value: y ? ca(y[0].replace(sa, ut)) : ut
      });
      return l(Qo), _;
    }
  }
  function m() {
    var h = [];
    f(h);
    for (var E; E = b(); )
      E !== !1 && (h.push(E), f(h));
    return h;
  }
  return c(), m();
};
function ca(e) {
  return e ? e.replace(Xo, ut) : ut;
}
var tl = Xr && Xr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Hi, "__esModule", { value: !0 });
var nl = tl(el);
function rl(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, nl.default)(e), a = typeof t == "function";
  return r.forEach(function(u) {
    if (u.type === "declaration") {
      var i = u.property, o = u.value;
      a ? t(i, o, u) : o && (n = n || {}, n[i] = o);
    }
  }), n;
}
var da = Hi.default = rl;
const al = da.default || da, Cn = Ui("end"), Ye = Ui("start");
function Ui(e) {
  return t;
  function t(n) {
    const r = n && n.position && n.position[e] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function il(e) {
  const t = Ye(e), n = Cn(e);
  if (t && n)
    return { start: t, end: n };
}
function vt(e) {
  return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? fa(e.position) : "start" in e || "end" in e ? fa(e) : "line" in e || "column" in e ? ar(e) : "";
}
function ar(e) {
  return ha(e && e.line) + ":" + ha(e && e.column);
}
function fa(e) {
  return ar(e && e.start) + "-" + ar(e && e.end);
}
function ha(e) {
  return e && typeof e == "number" ? e : 1;
}
class be extends Error {
  /**
   * Create a message for `reason`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n, r) {
    super(), typeof n == "string" && (r = n, n = void 0);
    let a = "", u = {}, i = !1;
    if (n && ("line" in n && "column" in n ? u = { place: n } : "start" in n && "end" in n ? u = { place: n } : "type" in n ? u = {
      ancestors: [n],
      place: n.position
    } : u = { ...n }), typeof t == "string" ? a = t : !u.cause && t && (i = !0, a = t.message, u.cause = t), !u.ruleId && !u.source && typeof r == "string") {
      const l = r.indexOf(":");
      l === -1 ? u.ruleId = r : (u.source = r.slice(0, l), u.ruleId = r.slice(l + 1));
    }
    if (!u.place && u.ancestors && u.ancestors) {
      const l = u.ancestors[u.ancestors.length - 1];
      l && (u.place = l.position);
    }
    const o = u.place && "start" in u.place ? u.place.start : u.place;
    this.ancestors = u.ancestors || void 0, this.cause = u.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file, this.message = a, this.line = o ? o.line : void 0, this.name = vt(u.place) || "1:1", this.place = u.place || void 0, this.reason = this.message, this.ruleId = u.ruleId || void 0, this.source = u.source || void 0, this.stack = i && u.cause && typeof u.cause.stack == "string" ? u.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
be.prototype.file = "";
be.prototype.name = "";
be.prototype.reason = "";
be.prototype.message = "";
be.prototype.stack = "";
be.prototype.column = void 0;
be.prototype.line = void 0;
be.prototype.ancestors = void 0;
be.prototype.cause = void 0;
be.prototype.fatal = void 0;
be.prototype.place = void 0;
be.prototype.ruleId = void 0;
be.prototype.source = void 0;
const Cr = {}.hasOwnProperty, ul = /* @__PURE__ */ new Map(), sl = /[A-Z]/g, ol = /-([a-z])/g, ll = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]), cl = /* @__PURE__ */ new Set(["td", "th"]), zi = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function dl(e, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = Tl(n, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = El(n, t.jsx, t.jsxs);
  }
  const a = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n,
    ignoreInvalidStyle: t.ignoreInvalidStyle || !1,
    passKeys: t.passKeys !== !1,
    passNode: t.passNode || !1,
    schema: t.space === "svg" ? et : Xt,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== !1
  }, u = Yi(a, e, void 0);
  return u && typeof u != "string" ? u : a.create(
    e,
    a.Fragment,
    { children: u || void 0 },
    void 0
  );
}
function Yi(e, t, n) {
  if (t.type === "element")
    return fl(e, t, n);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return hl(e, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return ml(e, t, n);
  if (t.type === "mdxjsEsm")
    return pl(e, t);
  if (t.type === "root")
    return gl(e, t, n);
  if (t.type === "text")
    return bl(e, t);
}
function fl(e, t, n) {
  const r = e.schema;
  let a = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (a = et, e.schema = a), e.ancestors.push(t);
  const u = Gi(e, t.tagName, !1), i = yl(e, t);
  let o = kr(e, t);
  return ll.has(t.tagName) && (o = o.filter(function(l) {
    return typeof l == "string" ? !Po(l) : !0;
  })), ji(e, i, u, t), xr(i, o), e.ancestors.pop(), e.schema = r, e.create(t, u, i, n);
}
function hl(e, t) {
  if (t.data && t.data.estree && e.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e.evaluater.evaluateExpression(r.expression);
  }
  Wt(e, t.position);
}
function pl(e, t) {
  if (t.data && t.data.estree && e.evaluater)
    return (
      /** @type {Child | undefined} */
      e.evaluater.evaluateProgram(t.data.estree)
    );
  Wt(e, t.position);
}
function ml(e, t, n) {
  const r = e.schema;
  let a = r;
  t.name === "svg" && r.space === "html" && (a = et, e.schema = a), e.ancestors.push(t);
  const u = t.name === null ? e.Fragment : Gi(e, t.name, !0), i = Al(e, t), o = kr(e, t);
  return ji(e, i, u, t), xr(i, o), e.ancestors.pop(), e.schema = r, e.create(t, u, i, n);
}
function gl(e, t, n) {
  const r = {};
  return xr(r, kr(e, t)), e.create(t, e.Fragment, r, n);
}
function bl(e, t) {
  return t.value;
}
function ji(e, t, n, r) {
  typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r);
}
function xr(e, t) {
  if (t.length > 0) {
    const n = t.length > 1 ? t : t[0];
    n && (e.children = n);
  }
}
function El(e, t, n) {
  return r;
  function r(a, u, i, o) {
    const c = Array.isArray(i.children) ? n : t;
    return o ? c(u, i, o) : c(u, i);
  }
}
function Tl(e, t) {
  return n;
  function n(r, a, u, i) {
    const o = Array.isArray(u.children), l = Ye(r);
    return t(
      a,
      u,
      i,
      o,
      {
        columnNumber: l ? l.column - 1 : void 0,
        fileName: e,
        lineNumber: l ? l.line : void 0
      },
      void 0
    );
  }
}
function yl(e, t) {
  const n = {};
  let r, a;
  for (a in t.properties)
    if (a !== "children" && Cr.call(t.properties, a)) {
      const u = _l(e, a, t.properties[a]);
      if (u) {
        const [i, o] = u;
        e.tableCellAlignToStyle && i === "align" && typeof o == "string" && cl.has(t.tagName) ? r = o : n[i] = o;
      }
    }
  if (r) {
    const u = (
      /** @type {Style} */
      n.style || (n.style = {})
    );
    u[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n;
}
function Al(e, t) {
  const n = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e.evaluater) {
        const u = r.data.estree.body[0];
        u.type;
        const i = u.expression;
        i.type;
        const o = i.properties[0];
        o.type, Object.assign(
          n,
          e.evaluater.evaluateExpression(o.argument)
        );
      } else
        Wt(e, t.position);
    else {
      const a = r.name;
      let u;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e.evaluater) {
          const o = r.value.data.estree.body[0];
          o.type, u = e.evaluater.evaluateExpression(o.expression);
        } else
          Wt(e, t.position);
      else
        u = r.value === null ? !0 : r.value;
      n[a] = /** @type {Props[keyof Props]} */
      u;
    }
  return n;
}
function kr(e, t) {
  const n = [];
  let r = -1;
  const a = e.passKeys ? /* @__PURE__ */ new Map() : ul;
  for (; ++r < t.children.length; ) {
    const u = t.children[r];
    let i;
    if (e.passKeys) {
      const l = u.type === "element" ? u.tagName : u.type === "mdxJsxFlowElement" || u.type === "mdxJsxTextElement" ? u.name : void 0;
      if (l) {
        const c = a.get(l) || 0;
        i = l + "-" + c, a.set(l, c + 1);
      }
    }
    const o = Yi(e, u, i);
    o !== void 0 && n.push(o);
  }
  return n;
}
function _l(e, t, n) {
  const r = _n(e.schema, t);
  if (!(n == null || typeof n == "number" && Number.isNaN(n))) {
    if (Array.isArray(n) && (n = r.commaSeparated ? Ri(n) : vi(n)), r.property === "style") {
      let a = typeof n == "object" ? n : Cl(e, String(n));
      return e.stylePropertyNameCase === "css" && (a = xl(a)), ["style", a];
    }
    return [
      e.elementAttributeNameCase === "react" && r.space ? jo[r.property] || r.property : r.attribute,
      n
    ];
  }
}
function Cl(e, t) {
  const n = {};
  try {
    al(t, r);
  } catch (a) {
    if (!e.ignoreInvalidStyle) {
      const u = (
        /** @type {Error} */
        a
      ), i = new be("Cannot parse `style` attribute", {
        ancestors: e.ancestors,
        cause: u,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw i.file = e.filePath || void 0, i.url = zi + "#cannot-parse-style-attribute", i;
    }
  }
  return n;
  function r(a, u) {
    let i = a;
    i.slice(0, 2) !== "--" && (i.slice(0, 4) === "-ms-" && (i = "ms-" + i.slice(4)), i = i.replace(ol, Il)), n[i] = u;
  }
}
function Gi(e, t, n) {
  let r;
  if (!n)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const a = t.split(".");
    let u = -1, i;
    for (; ++u < a.length; ) {
      const o = na(a[u]) ? { type: "Identifier", name: a[u] } : { type: "Literal", value: a[u] };
      i = i ? {
        type: "MemberExpression",
        object: i,
        property: o,
        computed: !!(u && o.type === "Literal"),
        optional: !1
      } : o;
    }
    r = i;
  } else
    r = na(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const a = (
      /** @type {keyof JSX.IntrinsicElements} */
      r.value
    );
    return Cr.call(e.components, a) ? e.components[a] : a;
  }
  if (e.evaluater)
    return e.evaluater.evaluateExpression(r);
  Wt(e);
}
function Wt(e, t) {
  const n = new be(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n.file = e.filePath || void 0, n.url = zi + "#cannot-handle-mdx-estrees-without-createevaluater", n;
}
function xl(e) {
  const t = {};
  let n;
  for (n in e)
    Cr.call(e, n) && (t[kl(n)] = e[n]);
  return t;
}
function kl(e) {
  let t = e.replace(sl, Sl);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function Il(e, t) {
  return t.toUpperCase();
}
function Sl(e) {
  return "-" + e.toLowerCase();
}
const vn = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
}, Nl = {};
function Ir(e, t) {
  const n = Nl, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, a = typeof n.includeHtml == "boolean" ? n.includeHtml : !0;
  return qi(e, r, a);
}
function qi(e, t, n) {
  if (Rl(e)) {
    if ("value" in e)
      return e.type === "html" && !n ? "" : e.value;
    if (t && "alt" in e && e.alt)
      return e.alt;
    if ("children" in e)
      return pa(e.children, t, n);
  }
  return Array.isArray(e) ? pa(e, t, n) : "";
}
function pa(e, t, n) {
  const r = [];
  let a = -1;
  for (; ++a < e.length; )
    r[a] = qi(e[a], t, n);
  return r.join("");
}
function Rl(e) {
  return !!(e && typeof e == "object");
}
const ma = typeof document < "u" && document.createElement("i");
function Sr(e) {
  const t = "&" + e + ";";
  ma.innerHTML = t;
  const n = ma.textContent;
  return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n;
}
function Ne(e, t, n, r) {
  const a = e.length;
  let u = 0, i;
  if (t < 0 ? t = -t > a ? 0 : a + t : t = t > a ? a : t, n = n > 0 ? n : 0, r.length < 1e4)
    i = Array.from(r), i.unshift(t, n), e.splice(...i);
  else
    for (n && e.splice(t, n); u < r.length; )
      i = r.slice(u, u + 1e4), i.unshift(t, 0), e.splice(...i), u += 1e4, t += 1e4;
}
function Re(e, t) {
  return e.length > 0 ? (Ne(e, e.length, 0, t), e) : t;
}
const ga = {}.hasOwnProperty;
function $i(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    Ll(t, e[n]);
  return t;
}
function Ll(e, t) {
  let n;
  for (n in t) {
    const a = (ga.call(e, n) ? e[n] : void 0) || (e[n] = {}), u = t[n];
    let i;
    if (u)
      for (i in u) {
        ga.call(a, i) || (a[i] = []);
        const o = u[i];
        Ol(
          // @ts-expect-error Looks like a list.
          a[i],
          Array.isArray(o) ? o : o ? [o] : []
        );
      }
  }
}
function Ol(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; )
    (t[n].add === "after" ? e : r).push(t[n]);
  Ne(e, 0, 0, r);
}
function Wi(e, t) {
  const n = Number.parseInt(e, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n < 9 || n === 11 || n > 13 && n < 32 || // Control character (DEL) of C0, and C1 controls.
    n > 126 && n < 160 || // Lone high surrogates and low surrogates.
    n > 55295 && n < 57344 || // Noncharacters.
    n > 64975 && n < 65008 || /* eslint-disable no-bitwise */
    (n & 65535) === 65535 || (n & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n > 1114111 ? "" : String.fromCodePoint(n)
  );
}
function De(e) {
  return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const ye = tt(/[A-Za-z]/), ge = tt(/[\dA-Za-z]/), wl = tt(/[#-'*+\--9=?A-Z^-~]/);
function mn(e) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e !== null && (e < 32 || e === 127)
  );
}
const ir = tt(/\d/), Dl = tt(/[\dA-Fa-f]/), Pl = tt(/[!-/:-@[-`{-~]/);
function z(e) {
  return e !== null && e < -2;
}
function ie(e) {
  return e !== null && (e < 0 || e === 32);
}
function K(e) {
  return e === -2 || e === -1 || e === 32;
}
const xn = tt(new RegExp("\\p{P}|\\p{S}", "u")), lt = tt(/\s/);
function tt(e) {
  return t;
  function t(n) {
    return n !== null && n > -1 && e.test(String.fromCharCode(n));
  }
}
function It(e) {
  const t = [];
  let n = -1, r = 0, a = 0;
  for (; ++n < e.length; ) {
    const u = e.charCodeAt(n);
    let i = "";
    if (u === 37 && ge(e.charCodeAt(n + 1)) && ge(e.charCodeAt(n + 2)))
      a = 2;
    else if (u < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(u)) || (i = String.fromCharCode(u));
    else if (u > 55295 && u < 57344) {
      const o = e.charCodeAt(n + 1);
      u < 56320 && o > 56319 && o < 57344 ? (i = String.fromCharCode(u, o), a = 1) : i = "";
    } else
      i = String.fromCharCode(u);
    i && (t.push(e.slice(r, n), encodeURIComponent(i)), r = n + a + 1, i = ""), a && (n += a, a = 0);
  }
  return t.join("") + e.slice(r);
}
function J(e, t, n, r) {
  const a = r ? r - 1 : Number.POSITIVE_INFINITY;
  let u = 0;
  return i;
  function i(l) {
    return K(l) ? (e.enter(n), o(l)) : t(l);
  }
  function o(l) {
    return K(l) && u++ < a ? (e.consume(l), o) : (e.exit(n), t(l));
  }
}
const Ml = {
  tokenize: Fl
};
function Fl(e) {
  const t = e.attempt(
    this.parser.constructs.contentInitial,
    r,
    a
  );
  let n;
  return t;
  function r(o) {
    if (o === null) {
      e.consume(o);
      return;
    }
    return e.enter("lineEnding"), e.consume(o), e.exit("lineEnding"), J(e, t, "linePrefix");
  }
  function a(o) {
    return e.enter("paragraph"), u(o);
  }
  function u(o) {
    const l = e.enter("chunkText", {
      contentType: "text",
      previous: n
    });
    return n && (n.next = l), n = l, i(o);
  }
  function i(o) {
    if (o === null) {
      e.exit("chunkText"), e.exit("paragraph"), e.consume(o);
      return;
    }
    return z(o) ? (e.consume(o), e.exit("chunkText"), u) : (e.consume(o), i);
  }
}
const Bl = {
  tokenize: vl
}, ba = {
  tokenize: Hl
};
function vl(e) {
  const t = this, n = [];
  let r = 0, a, u, i;
  return o;
  function o(I) {
    if (r < n.length) {
      const M = n[r];
      return t.containerState = M[1], e.attempt(
        M[0].continuation,
        l,
        c
      )(I);
    }
    return c(I);
  }
  function l(I) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, a && x();
      const M = t.events.length;
      let B = M, R;
      for (; B--; )
        if (t.events[B][0] === "exit" && t.events[B][1].type === "chunkFlow") {
          R = t.events[B][1].end;
          break;
        }
      _(r);
      let U = M;
      for (; U < t.events.length; )
        t.events[U][1].end = Object.assign({}, R), U++;
      return Ne(
        t.events,
        B + 1,
        0,
        t.events.slice(M)
      ), t.events.length = U, c(I);
    }
    return o(I);
  }
  function c(I) {
    if (r === n.length) {
      if (!a)
        return b(I);
      if (a.currentConstruct && a.currentConstruct.concrete)
        return h(I);
      t.interrupt = !!(a.currentConstruct && !a._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e.check(
      ba,
      f,
      d
    )(I);
  }
  function f(I) {
    return a && x(), _(r), b(I);
  }
  function d(I) {
    return t.parser.lazy[t.now().line] = r !== n.length, i = t.now().offset, h(I);
  }
  function b(I) {
    return t.containerState = {}, e.attempt(
      ba,
      m,
      h
    )(I);
  }
  function m(I) {
    return r++, n.push([t.currentConstruct, t.containerState]), b(I);
  }
  function h(I) {
    if (I === null) {
      a && x(), _(0), e.consume(I);
      return;
    }
    return a = a || t.parser.flow(t.now()), e.enter("chunkFlow", {
      contentType: "flow",
      previous: u,
      _tokenizer: a
    }), E(I);
  }
  function E(I) {
    if (I === null) {
      y(e.exit("chunkFlow"), !0), _(0), e.consume(I);
      return;
    }
    return z(I) ? (e.consume(I), y(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, o) : (e.consume(I), E);
  }
  function y(I, M) {
    const B = t.sliceStream(I);
    if (M && B.push(null), I.previous = u, u && (u.next = I), u = I, a.defineSkip(I.start), a.write(B), t.parser.lazy[I.start.line]) {
      let R = a.events.length;
      for (; R--; )
        if (
          // The token starts before the line ending
          a.events[R][1].start.offset < i && // and either is not ended yet
          (!a.events[R][1].end || // or ends after it.
          a.events[R][1].end.offset > i)
        )
          return;
      const U = t.events.length;
      let q = U, Y, S;
      for (; q--; )
        if (t.events[q][0] === "exit" && t.events[q][1].type === "chunkFlow") {
          if (Y) {
            S = t.events[q][1].end;
            break;
          }
          Y = !0;
        }
      for (_(r), R = U; R < t.events.length; )
        t.events[R][1].end = Object.assign({}, S), R++;
      Ne(
        t.events,
        q + 1,
        0,
        t.events.slice(U)
      ), t.events.length = R;
    }
  }
  function _(I) {
    let M = n.length;
    for (; M-- > I; ) {
      const B = n[M];
      t.containerState = B[1], B[0].exit.call(t, e);
    }
    n.length = I;
  }
  function x() {
    a.write([null]), u = void 0, a = void 0, t.containerState._closeFlow = void 0;
  }
}
function Hl(e, t, n) {
  return J(
    e,
    e.attempt(this.parser.constructs.document, t, n),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function gn(e) {
  if (e === null || ie(e) || lt(e))
    return 1;
  if (xn(e))
    return 2;
}
function kn(e, t, n) {
  const r = [];
  let a = -1;
  for (; ++a < e.length; ) {
    const u = e[a].resolveAll;
    u && !r.includes(u) && (t = u(t, n), r.push(u));
  }
  return t;
}
const ur = {
  name: "attention",
  tokenize: zl,
  resolveAll: Ul
};
function Ul(e, t) {
  let n = -1, r, a, u, i, o, l, c, f;
  for (; ++n < e.length; )
    if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) {
      for (r = n; r--; )
        if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) {
          if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3))
            continue;
          l = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1;
          const d = Object.assign({}, e[r][1].end), b = Object.assign({}, e[n][1].start);
          Ea(d, -l), Ea(b, l), i = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: d,
            end: Object.assign({}, e[r][1].end)
          }, o = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e[n][1].start),
            end: b
          }, u = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e[r][1].end),
            end: Object.assign({}, e[n][1].start)
          }, a = {
            type: l > 1 ? "strong" : "emphasis",
            start: Object.assign({}, i.start),
            end: Object.assign({}, o.end)
          }, e[r][1].end = Object.assign({}, i.start), e[n][1].start = Object.assign({}, o.end), c = [], e[r][1].end.offset - e[r][1].start.offset && (c = Re(c, [
            ["enter", e[r][1], t],
            ["exit", e[r][1], t]
          ])), c = Re(c, [
            ["enter", a, t],
            ["enter", i, t],
            ["exit", i, t],
            ["enter", u, t]
          ]), c = Re(
            c,
            kn(
              t.parser.constructs.insideSpan.null,
              e.slice(r + 1, n),
              t
            )
          ), c = Re(c, [
            ["exit", u, t],
            ["enter", o, t],
            ["exit", o, t],
            ["exit", a, t]
          ]), e[n][1].end.offset - e[n][1].start.offset ? (f = 2, c = Re(c, [
            ["enter", e[n][1], t],
            ["exit", e[n][1], t]
          ])) : f = 0, Ne(e, r - 1, n - r + 3, c), n = r + c.length - f - 2;
          break;
        }
    }
  for (n = -1; ++n < e.length; )
    e[n][1].type === "attentionSequence" && (e[n][1].type = "data");
  return e;
}
function zl(e, t) {
  const n = this.parser.constructs.attentionMarkers.null, r = this.previous, a = gn(r);
  let u;
  return i;
  function i(l) {
    return u = l, e.enter("attentionSequence"), o(l);
  }
  function o(l) {
    if (l === u)
      return e.consume(l), o;
    const c = e.exit("attentionSequence"), f = gn(l), d = !f || f === 2 && a || n.includes(l), b = !a || a === 2 && f || n.includes(r);
    return c._open = !!(u === 42 ? d : d && (a || !b)), c._close = !!(u === 42 ? b : b && (f || !d)), t(l);
  }
}
function Ea(e, t) {
  e.column += t, e.offset += t, e._bufferIndex += t;
}
const Yl = {
  name: "autolink",
  tokenize: jl
};
function jl(e, t, n) {
  let r = 0;
  return a;
  function a(m) {
    return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(m), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), u;
  }
  function u(m) {
    return ye(m) ? (e.consume(m), i) : c(m);
  }
  function i(m) {
    return m === 43 || m === 45 || m === 46 || ge(m) ? (r = 1, o(m)) : c(m);
  }
  function o(m) {
    return m === 58 ? (e.consume(m), r = 0, l) : (m === 43 || m === 45 || m === 46 || ge(m)) && r++ < 32 ? (e.consume(m), o) : (r = 0, c(m));
  }
  function l(m) {
    return m === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(m), e.exit("autolinkMarker"), e.exit("autolink"), t) : m === null || m === 32 || m === 60 || mn(m) ? n(m) : (e.consume(m), l);
  }
  function c(m) {
    return m === 64 ? (e.consume(m), f) : wl(m) ? (e.consume(m), c) : n(m);
  }
  function f(m) {
    return ge(m) ? d(m) : n(m);
  }
  function d(m) {
    return m === 46 ? (e.consume(m), r = 0, f) : m === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(m), e.exit("autolinkMarker"), e.exit("autolink"), t) : b(m);
  }
  function b(m) {
    if ((m === 45 || ge(m)) && r++ < 63) {
      const h = m === 45 ? b : d;
      return e.consume(m), h;
    }
    return n(m);
  }
}
const Kt = {
  tokenize: Gl,
  partial: !0
};
function Gl(e, t, n) {
  return r;
  function r(u) {
    return K(u) ? J(e, a, "linePrefix")(u) : a(u);
  }
  function a(u) {
    return u === null || z(u) ? t(u) : n(u);
  }
}
const Vi = {
  name: "blockQuote",
  tokenize: ql,
  continuation: {
    tokenize: $l
  },
  exit: Wl
};
function ql(e, t, n) {
  const r = this;
  return a;
  function a(i) {
    if (i === 62) {
      const o = r.containerState;
      return o.open || (e.enter("blockQuote", {
        _container: !0
      }), o.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(i), e.exit("blockQuoteMarker"), u;
    }
    return n(i);
  }
  function u(i) {
    return K(i) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(i), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(i));
  }
}
function $l(e, t, n) {
  const r = this;
  return a;
  function a(i) {
    return K(i) ? J(
      e,
      u,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(i) : u(i);
  }
  function u(i) {
    return e.attempt(Vi, t, n)(i);
  }
}
function Wl(e) {
  e.exit("blockQuote");
}
const Qi = {
  name: "characterEscape",
  tokenize: Vl
};
function Vl(e, t, n) {
  return r;
  function r(u) {
    return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(u), e.exit("escapeMarker"), a;
  }
  function a(u) {
    return Pl(u) ? (e.enter("characterEscapeValue"), e.consume(u), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(u);
  }
}
const Xi = {
  name: "characterReference",
  tokenize: Ql
};
function Ql(e, t, n) {
  const r = this;
  let a = 0, u, i;
  return o;
  function o(d) {
    return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), l;
  }
  function l(d) {
    return d === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(d), e.exit("characterReferenceMarkerNumeric"), c) : (e.enter("characterReferenceValue"), u = 31, i = ge, f(d));
  }
  function c(d) {
    return d === 88 || d === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(d), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), u = 6, i = Dl, f) : (e.enter("characterReferenceValue"), u = 7, i = ir, f(d));
  }
  function f(d) {
    if (d === 59 && a) {
      const b = e.exit("characterReferenceValue");
      return i === ge && !Sr(r.sliceSerialize(b)) ? n(d) : (e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), e.exit("characterReference"), t);
    }
    return i(d) && a++ < u ? (e.consume(d), f) : n(d);
  }
}
const Ta = {
  tokenize: Kl,
  partial: !0
}, ya = {
  name: "codeFenced",
  tokenize: Xl,
  concrete: !0
};
function Xl(e, t, n) {
  const r = this, a = {
    tokenize: B,
    partial: !0
  };
  let u = 0, i = 0, o;
  return l;
  function l(R) {
    return c(R);
  }
  function c(R) {
    const U = r.events[r.events.length - 1];
    return u = U && U[1].type === "linePrefix" ? U[2].sliceSerialize(U[1], !0).length : 0, o = R, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), f(R);
  }
  function f(R) {
    return R === o ? (i++, e.consume(R), f) : i < 3 ? n(R) : (e.exit("codeFencedFenceSequence"), K(R) ? J(e, d, "whitespace")(R) : d(R));
  }
  function d(R) {
    return R === null || z(R) ? (e.exit("codeFencedFence"), r.interrupt ? t(R) : e.check(Ta, E, M)(R)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", {
      contentType: "string"
    }), b(R));
  }
  function b(R) {
    return R === null || z(R) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), d(R)) : K(R) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), J(e, m, "whitespace")(R)) : R === 96 && R === o ? n(R) : (e.consume(R), b);
  }
  function m(R) {
    return R === null || z(R) ? d(R) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", {
      contentType: "string"
    }), h(R));
  }
  function h(R) {
    return R === null || z(R) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), d(R)) : R === 96 && R === o ? n(R) : (e.consume(R), h);
  }
  function E(R) {
    return e.attempt(a, M, y)(R);
  }
  function y(R) {
    return e.enter("lineEnding"), e.consume(R), e.exit("lineEnding"), _;
  }
  function _(R) {
    return u > 0 && K(R) ? J(
      e,
      x,
      "linePrefix",
      u + 1
    )(R) : x(R);
  }
  function x(R) {
    return R === null || z(R) ? e.check(Ta, E, M)(R) : (e.enter("codeFlowValue"), I(R));
  }
  function I(R) {
    return R === null || z(R) ? (e.exit("codeFlowValue"), x(R)) : (e.consume(R), I);
  }
  function M(R) {
    return e.exit("codeFenced"), t(R);
  }
  function B(R, U, q) {
    let Y = 0;
    return S;
    function S(j) {
      return R.enter("lineEnding"), R.consume(j), R.exit("lineEnding"), H;
    }
    function H(j) {
      return R.enter("codeFencedFence"), K(j) ? J(
        R,
        F,
        "linePrefix",
        r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(j) : F(j);
    }
    function F(j) {
      return j === o ? (R.enter("codeFencedFenceSequence"), ee(j)) : q(j);
    }
    function ee(j) {
      return j === o ? (Y++, R.consume(j), ee) : Y >= i ? (R.exit("codeFencedFenceSequence"), K(j) ? J(R, G, "whitespace")(j) : G(j)) : q(j);
    }
    function G(j) {
      return j === null || z(j) ? (R.exit("codeFencedFence"), U(j)) : q(j);
    }
  }
}
function Kl(e, t, n) {
  const r = this;
  return a;
  function a(i) {
    return i === null ? n(i) : (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), u);
  }
  function u(i) {
    return r.parser.lazy[r.now().line] ? n(i) : t(i);
  }
}
const Hn = {
  name: "codeIndented",
  tokenize: Jl
}, Zl = {
  tokenize: ec,
  partial: !0
};
function Jl(e, t, n) {
  const r = this;
  return a;
  function a(c) {
    return e.enter("codeIndented"), J(e, u, "linePrefix", 5)(c);
  }
  function u(c) {
    const f = r.events[r.events.length - 1];
    return f && f[1].type === "linePrefix" && f[2].sliceSerialize(f[1], !0).length >= 4 ? i(c) : n(c);
  }
  function i(c) {
    return c === null ? l(c) : z(c) ? e.attempt(Zl, i, l)(c) : (e.enter("codeFlowValue"), o(c));
  }
  function o(c) {
    return c === null || z(c) ? (e.exit("codeFlowValue"), i(c)) : (e.consume(c), o);
  }
  function l(c) {
    return e.exit("codeIndented"), t(c);
  }
}
function ec(e, t, n) {
  const r = this;
  return a;
  function a(i) {
    return r.parser.lazy[r.now().line] ? n(i) : z(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), a) : J(e, u, "linePrefix", 5)(i);
  }
  function u(i) {
    const o = r.events[r.events.length - 1];
    return o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(i) : z(i) ? a(i) : n(i);
  }
}
const tc = {
  name: "codeText",
  tokenize: ac,
  resolve: nc,
  previous: rc
};
function nc(e) {
  let t = e.length - 4, n = 3, r, a;
  if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) {
    for (r = n; ++r < t; )
      if (e[r][1].type === "codeTextData") {
        e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2;
        break;
      }
  }
  for (r = n - 1, t++; ++r <= t; )
    a === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (a = r) : (r === t || e[r][1].type === "lineEnding") && (e[a][1].type = "codeTextData", r !== a + 2 && (e[a][1].end = e[r - 1][1].end, e.splice(a + 2, r - a - 2), t -= r - a - 2, r = a + 2), a = void 0);
  return e;
}
function rc(e) {
  return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function ac(e, t, n) {
  let r = 0, a, u;
  return i;
  function i(d) {
    return e.enter("codeText"), e.enter("codeTextSequence"), o(d);
  }
  function o(d) {
    return d === 96 ? (e.consume(d), r++, o) : (e.exit("codeTextSequence"), l(d));
  }
  function l(d) {
    return d === null ? n(d) : d === 32 ? (e.enter("space"), e.consume(d), e.exit("space"), l) : d === 96 ? (u = e.enter("codeTextSequence"), a = 0, f(d)) : z(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), l) : (e.enter("codeTextData"), c(d));
  }
  function c(d) {
    return d === null || d === 32 || d === 96 || z(d) ? (e.exit("codeTextData"), l(d)) : (e.consume(d), c);
  }
  function f(d) {
    return d === 96 ? (e.consume(d), a++, f) : a === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(d)) : (u.type = "codeTextData", c(d));
  }
}
function Ki(e) {
  const t = {};
  let n = -1, r, a, u, i, o, l, c;
  for (; ++n < e.length; ) {
    for (; n in t; )
      n = t[n];
    if (r = e[n], n && r[1].type === "chunkFlow" && e[n - 1][1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, u = 0, u < l.length && l[u][1].type === "lineEndingBlank" && (u += 2), u < l.length && l[u][1].type === "content"))
      for (; ++u < l.length && l[u][1].type !== "content"; )
        l[u][1].type === "chunkText" && (l[u][1]._isInFirstContentOfListItem = !0, u++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, ic(e, n)), n = t[n], c = !0);
    else if (r[1]._container) {
      for (u = n, a = void 0; u-- && (i = e[u], i[1].type === "lineEnding" || i[1].type === "lineEndingBlank"); )
        i[0] === "enter" && (a && (e[a][1].type = "lineEndingBlank"), i[1].type = "lineEnding", a = u);
      a && (r[1].end = Object.assign({}, e[a][1].start), o = e.slice(a, n), o.unshift(r), Ne(e, a, n - a + 1, o));
    }
  }
  return !c;
}
function ic(e, t) {
  const n = e[t][1], r = e[t][2];
  let a = t - 1;
  const u = [], i = n._tokenizer || r.parser[n.contentType](n.start), o = i.events, l = [], c = {};
  let f, d, b = -1, m = n, h = 0, E = 0;
  const y = [E];
  for (; m; ) {
    for (; e[++a][1] !== m; )
      ;
    u.push(a), m._tokenizer || (f = r.sliceStream(m), m.next || f.push(null), d && i.defineSkip(m.start), m._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = !0), i.write(f), m._isInFirstContentOfListItem && (i._gfmTasklistFirstContentOfListItem = void 0)), d = m, m = m.next;
  }
  for (m = n; ++b < o.length; )
    // Find a void token that includes a break.
    o[b][0] === "exit" && o[b - 1][0] === "enter" && o[b][1].type === o[b - 1][1].type && o[b][1].start.line !== o[b][1].end.line && (E = b + 1, y.push(E), m._tokenizer = void 0, m.previous = void 0, m = m.next);
  for (i.events = [], m ? (m._tokenizer = void 0, m.previous = void 0) : y.pop(), b = y.length; b--; ) {
    const _ = o.slice(y[b], y[b + 1]), x = u.pop();
    l.unshift([x, x + _.length - 1]), Ne(e, x, 2, _);
  }
  for (b = -1; ++b < l.length; )
    c[h + l[b][0]] = h + l[b][1], h += l[b][1] - l[b][0] - 1;
  return c;
}
const uc = {
  tokenize: lc,
  resolve: oc
}, sc = {
  tokenize: cc,
  partial: !0
};
function oc(e) {
  return Ki(e), e;
}
function lc(e, t) {
  let n;
  return r;
  function r(o) {
    return e.enter("content"), n = e.enter("chunkContent", {
      contentType: "content"
    }), a(o);
  }
  function a(o) {
    return o === null ? u(o) : z(o) ? e.check(
      sc,
      i,
      u
    )(o) : (e.consume(o), a);
  }
  function u(o) {
    return e.exit("chunkContent"), e.exit("content"), t(o);
  }
  function i(o) {
    return e.consume(o), e.exit("chunkContent"), n.next = e.enter("chunkContent", {
      contentType: "content",
      previous: n
    }), n = n.next, a;
  }
}
function cc(e, t, n) {
  const r = this;
  return a;
  function a(i) {
    return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), J(e, u, "linePrefix");
  }
  function u(i) {
    if (i === null || z(i))
      return n(i);
    const o = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && o && o[1].type === "linePrefix" && o[2].sliceSerialize(o[1], !0).length >= 4 ? t(i) : e.interrupt(r.parser.constructs.flow, n, t)(i);
  }
}
function Zi(e, t, n, r, a, u, i, o, l) {
  const c = l || Number.POSITIVE_INFINITY;
  let f = 0;
  return d;
  function d(_) {
    return _ === 60 ? (e.enter(r), e.enter(a), e.enter(u), e.consume(_), e.exit(u), b) : _ === null || _ === 32 || _ === 41 || mn(_) ? n(_) : (e.enter(r), e.enter(i), e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), E(_));
  }
  function b(_) {
    return _ === 62 ? (e.enter(u), e.consume(_), e.exit(u), e.exit(a), e.exit(r), t) : (e.enter(o), e.enter("chunkString", {
      contentType: "string"
    }), m(_));
  }
  function m(_) {
    return _ === 62 ? (e.exit("chunkString"), e.exit(o), b(_)) : _ === null || _ === 60 || z(_) ? n(_) : (e.consume(_), _ === 92 ? h : m);
  }
  function h(_) {
    return _ === 60 || _ === 62 || _ === 92 ? (e.consume(_), m) : m(_);
  }
  function E(_) {
    return !f && (_ === null || _ === 41 || ie(_)) ? (e.exit("chunkString"), e.exit(o), e.exit(i), e.exit(r), t(_)) : f < c && _ === 40 ? (e.consume(_), f++, E) : _ === 41 ? (e.consume(_), f--, E) : _ === null || _ === 32 || _ === 40 || mn(_) ? n(_) : (e.consume(_), _ === 92 ? y : E);
  }
  function y(_) {
    return _ === 40 || _ === 41 || _ === 92 ? (e.consume(_), E) : E(_);
  }
}
function Ji(e, t, n, r, a, u) {
  const i = this;
  let o = 0, l;
  return c;
  function c(m) {
    return e.enter(r), e.enter(a), e.consume(m), e.exit(a), e.enter(u), f;
  }
  function f(m) {
    return o > 999 || m === null || m === 91 || m === 93 && !l || // To do: remove in the future once weve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesnt need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    m === 94 && !o && "_hiddenFootnoteSupport" in i.parser.constructs ? n(m) : m === 93 ? (e.exit(u), e.enter(a), e.consume(m), e.exit(a), e.exit(r), t) : z(m) ? (e.enter("lineEnding"), e.consume(m), e.exit("lineEnding"), f) : (e.enter("chunkString", {
      contentType: "string"
    }), d(m));
  }
  function d(m) {
    return m === null || m === 91 || m === 93 || z(m) || o++ > 999 ? (e.exit("chunkString"), f(m)) : (e.consume(m), l || (l = !K(m)), m === 92 ? b : d);
  }
  function b(m) {
    return m === 91 || m === 92 || m === 93 ? (e.consume(m), o++, d) : d(m);
  }
}
function eu(e, t, n, r, a, u) {
  let i;
  return o;
  function o(b) {
    return b === 34 || b === 39 || b === 40 ? (e.enter(r), e.enter(a), e.consume(b), e.exit(a), i = b === 40 ? 41 : b, l) : n(b);
  }
  function l(b) {
    return b === i ? (e.enter(a), e.consume(b), e.exit(a), e.exit(r), t) : (e.enter(u), c(b));
  }
  function c(b) {
    return b === i ? (e.exit(u), l(i)) : b === null ? n(b) : z(b) ? (e.enter("lineEnding"), e.consume(b), e.exit("lineEnding"), J(e, c, "linePrefix")) : (e.enter("chunkString", {
      contentType: "string"
    }), f(b));
  }
  function f(b) {
    return b === i || b === null || z(b) ? (e.exit("chunkString"), c(b)) : (e.consume(b), b === 92 ? d : f);
  }
  function d(b) {
    return b === i || b === 92 ? (e.consume(b), f) : f(b);
  }
}
function Ht(e, t) {
  let n;
  return r;
  function r(a) {
    return z(a) ? (e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), n = !0, r) : K(a) ? J(
      e,
      r,
      n ? "linePrefix" : "lineSuffix"
    )(a) : t(a);
  }
}
const dc = {
  name: "definition",
  tokenize: hc
}, fc = {
  tokenize: pc,
  partial: !0
};
function hc(e, t, n) {
  const r = this;
  let a;
  return u;
  function u(m) {
    return e.enter("definition"), i(m);
  }
  function i(m) {
    return Ji.call(
      r,
      e,
      o,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(m);
  }
  function o(m) {
    return a = De(
      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
    ), m === 58 ? (e.enter("definitionMarker"), e.consume(m), e.exit("definitionMarker"), l) : n(m);
  }
  function l(m) {
    return ie(m) ? Ht(e, c)(m) : c(m);
  }
  function c(m) {
    return Zi(
      e,
      f,
      // Note: we dont need to reset the way `markdown-rs` does.
      n,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(m);
  }
  function f(m) {
    return e.attempt(fc, d, d)(m);
  }
  function d(m) {
    return K(m) ? J(e, b, "whitespace")(m) : b(m);
  }
  function b(m) {
    return m === null || z(m) ? (e.exit("definition"), r.parser.defined.push(a), t(m)) : n(m);
  }
}
function pc(e, t, n) {
  return r;
  function r(o) {
    return ie(o) ? Ht(e, a)(o) : n(o);
  }
  function a(o) {
    return eu(
      e,
      u,
      n,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(o);
  }
  function u(o) {
    return K(o) ? J(e, i, "whitespace")(o) : i(o);
  }
  function i(o) {
    return o === null || z(o) ? t(o) : n(o);
  }
}
const mc = {
  name: "hardBreakEscape",
  tokenize: gc
};
function gc(e, t, n) {
  return r;
  function r(u) {
    return e.enter("hardBreakEscape"), e.consume(u), a;
  }
  function a(u) {
    return z(u) ? (e.exit("hardBreakEscape"), t(u)) : n(u);
  }
}
const bc = {
  name: "headingAtx",
  tokenize: Tc,
  resolve: Ec
};
function Ec(e, t) {
  let n = e.length - 2, r = 3, a, u;
  return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (a = {
    type: "atxHeadingText",
    start: e[r][1].start,
    end: e[n][1].end
  }, u = {
    type: "chunkText",
    start: e[r][1].start,
    end: e[n][1].end,
    contentType: "text"
  }, Ne(e, r, n - r + 1, [
    ["enter", a, t],
    ["enter", u, t],
    ["exit", u, t],
    ["exit", a, t]
  ])), e;
}
function Tc(e, t, n) {
  let r = 0;
  return a;
  function a(f) {
    return e.enter("atxHeading"), u(f);
  }
  function u(f) {
    return e.enter("atxHeadingSequence"), i(f);
  }
  function i(f) {
    return f === 35 && r++ < 6 ? (e.consume(f), i) : f === null || ie(f) ? (e.exit("atxHeadingSequence"), o(f)) : n(f);
  }
  function o(f) {
    return f === 35 ? (e.enter("atxHeadingSequence"), l(f)) : f === null || z(f) ? (e.exit("atxHeading"), t(f)) : K(f) ? J(e, o, "whitespace")(f) : (e.enter("atxHeadingText"), c(f));
  }
  function l(f) {
    return f === 35 ? (e.consume(f), l) : (e.exit("atxHeadingSequence"), o(f));
  }
  function c(f) {
    return f === null || f === 35 || ie(f) ? (e.exit("atxHeadingText"), o(f)) : (e.consume(f), c);
  }
}
const yc = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], Aa = ["pre", "script", "style", "textarea"], Ac = {
  name: "htmlFlow",
  tokenize: kc,
  resolveTo: xc,
  concrete: !0
}, _c = {
  tokenize: Sc,
  partial: !0
}, Cc = {
  tokenize: Ic,
  partial: !0
};
function xc(e) {
  let t = e.length;
  for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e;
}
function kc(e, t, n) {
  const r = this;
  let a, u, i, o, l;
  return c;
  function c(C) {
    return f(C);
  }
  function f(C) {
    return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(C), d;
  }
  function d(C) {
    return C === 33 ? (e.consume(C), b) : C === 47 ? (e.consume(C), u = !0, E) : C === 63 ? (e.consume(C), a = 3, r.interrupt ? t : A) : ye(C) ? (e.consume(C), i = String.fromCharCode(C), y) : n(C);
  }
  function b(C) {
    return C === 45 ? (e.consume(C), a = 2, m) : C === 91 ? (e.consume(C), a = 5, o = 0, h) : ye(C) ? (e.consume(C), a = 4, r.interrupt ? t : A) : n(C);
  }
  function m(C) {
    return C === 45 ? (e.consume(C), r.interrupt ? t : A) : n(C);
  }
  function h(C) {
    const Te = "CDATA[";
    return C === Te.charCodeAt(o++) ? (e.consume(C), o === Te.length ? r.interrupt ? t : F : h) : n(C);
  }
  function E(C) {
    return ye(C) ? (e.consume(C), i = String.fromCharCode(C), y) : n(C);
  }
  function y(C) {
    if (C === null || C === 47 || C === 62 || ie(C)) {
      const Te = C === 47, Me = i.toLowerCase();
      return !Te && !u && Aa.includes(Me) ? (a = 1, r.interrupt ? t(C) : F(C)) : yc.includes(i.toLowerCase()) ? (a = 6, Te ? (e.consume(C), _) : r.interrupt ? t(C) : F(C)) : (a = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(C) : u ? x(C) : I(C));
    }
    return C === 45 || ge(C) ? (e.consume(C), i += String.fromCharCode(C), y) : n(C);
  }
  function _(C) {
    return C === 62 ? (e.consume(C), r.interrupt ? t : F) : n(C);
  }
  function x(C) {
    return K(C) ? (e.consume(C), x) : S(C);
  }
  function I(C) {
    return C === 47 ? (e.consume(C), S) : C === 58 || C === 95 || ye(C) ? (e.consume(C), M) : K(C) ? (e.consume(C), I) : S(C);
  }
  function M(C) {
    return C === 45 || C === 46 || C === 58 || C === 95 || ge(C) ? (e.consume(C), M) : B(C);
  }
  function B(C) {
    return C === 61 ? (e.consume(C), R) : K(C) ? (e.consume(C), B) : I(C);
  }
  function R(C) {
    return C === null || C === 60 || C === 61 || C === 62 || C === 96 ? n(C) : C === 34 || C === 39 ? (e.consume(C), l = C, U) : K(C) ? (e.consume(C), R) : q(C);
  }
  function U(C) {
    return C === l ? (e.consume(C), l = null, Y) : C === null || z(C) ? n(C) : (e.consume(C), U);
  }
  function q(C) {
    return C === null || C === 34 || C === 39 || C === 47 || C === 60 || C === 61 || C === 62 || C === 96 || ie(C) ? B(C) : (e.consume(C), q);
  }
  function Y(C) {
    return C === 47 || C === 62 || K(C) ? I(C) : n(C);
  }
  function S(C) {
    return C === 62 ? (e.consume(C), H) : n(C);
  }
  function H(C) {
    return C === null || z(C) ? F(C) : K(C) ? (e.consume(C), H) : n(C);
  }
  function F(C) {
    return C === 45 && a === 2 ? (e.consume(C), te) : C === 60 && a === 1 ? (e.consume(C), se) : C === 62 && a === 4 ? (e.consume(C), ae) : C === 63 && a === 3 ? (e.consume(C), A) : C === 93 && a === 5 ? (e.consume(C), me) : z(C) && (a === 6 || a === 7) ? (e.exit("htmlFlowData"), e.check(
      _c,
      Ae,
      ee
    )(C)) : C === null || z(C) ? (e.exit("htmlFlowData"), ee(C)) : (e.consume(C), F);
  }
  function ee(C) {
    return e.check(
      Cc,
      G,
      Ae
    )(C);
  }
  function G(C) {
    return e.enter("lineEnding"), e.consume(C), e.exit("lineEnding"), j;
  }
  function j(C) {
    return C === null || z(C) ? ee(C) : (e.enter("htmlFlowData"), F(C));
  }
  function te(C) {
    return C === 45 ? (e.consume(C), A) : F(C);
  }
  function se(C) {
    return C === 47 ? (e.consume(C), i = "", re) : F(C);
  }
  function re(C) {
    if (C === 62) {
      const Te = i.toLowerCase();
      return Aa.includes(Te) ? (e.consume(C), ae) : F(C);
    }
    return ye(C) && i.length < 8 ? (e.consume(C), i += String.fromCharCode(C), re) : F(C);
  }
  function me(C) {
    return C === 93 ? (e.consume(C), A) : F(C);
  }
  function A(C) {
    return C === 62 ? (e.consume(C), ae) : C === 45 && a === 2 ? (e.consume(C), A) : F(C);
  }
  function ae(C) {
    return C === null || z(C) ? (e.exit("htmlFlowData"), Ae(C)) : (e.consume(C), ae);
  }
  function Ae(C) {
    return e.exit("htmlFlow"), t(C);
  }
}
function Ic(e, t, n) {
  const r = this;
  return a;
  function a(i) {
    return z(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), u) : n(i);
  }
  function u(i) {
    return r.parser.lazy[r.now().line] ? n(i) : t(i);
  }
}
function Sc(e, t, n) {
  return r;
  function r(a) {
    return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), e.attempt(Kt, t, n);
  }
}
const Nc = {
  name: "htmlText",
  tokenize: Rc
};
function Rc(e, t, n) {
  const r = this;
  let a, u, i;
  return o;
  function o(A) {
    return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(A), l;
  }
  function l(A) {
    return A === 33 ? (e.consume(A), c) : A === 47 ? (e.consume(A), B) : A === 63 ? (e.consume(A), I) : ye(A) ? (e.consume(A), q) : n(A);
  }
  function c(A) {
    return A === 45 ? (e.consume(A), f) : A === 91 ? (e.consume(A), u = 0, h) : ye(A) ? (e.consume(A), x) : n(A);
  }
  function f(A) {
    return A === 45 ? (e.consume(A), m) : n(A);
  }
  function d(A) {
    return A === null ? n(A) : A === 45 ? (e.consume(A), b) : z(A) ? (i = d, se(A)) : (e.consume(A), d);
  }
  function b(A) {
    return A === 45 ? (e.consume(A), m) : d(A);
  }
  function m(A) {
    return A === 62 ? te(A) : A === 45 ? b(A) : d(A);
  }
  function h(A) {
    const ae = "CDATA[";
    return A === ae.charCodeAt(u++) ? (e.consume(A), u === ae.length ? E : h) : n(A);
  }
  function E(A) {
    return A === null ? n(A) : A === 93 ? (e.consume(A), y) : z(A) ? (i = E, se(A)) : (e.consume(A), E);
  }
  function y(A) {
    return A === 93 ? (e.consume(A), _) : E(A);
  }
  function _(A) {
    return A === 62 ? te(A) : A === 93 ? (e.consume(A), _) : E(A);
  }
  function x(A) {
    return A === null || A === 62 ? te(A) : z(A) ? (i = x, se(A)) : (e.consume(A), x);
  }
  function I(A) {
    return A === null ? n(A) : A === 63 ? (e.consume(A), M) : z(A) ? (i = I, se(A)) : (e.consume(A), I);
  }
  function M(A) {
    return A === 62 ? te(A) : I(A);
  }
  function B(A) {
    return ye(A) ? (e.consume(A), R) : n(A);
  }
  function R(A) {
    return A === 45 || ge(A) ? (e.consume(A), R) : U(A);
  }
  function U(A) {
    return z(A) ? (i = U, se(A)) : K(A) ? (e.consume(A), U) : te(A);
  }
  function q(A) {
    return A === 45 || ge(A) ? (e.consume(A), q) : A === 47 || A === 62 || ie(A) ? Y(A) : n(A);
  }
  function Y(A) {
    return A === 47 ? (e.consume(A), te) : A === 58 || A === 95 || ye(A) ? (e.consume(A), S) : z(A) ? (i = Y, se(A)) : K(A) ? (e.consume(A), Y) : te(A);
  }
  function S(A) {
    return A === 45 || A === 46 || A === 58 || A === 95 || ge(A) ? (e.consume(A), S) : H(A);
  }
  function H(A) {
    return A === 61 ? (e.consume(A), F) : z(A) ? (i = H, se(A)) : K(A) ? (e.consume(A), H) : Y(A);
  }
  function F(A) {
    return A === null || A === 60 || A === 61 || A === 62 || A === 96 ? n(A) : A === 34 || A === 39 ? (e.consume(A), a = A, ee) : z(A) ? (i = F, se(A)) : K(A) ? (e.consume(A), F) : (e.consume(A), G);
  }
  function ee(A) {
    return A === a ? (e.consume(A), a = void 0, j) : A === null ? n(A) : z(A) ? (i = ee, se(A)) : (e.consume(A), ee);
  }
  function G(A) {
    return A === null || A === 34 || A === 39 || A === 60 || A === 61 || A === 96 ? n(A) : A === 47 || A === 62 || ie(A) ? Y(A) : (e.consume(A), G);
  }
  function j(A) {
    return A === 47 || A === 62 || ie(A) ? Y(A) : n(A);
  }
  function te(A) {
    return A === 62 ? (e.consume(A), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(A);
  }
  function se(A) {
    return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(A), e.exit("lineEnding"), re;
  }
  function re(A) {
    return K(A) ? J(
      e,
      me,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(A) : me(A);
  }
  function me(A) {
    return e.enter("htmlTextData"), i(A);
  }
}
const Nr = {
  name: "labelEnd",
  tokenize: Mc,
  resolveTo: Pc,
  resolveAll: Dc
}, Lc = {
  tokenize: Fc
}, Oc = {
  tokenize: Bc
}, wc = {
  tokenize: vc
};
function Dc(e) {
  let t = -1;
  for (; ++t < e.length; ) {
    const n = e[t][1];
    (n.type === "labelImage" || n.type === "labelLink" || n.type === "labelEnd") && (e.splice(t + 1, n.type === "labelImage" ? 4 : 2), n.type = "data", t++);
  }
  return e;
}
function Pc(e, t) {
  let n = e.length, r = 0, a, u, i, o;
  for (; n--; )
    if (a = e[n][1], u) {
      if (a.type === "link" || a.type === "labelLink" && a._inactive)
        break;
      e[n][0] === "enter" && a.type === "labelLink" && (a._inactive = !0);
    } else if (i) {
      if (e[n][0] === "enter" && (a.type === "labelImage" || a.type === "labelLink") && !a._balanced && (u = n, a.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else a.type === "labelEnd" && (i = n);
  const l = {
    type: e[u][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e[u][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, c = {
    type: "label",
    start: Object.assign({}, e[u][1].start),
    end: Object.assign({}, e[i][1].end)
  }, f = {
    type: "labelText",
    start: Object.assign({}, e[u + r + 2][1].end),
    end: Object.assign({}, e[i - 2][1].start)
  };
  return o = [
    ["enter", l, t],
    ["enter", c, t]
  ], o = Re(o, e.slice(u + 1, u + r + 3)), o = Re(o, [["enter", f, t]]), o = Re(
    o,
    kn(
      t.parser.constructs.insideSpan.null,
      e.slice(u + r + 4, i - 3),
      t
    )
  ), o = Re(o, [
    ["exit", f, t],
    e[i - 2],
    e[i - 1],
    ["exit", c, t]
  ]), o = Re(o, e.slice(i + 1)), o = Re(o, [["exit", l, t]]), Ne(e, u, e.length, o), e;
}
function Mc(e, t, n) {
  const r = this;
  let a = r.events.length, u, i;
  for (; a--; )
    if ((r.events[a][1].type === "labelImage" || r.events[a][1].type === "labelLink") && !r.events[a][1]._balanced) {
      u = r.events[a][1];
      break;
    }
  return o;
  function o(b) {
    return u ? u._inactive ? d(b) : (i = r.parser.defined.includes(
      De(
        r.sliceSerialize({
          start: u.end,
          end: r.now()
        })
      )
    ), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(b), e.exit("labelMarker"), e.exit("labelEnd"), l) : n(b);
  }
  function l(b) {
    return b === 40 ? e.attempt(
      Lc,
      f,
      i ? f : d
    )(b) : b === 91 ? e.attempt(
      Oc,
      f,
      i ? c : d
    )(b) : i ? f(b) : d(b);
  }
  function c(b) {
    return e.attempt(
      wc,
      f,
      d
    )(b);
  }
  function f(b) {
    return t(b);
  }
  function d(b) {
    return u._balanced = !0, n(b);
  }
}
function Fc(e, t, n) {
  return r;
  function r(d) {
    return e.enter("resource"), e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), a;
  }
  function a(d) {
    return ie(d) ? Ht(e, u)(d) : u(d);
  }
  function u(d) {
    return d === 41 ? f(d) : Zi(
      e,
      i,
      o,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(d);
  }
  function i(d) {
    return ie(d) ? Ht(e, l)(d) : f(d);
  }
  function o(d) {
    return n(d);
  }
  function l(d) {
    return d === 34 || d === 39 || d === 40 ? eu(
      e,
      c,
      n,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(d) : f(d);
  }
  function c(d) {
    return ie(d) ? Ht(e, f)(d) : f(d);
  }
  function f(d) {
    return d === 41 ? (e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), e.exit("resource"), t) : n(d);
  }
}
function Bc(e, t, n) {
  const r = this;
  return a;
  function a(o) {
    return Ji.call(
      r,
      e,
      u,
      i,
      "reference",
      "referenceMarker",
      "referenceString"
    )(o);
  }
  function u(o) {
    return r.parser.defined.includes(
      De(
        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
      )
    ) ? t(o) : n(o);
  }
  function i(o) {
    return n(o);
  }
}
function vc(e, t, n) {
  return r;
  function r(u) {
    return e.enter("reference"), e.enter("referenceMarker"), e.consume(u), e.exit("referenceMarker"), a;
  }
  function a(u) {
    return u === 93 ? (e.enter("referenceMarker"), e.consume(u), e.exit("referenceMarker"), e.exit("reference"), t) : n(u);
  }
}
const Hc = {
  name: "labelStartImage",
  tokenize: Uc,
  resolveAll: Nr.resolveAll
};
function Uc(e, t, n) {
  const r = this;
  return a;
  function a(o) {
    return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(o), e.exit("labelImageMarker"), u;
  }
  function u(o) {
    return o === 91 ? (e.enter("labelMarker"), e.consume(o), e.exit("labelMarker"), e.exit("labelImage"), i) : n(o);
  }
  function i(o) {
    return o === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(o) : t(o);
  }
}
const zc = {
  name: "labelStartLink",
  tokenize: Yc,
  resolveAll: Nr.resolveAll
};
function Yc(e, t, n) {
  const r = this;
  return a;
  function a(i) {
    return e.enter("labelLink"), e.enter("labelMarker"), e.consume(i), e.exit("labelMarker"), e.exit("labelLink"), u;
  }
  function u(i) {
    return i === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(i) : t(i);
  }
}
const Un = {
  name: "lineEnding",
  tokenize: jc
};
function jc(e, t) {
  return n;
  function n(r) {
    return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), J(e, t, "linePrefix");
  }
}
const ln = {
  name: "thematicBreak",
  tokenize: Gc
};
function Gc(e, t, n) {
  let r = 0, a;
  return u;
  function u(c) {
    return e.enter("thematicBreak"), i(c);
  }
  function i(c) {
    return a = c, o(c);
  }
  function o(c) {
    return c === a ? (e.enter("thematicBreakSequence"), l(c)) : r >= 3 && (c === null || z(c)) ? (e.exit("thematicBreak"), t(c)) : n(c);
  }
  function l(c) {
    return c === a ? (e.consume(c), r++, l) : (e.exit("thematicBreakSequence"), K(c) ? J(e, o, "whitespace")(c) : o(c));
  }
}
const Ce = {
  name: "list",
  tokenize: Wc,
  continuation: {
    tokenize: Vc
  },
  exit: Xc
}, qc = {
  tokenize: Kc,
  partial: !0
}, $c = {
  tokenize: Qc,
  partial: !0
};
function Wc(e, t, n) {
  const r = this, a = r.events[r.events.length - 1];
  let u = a && a[1].type === "linePrefix" ? a[2].sliceSerialize(a[1], !0).length : 0, i = 0;
  return o;
  function o(m) {
    const h = r.containerState.type || (m === 42 || m === 43 || m === 45 ? "listUnordered" : "listOrdered");
    if (h === "listUnordered" ? !r.containerState.marker || m === r.containerState.marker : ir(m)) {
      if (r.containerState.type || (r.containerState.type = h, e.enter(h, {
        _container: !0
      })), h === "listUnordered")
        return e.enter("listItemPrefix"), m === 42 || m === 45 ? e.check(ln, n, c)(m) : c(m);
      if (!r.interrupt || m === 49)
        return e.enter("listItemPrefix"), e.enter("listItemValue"), l(m);
    }
    return n(m);
  }
  function l(m) {
    return ir(m) && ++i < 10 ? (e.consume(m), l) : (!r.interrupt || i < 2) && (r.containerState.marker ? m === r.containerState.marker : m === 41 || m === 46) ? (e.exit("listItemValue"), c(m)) : n(m);
  }
  function c(m) {
    return e.enter("listItemMarker"), e.consume(m), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || m, e.check(
      Kt,
      // Cant be empty when interrupting.
      r.interrupt ? n : f,
      e.attempt(
        qc,
        b,
        d
      )
    );
  }
  function f(m) {
    return r.containerState.initialBlankLine = !0, u++, b(m);
  }
  function d(m) {
    return K(m) ? (e.enter("listItemPrefixWhitespace"), e.consume(m), e.exit("listItemPrefixWhitespace"), b) : n(m);
  }
  function b(m) {
    return r.containerState.size = u + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(m);
  }
}
function Vc(e, t, n) {
  const r = this;
  return r.containerState._closeFlow = void 0, e.check(Kt, a, u);
  function a(o) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, J(
      e,
      t,
      "listItemIndent",
      r.containerState.size + 1
    )(o);
  }
  function u(o) {
    return r.containerState.furtherBlankLines || !K(o) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, i(o)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt($c, t, i)(o));
  }
  function i(o) {
    return r.containerState._closeFlow = !0, r.interrupt = void 0, J(
      e,
      e.attempt(Ce, t, n),
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(o);
  }
}
function Qc(e, t, n) {
  const r = this;
  return J(
    e,
    a,
    "listItemIndent",
    r.containerState.size + 1
  );
  function a(u) {
    const i = r.events[r.events.length - 1];
    return i && i[1].type === "listItemIndent" && i[2].sliceSerialize(i[1], !0).length === r.containerState.size ? t(u) : n(u);
  }
}
function Xc(e) {
  e.exit(this.containerState.type);
}
function Kc(e, t, n) {
  const r = this;
  return J(
    e,
    a,
    "listItemPrefixWhitespace",
    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5
  );
  function a(u) {
    const i = r.events[r.events.length - 1];
    return !K(u) && i && i[1].type === "listItemPrefixWhitespace" ? t(u) : n(u);
  }
}
const _a = {
  name: "setextUnderline",
  tokenize: Jc,
  resolveTo: Zc
};
function Zc(e, t) {
  let n = e.length, r, a, u;
  for (; n--; )
    if (e[n][0] === "enter") {
      if (e[n][1].type === "content") {
        r = n;
        break;
      }
      e[n][1].type === "paragraph" && (a = n);
    } else
      e[n][1].type === "content" && e.splice(n, 1), !u && e[n][1].type === "definition" && (u = n);
  const i = {
    type: "setextHeading",
    start: Object.assign({}, e[a][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  };
  return e[a][1].type = "setextHeadingText", u ? (e.splice(a, 0, ["enter", i, t]), e.splice(u + 1, 0, ["exit", e[r][1], t]), e[r][1].end = Object.assign({}, e[u][1].end)) : e[r][1] = i, e.push(["exit", i, t]), e;
}
function Jc(e, t, n) {
  const r = this;
  let a;
  return u;
  function u(c) {
    let f = r.events.length, d;
    for (; f--; )
      if (r.events[f][1].type !== "lineEnding" && r.events[f][1].type !== "linePrefix" && r.events[f][1].type !== "content") {
        d = r.events[f][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || d) ? (e.enter("setextHeadingLine"), a = c, i(c)) : n(c);
  }
  function i(c) {
    return e.enter("setextHeadingLineSequence"), o(c);
  }
  function o(c) {
    return c === a ? (e.consume(c), o) : (e.exit("setextHeadingLineSequence"), K(c) ? J(e, l, "lineSuffix")(c) : l(c));
  }
  function l(c) {
    return c === null || z(c) ? (e.exit("setextHeadingLine"), t(c)) : n(c);
  }
}
const ed = {
  tokenize: td
};
function td(e) {
  const t = this, n = e.attempt(
    // Try to parse a blank line.
    Kt,
    r,
    // Try to parse initial flow (essentially, only code).
    e.attempt(
      this.parser.constructs.flowInitial,
      a,
      J(
        e,
        e.attempt(
          this.parser.constructs.flow,
          a,
          e.attempt(uc, a)
        ),
        "linePrefix"
      )
    )
  );
  return n;
  function r(u) {
    if (u === null) {
      e.consume(u);
      return;
    }
    return e.enter("lineEndingBlank"), e.consume(u), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n;
  }
  function a(u) {
    if (u === null) {
      e.consume(u);
      return;
    }
    return e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), t.currentConstruct = void 0, n;
  }
}
const nd = {
  resolveAll: nu()
}, rd = tu("string"), ad = tu("text");
function tu(e) {
  return {
    tokenize: t,
    resolveAll: nu(
      e === "text" ? id : void 0
    )
  };
  function t(n) {
    const r = this, a = this.parser.constructs[e], u = n.attempt(a, i, o);
    return i;
    function i(f) {
      return c(f) ? u(f) : o(f);
    }
    function o(f) {
      if (f === null) {
        n.consume(f);
        return;
      }
      return n.enter("data"), n.consume(f), l;
    }
    function l(f) {
      return c(f) ? (n.exit("data"), u(f)) : (n.consume(f), l);
    }
    function c(f) {
      if (f === null)
        return !0;
      const d = a[f];
      let b = -1;
      if (d)
        for (; ++b < d.length; ) {
          const m = d[b];
          if (!m.previous || m.previous.call(r, r.previous))
            return !0;
        }
      return !1;
    }
  }
}
function nu(e) {
  return t;
  function t(n, r) {
    let a = -1, u;
    for (; ++a <= n.length; )
      u === void 0 ? n[a] && n[a][1].type === "data" && (u = a, a++) : (!n[a] || n[a][1].type !== "data") && (a !== u + 2 && (n[u][1].end = n[a - 1][1].end, n.splice(u + 2, a - u - 2), a = u + 2), u = void 0);
    return e ? e(n, r) : n;
  }
}
function id(e, t) {
  let n = 0;
  for (; ++n <= e.length; )
    if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") {
      const r = e[n - 1][1], a = t.sliceStream(r);
      let u = a.length, i = -1, o = 0, l;
      for (; u--; ) {
        const c = a[u];
        if (typeof c == "string") {
          for (i = c.length; c.charCodeAt(i - 1) === 32; )
            o++, i--;
          if (i) break;
          i = -1;
        } else if (c === -2)
          l = !0, o++;
        else if (c !== -1) {
          u++;
          break;
        }
      }
      if (o) {
        const c = {
          type: n === e.length || l || o < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - o,
            offset: r.end.offset - o,
            _index: r.start._index + u,
            _bufferIndex: u ? i : r.start._bufferIndex + i
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, c.start), r.start.offset === r.end.offset ? Object.assign(r, c) : (e.splice(
          n,
          0,
          ["enter", c, t],
          ["exit", c, t]
        ), n += 2);
      }
      n++;
    }
  return e;
}
function ud(e, t, n) {
  let r = Object.assign(
    n ? Object.assign({}, n) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const a = {}, u = [];
  let i = [], o = [];
  const l = {
    consume: x,
    enter: I,
    exit: M,
    attempt: U(B),
    check: U(R),
    interrupt: U(R, {
      interrupt: !0
    })
  }, c = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e,
    sliceStream: m,
    sliceSerialize: b,
    now: h,
    defineSkip: E,
    write: d
  };
  let f = t.tokenize.call(c, l);
  return t.resolveAll && u.push(t), c;
  function d(H) {
    return i = Re(i, H), y(), i[i.length - 1] !== null ? [] : (q(t, 0), c.events = kn(u, c.events, c), c.events);
  }
  function b(H, F) {
    return od(m(H), F);
  }
  function m(H) {
    return sd(i, H);
  }
  function h() {
    const { line: H, column: F, offset: ee, _index: G, _bufferIndex: j } = r;
    return {
      line: H,
      column: F,
      offset: ee,
      _index: G,
      _bufferIndex: j
    };
  }
  function E(H) {
    a[H.line] = H.column, S();
  }
  function y() {
    let H;
    for (; r._index < i.length; ) {
      const F = i[r._index];
      if (typeof F == "string")
        for (H = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === H && r._bufferIndex < F.length; )
          _(F.charCodeAt(r._bufferIndex));
      else
        _(F);
    }
  }
  function _(H) {
    f = f(H);
  }
  function x(H) {
    z(H) ? (r.line++, r.column = 1, r.offset += H === -3 ? 2 : 1, S()) : H !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === i[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = H;
  }
  function I(H, F) {
    const ee = F || {};
    return ee.type = H, ee.start = h(), c.events.push(["enter", ee, c]), o.push(ee), ee;
  }
  function M(H) {
    const F = o.pop();
    return F.end = h(), c.events.push(["exit", F, c]), F;
  }
  function B(H, F) {
    q(H, F.from);
  }
  function R(H, F) {
    F.restore();
  }
  function U(H, F) {
    return ee;
    function ee(G, j, te) {
      let se, re, me, A;
      return Array.isArray(G) ? Ae(G) : "tokenize" in G ? (
        // @ts-expect-error Looks like a construct.
        Ae([G])
      ) : ae(G);
      function ae(ce) {
        return Fe;
        function Fe(Be) {
          const ve = Be !== null && ce[Be], nt = Be !== null && ce.null, Mn = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ve) ? ve : ve ? [ve] : [],
            ...Array.isArray(nt) ? nt : nt ? [nt] : []
          ];
          return Ae(Mn)(Be);
        }
      }
      function Ae(ce) {
        return se = ce, re = 0, ce.length === 0 ? te : C(ce[re]);
      }
      function C(ce) {
        return Fe;
        function Fe(Be) {
          return A = Y(), me = ce, ce.partial || (c.currentConstruct = ce), ce.name && c.parser.constructs.disable.null.includes(ce.name) ? Me() : ce.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a live binding, which is needed for `interrupt`.
            F ? Object.assign(Object.create(c), F) : c,
            l,
            Te,
            Me
          )(Be);
        }
      }
      function Te(ce) {
        return H(me, A), j;
      }
      function Me(ce) {
        return A.restore(), ++re < se.length ? C(se[re]) : te;
      }
    }
  }
  function q(H, F) {
    H.resolveAll && !u.includes(H) && u.push(H), H.resolve && Ne(
      c.events,
      F,
      c.events.length - F,
      H.resolve(c.events.slice(F), c)
    ), H.resolveTo && (c.events = H.resolveTo(c.events, c));
  }
  function Y() {
    const H = h(), F = c.previous, ee = c.currentConstruct, G = c.events.length, j = Array.from(o);
    return {
      restore: te,
      from: G
    };
    function te() {
      r = H, c.previous = F, c.currentConstruct = ee, c.events.length = G, o = j, S();
    }
  }
  function S() {
    r.line in a && r.column < 2 && (r.column = a[r.line], r.offset += a[r.line] - 1);
  }
}
function sd(e, t) {
  const n = t.start._index, r = t.start._bufferIndex, a = t.end._index, u = t.end._bufferIndex;
  let i;
  if (n === a)
    i = [e[n].slice(r, u)];
  else {
    if (i = e.slice(n, a), r > -1) {
      const o = i[0];
      typeof o == "string" ? i[0] = o.slice(r) : i.shift();
    }
    u > 0 && i.push(e[a].slice(0, u));
  }
  return i;
}
function od(e, t) {
  let n = -1;
  const r = [];
  let a;
  for (; ++n < e.length; ) {
    const u = e[n];
    let i;
    if (typeof u == "string")
      i = u;
    else
      switch (u) {
        case -5: {
          i = "\r";
          break;
        }
        case -4: {
          i = `
`;
          break;
        }
        case -3: {
          i = `\r
`;
          break;
        }
        case -2: {
          i = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && a) continue;
          i = " ";
          break;
        }
        default:
          i = String.fromCharCode(u);
      }
    a = u === -2, r.push(i);
  }
  return r.join("");
}
const ld = {
  42: Ce,
  43: Ce,
  45: Ce,
  48: Ce,
  49: Ce,
  50: Ce,
  51: Ce,
  52: Ce,
  53: Ce,
  54: Ce,
  55: Ce,
  56: Ce,
  57: Ce,
  62: Vi
}, cd = {
  91: dc
}, dd = {
  [-2]: Hn,
  [-1]: Hn,
  32: Hn
}, fd = {
  35: bc,
  42: ln,
  45: [_a, ln],
  60: Ac,
  61: _a,
  95: ln,
  96: ya,
  126: ya
}, hd = {
  38: Xi,
  92: Qi
}, pd = {
  [-5]: Un,
  [-4]: Un,
  [-3]: Un,
  33: Hc,
  38: Xi,
  42: ur,
  60: [Yl, Nc],
  91: zc,
  92: [mc, Qi],
  93: Nr,
  95: ur,
  96: tc
}, md = {
  null: [ur, nd]
}, gd = {
  null: [42, 95]
}, bd = {
  null: []
}, Ed = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers: gd,
  contentInitial: cd,
  disable: bd,
  document: ld,
  flow: fd,
  flowInitial: dd,
  insideSpan: md,
  string: hd,
  text: pd
}, Symbol.toStringTag, { value: "Module" }));
function Td(e) {
  const n = (
    /** @type {FullNormalizedExtension} */
    $i([Ed, ...(e || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: n,
    content: a(Ml),
    document: a(Bl),
    flow: a(ed),
    string: a(rd),
    text: a(ad)
  };
  return r;
  function a(u) {
    return i;
    function i(o) {
      return ud(r, u, o);
    }
  }
}
function yd(e) {
  for (; !Ki(e); )
    ;
  return e;
}
const Ca = /[\0\t\n\r]/g;
function Ad() {
  let e = 1, t = "", n = !0, r;
  return a;
  function a(u, i, o) {
    const l = [];
    let c, f, d, b, m;
    for (u = t + (typeof u == "string" ? u.toString() : new TextDecoder(i || void 0).decode(u)), d = 0, t = "", n && (u.charCodeAt(0) === 65279 && d++, n = void 0); d < u.length; ) {
      if (Ca.lastIndex = d, c = Ca.exec(u), b = c && c.index !== void 0 ? c.index : u.length, m = u.charCodeAt(b), !c) {
        t = u.slice(d);
        break;
      }
      if (m === 10 && d === b && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), d < b && (l.push(u.slice(d, b)), e += b - d), m) {
          case 0: {
            l.push(65533), e++;
            break;
          }
          case 9: {
            for (f = Math.ceil(e / 4) * 4, l.push(-2); e++ < f; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e = 1;
            break;
          }
          default:
            r = !0, e = 1;
        }
      d = b + 1;
    }
    return o && (r && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
const _d = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Cd(e) {
  return e.replace(_d, xd);
}
function xd(e, t, n) {
  if (t)
    return t;
  if (n.charCodeAt(0) === 35) {
    const a = n.charCodeAt(1), u = a === 120 || a === 88;
    return Wi(n.slice(u ? 2 : 1), u ? 16 : 10);
  }
  return Sr(n) || e;
}
const ru = {}.hasOwnProperty;
function kd(e, t, n) {
  return typeof t != "string" && (n = t, t = void 0), Id(n)(
    yd(
      Td(n).document().write(Ad()(e, t, !0))
    )
  );
}
function Id(e) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: u(Wr),
      autolinkProtocol: Y,
      autolinkEmail: Y,
      atxHeading: u(Gr),
      blockQuote: u(ve),
      characterEscape: Y,
      characterReference: Y,
      codeFenced: u(nt),
      codeFencedFenceInfo: i,
      codeFencedFenceMeta: i,
      codeIndented: u(nt, i),
      codeText: u(Mn, i),
      codeTextData: Y,
      data: Y,
      codeFlowValue: Y,
      definition: u(Ss),
      definitionDestinationString: i,
      definitionLabelString: i,
      definitionTitleString: i,
      emphasis: u(Ns),
      hardBreakEscape: u(qr),
      hardBreakTrailing: u(qr),
      htmlFlow: u($r, i),
      htmlFlowData: Y,
      htmlText: u($r, i),
      htmlTextData: Y,
      image: u(Rs),
      label: i,
      link: u(Wr),
      listItem: u(Ls),
      listItemValue: b,
      listOrdered: u(Vr, d),
      listUnordered: u(Vr),
      paragraph: u(Os),
      reference: C,
      referenceString: i,
      resourceDestinationString: i,
      resourceTitleString: i,
      setextHeading: u(Gr),
      strong: u(ws),
      thematicBreak: u(Ps)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: B,
      autolink: l(),
      autolinkEmail: Be,
      autolinkProtocol: Fe,
      blockQuote: l(),
      characterEscapeValue: S,
      characterReferenceMarkerHexadecimal: Me,
      characterReferenceMarkerNumeric: Me,
      characterReferenceValue: ce,
      codeFenced: l(y),
      codeFencedFence: E,
      codeFencedFenceInfo: m,
      codeFencedFenceMeta: h,
      codeFlowValue: S,
      codeIndented: l(_),
      codeText: l(j),
      codeTextData: S,
      data: S,
      definition: l(),
      definitionDestinationString: M,
      definitionLabelString: x,
      definitionTitleString: I,
      emphasis: l(),
      hardBreakEscape: l(F),
      hardBreakTrailing: l(F),
      htmlFlow: l(ee),
      htmlFlowData: S,
      htmlText: l(G),
      htmlTextData: S,
      image: l(se),
      label: me,
      labelText: re,
      lineEnding: H,
      link: l(te),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: Te,
      resourceDestinationString: A,
      resourceTitleString: ae,
      resource: Ae,
      setextHeading: l(q),
      setextHeadingLineSequence: U,
      setextHeadingText: R,
      strong: l(),
      thematicBreak: l()
    }
  };
  au(t, (e || {}).mdastExtensions || []);
  const n = {};
  return r;
  function r(O) {
    let v = {
      type: "root",
      children: []
    };
    const $ = {
      stack: [v],
      tokenStack: [],
      config: t,
      enter: o,
      exit: c,
      buffer: i,
      resume: f,
      data: n
    }, Z = [];
    let ne = -1;
    for (; ++ne < O.length; )
      if (O[ne][1].type === "listOrdered" || O[ne][1].type === "listUnordered")
        if (O[ne][0] === "enter")
          Z.push(ne);
        else {
          const Oe = Z.pop();
          ne = a(O, Oe, ne);
        }
    for (ne = -1; ++ne < O.length; ) {
      const Oe = t[O[ne][0]];
      ru.call(Oe, O[ne][1].type) && Oe[O[ne][1].type].call(
        Object.assign(
          {
            sliceSerialize: O[ne][2].sliceSerialize
          },
          $
        ),
        O[ne][1]
      );
    }
    if ($.tokenStack.length > 0) {
      const Oe = $.tokenStack[$.tokenStack.length - 1];
      (Oe[1] || xa).call($, void 0, Oe[0]);
    }
    for (v.position = {
      start: Xe(
        O.length > 0 ? O[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: Xe(
        O.length > 0 ? O[O.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, ne = -1; ++ne < t.transforms.length; )
      v = t.transforms[ne](v) || v;
    return v;
  }
  function a(O, v, $) {
    let Z = v - 1, ne = -1, Oe = !1, rt, Ge, Lt, Ot;
    for (; ++Z <= $; ) {
      const xe = O[Z];
      switch (xe[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          xe[0] === "enter" ? ne++ : ne--, Ot = void 0;
          break;
        }
        case "lineEndingBlank": {
          xe[0] === "enter" && (rt && !Ot && !ne && !Lt && (Lt = Z), Ot = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Ot = void 0;
      }
      if (!ne && xe[0] === "enter" && xe[1].type === "listItemPrefix" || ne === -1 && xe[0] === "exit" && (xe[1].type === "listUnordered" || xe[1].type === "listOrdered")) {
        if (rt) {
          let ft = Z;
          for (Ge = void 0; ft--; ) {
            const qe = O[ft];
            if (qe[1].type === "lineEnding" || qe[1].type === "lineEndingBlank") {
              if (qe[0] === "exit") continue;
              Ge && (O[Ge][1].type = "lineEndingBlank", Oe = !0), qe[1].type = "lineEnding", Ge = ft;
            } else if (!(qe[1].type === "linePrefix" || qe[1].type === "blockQuotePrefix" || qe[1].type === "blockQuotePrefixWhitespace" || qe[1].type === "blockQuoteMarker" || qe[1].type === "listItemIndent")) break;
          }
          Lt && (!Ge || Lt < Ge) && (rt._spread = !0), rt.end = Object.assign(
            {},
            Ge ? O[Ge][1].start : xe[1].end
          ), O.splice(Ge || Z, 0, ["exit", rt, xe[2]]), Z++, $++;
        }
        if (xe[1].type === "listItemPrefix") {
          const ft = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, xe[1].start),
            // @ts-expect-error: well add `end` in a second.
            end: void 0
          };
          rt = ft, O.splice(Z, 0, ["enter", ft, xe[2]]), Z++, $++, Lt = void 0, Ot = !0;
        }
      }
    }
    return O[v][1]._spread = Oe, $;
  }
  function u(O, v) {
    return $;
    function $(Z) {
      o.call(this, O(Z), Z), v && v.call(this, Z);
    }
  }
  function i() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o(O, v, $) {
    this.stack[this.stack.length - 1].children.push(O), this.stack.push(O), this.tokenStack.push([v, $]), O.position = {
      start: Xe(v.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(O) {
    return v;
    function v($) {
      O && O.call(this, $), c.call(this, $);
    }
  }
  function c(O, v) {
    const $ = this.stack.pop(), Z = this.tokenStack.pop();
    if (Z)
      Z[0].type !== O.type && (v ? v.call(this, O, Z[0]) : (Z[1] || xa).call(this, O, Z[0]));
    else throw new Error(
      "Cannot close `" + O.type + "` (" + vt({
        start: O.start,
        end: O.end
      }) + "): its not open"
    );
    $.position.end = Xe(O.end);
  }
  function f() {
    return Ir(this.stack.pop());
  }
  function d() {
    this.data.expectingFirstListItemValue = !0;
  }
  function b(O) {
    if (this.data.expectingFirstListItemValue) {
      const v = this.stack[this.stack.length - 2];
      v.start = Number.parseInt(this.sliceSerialize(O), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function m() {
    const O = this.resume(), v = this.stack[this.stack.length - 1];
    v.lang = O;
  }
  function h() {
    const O = this.resume(), v = this.stack[this.stack.length - 1];
    v.meta = O;
  }
  function E() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function y() {
    const O = this.resume(), v = this.stack[this.stack.length - 1];
    v.value = O.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function _() {
    const O = this.resume(), v = this.stack[this.stack.length - 1];
    v.value = O.replace(/(\r?\n|\r)$/g, "");
  }
  function x(O) {
    const v = this.resume(), $ = this.stack[this.stack.length - 1];
    $.label = v, $.identifier = De(
      this.sliceSerialize(O)
    ).toLowerCase();
  }
  function I() {
    const O = this.resume(), v = this.stack[this.stack.length - 1];
    v.title = O;
  }
  function M() {
    const O = this.resume(), v = this.stack[this.stack.length - 1];
    v.url = O;
  }
  function B(O) {
    const v = this.stack[this.stack.length - 1];
    if (!v.depth) {
      const $ = this.sliceSerialize(O).length;
      v.depth = $;
    }
  }
  function R() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function U(O) {
    const v = this.stack[this.stack.length - 1];
    v.depth = this.sliceSerialize(O).codePointAt(0) === 61 ? 1 : 2;
  }
  function q() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function Y(O) {
    const $ = this.stack[this.stack.length - 1].children;
    let Z = $[$.length - 1];
    (!Z || Z.type !== "text") && (Z = Ds(), Z.position = {
      start: Xe(O.start),
      // @ts-expect-error: well add `end` later.
      end: void 0
    }, $.push(Z)), this.stack.push(Z);
  }
  function S(O) {
    const v = this.stack.pop();
    v.value += this.sliceSerialize(O), v.position.end = Xe(O.end);
  }
  function H(O) {
    const v = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const $ = v.children[v.children.length - 1];
      $.position.end = Xe(O.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(v.type) && (Y.call(this, O), S.call(this, O));
  }
  function F() {
    this.data.atHardBreak = !0;
  }
  function ee() {
    const O = this.resume(), v = this.stack[this.stack.length - 1];
    v.value = O;
  }
  function G() {
    const O = this.resume(), v = this.stack[this.stack.length - 1];
    v.value = O;
  }
  function j() {
    const O = this.resume(), v = this.stack[this.stack.length - 1];
    v.value = O;
  }
  function te() {
    const O = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const v = this.data.referenceType || "shortcut";
      O.type += "Reference", O.referenceType = v, delete O.url, delete O.title;
    } else
      delete O.identifier, delete O.label;
    this.data.referenceType = void 0;
  }
  function se() {
    const O = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const v = this.data.referenceType || "shortcut";
      O.type += "Reference", O.referenceType = v, delete O.url, delete O.title;
    } else
      delete O.identifier, delete O.label;
    this.data.referenceType = void 0;
  }
  function re(O) {
    const v = this.sliceSerialize(O), $ = this.stack[this.stack.length - 2];
    $.label = Cd(v), $.identifier = De(v).toLowerCase();
  }
  function me() {
    const O = this.stack[this.stack.length - 1], v = this.resume(), $ = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, $.type === "link") {
      const Z = O.children;
      $.children = Z;
    } else
      $.alt = v;
  }
  function A() {
    const O = this.resume(), v = this.stack[this.stack.length - 1];
    v.url = O;
  }
  function ae() {
    const O = this.resume(), v = this.stack[this.stack.length - 1];
    v.title = O;
  }
  function Ae() {
    this.data.inReference = void 0;
  }
  function C() {
    this.data.referenceType = "collapsed";
  }
  function Te(O) {
    const v = this.resume(), $ = this.stack[this.stack.length - 1];
    $.label = v, $.identifier = De(
      this.sliceSerialize(O)
    ).toLowerCase(), this.data.referenceType = "full";
  }
  function Me(O) {
    this.data.characterReferenceType = O.type;
  }
  function ce(O) {
    const v = this.sliceSerialize(O), $ = this.data.characterReferenceType;
    let Z;
    $ ? (Z = Wi(
      v,
      $ === "characterReferenceMarkerNumeric" ? 10 : 16
    ), this.data.characterReferenceType = void 0) : Z = Sr(v);
    const ne = this.stack.pop();
    ne.value += Z, ne.position.end = Xe(O.end);
  }
  function Fe(O) {
    S.call(this, O);
    const v = this.stack[this.stack.length - 1];
    v.url = this.sliceSerialize(O);
  }
  function Be(O) {
    S.call(this, O);
    const v = this.stack[this.stack.length - 1];
    v.url = "mailto:" + this.sliceSerialize(O);
  }
  function ve() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function nt() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Mn() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Ss() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function Ns() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Gr() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function qr() {
    return {
      type: "break"
    };
  }
  function $r() {
    return {
      type: "html",
      value: ""
    };
  }
  function Rs() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Wr() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Vr(O) {
    return {
      type: "list",
      ordered: O.type === "listOrdered",
      start: null,
      spread: O._spread,
      children: []
    };
  }
  function Ls(O) {
    return {
      type: "listItem",
      spread: O._spread,
      checked: null,
      children: []
    };
  }
  function Os() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function ws() {
    return {
      type: "strong",
      children: []
    };
  }
  function Ds() {
    return {
      type: "text",
      value: ""
    };
  }
  function Ps() {
    return {
      type: "thematicBreak"
    };
  }
}
function Xe(e) {
  return {
    line: e.line,
    column: e.column,
    offset: e.offset
  };
}
function au(e, t) {
  let n = -1;
  for (; ++n < t.length; ) {
    const r = t[n];
    Array.isArray(r) ? au(e, r) : Sd(e, r);
  }
}
function Sd(e, t) {
  let n;
  for (n in t)
    if (ru.call(t, n))
      switch (n) {
        case "canContainEols": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n];
          r && e[n].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n];
          r && Object.assign(e[n], r);
          break;
        }
      }
}
function xa(e, t) {
  throw e ? new Error(
    "Cannot close `" + e.type + "` (" + vt({
      start: e.start,
      end: e.end
    }) + "): a different token (`" + t.type + "`, " + vt({
      start: t.start,
      end: t.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + t.type + "`, " + vt({
      start: t.start,
      end: t.end
    }) + ") is still open"
  );
}
function Nd(e) {
  const t = this;
  t.parser = n;
  function n(r) {
    return kd(r, {
      ...t.data("settings"),
      ...e,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function Rd(e, t) {
  const n = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e.wrap(e.all(t), !0)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Ld(e, t) {
  const n = { type: "element", tagName: "br", properties: {}, children: [] };
  return e.patch(t, n), [e.applyData(t, n), { type: "text", value: `
` }];
}
function Od(e, t) {
  const n = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let a = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n }]
  };
  return t.meta && (a.data = { meta: t.meta }), e.patch(t, a), a = e.applyData(t, a), a = { type: "element", tagName: "pre", properties: {}, children: [a] }, e.patch(t, a), a;
}
function wd(e, t) {
  const n = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Dd(e, t) {
  const n = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Pd(e, t) {
  const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), a = It(r.toLowerCase()), u = e.footnoteOrder.indexOf(r);
  let i, o = e.footnoteCounts.get(r);
  o === void 0 ? (o = 0, e.footnoteOrder.push(r), i = e.footnoteOrder.length) : i = u + 1, o += 1, e.footnoteCounts.set(r, o);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n + "fn-" + a,
      id: n + "fnref-" + a + (o > 1 ? "-" + o : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(i) }]
  };
  e.patch(t, l);
  const c = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e.patch(t, c), e.applyData(t, c);
}
function Md(e, t) {
  const n = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Fd(e, t) {
  if (e.options.allowDangerousHtml) {
    const n = { type: "raw", value: t.value };
    return e.patch(t, n), e.applyData(t, n);
  }
}
function iu(e, t) {
  const n = t.referenceType;
  let r = "]";
  if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const a = e.all(t), u = a[0];
  u && u.type === "text" ? u.value = "[" + u.value : a.unshift({ type: "text", value: "[" });
  const i = a[a.length - 1];
  return i && i.type === "text" ? i.value += r : a.push({ type: "text", value: r }), a;
}
function Bd(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return iu(e, t);
  const a = { src: It(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (a.title = r.title);
  const u = { type: "element", tagName: "img", properties: a, children: [] };
  return e.patch(t, u), e.applyData(t, u);
}
function vd(e, t) {
  const n = { src: It(t.url) };
  t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = { type: "element", tagName: "img", properties: n, children: [] };
  return e.patch(t, r), e.applyData(t, r);
}
function Hd(e, t) {
  const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e.patch(t, n);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n]
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Ud(e, t) {
  const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n);
  if (!r)
    return iu(e, t);
  const a = { href: It(r.url || "") };
  r.title !== null && r.title !== void 0 && (a.title = r.title);
  const u = {
    type: "element",
    tagName: "a",
    properties: a,
    children: e.all(t)
  };
  return e.patch(t, u), e.applyData(t, u);
}
function zd(e, t) {
  const n = { href: It(t.url) };
  t.title !== null && t.title !== void 0 && (n.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n,
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function Yd(e, t, n) {
  const r = e.all(t), a = n ? jd(n) : uu(t), u = {}, i = [];
  if (typeof t.checked == "boolean") {
    const f = r[0];
    let d;
    f && f.type === "element" && f.tagName === "p" ? d = f : (d = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(d)), d.children.length > 0 && d.children.unshift({ type: "text", value: " " }), d.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: !0 },
      children: []
    }), u.className = ["task-list-item"];
  }
  let o = -1;
  for (; ++o < r.length; ) {
    const f = r[o];
    (a || o !== 0 || f.type !== "element" || f.tagName !== "p") && i.push({ type: "text", value: `
` }), f.type === "element" && f.tagName === "p" && !a ? i.push(...f.children) : i.push(f);
  }
  const l = r[r.length - 1];
  l && (a || l.type !== "element" || l.tagName !== "p") && i.push({ type: "text", value: `
` });
  const c = { type: "element", tagName: "li", properties: u, children: i };
  return e.patch(t, c), e.applyData(t, c);
}
function jd(e) {
  let t = !1;
  if (e.type === "list") {
    t = e.spread || !1;
    const n = e.children;
    let r = -1;
    for (; !t && ++r < n.length; )
      t = uu(n[r]);
  }
  return t;
}
function uu(e) {
  const t = e.spread;
  return t ?? e.children.length > 1;
}
function Gd(e, t) {
  const n = {}, r = e.all(t);
  let a = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++a < r.length; ) {
    const i = r[a];
    if (i.type === "element" && i.tagName === "li" && i.properties && Array.isArray(i.properties.className) && i.properties.className.includes("task-list-item")) {
      n.className = ["contains-task-list"];
      break;
    }
  }
  const u = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n,
    children: e.wrap(r, !0)
  };
  return e.patch(t, u), e.applyData(t, u);
}
function qd(e, t) {
  const n = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function $d(e, t) {
  const n = { type: "root", children: e.wrap(e.all(t)) };
  return e.patch(t, n), e.applyData(t, n);
}
function Wd(e, t) {
  const n = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
function Vd(e, t) {
  const n = e.all(t), r = n.shift(), a = [];
  if (r) {
    const i = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e.wrap([r], !0)
    };
    e.patch(t.children[0], i), a.push(i);
  }
  if (n.length > 0) {
    const i = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e.wrap(n, !0)
    }, o = Ye(t.children[1]), l = Cn(t.children[t.children.length - 1]);
    o && l && (i.position = { start: o, end: l }), a.push(i);
  }
  const u = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e.wrap(a, !0)
  };
  return e.patch(t, u), e.applyData(t, u);
}
function Qd(e, t, n) {
  const r = n ? n.children : void 0, u = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", i = n && n.type === "table" ? n.align : void 0, o = i ? i.length : t.children.length;
  let l = -1;
  const c = [];
  for (; ++l < o; ) {
    const d = t.children[l], b = {}, m = i ? i[l] : void 0;
    m && (b.align = m);
    let h = { type: "element", tagName: u, properties: b, children: [] };
    d && (h.children = e.all(d), e.patch(d, h), h = e.applyData(d, h)), c.push(h);
  }
  const f = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e.wrap(c, !0)
  };
  return e.patch(t, f), e.applyData(t, f);
}
function Xd(e, t) {
  const n = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, n), e.applyData(t, n);
}
const ka = 9, Ia = 32;
function Kd(e) {
  const t = String(e), n = /\r?\n|\r/g;
  let r = n.exec(t), a = 0;
  const u = [];
  for (; r; )
    u.push(
      Sa(t.slice(a, r.index), a > 0, !0),
      r[0]
    ), a = r.index + r[0].length, r = n.exec(t);
  return u.push(Sa(t.slice(a), a > 0, !1)), u.join("");
}
function Sa(e, t, n) {
  let r = 0, a = e.length;
  if (t) {
    let u = e.codePointAt(r);
    for (; u === ka || u === Ia; )
      r++, u = e.codePointAt(r);
  }
  if (n) {
    let u = e.codePointAt(a - 1);
    for (; u === ka || u === Ia; )
      a--, u = e.codePointAt(a - 1);
  }
  return a > r ? e.slice(r, a) : "";
}
function Zd(e, t) {
  const n = { type: "text", value: Kd(String(t.value)) };
  return e.patch(t, n), e.applyData(t, n);
}
function Jd(e, t) {
  const n = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e.patch(t, n), e.applyData(t, n);
}
const e0 = {
  blockquote: Rd,
  break: Ld,
  code: Od,
  delete: wd,
  emphasis: Dd,
  footnoteReference: Pd,
  heading: Md,
  html: Fd,
  imageReference: Bd,
  image: vd,
  inlineCode: Hd,
  linkReference: Ud,
  link: zd,
  listItem: Yd,
  list: Gd,
  paragraph: qd,
  // @ts-expect-error: root is different, but hard to type.
  root: $d,
  strong: Wd,
  table: Vd,
  tableCell: Xd,
  tableRow: Qd,
  text: Zd,
  thematicBreak: Jd,
  toml: nn,
  yaml: nn,
  definition: nn,
  footnoteDefinition: nn
};
function nn() {
}
const su = -1, In = 0, bn = 1, En = 2, Rr = 3, Lr = 4, Or = 5, wr = 6, ou = 7, lu = 8, Na = typeof self == "object" ? self : globalThis, t0 = (e, t) => {
  const n = (a, u) => (e.set(u, a), a), r = (a) => {
    if (e.has(a))
      return e.get(a);
    const [u, i] = t[a];
    switch (u) {
      case In:
      case su:
        return n(i, a);
      case bn: {
        const o = n([], a);
        for (const l of i)
          o.push(r(l));
        return o;
      }
      case En: {
        const o = n({}, a);
        for (const [l, c] of i)
          o[r(l)] = r(c);
        return o;
      }
      case Rr:
        return n(new Date(i), a);
      case Lr: {
        const { source: o, flags: l } = i;
        return n(new RegExp(o, l), a);
      }
      case Or: {
        const o = n(/* @__PURE__ */ new Map(), a);
        for (const [l, c] of i)
          o.set(r(l), r(c));
        return o;
      }
      case wr: {
        const o = n(/* @__PURE__ */ new Set(), a);
        for (const l of i)
          o.add(r(l));
        return o;
      }
      case ou: {
        const { name: o, message: l } = i;
        return n(new Na[o](l), a);
      }
      case lu:
        return n(BigInt(i), a);
      case "BigInt":
        return n(Object(BigInt(i)), a);
    }
    return n(new Na[u](i), a);
  };
  return r;
}, Ra = (e) => t0(/* @__PURE__ */ new Map(), e)(0), pt = "", { toString: n0 } = {}, { keys: r0 } = Object, Pt = (e) => {
  const t = typeof e;
  if (t !== "object" || !e)
    return [In, t];
  const n = n0.call(e).slice(8, -1);
  switch (n) {
    case "Array":
      return [bn, pt];
    case "Object":
      return [En, pt];
    case "Date":
      return [Rr, pt];
    case "RegExp":
      return [Lr, pt];
    case "Map":
      return [Or, pt];
    case "Set":
      return [wr, pt];
  }
  return n.includes("Array") ? [bn, n] : n.includes("Error") ? [ou, n] : [En, n];
}, rn = ([e, t]) => e === In && (t === "function" || t === "symbol"), a0 = (e, t, n, r) => {
  const a = (i, o) => {
    const l = r.push(i) - 1;
    return n.set(o, l), l;
  }, u = (i) => {
    if (n.has(i))
      return n.get(i);
    let [o, l] = Pt(i);
    switch (o) {
      case In: {
        let f = i;
        switch (l) {
          case "bigint":
            o = lu, f = i.toString();
            break;
          case "function":
          case "symbol":
            if (e)
              throw new TypeError("unable to serialize " + l);
            f = null;
            break;
          case "undefined":
            return a([su], i);
        }
        return a([o, f], i);
      }
      case bn: {
        if (l)
          return a([l, [...i]], i);
        const f = [], d = a([o, f], i);
        for (const b of i)
          f.push(u(b));
        return d;
      }
      case En: {
        if (l)
          switch (l) {
            case "BigInt":
              return a([l, i.toString()], i);
            case "Boolean":
            case "Number":
            case "String":
              return a([l, i.valueOf()], i);
          }
        if (t && "toJSON" in i)
          return u(i.toJSON());
        const f = [], d = a([o, f], i);
        for (const b of r0(i))
          (e || !rn(Pt(i[b]))) && f.push([u(b), u(i[b])]);
        return d;
      }
      case Rr:
        return a([o, i.toISOString()], i);
      case Lr: {
        const { source: f, flags: d } = i;
        return a([o, { source: f, flags: d }], i);
      }
      case Or: {
        const f = [], d = a([o, f], i);
        for (const [b, m] of i)
          (e || !(rn(Pt(b)) || rn(Pt(m)))) && f.push([u(b), u(m)]);
        return d;
      }
      case wr: {
        const f = [], d = a([o, f], i);
        for (const b of i)
          (e || !rn(Pt(b))) && f.push(u(b));
        return d;
      }
    }
    const { message: c } = i;
    return a([o, { name: l, message: c }], i);
  };
  return u;
}, La = (e, { json: t, lossy: n } = {}) => {
  const r = [];
  return a0(!(t || n), !!t, /* @__PURE__ */ new Map(), r)(e), r;
}, _t = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e, t) => t && ("json" in t || "lossy" in t) ? Ra(La(e, t)) : structuredClone(e)
) : (e, t) => Ra(La(e, t));
function i0(e, t) {
  const n = [{ type: "text", value: "" }];
  return t > 1 && n.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n;
}
function u0(e, t) {
  return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "");
}
function s0(e) {
  const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || i0, r = e.options.footnoteBackLabel || u0, a = e.options.footnoteLabel || "Footnotes", u = e.options.footnoteLabelTagName || "h2", i = e.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o = [];
  let l = -1;
  for (; ++l < e.footnoteOrder.length; ) {
    const c = e.footnoteById.get(e.footnoteOrder[l]);
    if (!c)
      continue;
    const f = e.all(c), d = String(c.identifier).toUpperCase(), b = It(d.toLowerCase());
    let m = 0;
    const h = [], E = e.footnoteCounts.get(d);
    for (; E !== void 0 && ++m <= E; ) {
      h.length > 0 && h.push({ type: "text", value: " " });
      let x = typeof n == "string" ? n : n(l, m);
      typeof x == "string" && (x = { type: "text", value: x }), h.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + b + (m > 1 ? "-" + m : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(l, m),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(x) ? x : [x]
      });
    }
    const y = f[f.length - 1];
    if (y && y.type === "element" && y.tagName === "p") {
      const x = y.children[y.children.length - 1];
      x && x.type === "text" ? x.value += " " : y.children.push({ type: "text", value: " " }), y.children.push(...h);
    } else
      f.push(...h);
    const _ = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + b },
      children: e.wrap(f, !0)
    };
    e.patch(c, _), o.push(_);
  }
  if (o.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: u,
          properties: {
            ..._t(i),
            id: "footnote-label"
          },
          children: [{ type: "text", value: a }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e.wrap(o, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const Sn = (
  // Note: overloads in JSDoc cant yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e) {
    if (e == null)
      return d0;
    if (typeof e == "function")
      return Nn(e);
    if (typeof e == "object")
      return Array.isArray(e) ? o0(e) : l0(e);
    if (typeof e == "string")
      return c0(e);
    throw new Error("Expected function, string, or object as test");
  }
);
function o0(e) {
  const t = [];
  let n = -1;
  for (; ++n < e.length; )
    t[n] = Sn(e[n]);
  return Nn(r);
  function r(...a) {
    let u = -1;
    for (; ++u < t.length; )
      if (t[u].apply(this, a)) return !0;
    return !1;
  }
}
function l0(e) {
  const t = (
    /** @type {Record<string, unknown>} */
    e
  );
  return Nn(n);
  function n(r) {
    const a = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let u;
    for (u in e)
      if (a[u] !== t[u]) return !1;
    return !0;
  }
}
function c0(e) {
  return Nn(t);
  function t(n) {
    return n && n.type === e;
  }
}
function Nn(e) {
  return t;
  function t(n, r, a) {
    return !!(f0(n) && e.call(
      this,
      n,
      typeof r == "number" ? r : void 0,
      a || void 0
    ));
  }
}
function d0() {
  return !0;
}
function f0(e) {
  return e !== null && typeof e == "object" && "type" in e;
}
const cu = [], h0 = !0, sr = !1, p0 = "skip";
function du(e, t, n, r) {
  let a;
  typeof t == "function" && typeof n != "function" ? (r = n, n = t) : a = t;
  const u = Sn(a), i = r ? -1 : 1;
  o(e, void 0, [])();
  function o(l, c, f) {
    const d = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof d.type == "string") {
      const m = (
        // `hast`
        typeof d.tagName == "string" ? d.tagName : (
          // `xast`
          typeof d.name == "string" ? d.name : void 0
        )
      );
      Object.defineProperty(b, "name", {
        value: "node (" + (l.type + (m ? "<" + m + ">" : "")) + ")"
      });
    }
    return b;
    function b() {
      let m = cu, h, E, y;
      if ((!t || u(l, c, f[f.length - 1] || void 0)) && (m = m0(n(l, f)), m[0] === sr))
        return m;
      if ("children" in l && l.children) {
        const _ = (
          /** @type {UnistParent} */
          l
        );
        if (_.children && m[0] !== p0)
          for (E = (r ? _.children.length : -1) + i, y = f.concat(_); E > -1 && E < _.children.length; ) {
            const x = _.children[E];
            if (h = o(x, E, y)(), h[0] === sr)
              return h;
            E = typeof h[1] == "number" ? h[1] : E + i;
          }
      }
      return m;
    }
  }
}
function m0(e) {
  return Array.isArray(e) ? e : typeof e == "number" ? [h0, e] : e == null ? cu : [e];
}
function Zt(e, t, n, r) {
  let a, u, i;
  typeof t == "function" && typeof n != "function" ? (u = void 0, i = t, a = n) : (u = t, i = n, a = r), du(e, u, o, a);
  function o(l, c) {
    const f = c[c.length - 1], d = f ? f.children.indexOf(l) : void 0;
    return i(l, d, f);
  }
}
const or = {}.hasOwnProperty, g0 = {};
function b0(e, t) {
  const n = t || g0, r = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), u = /* @__PURE__ */ new Map(), i = { ...e0, ...n.handlers }, o = {
    all: c,
    applyData: T0,
    definitionById: r,
    footnoteById: a,
    footnoteCounts: u,
    footnoteOrder: [],
    handlers: i,
    one: l,
    options: n,
    patch: E0,
    wrap: A0
  };
  return Zt(e, function(f) {
    if (f.type === "definition" || f.type === "footnoteDefinition") {
      const d = f.type === "definition" ? r : a, b = String(f.identifier).toUpperCase();
      d.has(b) || d.set(b, f);
    }
  }), o;
  function l(f, d) {
    const b = f.type, m = o.handlers[b];
    if (or.call(o.handlers, b) && m)
      return m(o, f, d);
    if (o.options.passThrough && o.options.passThrough.includes(b)) {
      if ("children" in f) {
        const { children: E, ...y } = f, _ = _t(y);
        return _.children = o.all(f), _;
      }
      return _t(f);
    }
    return (o.options.unknownHandler || y0)(o, f, d);
  }
  function c(f) {
    const d = [];
    if ("children" in f) {
      const b = f.children;
      let m = -1;
      for (; ++m < b.length; ) {
        const h = o.one(b[m], f);
        if (h) {
          if (m && b[m - 1].type === "break" && (!Array.isArray(h) && h.type === "text" && (h.value = Oa(h.value)), !Array.isArray(h) && h.type === "element")) {
            const E = h.children[0];
            E && E.type === "text" && (E.value = Oa(E.value));
          }
          Array.isArray(h) ? d.push(...h) : d.push(h);
        }
      }
    }
    return d;
  }
}
function E0(e, t) {
  e.position && (t.position = il(e));
}
function T0(e, t) {
  let n = t;
  if (e && e.data) {
    const r = e.data.hName, a = e.data.hChildren, u = e.data.hProperties;
    if (typeof r == "string")
      if (n.type === "element")
        n.tagName = r;
      else {
        const i = "children" in n ? n.children : [n];
        n = { type: "element", tagName: r, properties: {}, children: i };
      }
    n.type === "element" && u && Object.assign(n.properties, _t(u)), "children" in n && n.children && a !== null && a !== void 0 && (n.children = a);
  }
  return n;
}
function y0(e, t) {
  const n = t.data || {}, r = "value" in t && !(or.call(n, "hProperties") || or.call(n, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e.all(t)
  };
  return e.patch(t, r), e.applyData(t, r);
}
function A0(e, t) {
  const n = [];
  let r = -1;
  for (t && n.push({ type: "text", value: `
` }); ++r < e.length; )
    r && n.push({ type: "text", value: `
` }), n.push(e[r]);
  return t && e.length > 0 && n.push({ type: "text", value: `
` }), n;
}
function Oa(e) {
  let t = 0, n = e.charCodeAt(t);
  for (; n === 9 || n === 32; )
    t++, n = e.charCodeAt(t);
  return e.slice(t);
}
function wa(e, t) {
  const n = b0(e, t), r = n.one(e, void 0), a = s0(n), u = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return a && u.children.push({ type: "text", value: `
` }, a), u;
}
function _0(e, t) {
  return e && "run" in e ? async function(n, r) {
    const a = (
      /** @type {HastRoot} */
      wa(n, { file: r, ...t })
    );
    await e.run(a, r);
  } : function(n, r) {
    return (
      /** @type {HastRoot} */
      wa(n, { file: r, ...t || e })
    );
  };
}
function Da(e) {
  if (e)
    throw e;
}
var cn = Object.prototype.hasOwnProperty, fu = Object.prototype.toString, Pa = Object.defineProperty, Ma = Object.getOwnPropertyDescriptor, Fa = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : fu.call(t) === "[object Array]";
}, Ba = function(t) {
  if (!t || fu.call(t) !== "[object Object]")
    return !1;
  var n = cn.call(t, "constructor"), r = t.constructor && t.constructor.prototype && cn.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !n && !r)
    return !1;
  var a;
  for (a in t)
    ;
  return typeof a > "u" || cn.call(t, a);
}, va = function(t, n) {
  Pa && n.name === "__proto__" ? Pa(t, n.name, {
    enumerable: !0,
    configurable: !0,
    value: n.newValue,
    writable: !0
  }) : t[n.name] = n.newValue;
}, Ha = function(t, n) {
  if (n === "__proto__")
    if (cn.call(t, n)) {
      if (Ma)
        return Ma(t, n).value;
    } else return;
  return t[n];
}, C0 = function e() {
  var t, n, r, a, u, i, o = arguments[0], l = 1, c = arguments.length, f = !1;
  for (typeof o == "boolean" && (f = o, o = arguments[1] || {}, l = 2), (o == null || typeof o != "object" && typeof o != "function") && (o = {}); l < c; ++l)
    if (t = arguments[l], t != null)
      for (n in t)
        r = Ha(o, n), a = Ha(t, n), o !== a && (f && a && (Ba(a) || (u = Fa(a))) ? (u ? (u = !1, i = r && Fa(r) ? r : []) : i = r && Ba(r) ? r : {}, va(o, { name: n, newValue: e(f, i, a) })) : typeof a < "u" && va(o, { name: n, newValue: a }));
  return o;
};
const zn = /* @__PURE__ */ Ys(C0);
function lr(e) {
  if (typeof e != "object" || e === null)
    return !1;
  const t = Object.getPrototypeOf(e);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e);
}
function x0() {
  const e = [], t = { run: n, use: r };
  return t;
  function n(...a) {
    let u = -1;
    const i = a.pop();
    if (typeof i != "function")
      throw new TypeError("Expected function as last argument, not " + i);
    o(null, ...a);
    function o(l, ...c) {
      const f = e[++u];
      let d = -1;
      if (l) {
        i(l);
        return;
      }
      for (; ++d < a.length; )
        (c[d] === null || c[d] === void 0) && (c[d] = a[d]);
      a = c, f ? k0(f, o)(...c) : i(null, ...c);
    }
  }
  function r(a) {
    if (typeof a != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + a
      );
    return e.push(a), t;
  }
}
function k0(e, t) {
  let n;
  return r;
  function r(...i) {
    const o = e.length > i.length;
    let l;
    o && i.push(a);
    try {
      l = e.apply(this, i);
    } catch (c) {
      const f = (
        /** @type {Error} */
        c
      );
      if (o && n)
        throw f;
      return a(f);
    }
    o || (l && l.then && typeof l.then == "function" ? l.then(u, a) : l instanceof Error ? a(l) : u(l));
  }
  function a(i, ...o) {
    n || (n = !0, t(i, ...o));
  }
  function u(i) {
    a(null, i);
  }
}
const He = { basename: I0, dirname: S0, extname: N0, join: R0, sep: "/" };
function I0(e, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  Jt(e);
  let n = 0, r = -1, a = e.length, u;
  if (t === void 0 || t.length === 0 || t.length > e.length) {
    for (; a--; )
      if (e.codePointAt(a) === 47) {
        if (u) {
          n = a + 1;
          break;
        }
      } else r < 0 && (u = !0, r = a + 1);
    return r < 0 ? "" : e.slice(n, r);
  }
  if (t === e)
    return "";
  let i = -1, o = t.length - 1;
  for (; a--; )
    if (e.codePointAt(a) === 47) {
      if (u) {
        n = a + 1;
        break;
      }
    } else
      i < 0 && (u = !0, i = a + 1), o > -1 && (e.codePointAt(a) === t.codePointAt(o--) ? o < 0 && (r = a) : (o = -1, r = i));
  return n === r ? r = i : r < 0 && (r = e.length), e.slice(n, r);
}
function S0(e) {
  if (Jt(e), e.length === 0)
    return ".";
  let t = -1, n = e.length, r;
  for (; --n; )
    if (e.codePointAt(n) === 47) {
      if (r) {
        t = n;
        break;
      }
    } else r || (r = !0);
  return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t);
}
function N0(e) {
  Jt(e);
  let t = e.length, n = -1, r = 0, a = -1, u = 0, i;
  for (; t--; ) {
    const o = e.codePointAt(t);
    if (o === 47) {
      if (i) {
        r = t + 1;
        break;
      }
      continue;
    }
    n < 0 && (i = !0, n = t + 1), o === 46 ? a < 0 ? a = t : u !== 1 && (u = 1) : a > -1 && (u = -1);
  }
  return a < 0 || n < 0 || // We saw a non-dot character immediately before the dot.
  u === 0 || // The (right-most) trimmed path component is exactly `..`.
  u === 1 && a === n - 1 && a === r + 1 ? "" : e.slice(a, n);
}
function R0(...e) {
  let t = -1, n;
  for (; ++t < e.length; )
    Jt(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]);
  return n === void 0 ? "." : L0(n);
}
function L0(e) {
  Jt(e);
  const t = e.codePointAt(0) === 47;
  let n = O0(e, !t);
  return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n;
}
function O0(e, t) {
  let n = "", r = 0, a = -1, u = 0, i = -1, o, l;
  for (; ++i <= e.length; ) {
    if (i < e.length)
      o = e.codePointAt(i);
    else {
      if (o === 47)
        break;
      o = 47;
    }
    if (o === 47) {
      if (!(a === i - 1 || u === 1)) if (a !== i - 1 && u === 2) {
        if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) {
          if (n.length > 2) {
            if (l = n.lastIndexOf("/"), l !== n.length - 1) {
              l < 0 ? (n = "", r = 0) : (n = n.slice(0, l), r = n.length - 1 - n.lastIndexOf("/")), a = i, u = 0;
              continue;
            }
          } else if (n.length > 0) {
            n = "", r = 0, a = i, u = 0;
            continue;
          }
        }
        t && (n = n.length > 0 ? n + "/.." : "..", r = 2);
      } else
        n.length > 0 ? n += "/" + e.slice(a + 1, i) : n = e.slice(a + 1, i), r = i - a - 1;
      a = i, u = 0;
    } else o === 46 && u > -1 ? u++ : u = -1;
  }
  return n;
}
function Jt(e) {
  if (typeof e != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e)
    );
}
const w0 = { cwd: D0 };
function D0() {
  return "/";
}
function cr(e) {
  return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && // @ts-expect-error: indexing is fine.
  e.auth === void 0);
}
function P0(e) {
  if (typeof e == "string")
    e = new URL(e);
  else if (!cr(e)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return M0(e);
}
function M0(e) {
  if (e.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e.pathname;
  let n = -1;
  for (; ++n < t.length; )
    if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) {
      const r = t.codePointAt(n + 2);
      if (r === 70 || r === 102) {
        const a = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw a.code = "ERR_INVALID_FILE_URL_PATH", a;
      }
    }
  return decodeURIComponent(t);
}
const Yn = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class hu {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array`  `{value: options}`
   * *   `URL`  `{path: options}`
   * *   `VFile`  shallow copies its data over to the new file
   * *   `object`  all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n;
    t ? cr(t) ? n = { path: t } : typeof t == "string" || F0(t) ? n = { value: t } : n = t : n = {}, this.cwd = w0.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < Yn.length; ) {
      const u = Yn[r];
      u in n && n[u] !== void 0 && n[u] !== null && (this[u] = u === "history" ? [...n[u]] : n[u]);
    }
    let a;
    for (a in n)
      Yn.includes(a) || (this[a] = n[a]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? He.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    Gn(t, "basename"), jn(t, "basename"), this.path = He.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? He.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    Ua(this.basename, "dirname"), this.path = He.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? He.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if theres no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (jn(t, "extname"), Ua(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = He.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    cr(t) && (t = P0(t)), Gn(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? He.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    Gn(t, "stem"), jn(t, "stem"), this.path = He.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n, r) {
    const a = this.message(t, n, r);
    throw a.fatal = !0, a;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n, r) {
    const a = this.message(t, n, r);
    return a.fatal = void 0, a;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * >  **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n, r) {
    const a = new be(
      // @ts-expect-error: the overloads are fine.
      t,
      n,
      r
    );
    return this.path && (a.name = this.path + ":" + a.name, a.file = this.path), a.fatal = !1, this.messages.push(a), a;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when its a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
}
function jn(e, t) {
  if (e && e.includes(He.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + He.sep + "`"
    );
}
function Gn(e, t) {
  if (!e)
    throw new Error("`" + t + "` cannot be empty");
}
function Ua(e, t) {
  if (!e)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function F0(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const B0 = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), a = r[e], u = function() {
      return a.apply(u, arguments);
    };
    Object.setPrototypeOf(u, r);
    const i = Object.getOwnPropertyNames(a);
    for (const o of i) {
      const l = Object.getOwnPropertyDescriptor(a, o);
      l && Object.defineProperty(u, o, l);
    }
    return u;
  }
), v0 = {}.hasOwnProperty;
class Dr extends B0 {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = x0();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@link Processor `Processor`}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Dr()
    );
    let n = -1;
    for (; ++n < this.attachers.length; ) {
      const r = this.attachers[n];
      t.use(...r);
    }
    return t.data(zn(!0, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * >  **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * >  **Note**: to register custom data in TypeScript, augment the
   * > {@link Data `Data`} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n) {
    return typeof t == "string" ? arguments.length === 2 ? (Wn("data", this.frozen), this.namespace[t] = n, this) : v0.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (Wn("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * Its possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === !1)
        continue;
      r[0] === !0 && (r[0] = void 0);
      const a = n.call(t, ...r);
      typeof a == "function" && this.transformers.use(a);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * >  **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n = an(t), r = this.parser || this.Parser;
    return qn("parse", r), r(String(n), n);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * >  **Note**: `process` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n) {
    const r = this;
    return this.freeze(), qn("process", this.parser || this.Parser), $n("process", this.compiler || this.Compiler), n ? a(void 0, n) : new Promise(a);
    function a(u, i) {
      const o = an(t), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(o)
      );
      r.run(l, o, function(f, d, b) {
        if (f || !d || !b)
          return c(f);
        const m = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          d
        ), h = r.stringify(m, b);
        z0(h) ? b.value = h : b.result = h, c(
          f,
          /** @type {VFileWithOutput<CompileResult>} */
          b
        );
      });
      function c(f, d) {
        f || !d ? i(f) : u ? u(d) : n(void 0, d);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n = !1, r;
    return this.freeze(), qn("processSync", this.parser || this.Parser), $n("processSync", this.compiler || this.Compiler), this.process(t, a), Ya("processSync", "process", n), r;
    function a(u, i) {
      n = !0, Da(u), r = i;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * >  **Note**: `run` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n, r) {
    za(t), this.freeze();
    const a = this.transformers;
    return !r && typeof n == "function" && (r = n, n = void 0), r ? u(void 0, r) : new Promise(u);
    function u(i, o) {
      const l = an(n);
      a.run(t, l, c);
      function c(f, d, b) {
        const m = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          d || t
        );
        f ? o(f) : i ? i(m) : r(void 0, m, b);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * >  **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n) {
    let r = !1, a;
    return this.run(t, n, u), Ya("runSync", "run", r), a;
    function u(i, o) {
      Da(i), a = o, r = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * >  **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * >  **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   >  **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If youre using a compiler that doesnt serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n) {
    this.freeze();
    const r = an(n), a = this.compiler || this.Compiler;
    return $n("stringify", a), za(t), a(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * >  **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n) {
    const r = this.attachers, a = this.namespace;
    if (Wn("use", this.frozen), t != null) if (typeof t == "function")
      l(t, n);
    else if (typeof t == "object")
      Array.isArray(t) ? o(t) : i(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function u(c) {
      if (typeof c == "function")
        l(c, []);
      else if (typeof c == "object")
        if (Array.isArray(c)) {
          const [f, ...d] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c
          );
          l(f, d);
        } else
          i(c);
      else
        throw new TypeError("Expected usable value, not `" + c + "`");
    }
    function i(c) {
      if (!("plugins" in c) && !("settings" in c))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      o(c.plugins), c.settings && (a.settings = zn(!0, a.settings, c.settings));
    }
    function o(c) {
      let f = -1;
      if (c != null) if (Array.isArray(c))
        for (; ++f < c.length; ) {
          const d = c[f];
          u(d);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c + "`");
    }
    function l(c, f) {
      let d = -1, b = -1;
      for (; ++d < r.length; )
        if (r[d][0] === c) {
          b = d;
          break;
        }
      if (b === -1)
        r.push([c, ...f]);
      else if (f.length > 0) {
        let [m, ...h] = f;
        const E = r[b][1];
        lr(E) && lr(m) && (m = zn(!0, E, m)), r[b] = [c, m, ...h];
      }
    }
  }
}
const H0 = new Dr().freeze();
function qn(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `parser`");
}
function $n(e, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e + "` without `compiler`");
}
function Wn(e, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function za(e) {
  if (!lr(e) || typeof e.type != "string")
    throw new TypeError("Expected node, got `" + e + "`");
}
function Ya(e, t, n) {
  if (!n)
    throw new Error(
      "`" + e + "` finished async. Use `" + t + "` instead"
    );
}
function an(e) {
  return U0(e) ? e : new hu(e);
}
function U0(e) {
  return !!(e && typeof e == "object" && "message" in e && "messages" in e);
}
function z0(e) {
  return typeof e == "string" || Y0(e);
}
function Y0(e) {
  return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e);
}
const j0 = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", ja = [], Ga = { allowDangerousHtml: !0 }, G0 = /^(https?|ircs?|mailto|xmpp)$/i, q0 = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function $0(e) {
  const t = e.allowedElements, n = e.allowElement, r = e.children || "", a = e.className, u = e.components, i = e.disallowedElements, o = e.rehypePlugins || ja, l = e.remarkPlugins || ja, c = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...Ga } : Ga, f = e.skipHtml, d = e.unwrapDisallowed, b = e.urlTransform || W0, m = H0().use(Nd).use(l).use(_0, c).use(o), h = new hu();
  typeof r == "string" && (h.value = r);
  for (const x of q0)
    Object.hasOwn(e, x.from) && ("" + x.from + (x.to ? "use `" + x.to + "` instead" : "remove it") + j0 + x.id, void 0);
  const E = m.parse(h);
  let y = m.runSync(E, h);
  return a && (y = {
    type: "element",
    tagName: "div",
    properties: { className: a },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      y.type === "root" ? y.children : [y]
    )
  }), Zt(y, _), dl(y, {
    Fragment: Q.Fragment,
    components: u,
    ignoreInvalidStyle: !0,
    jsx: Q.jsx,
    jsxs: Q.jsxs,
    passKeys: !0,
    passNode: !0
  });
  function _(x, I, M) {
    if (x.type === "raw" && M && typeof I == "number")
      return f ? M.children.splice(I, 1) : M.children[I] = { type: "text", value: x.value }, I;
    if (x.type === "element") {
      let B;
      for (B in vn)
        if (Object.hasOwn(vn, B) && Object.hasOwn(x.properties, B)) {
          const R = x.properties[B], U = vn[B];
          (U === null || U.includes(x.tagName)) && (x.properties[B] = b(String(R || ""), B, x));
        }
    }
    if (x.type === "element") {
      let B = t ? !t.includes(x.tagName) : i ? i.includes(x.tagName) : !1;
      if (!B && n && typeof I == "number" && (B = !n(x, I, M)), B && M && typeof I == "number")
        return d && x.children ? M.children.splice(I, 1, ...x.children) : M.children.splice(I, 1), I;
    }
  }
}
function W0(e) {
  const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), a = e.indexOf("/");
  return (
    // If there is no protocol, its relative.
    t < 0 || // If the first colon is after a `?`, `#`, or `/`, its not a protocol.
    a > -1 && t > a || n > -1 && t > n || r > -1 && t > r || // It is a protocol, it should be allowed.
    G0.test(e.slice(0, t)) ? e : ""
  );
}
const qa = /[#.]/g;
function V0(e, t) {
  const n = e || "", r = {};
  let a = 0, u, i;
  for (; a < n.length; ) {
    qa.lastIndex = a;
    const o = qa.exec(n), l = n.slice(a, o ? o.index : n.length);
    l && (u ? u === "#" ? r.id = l : Array.isArray(r.className) ? r.className.push(l) : r.className = [l] : i = l, a += l.length), o && (u = o[0], a++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: i || t || "div",
    properties: r,
    children: []
  };
}
const Q0 = /* @__PURE__ */ new Set(["button", "menu", "reset", "submit"]), dr = {}.hasOwnProperty;
function pu(e, t, n) {
  const r = n && J0(n);
  function a(u, i, ...o) {
    let l = -1, c;
    if (u == null) {
      c = { type: "root", children: [] };
      const f = (
        /** @type {Child} */
        i
      );
      o.unshift(f);
    } else if (c = V0(u, t), c.tagName = c.tagName.toLowerCase(), r && dr.call(r, c.tagName) && (c.tagName = r[c.tagName]), X0(i, c.tagName)) {
      let f;
      for (f in i)
        dr.call(i, f) && K0(e, c.properties, f, i[f]);
    } else
      o.unshift(i);
    for (; ++l < o.length; )
      fr(c.children, o[l]);
    return c.type === "element" && c.tagName === "template" && (c.content = { type: "root", children: c.children }, c.children = []), c;
  }
  return a;
}
function X0(e, t) {
  return e == null || typeof e != "object" || Array.isArray(e) ? !1 : t === "input" || !e.type || typeof e.type != "string" ? !0 : "children" in e && Array.isArray(e.children) ? !1 : t === "button" ? Q0.has(e.type.toLowerCase()) : !("value" in e);
}
function K0(e, t, n, r) {
  const a = _n(e, n);
  let u = -1, i;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r)) return;
      i = r;
    } else typeof r == "boolean" ? i = r : typeof r == "string" ? a.spaceSeparated ? i = ua(r) : a.commaSeparated ? i = ta(r) : a.commaOrSpaceSeparated ? i = ua(ta(r).join(" ")) : i = $a(a, a.property, r) : Array.isArray(r) ? i = r.concat() : i = a.property === "style" ? Z0(r) : String(r);
    if (Array.isArray(i)) {
      const o = [];
      for (; ++u < i.length; ) {
        const l = (
          /** @type {number | string} */
          $a(a, a.property, i[u])
        );
        o[u] = l;
      }
      i = o;
    }
    if (a.property === "className" && Array.isArray(t.className)) {
      const o = (
        /** @type {number | string} */
        i
      );
      i = t.className.concat(o);
    }
    t[a.property] = i;
  }
}
function fr(e, t) {
  let n = -1;
  if (t != null) if (typeof t == "string" || typeof t == "number")
    e.push({ type: "text", value: String(t) });
  else if (Array.isArray(t))
    for (; ++n < t.length; )
      fr(e, t[n]);
  else if (typeof t == "object" && "type" in t)
    t.type === "root" ? fr(e, t.children) : e.push(t);
  else
    throw new Error("Expected node, nodes, or string, got `" + t + "`");
}
function $a(e, t, n) {
  if (typeof n == "string") {
    if (e.number && n && !Number.isNaN(Number(n)))
      return Number(n);
    if ((e.boolean || e.overloadedBoolean) && (n === "" || $t(n) === $t(t)))
      return !0;
  }
  return n;
}
function Z0(e) {
  const t = [];
  let n;
  for (n in e)
    dr.call(e, n) && t.push([n, e[n]].join(": "));
  return t.join("; ");
}
function J0(e) {
  const t = {};
  let n = -1;
  for (; ++n < e.length; )
    t[e[n].toLowerCase()] = e[n];
  return t;
}
const ef = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
], tf = pu(Xt, "div"), nf = pu(et, "g", ef);
function rf(e) {
  const t = String(e), n = [];
  return { toOffset: a, toPoint: r };
  function r(u) {
    if (typeof u == "number" && u > -1 && u <= t.length) {
      let i = 0;
      for (; ; ) {
        let o = n[i];
        if (o === void 0) {
          const l = Wa(t, n[i - 1]);
          o = l === -1 ? t.length + 1 : l + 1, n[i] = o;
        }
        if (o > u)
          return {
            line: i + 1,
            column: u - (i > 0 ? n[i - 1] : 0) + 1,
            offset: u
          };
        i++;
      }
    }
  }
  function a(u) {
    if (u && typeof u.line == "number" && typeof u.column == "number" && !Number.isNaN(u.line) && !Number.isNaN(u.column)) {
      for (; n.length < u.line; ) {
        const o = n[n.length - 1], l = Wa(t, o), c = l === -1 ? t.length + 1 : l + 1;
        if (o === c) break;
        n.push(c);
      }
      const i = (u.line > 1 ? n[u.line - 2] : 0) + u.column - 1;
      if (i < n[u.line - 1]) return i;
    }
  }
}
function Wa(e, t) {
  const n = e.indexOf("\r", t), r = e.indexOf(`
`, t);
  return r === -1 ? n : n === -1 || n + 1 === r ? r : n < r ? n : r;
}
const ot = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
}, mu = {}.hasOwnProperty, af = Object.prototype;
function uf(e, t) {
  const n = t || {};
  return Pr(
    {
      file: n.file || void 0,
      location: !1,
      schema: n.space === "svg" ? et : Xt,
      verbose: n.verbose || !1
    },
    e
  );
}
function Pr(e, t) {
  let n;
  switch (t.nodeName) {
    case "#comment": {
      const r = (
        /** @type {P5Comment} */
        t
      );
      return n = { type: "comment", value: r.data }, dn(e, r, n), n;
    }
    case "#document":
    case "#document-fragment": {
      const r = (
        /** @type {P5Document | P5DocumentFragment} */
        t
      ), a = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1;
      if (n = {
        type: "root",
        children: gu(e, t.childNodes),
        data: { quirksMode: a }
      }, e.file && e.location) {
        const u = String(e.file), i = rf(u), o = i.toPoint(0), l = i.toPoint(u.length);
        n.position = { start: o, end: l };
      }
      return n;
    }
    case "#documentType": {
      const r = (
        /** @type {P5DocumentType} */
        t
      );
      return n = { type: "doctype" }, dn(e, r, n), n;
    }
    case "#text": {
      const r = (
        /** @type {P5Text} */
        t
      );
      return n = { type: "text", value: r.value }, dn(e, r, n), n;
    }
    default:
      return n = sf(
        e,
        /** @type {P5Element} */
        t
      ), n;
  }
}
function gu(e, t) {
  let n = -1;
  const r = [];
  for (; ++n < t.length; ) {
    const a = (
      /** @type {RootContent} */
      Pr(e, t[n])
    );
    r.push(a);
  }
  return r;
}
function sf(e, t) {
  const n = e.schema;
  e.schema = t.namespaceURI === ot.svg ? et : Xt;
  let r = -1;
  const a = {};
  for (; ++r < t.attrs.length; ) {
    const o = t.attrs[r], l = (o.prefix ? o.prefix + ":" : "") + o.name;
    mu.call(af, l) || (a[l] = o.value);
  }
  const i = (e.schema.space === "svg" ? nf : tf)(t.tagName, a, gu(e, t.childNodes));
  if (dn(e, t, i), i.tagName === "template") {
    const o = (
      /** @type {P5Template} */
      t
    ), l = o.sourceCodeLocation, c = l && l.startTag && Et(l.startTag), f = l && l.endTag && Et(l.endTag), d = (
      /** @type {Root} */
      Pr(e, o.content)
    );
    c && f && e.file && (d.position = { start: c.end, end: f.start }), i.content = d;
  }
  return e.schema = n, i;
}
function dn(e, t, n) {
  if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) {
    const r = of(e, n, t.sourceCodeLocation);
    r && (e.location = !0, n.position = r);
  }
}
function of(e, t, n) {
  const r = Et(n);
  if (t.type === "element") {
    const a = t.children[t.children.length - 1];
    if (r && !n.endTag && a && a.position && a.position.end && (r.end = Object.assign({}, a.position.end)), e.verbose) {
      const u = {};
      let i;
      if (n.attrs)
        for (i in n.attrs)
          mu.call(n.attrs, i) && (u[_n(e.schema, i).property] = Et(
            n.attrs[i]
          ));
      n.startTag;
      const o = Et(n.startTag), l = n.endTag ? Et(n.endTag) : void 0, c = { opening: o };
      l && (c.closing = l), c.properties = u, t.data = { position: c };
    }
  }
  return r;
}
function Et(e) {
  const t = Va({
    line: e.startLine,
    column: e.startCol,
    offset: e.startOffset
  }), n = Va({
    line: e.endLine,
    column: e.endCol,
    offset: e.endOffset
  });
  return t || n ? { start: t, end: n } : void 0;
}
function Va(e) {
  return e.line && e.column ? e : void 0;
}
const Qa = {}.hasOwnProperty;
function bu(e, t) {
  const n = t || {};
  function r(a, ...u) {
    let i = r.invalid;
    const o = r.handlers;
    if (a && Qa.call(a, e)) {
      const l = String(a[e]);
      i = Qa.call(o, l) ? o[l] : r.unknown;
    }
    if (i)
      return i.call(this, a, ...u);
  }
  return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r;
}
const lf = {}, cf = {}.hasOwnProperty, Eu = bu("type", { handlers: { root: ff, element: bf, text: mf, comment: gf, doctype: pf } });
function df(e, t) {
  const r = (t || lf).space;
  return Eu(e, r === "svg" ? et : Xt);
}
function ff(e, t) {
  const n = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return n.childNodes = Mr(e.children, n, t), St(e, n), n;
}
function hf(e, t) {
  const n = { nodeName: "#document-fragment", childNodes: [] };
  return n.childNodes = Mr(e.children, n, t), St(e, n), n;
}
function pf(e) {
  const t = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  return St(e, t), t;
}
function mf(e) {
  const t = {
    nodeName: "#text",
    value: e.value,
    parentNode: null
  };
  return St(e, t), t;
}
function gf(e) {
  const t = {
    nodeName: "#comment",
    data: e.value,
    parentNode: null
  };
  return St(e, t), t;
}
function bf(e, t) {
  const n = t;
  let r = n;
  e.type === "element" && e.tagName.toLowerCase() === "svg" && n.space === "html" && (r = et);
  const a = [];
  let u;
  if (e.properties) {
    for (u in e.properties)
      if (u !== "children" && cf.call(e.properties, u)) {
        const l = Ef(
          r,
          u,
          e.properties[u]
        );
        l && a.push(l);
      }
  }
  const i = r.space, o = {
    nodeName: e.tagName,
    tagName: e.tagName,
    attrs: a,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: ot[i],
    childNodes: [],
    parentNode: null
  };
  return o.childNodes = Mr(e.children, o, r), St(e, o), e.tagName === "template" && e.content && (o.content = hf(e.content, r)), o;
}
function Ef(e, t, n) {
  const r = _n(e, t);
  if (n === !1 || n === null || n === void 0 || typeof n == "number" && Number.isNaN(n) || !n && r.boolean)
    return;
  Array.isArray(n) && (n = r.commaSeparated ? Ri(n) : vi(n));
  const a = {
    name: r.attribute,
    value: n === !0 ? "" : String(n)
  };
  if (r.space && r.space !== "html" && r.space !== "svg") {
    const u = a.name.indexOf(":");
    u < 0 ? a.prefix = "" : (a.name = a.name.slice(u + 1), a.prefix = r.attribute.slice(0, u)), a.namespace = ot[r.space];
  }
  return a;
}
function Mr(e, t, n) {
  let r = -1;
  const a = [];
  if (e)
    for (; ++r < e.length; ) {
      const u = Eu(e[r], n);
      u.parentNode = t, a.push(u);
    }
  return a;
}
function St(e, t) {
  const n = e.position;
  n && n.start && n.end && (n.start.offset, n.end.offset, t.sourceCodeLocation = {
    startLine: n.start.line,
    startCol: n.start.column,
    startOffset: n.start.offset,
    endLine: n.end.line,
    endCol: n.end.column,
    endOffset: n.end.offset
  });
}
const Tf = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], yf = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]), le = "";
var p;
(function(e) {
  e[e.EOF = -1] = "EOF", e[e.NULL = 0] = "NULL", e[e.TABULATION = 9] = "TABULATION", e[e.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e[e.LINE_FEED = 10] = "LINE_FEED", e[e.FORM_FEED = 12] = "FORM_FEED", e[e.SPACE = 32] = "SPACE", e[e.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e[e.QUOTATION_MARK = 34] = "QUOTATION_MARK", e[e.NUMBER_SIGN = 35] = "NUMBER_SIGN", e[e.AMPERSAND = 38] = "AMPERSAND", e[e.APOSTROPHE = 39] = "APOSTROPHE", e[e.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e[e.SOLIDUS = 47] = "SOLIDUS", e[e.DIGIT_0 = 48] = "DIGIT_0", e[e.DIGIT_9 = 57] = "DIGIT_9", e[e.SEMICOLON = 59] = "SEMICOLON", e[e.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e[e.EQUALS_SIGN = 61] = "EQUALS_SIGN", e[e.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e[e.QUESTION_MARK = 63] = "QUESTION_MARK", e[e.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e[e.LATIN_CAPITAL_F = 70] = "LATIN_CAPITAL_F", e[e.LATIN_CAPITAL_X = 88] = "LATIN_CAPITAL_X", e[e.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e[e.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e[e.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e[e.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e[e.LATIN_SMALL_F = 102] = "LATIN_SMALL_F", e[e.LATIN_SMALL_X = 120] = "LATIN_SMALL_X", e[e.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z", e[e.REPLACEMENT_CHARACTER = 65533] = "REPLACEMENT_CHARACTER";
})(p = p || (p = {}));
const _e = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function Tu(e) {
  return e >= 55296 && e <= 57343;
}
function Af(e) {
  return e >= 56320 && e <= 57343;
}
function _f(e, t) {
  return (e - 55296) * 1024 + 9216 + t;
}
function yu(e) {
  return e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31 || e >= 127 && e <= 159;
}
function Au(e) {
  return e >= 64976 && e <= 65007 || yf.has(e);
}
var N;
(function(e) {
  e.controlCharacterInInputStream = "control-character-in-input-stream", e.noncharacterInInputStream = "noncharacter-in-input-stream", e.surrogateInInputStream = "surrogate-in-input-stream", e.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e.endTagWithAttributes = "end-tag-with-attributes", e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e.unexpectedNullCharacter = "unexpected-null-character", e.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e.missingEndTagName = "missing-end-tag-name", e.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e.unknownNamedCharacterReference = "unknown-named-character-reference", e.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e.eofBeforeTagName = "eof-before-tag-name", e.eofInTag = "eof-in-tag", e.missingAttributeValue = "missing-attribute-value", e.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e.cdataInHtmlContent = "cdata-in-html-content", e.incorrectlyOpenedComment = "incorrectly-opened-comment", e.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e.eofInDoctype = "eof-in-doctype", e.nestedComment = "nested-comment", e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e.eofInComment = "eof-in-comment", e.incorrectlyClosedComment = "incorrectly-closed-comment", e.eofInCdata = "eof-in-cdata", e.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e.nullCharacterReference = "null-character-reference", e.surrogateCharacterReference = "surrogate-character-reference", e.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e.controlCharacterReference = "control-character-reference", e.noncharacterCharacterReference = "noncharacter-character-reference", e.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e.missingDoctypeName = "missing-doctype-name", e.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e.duplicateAttribute = "duplicate-attribute", e.nonConformingDoctype = "non-conforming-doctype", e.missingDoctype = "missing-doctype", e.misplacedDoctype = "misplaced-doctype", e.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e.openElementsLeftAfterEof = "open-elements-left-after-eof", e.abandonedHeadElementChild = "abandoned-head-element-child", e.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e.nestedNoscriptInHead = "nested-noscript-in-head", e.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(N = N || (N = {}));
const Cf = 65536;
class xf {
  constructor(t) {
    this.handler = t, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = Cf, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(t) {
    const { line: n, col: r, offset: a } = this;
    return {
      code: t,
      startLine: n,
      endLine: n,
      startCol: r,
      endCol: r,
      startOffset: a,
      endOffset: a
    };
  }
  _err(t) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(t) {
    if (this.pos !== this.html.length - 1) {
      const n = this.html.charCodeAt(this.pos + 1);
      if (Af(n))
        return this.pos++, this._addGap(), _f(t, n);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = !0, p.EOF;
    return this._err(N.surrogateInInputStream), t;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(t, n) {
    this.html.length > 0 ? this.html += t : this.html = t, this.endOfChunkHit = !1, this.lastChunkWritten = n;
  }
  insertHtmlAtCurrentPos(t) {
    this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1), this.endOfChunkHit = !1;
  }
  startsWith(t, n) {
    if (this.pos + t.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, !1;
    if (n)
      return this.html.startsWith(t, this.pos);
    for (let r = 0; r < t.length; r++)
      if ((this.html.charCodeAt(this.pos + r) | 32) !== t.charCodeAt(r))
        return !1;
    return !0;
  }
  peek(t) {
    const n = this.pos + t;
    if (n >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, p.EOF;
    const r = this.html.charCodeAt(n);
    return r === p.CARRIAGE_RETURN ? p.LINE_FEED : r;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, p.EOF;
    let t = this.html.charCodeAt(this.pos);
    return t === p.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, p.LINE_FEED) : t === p.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, Tu(t) && (t = this._processSurrogate(t)), this.handler.onParseError === null || t > 31 && t < 127 || t === p.LINE_FEED || t === p.CARRIAGE_RETURN || t > 159 && t < 64976 || this._checkForProblematicCharacters(t), t);
  }
  _checkForProblematicCharacters(t) {
    yu(t) ? this._err(N.controlCharacterInInputStream) : Au(t) && this._err(N.noncharacterInInputStream);
  }
  retreat(t) {
    for (this.pos -= t; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = !1;
  }
}
var X;
(function(e) {
  e[e.CHARACTER = 0] = "CHARACTER", e[e.NULL_CHARACTER = 1] = "NULL_CHARACTER", e[e.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e[e.START_TAG = 3] = "START_TAG", e[e.END_TAG = 4] = "END_TAG", e[e.COMMENT = 5] = "COMMENT", e[e.DOCTYPE = 6] = "DOCTYPE", e[e.EOF = 7] = "EOF", e[e.HIBERNATION = 8] = "HIBERNATION";
})(X = X || (X = {}));
function _u(e, t) {
  for (let n = e.attrs.length - 1; n >= 0; n--)
    if (e.attrs[n].name === t)
      return e.attrs[n].value;
  return null;
}
const Ke = new Uint16Array(
  // prettier-ignore
  '<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map((e) => e.charCodeAt(0))
), kf = new Uint16Array(
  // prettier-ignore
  "aglq	\x1B\0\0p;os;t;t;uot;".split("").map((e) => e.charCodeAt(0))
);
var Vn;
const If = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]), Sf = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (Vn = String.fromCodePoint) !== null && Vn !== void 0 ? Vn : function(e) {
    let t = "";
    return e > 65535 && (e -= 65536, t += String.fromCharCode(e >>> 10 & 1023 | 55296), e = 56320 | e & 1023), t += String.fromCharCode(e), t;
  }
);
function Nf(e) {
  var t;
  return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = If.get(e)) !== null && t !== void 0 ? t : e;
}
var pe;
(function(e) {
  e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z";
})(pe || (pe = {}));
const Rf = 32;
var Ue;
(function(e) {
  e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Ue || (Ue = {}));
function hr(e) {
  return e >= pe.ZERO && e <= pe.NINE;
}
function Lf(e) {
  return e >= pe.UPPER_A && e <= pe.UPPER_F || e >= pe.LOWER_A && e <= pe.LOWER_F;
}
function Of(e) {
  return e >= pe.UPPER_A && e <= pe.UPPER_Z || e >= pe.LOWER_A && e <= pe.LOWER_Z || hr(e);
}
function wf(e) {
  return e === pe.EQUALS || Of(e);
}
var he;
(function(e) {
  e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity";
})(he || (he = {}));
var st;
(function(e) {
  e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute";
})(st || (st = {}));
class Df {
  constructor(t, n, r) {
    this.decodeTree = t, this.emitCodePoint = n, this.errors = r, this.state = he.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = st.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = he.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, n) {
    switch (this.state) {
      case he.EntityStart:
        return t.charCodeAt(n) === pe.NUM ? (this.state = he.NumericStart, this.consumed += 1, this.stateNumericStart(t, n + 1)) : (this.state = he.NamedEntity, this.stateNamedEntity(t, n));
      case he.NumericStart:
        return this.stateNumericStart(t, n);
      case he.NumericDecimal:
        return this.stateNumericDecimal(t, n);
      case he.NumericHex:
        return this.stateNumericHex(t, n);
      case he.NamedEntity:
        return this.stateNamedEntity(t, n);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, n) {
    return n >= t.length ? -1 : (t.charCodeAt(n) | Rf) === pe.LOWER_X ? (this.state = he.NumericHex, this.consumed += 1, this.stateNumericHex(t, n + 1)) : (this.state = he.NumericDecimal, this.stateNumericDecimal(t, n));
  }
  addToNumericResult(t, n, r, a) {
    if (n !== r) {
      const u = r - n;
      this.result = this.result * Math.pow(a, u) + parseInt(t.substr(n, u), a), this.consumed += u;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const a = t.charCodeAt(n);
      if (hr(a) || Lf(a))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 16), this.emitNumericEntity(a, 3);
    }
    return this.addToNumericResult(t, r, n, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, n) {
    const r = n;
    for (; n < t.length; ) {
      const a = t.charCodeAt(n);
      if (hr(a))
        n += 1;
      else
        return this.addToNumericResult(t, r, n, 10), this.emitNumericEntity(a, 2);
    }
    return this.addToNumericResult(t, r, n, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, n) {
    var r;
    if (this.consumed <= n)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === pe.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === st.Strict)
      return 0;
    return this.emitCodePoint(Nf(this.result), this.consumed), this.errors && (t !== pe.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, n) {
    const { decodeTree: r } = this;
    let a = r[this.treeIndex], u = (a & Ue.VALUE_LENGTH) >> 14;
    for (; n < t.length; n++, this.excess++) {
      const i = t.charCodeAt(n);
      if (this.treeIndex = xu(r, a, this.treeIndex + Math.max(1, u), i), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === st.Attribute && // We shouldn't have consumed any characters after the entity,
        (u === 0 || // And there should be no invalid characters.
        wf(i)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (a = r[this.treeIndex], u = (a & Ue.VALUE_LENGTH) >> 14, u !== 0) {
        if (i === pe.SEMI)
          return this.emitNamedEntityData(this.treeIndex, u, this.consumed + this.excess);
        this.decodeMode !== st.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: n, decodeTree: r } = this, a = (r[n] & Ue.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n, a, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, n, r) {
    const { decodeTree: a } = this;
    return this.emitCodePoint(n === 1 ? a[t] & ~Ue.VALUE_LENGTH : a[t + 1], r), n === 3 && this.emitCodePoint(a[t + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case he.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== st.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case he.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case he.NumericHex:
        return this.emitNumericEntity(0, 3);
      case he.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case he.EntityStart:
        return 0;
    }
  }
}
function Cu(e) {
  let t = "";
  const n = new Df(e, (r) => t += Sf(r));
  return function(a, u) {
    let i = 0, o = 0;
    for (; (o = a.indexOf("&", o)) >= 0; ) {
      t += a.slice(i, o), n.startEntity(u);
      const c = n.write(
        a,
        // Skip the "&"
        o + 1
      );
      if (c < 0) {
        i = o + n.end();
        break;
      }
      i = o + c, o = c === 0 ? i + 1 : i;
    }
    const l = t + a.slice(i);
    return t = "", l;
  };
}
function xu(e, t, n, r) {
  const a = (t & Ue.BRANCH_LENGTH) >> 7, u = t & Ue.JUMP_TABLE;
  if (a === 0)
    return u !== 0 && r === u ? n : -1;
  if (u) {
    const l = r - u;
    return l < 0 || l >= a ? -1 : e[n + l] - 1;
  }
  let i = n, o = i + a - 1;
  for (; i <= o; ) {
    const l = i + o >>> 1, c = e[l];
    if (c < r)
      i = l + 1;
    else if (c > r)
      o = l - 1;
    else
      return e[l + a];
  }
  return -1;
}
Cu(Ke);
Cu(kf);
var L;
(function(e) {
  e.HTML = "http://www.w3.org/1999/xhtml", e.MATHML = "http://www.w3.org/1998/Math/MathML", e.SVG = "http://www.w3.org/2000/svg", e.XLINK = "http://www.w3.org/1999/xlink", e.XML = "http://www.w3.org/XML/1998/namespace", e.XMLNS = "http://www.w3.org/2000/xmlns/";
})(L = L || (L = {}));
var Je;
(function(e) {
  e.TYPE = "type", e.ACTION = "action", e.ENCODING = "encoding", e.PROMPT = "prompt", e.NAME = "name", e.COLOR = "color", e.FACE = "face", e.SIZE = "size";
})(Je = Je || (Je = {}));
var Se;
(function(e) {
  e.NO_QUIRKS = "no-quirks", e.QUIRKS = "quirks", e.LIMITED_QUIRKS = "limited-quirks";
})(Se = Se || (Se = {}));
var k;
(function(e) {
  e.A = "a", e.ADDRESS = "address", e.ANNOTATION_XML = "annotation-xml", e.APPLET = "applet", e.AREA = "area", e.ARTICLE = "article", e.ASIDE = "aside", e.B = "b", e.BASE = "base", e.BASEFONT = "basefont", e.BGSOUND = "bgsound", e.BIG = "big", e.BLOCKQUOTE = "blockquote", e.BODY = "body", e.BR = "br", e.BUTTON = "button", e.CAPTION = "caption", e.CENTER = "center", e.CODE = "code", e.COL = "col", e.COLGROUP = "colgroup", e.DD = "dd", e.DESC = "desc", e.DETAILS = "details", e.DIALOG = "dialog", e.DIR = "dir", e.DIV = "div", e.DL = "dl", e.DT = "dt", e.EM = "em", e.EMBED = "embed", e.FIELDSET = "fieldset", e.FIGCAPTION = "figcaption", e.FIGURE = "figure", e.FONT = "font", e.FOOTER = "footer", e.FOREIGN_OBJECT = "foreignObject", e.FORM = "form", e.FRAME = "frame", e.FRAMESET = "frameset", e.H1 = "h1", e.H2 = "h2", e.H3 = "h3", e.H4 = "h4", e.H5 = "h5", e.H6 = "h6", e.HEAD = "head", e.HEADER = "header", e.HGROUP = "hgroup", e.HR = "hr", e.HTML = "html", e.I = "i", e.IMG = "img", e.IMAGE = "image", e.INPUT = "input", e.IFRAME = "iframe", e.KEYGEN = "keygen", e.LABEL = "label", e.LI = "li", e.LINK = "link", e.LISTING = "listing", e.MAIN = "main", e.MALIGNMARK = "malignmark", e.MARQUEE = "marquee", e.MATH = "math", e.MENU = "menu", e.META = "meta", e.MGLYPH = "mglyph", e.MI = "mi", e.MO = "mo", e.MN = "mn", e.MS = "ms", e.MTEXT = "mtext", e.NAV = "nav", e.NOBR = "nobr", e.NOFRAMES = "noframes", e.NOEMBED = "noembed", e.NOSCRIPT = "noscript", e.OBJECT = "object", e.OL = "ol", e.OPTGROUP = "optgroup", e.OPTION = "option", e.P = "p", e.PARAM = "param", e.PLAINTEXT = "plaintext", e.PRE = "pre", e.RB = "rb", e.RP = "rp", e.RT = "rt", e.RTC = "rtc", e.RUBY = "ruby", e.S = "s", e.SCRIPT = "script", e.SECTION = "section", e.SELECT = "select", e.SOURCE = "source", e.SMALL = "small", e.SPAN = "span", e.STRIKE = "strike", e.STRONG = "strong", e.STYLE = "style", e.SUB = "sub", e.SUMMARY = "summary", e.SUP = "sup", e.TABLE = "table", e.TBODY = "tbody", e.TEMPLATE = "template", e.TEXTAREA = "textarea", e.TFOOT = "tfoot", e.TD = "td", e.TH = "th", e.THEAD = "thead", e.TITLE = "title", e.TR = "tr", e.TRACK = "track", e.TT = "tt", e.U = "u", e.UL = "ul", e.SVG = "svg", e.VAR = "var", e.WBR = "wbr", e.XMP = "xmp";
})(k = k || (k = {}));
var s;
(function(e) {
  e[e.UNKNOWN = 0] = "UNKNOWN", e[e.A = 1] = "A", e[e.ADDRESS = 2] = "ADDRESS", e[e.ANNOTATION_XML = 3] = "ANNOTATION_XML", e[e.APPLET = 4] = "APPLET", e[e.AREA = 5] = "AREA", e[e.ARTICLE = 6] = "ARTICLE", e[e.ASIDE = 7] = "ASIDE", e[e.B = 8] = "B", e[e.BASE = 9] = "BASE", e[e.BASEFONT = 10] = "BASEFONT", e[e.BGSOUND = 11] = "BGSOUND", e[e.BIG = 12] = "BIG", e[e.BLOCKQUOTE = 13] = "BLOCKQUOTE", e[e.BODY = 14] = "BODY", e[e.BR = 15] = "BR", e[e.BUTTON = 16] = "BUTTON", e[e.CAPTION = 17] = "CAPTION", e[e.CENTER = 18] = "CENTER", e[e.CODE = 19] = "CODE", e[e.COL = 20] = "COL", e[e.COLGROUP = 21] = "COLGROUP", e[e.DD = 22] = "DD", e[e.DESC = 23] = "DESC", e[e.DETAILS = 24] = "DETAILS", e[e.DIALOG = 25] = "DIALOG", e[e.DIR = 26] = "DIR", e[e.DIV = 27] = "DIV", e[e.DL = 28] = "DL", e[e.DT = 29] = "DT", e[e.EM = 30] = "EM", e[e.EMBED = 31] = "EMBED", e[e.FIELDSET = 32] = "FIELDSET", e[e.FIGCAPTION = 33] = "FIGCAPTION", e[e.FIGURE = 34] = "FIGURE", e[e.FONT = 35] = "FONT", e[e.FOOTER = 36] = "FOOTER", e[e.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e[e.FORM = 38] = "FORM", e[e.FRAME = 39] = "FRAME", e[e.FRAMESET = 40] = "FRAMESET", e[e.H1 = 41] = "H1", e[e.H2 = 42] = "H2", e[e.H3 = 43] = "H3", e[e.H4 = 44] = "H4", e[e.H5 = 45] = "H5", e[e.H6 = 46] = "H6", e[e.HEAD = 47] = "HEAD", e[e.HEADER = 48] = "HEADER", e[e.HGROUP = 49] = "HGROUP", e[e.HR = 50] = "HR", e[e.HTML = 51] = "HTML", e[e.I = 52] = "I", e[e.IMG = 53] = "IMG", e[e.IMAGE = 54] = "IMAGE", e[e.INPUT = 55] = "INPUT", e[e.IFRAME = 56] = "IFRAME", e[e.KEYGEN = 57] = "KEYGEN", e[e.LABEL = 58] = "LABEL", e[e.LI = 59] = "LI", e[e.LINK = 60] = "LINK", e[e.LISTING = 61] = "LISTING", e[e.MAIN = 62] = "MAIN", e[e.MALIGNMARK = 63] = "MALIGNMARK", e[e.MARQUEE = 64] = "MARQUEE", e[e.MATH = 65] = "MATH", e[e.MENU = 66] = "MENU", e[e.META = 67] = "META", e[e.MGLYPH = 68] = "MGLYPH", e[e.MI = 69] = "MI", e[e.MO = 70] = "MO", e[e.MN = 71] = "MN", e[e.MS = 72] = "MS", e[e.MTEXT = 73] = "MTEXT", e[e.NAV = 74] = "NAV", e[e.NOBR = 75] = "NOBR", e[e.NOFRAMES = 76] = "NOFRAMES", e[e.NOEMBED = 77] = "NOEMBED", e[e.NOSCRIPT = 78] = "NOSCRIPT", e[e.OBJECT = 79] = "OBJECT", e[e.OL = 80] = "OL", e[e.OPTGROUP = 81] = "OPTGROUP", e[e.OPTION = 82] = "OPTION", e[e.P = 83] = "P", e[e.PARAM = 84] = "PARAM", e[e.PLAINTEXT = 85] = "PLAINTEXT", e[e.PRE = 86] = "PRE", e[e.RB = 87] = "RB", e[e.RP = 88] = "RP", e[e.RT = 89] = "RT", e[e.RTC = 90] = "RTC", e[e.RUBY = 91] = "RUBY", e[e.S = 92] = "S", e[e.SCRIPT = 93] = "SCRIPT", e[e.SECTION = 94] = "SECTION", e[e.SELECT = 95] = "SELECT", e[e.SOURCE = 96] = "SOURCE", e[e.SMALL = 97] = "SMALL", e[e.SPAN = 98] = "SPAN", e[e.STRIKE = 99] = "STRIKE", e[e.STRONG = 100] = "STRONG", e[e.STYLE = 101] = "STYLE", e[e.SUB = 102] = "SUB", e[e.SUMMARY = 103] = "SUMMARY", e[e.SUP = 104] = "SUP", e[e.TABLE = 105] = "TABLE", e[e.TBODY = 106] = "TBODY", e[e.TEMPLATE = 107] = "TEMPLATE", e[e.TEXTAREA = 108] = "TEXTAREA", e[e.TFOOT = 109] = "TFOOT", e[e.TD = 110] = "TD", e[e.TH = 111] = "TH", e[e.THEAD = 112] = "THEAD", e[e.TITLE = 113] = "TITLE", e[e.TR = 114] = "TR", e[e.TRACK = 115] = "TRACK", e[e.TT = 116] = "TT", e[e.U = 117] = "U", e[e.UL = 118] = "UL", e[e.SVG = 119] = "SVG", e[e.VAR = 120] = "VAR", e[e.WBR = 121] = "WBR", e[e.XMP = 122] = "XMP";
})(s = s || (s = {}));
const Pf = /* @__PURE__ */ new Map([
  [k.A, s.A],
  [k.ADDRESS, s.ADDRESS],
  [k.ANNOTATION_XML, s.ANNOTATION_XML],
  [k.APPLET, s.APPLET],
  [k.AREA, s.AREA],
  [k.ARTICLE, s.ARTICLE],
  [k.ASIDE, s.ASIDE],
  [k.B, s.B],
  [k.BASE, s.BASE],
  [k.BASEFONT, s.BASEFONT],
  [k.BGSOUND, s.BGSOUND],
  [k.BIG, s.BIG],
  [k.BLOCKQUOTE, s.BLOCKQUOTE],
  [k.BODY, s.BODY],
  [k.BR, s.BR],
  [k.BUTTON, s.BUTTON],
  [k.CAPTION, s.CAPTION],
  [k.CENTER, s.CENTER],
  [k.CODE, s.CODE],
  [k.COL, s.COL],
  [k.COLGROUP, s.COLGROUP],
  [k.DD, s.DD],
  [k.DESC, s.DESC],
  [k.DETAILS, s.DETAILS],
  [k.DIALOG, s.DIALOG],
  [k.DIR, s.DIR],
  [k.DIV, s.DIV],
  [k.DL, s.DL],
  [k.DT, s.DT],
  [k.EM, s.EM],
  [k.EMBED, s.EMBED],
  [k.FIELDSET, s.FIELDSET],
  [k.FIGCAPTION, s.FIGCAPTION],
  [k.FIGURE, s.FIGURE],
  [k.FONT, s.FONT],
  [k.FOOTER, s.FOOTER],
  [k.FOREIGN_OBJECT, s.FOREIGN_OBJECT],
  [k.FORM, s.FORM],
  [k.FRAME, s.FRAME],
  [k.FRAMESET, s.FRAMESET],
  [k.H1, s.H1],
  [k.H2, s.H2],
  [k.H3, s.H3],
  [k.H4, s.H4],
  [k.H5, s.H5],
  [k.H6, s.H6],
  [k.HEAD, s.HEAD],
  [k.HEADER, s.HEADER],
  [k.HGROUP, s.HGROUP],
  [k.HR, s.HR],
  [k.HTML, s.HTML],
  [k.I, s.I],
  [k.IMG, s.IMG],
  [k.IMAGE, s.IMAGE],
  [k.INPUT, s.INPUT],
  [k.IFRAME, s.IFRAME],
  [k.KEYGEN, s.KEYGEN],
  [k.LABEL, s.LABEL],
  [k.LI, s.LI],
  [k.LINK, s.LINK],
  [k.LISTING, s.LISTING],
  [k.MAIN, s.MAIN],
  [k.MALIGNMARK, s.MALIGNMARK],
  [k.MARQUEE, s.MARQUEE],
  [k.MATH, s.MATH],
  [k.MENU, s.MENU],
  [k.META, s.META],
  [k.MGLYPH, s.MGLYPH],
  [k.MI, s.MI],
  [k.MO, s.MO],
  [k.MN, s.MN],
  [k.MS, s.MS],
  [k.MTEXT, s.MTEXT],
  [k.NAV, s.NAV],
  [k.NOBR, s.NOBR],
  [k.NOFRAMES, s.NOFRAMES],
  [k.NOEMBED, s.NOEMBED],
  [k.NOSCRIPT, s.NOSCRIPT],
  [k.OBJECT, s.OBJECT],
  [k.OL, s.OL],
  [k.OPTGROUP, s.OPTGROUP],
  [k.OPTION, s.OPTION],
  [k.P, s.P],
  [k.PARAM, s.PARAM],
  [k.PLAINTEXT, s.PLAINTEXT],
  [k.PRE, s.PRE],
  [k.RB, s.RB],
  [k.RP, s.RP],
  [k.RT, s.RT],
  [k.RTC, s.RTC],
  [k.RUBY, s.RUBY],
  [k.S, s.S],
  [k.SCRIPT, s.SCRIPT],
  [k.SECTION, s.SECTION],
  [k.SELECT, s.SELECT],
  [k.SOURCE, s.SOURCE],
  [k.SMALL, s.SMALL],
  [k.SPAN, s.SPAN],
  [k.STRIKE, s.STRIKE],
  [k.STRONG, s.STRONG],
  [k.STYLE, s.STYLE],
  [k.SUB, s.SUB],
  [k.SUMMARY, s.SUMMARY],
  [k.SUP, s.SUP],
  [k.TABLE, s.TABLE],
  [k.TBODY, s.TBODY],
  [k.TEMPLATE, s.TEMPLATE],
  [k.TEXTAREA, s.TEXTAREA],
  [k.TFOOT, s.TFOOT],
  [k.TD, s.TD],
  [k.TH, s.TH],
  [k.THEAD, s.THEAD],
  [k.TITLE, s.TITLE],
  [k.TR, s.TR],
  [k.TRACK, s.TRACK],
  [k.TT, s.TT],
  [k.U, s.U],
  [k.UL, s.UL],
  [k.SVG, s.SVG],
  [k.VAR, s.VAR],
  [k.WBR, s.WBR],
  [k.XMP, s.XMP]
]);
function Nt(e) {
  var t;
  return (t = Pf.get(e)) !== null && t !== void 0 ? t : s.UNKNOWN;
}
const D = s, Mf = {
  [L.HTML]: /* @__PURE__ */ new Set([
    D.ADDRESS,
    D.APPLET,
    D.AREA,
    D.ARTICLE,
    D.ASIDE,
    D.BASE,
    D.BASEFONT,
    D.BGSOUND,
    D.BLOCKQUOTE,
    D.BODY,
    D.BR,
    D.BUTTON,
    D.CAPTION,
    D.CENTER,
    D.COL,
    D.COLGROUP,
    D.DD,
    D.DETAILS,
    D.DIR,
    D.DIV,
    D.DL,
    D.DT,
    D.EMBED,
    D.FIELDSET,
    D.FIGCAPTION,
    D.FIGURE,
    D.FOOTER,
    D.FORM,
    D.FRAME,
    D.FRAMESET,
    D.H1,
    D.H2,
    D.H3,
    D.H4,
    D.H5,
    D.H6,
    D.HEAD,
    D.HEADER,
    D.HGROUP,
    D.HR,
    D.HTML,
    D.IFRAME,
    D.IMG,
    D.INPUT,
    D.LI,
    D.LINK,
    D.LISTING,
    D.MAIN,
    D.MARQUEE,
    D.MENU,
    D.META,
    D.NAV,
    D.NOEMBED,
    D.NOFRAMES,
    D.NOSCRIPT,
    D.OBJECT,
    D.OL,
    D.P,
    D.PARAM,
    D.PLAINTEXT,
    D.PRE,
    D.SCRIPT,
    D.SECTION,
    D.SELECT,
    D.SOURCE,
    D.STYLE,
    D.SUMMARY,
    D.TABLE,
    D.TBODY,
    D.TD,
    D.TEMPLATE,
    D.TEXTAREA,
    D.TFOOT,
    D.TH,
    D.THEAD,
    D.TITLE,
    D.TR,
    D.TRACK,
    D.UL,
    D.WBR,
    D.XMP
  ]),
  [L.MATHML]: /* @__PURE__ */ new Set([D.MI, D.MO, D.MN, D.MS, D.MTEXT, D.ANNOTATION_XML]),
  [L.SVG]: /* @__PURE__ */ new Set([D.TITLE, D.FOREIGN_OBJECT, D.DESC]),
  [L.XLINK]: /* @__PURE__ */ new Set(),
  [L.XML]: /* @__PURE__ */ new Set(),
  [L.XMLNS]: /* @__PURE__ */ new Set()
};
function ku(e) {
  return e === D.H1 || e === D.H2 || e === D.H3 || e === D.H4 || e === D.H5 || e === D.H6;
}
k.STYLE, k.SCRIPT, k.XMP, k.IFRAME, k.NOEMBED, k.NOFRAMES, k.PLAINTEXT;
const Ff = /* @__PURE__ */ new Map([
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var g;
(function(e) {
  e[e.DATA = 0] = "DATA", e[e.RCDATA = 1] = "RCDATA", e[e.RAWTEXT = 2] = "RAWTEXT", e[e.SCRIPT_DATA = 3] = "SCRIPT_DATA", e[e.PLAINTEXT = 4] = "PLAINTEXT", e[e.TAG_OPEN = 5] = "TAG_OPEN", e[e.END_TAG_OPEN = 6] = "END_TAG_OPEN", e[e.TAG_NAME = 7] = "TAG_NAME", e[e.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e[e.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e[e.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e[e.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e[e.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e[e.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e[e.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e[e.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e[e.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e[e.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e[e.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e[e.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e[e.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e[e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e[e.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e[e.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e[e.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e[e.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e[e.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e[e.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e[e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e[e.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e[e.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e[e.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e[e.COMMENT_START = 42] = "COMMENT_START", e[e.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e[e.COMMENT = 44] = "COMMENT", e[e.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e[e.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e[e.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e[e.COMMENT_END = 50] = "COMMENT_END", e[e.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e[e.DOCTYPE = 52] = "DOCTYPE", e[e.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e[e.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e[e.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e[e.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e[e.CDATA_SECTION = 68] = "CDATA_SECTION", e[e.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e[e.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e[e.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e[e.NAMED_CHARACTER_REFERENCE = 72] = "NAMED_CHARACTER_REFERENCE", e[e.AMBIGUOUS_AMPERSAND = 73] = "AMBIGUOUS_AMPERSAND", e[e.NUMERIC_CHARACTER_REFERENCE = 74] = "NUMERIC_CHARACTER_REFERENCE", e[e.HEXADEMICAL_CHARACTER_REFERENCE_START = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START", e[e.HEXADEMICAL_CHARACTER_REFERENCE = 76] = "HEXADEMICAL_CHARACTER_REFERENCE", e[e.DECIMAL_CHARACTER_REFERENCE = 77] = "DECIMAL_CHARACTER_REFERENCE", e[e.NUMERIC_CHARACTER_REFERENCE_END = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
})(g || (g = {}));
const de = {
  DATA: g.DATA,
  RCDATA: g.RCDATA,
  RAWTEXT: g.RAWTEXT,
  SCRIPT_DATA: g.SCRIPT_DATA,
  PLAINTEXT: g.PLAINTEXT,
  CDATA_SECTION: g.CDATA_SECTION
};
function Ut(e) {
  return e >= p.DIGIT_0 && e <= p.DIGIT_9;
}
function Bt(e) {
  return e >= p.LATIN_CAPITAL_A && e <= p.LATIN_CAPITAL_Z;
}
function Bf(e) {
  return e >= p.LATIN_SMALL_A && e <= p.LATIN_SMALL_Z;
}
function Ze(e) {
  return Bf(e) || Bt(e);
}
function pr(e) {
  return Ze(e) || Ut(e);
}
function Iu(e) {
  return e >= p.LATIN_CAPITAL_A && e <= p.LATIN_CAPITAL_F;
}
function Su(e) {
  return e >= p.LATIN_SMALL_A && e <= p.LATIN_SMALL_F;
}
function vf(e) {
  return Ut(e) || Iu(e) || Su(e);
}
function un(e) {
  return e + 32;
}
function Nu(e) {
  return e === p.SPACE || e === p.LINE_FEED || e === p.TABULATION || e === p.FORM_FEED;
}
function Hf(e) {
  return e === p.EQUALS_SIGN || pr(e);
}
function Xa(e) {
  return Nu(e) || e === p.SOLIDUS || e === p.GREATER_THAN_SIGN;
}
class Uf {
  constructor(t, n) {
    this.options = t, this.handler = n, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = g.DATA, this.returnState = g.DATA, this.charRefCode = -1, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new xf(n), this.currentLocation = this.getCurrentLocation(-1);
  }
  //Errors
  _err(t) {
    var n, r;
    (r = (n = this.handler).onParseError) === null || r === void 0 || r.call(n, this.preprocessor.getError(t));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(t) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - t,
      startOffset: this.preprocessor.offset - t,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = !0; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const t = this._consume();
        this._ensureHibernation() || this._callState(t);
      }
      this.inLoop = !1;
    }
  }
  //API
  pause() {
    this.paused = !0;
  }
  resume(t) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || t == null || t());
  }
  write(t, n, r) {
    this.active = !0, this.preprocessor.write(t, n), this._runParsingLoop(), this.paused || r == null || r();
  }
  insertHtmlAtCurrentPos(t) {
    this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this._unconsume(this.consumedAfterSnapshot), this.active = !1, !0) : !1;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _unconsume(t) {
    this.consumedAfterSnapshot -= t, this.preprocessor.retreat(t);
  }
  _reconsumeInState(t, n) {
    this.state = t, this._callState(n);
  }
  _advanceBy(t) {
    this.consumedAfterSnapshot += t;
    for (let n = 0; n < t; n++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(t, n) {
    return this.preprocessor.startsWith(t, n) ? (this._advanceBy(t.length - 1), !0) : !1;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: X.START_TAG,
      tagName: "",
      tagID: s.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: X.END_TAG,
      tagName: "",
      tagID: s.UNKNOWN,
      selfClosing: !1,
      ackSelfClosing: !1,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(t) {
    this.currentToken = {
      type: X.COMMENT,
      data: "",
      location: this.getCurrentLocation(t)
    };
  }
  _createDoctypeToken(t) {
    this.currentToken = {
      type: X.DOCTYPE,
      name: t,
      forceQuirks: !1,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(t, n) {
    this.currentCharacterToken = {
      type: t,
      chars: n,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(t) {
    this.currentAttr = {
      name: t,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var t, n;
    const r = this.currentToken;
    if (_u(r, this.currentAttr.name) === null) {
      if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) {
        const a = (t = (n = r.location).attrs) !== null && t !== void 0 ? t : n.attrs = /* @__PURE__ */ Object.create(null);
        a[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(N.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(t) {
    this._emitCurrentCharacterToken(t.location), this.currentToken = null, t.location && (t.location.endLine = this.preprocessor.line, t.location.endCol = this.preprocessor.col + 1, t.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const t = this.currentToken;
    this.prepareToken(t), t.tagID = Nt(t.tagName), t.type === X.START_TAG ? (this.lastStartTagName = t.tagName, this.handler.onStartTag(t)) : (t.attrs.length > 0 && this._err(N.endTagWithAttributes), t.selfClosing && this._err(N.endTagWithTrailingSolidus), this.handler.onEndTag(t)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(t) {
    this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(t) {
    this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(t) {
    if (this.currentCharacterToken) {
      switch (t && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t.startLine, this.currentCharacterToken.location.endCol = t.startCol, this.currentCharacterToken.location.endOffset = t.startOffset), this.currentCharacterToken.type) {
        case X.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case X.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case X.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const t = this.getCurrentLocation(0);
    t && (t.endLine = t.startLine, t.endCol = t.startCol, t.endOffset = t.startOffset), this._emitCurrentCharacterToken(t), this.handler.onEof({ type: X.EOF, location: t }), this.active = !1;
  }
  //Characters emission
  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(t, n) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type !== t)
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
      else {
        this.currentCharacterToken.chars += n;
        return;
      }
    this._createCharacterToken(t, n);
  }
  _emitCodePoint(t) {
    const n = Nu(t) ? X.WHITESPACE_CHARACTER : t === p.NULL ? X.NULL_CHARACTER : X.CHARACTER;
    this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(t));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(t) {
    this._appendCharToCurrentCharacterToken(X.CHARACTER, t);
  }
  // Character reference helpers
  _matchNamedCharacterReference(t) {
    let n = null, r = 0, a = !1;
    for (let u = 0, i = Ke[0]; u >= 0 && (u = xu(Ke, i, u + 1, t), !(u < 0)); t = this._consume()) {
      r += 1, i = Ke[u];
      const o = i & Ue.VALUE_LENGTH;
      if (o) {
        const l = (o >> 14) - 1;
        if (t !== p.SEMICOLON && this._isCharacterReferenceInAttribute() && Hf(this.preprocessor.peek(1)) ? (n = [p.AMPERSAND], u += l) : (n = l === 0 ? [Ke[u] & ~Ue.VALUE_LENGTH] : l === 1 ? [Ke[++u]] : [Ke[++u], Ke[++u]], r = 0, a = t !== p.SEMICOLON), l === 0) {
          this._consume();
          break;
        }
      }
    }
    return this._unconsume(r), a && !this.preprocessor.endOfChunkHit && this._err(N.missingSemicolonAfterCharacterReference), this._unconsume(1), n;
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === g.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === g.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === g.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(t) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t) : this._emitCodePoint(t);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(t) {
    switch (this.state) {
      case g.DATA: {
        this._stateData(t);
        break;
      }
      case g.RCDATA: {
        this._stateRcdata(t);
        break;
      }
      case g.RAWTEXT: {
        this._stateRawtext(t);
        break;
      }
      case g.SCRIPT_DATA: {
        this._stateScriptData(t);
        break;
      }
      case g.PLAINTEXT: {
        this._statePlaintext(t);
        break;
      }
      case g.TAG_OPEN: {
        this._stateTagOpen(t);
        break;
      }
      case g.END_TAG_OPEN: {
        this._stateEndTagOpen(t);
        break;
      }
      case g.TAG_NAME: {
        this._stateTagName(t);
        break;
      }
      case g.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(t);
        break;
      }
      case g.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(t);
        break;
      }
      case g.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(t);
        break;
      }
      case g.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(t);
        break;
      }
      case g.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(t);
        break;
      }
      case g.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(t);
        break;
      }
      case g.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(t);
        break;
      }
      case g.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(t);
        break;
      }
      case g.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(t);
        break;
      }
      case g.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(t);
        break;
      }
      case g.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(t);
        break;
      }
      case g.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(t);
        break;
      }
      case g.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(t);
        break;
      }
      case g.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(t);
        break;
      }
      case g.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(t);
        break;
      }
      case g.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(t);
        break;
      }
      case g.ATTRIBUTE_NAME: {
        this._stateAttributeName(t);
        break;
      }
      case g.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(t);
        break;
      }
      case g.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(t);
        break;
      }
      case g.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(t);
        break;
      }
      case g.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(t);
        break;
      }
      case g.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(t);
        break;
      }
      case g.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(t);
        break;
      }
      case g.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(t);
        break;
      }
      case g.BOGUS_COMMENT: {
        this._stateBogusComment(t);
        break;
      }
      case g.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(t);
        break;
      }
      case g.COMMENT_START: {
        this._stateCommentStart(t);
        break;
      }
      case g.COMMENT_START_DASH: {
        this._stateCommentStartDash(t);
        break;
      }
      case g.COMMENT: {
        this._stateComment(t);
        break;
      }
      case g.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(t);
        break;
      }
      case g.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(t);
        break;
      }
      case g.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(t);
        break;
      }
      case g.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(t);
        break;
      }
      case g.COMMENT_END_DASH: {
        this._stateCommentEndDash(t);
        break;
      }
      case g.COMMENT_END: {
        this._stateCommentEnd(t);
        break;
      }
      case g.COMMENT_END_BANG: {
        this._stateCommentEndBang(t);
        break;
      }
      case g.DOCTYPE: {
        this._stateDoctype(t);
        break;
      }
      case g.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(t);
        break;
      }
      case g.DOCTYPE_NAME: {
        this._stateDoctypeName(t);
        break;
      }
      case g.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(t);
        break;
      }
      case g.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(t);
        break;
      }
      case g.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(t);
        break;
      }
      case g.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(t);
        break;
      }
      case g.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(t);
        break;
      }
      case g.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(t);
        break;
      }
      case g.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(t);
        break;
      }
      case g.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(t);
        break;
      }
      case g.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(t);
        break;
      }
      case g.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(t);
        break;
      }
      case g.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(t);
        break;
      }
      case g.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(t);
        break;
      }
      case g.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(t);
        break;
      }
      case g.CDATA_SECTION: {
        this._stateCdataSection(t);
        break;
      }
      case g.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(t);
        break;
      }
      case g.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(t);
        break;
      }
      case g.CHARACTER_REFERENCE: {
        this._stateCharacterReference(t);
        break;
      }
      case g.NAMED_CHARACTER_REFERENCE: {
        this._stateNamedCharacterReference(t);
        break;
      }
      case g.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(t);
        break;
      }
      case g.NUMERIC_CHARACTER_REFERENCE: {
        this._stateNumericCharacterReference(t);
        break;
      }
      case g.HEXADEMICAL_CHARACTER_REFERENCE_START: {
        this._stateHexademicalCharacterReferenceStart(t);
        break;
      }
      case g.HEXADEMICAL_CHARACTER_REFERENCE: {
        this._stateHexademicalCharacterReference(t);
        break;
      }
      case g.DECIMAL_CHARACTER_REFERENCE: {
        this._stateDecimalCharacterReference(t);
        break;
      }
      case g.NUMERIC_CHARACTER_REFERENCE_END: {
        this._stateNumericCharacterReferenceEnd(t);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(t) {
    switch (t) {
      case p.LESS_THAN_SIGN: {
        this.state = g.TAG_OPEN;
        break;
      }
      case p.AMPERSAND: {
        this.returnState = g.DATA, this.state = g.CHARACTER_REFERENCE;
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), this._emitCodePoint(t);
        break;
      }
      case p.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(t) {
    switch (t) {
      case p.AMPERSAND: {
        this.returnState = g.RCDATA, this.state = g.CHARACTER_REFERENCE;
        break;
      }
      case p.LESS_THAN_SIGN: {
        this.state = g.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), this._emitChars(le);
        break;
      }
      case p.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(t) {
    switch (t) {
      case p.LESS_THAN_SIGN: {
        this.state = g.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), this._emitChars(le);
        break;
      }
      case p.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(t) {
    switch (t) {
      case p.LESS_THAN_SIGN: {
        this.state = g.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), this._emitChars(le);
        break;
      }
      case p.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(t) {
    switch (t) {
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), this._emitChars(le);
        break;
      }
      case p.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(t) {
    if (Ze(t))
      this._createStartTagToken(), this.state = g.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case p.EXCLAMATION_MARK: {
          this.state = g.MARKUP_DECLARATION_OPEN;
          break;
        }
        case p.SOLIDUS: {
          this.state = g.END_TAG_OPEN;
          break;
        }
        case p.QUESTION_MARK: {
          this._err(N.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = g.BOGUS_COMMENT, this._stateBogusComment(t);
          break;
        }
        case p.EOF: {
          this._err(N.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(N.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = g.DATA, this._stateData(t);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(t) {
    if (Ze(t))
      this._createEndTagToken(), this.state = g.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case p.GREATER_THAN_SIGN: {
          this._err(N.missingEndTagName), this.state = g.DATA;
          break;
        }
        case p.EOF: {
          this._err(N.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(N.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = g.BOGUS_COMMENT, this._stateBogusComment(t);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this.state = g.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case p.SOLIDUS: {
        this.state = g.SELF_CLOSING_START_TAG;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this.state = g.DATA, this.emitCurrentTagToken();
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), n.tagName += le;
        break;
      }
      case p.EOF: {
        this._err(N.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        n.tagName += String.fromCodePoint(Bt(t) ? un(t) : t);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(t) {
    t === p.SOLIDUS ? this.state = g.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = g.RCDATA, this._stateRcdata(t));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(t) {
    Ze(t) ? (this.state = g.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t)) : (this._emitChars("</"), this.state = g.RCDATA, this._stateRcdata(t));
  }
  handleSpecialEndTag(t) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, !1))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const n = this.currentToken;
    switch (n.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = g.BEFORE_ATTRIBUTE_NAME, !1;
      case p.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = g.SELF_CLOSING_START_TAG, !1;
      case p.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = g.DATA, !1;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = g.RCDATA, this._stateRcdata(t));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(t) {
    t === p.SOLIDUS ? this.state = g.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = g.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(t) {
    Ze(t) ? (this.state = g.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t)) : (this._emitChars("</"), this.state = g.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = g.RAWTEXT, this._stateRawtext(t));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(t) {
    switch (t) {
      case p.SOLIDUS: {
        this.state = g.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case p.EXCLAMATION_MARK: {
        this.state = g.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = g.SCRIPT_DATA, this._stateScriptData(t);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(t) {
    Ze(t) ? (this.state = g.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t)) : (this._emitChars("</"), this.state = g.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = g.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(t) {
    t === p.HYPHEN_MINUS ? (this.state = g.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = g.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(t) {
    t === p.HYPHEN_MINUS ? (this.state = g.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = g.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(t) {
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = g.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case p.LESS_THAN_SIGN: {
        this.state = g.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), this._emitChars(le);
        break;
      }
      case p.EOF: {
        this._err(N.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(t) {
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = g.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case p.LESS_THAN_SIGN: {
        this.state = g.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), this.state = g.SCRIPT_DATA_ESCAPED, this._emitChars(le);
        break;
      }
      case p.EOF: {
        this._err(N.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = g.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(t) {
    switch (t) {
      case p.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case p.LESS_THAN_SIGN: {
        this.state = g.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this.state = g.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), this.state = g.SCRIPT_DATA_ESCAPED, this._emitChars(le);
        break;
      }
      case p.EOF: {
        this._err(N.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = g.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(t) {
    t === p.SOLIDUS ? this.state = g.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : Ze(t) ? (this._emitChars("<"), this.state = g.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t)) : (this._emitChars("<"), this.state = g.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(t) {
    Ze(t) ? (this.state = g.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t)) : (this._emitChars("</"), this.state = g.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = g.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(t) {
    if (this.preprocessor.startsWith(_e.SCRIPT, !1) && Xa(this.preprocessor.peek(_e.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < _e.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = g.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(t) {
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case p.LESS_THAN_SIGN: {
        this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), this._emitChars(le);
        break;
      }
      case p.EOF: {
        this._err(N.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(t) {
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case p.LESS_THAN_SIGN: {
        this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(le);
        break;
      }
      case p.EOF: {
        this._err(N.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(t) {
    switch (t) {
      case p.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case p.LESS_THAN_SIGN: {
        this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this.state = g.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(le);
        break;
      }
      case p.EOF: {
        this._err(N.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(t) {
    t === p.SOLIDUS ? (this.state = g.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(t) {
    if (this.preprocessor.startsWith(_e.SCRIPT, !1) && Xa(this.preprocessor.peek(_e.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n = 0; n < _e.SCRIPT.length; n++)
        this._emitCodePoint(this._consume());
      this.state = g.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(t) {
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.SOLIDUS:
      case p.GREATER_THAN_SIGN:
      case p.EOF: {
        this.state = g.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case p.EQUALS_SIGN: {
        this._err(N.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = g.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = g.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(t) {
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
      case p.SOLIDUS:
      case p.GREATER_THAN_SIGN:
      case p.EOF: {
        this._leaveAttrName(), this.state = g.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case p.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = g.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case p.QUOTATION_MARK:
      case p.APOSTROPHE:
      case p.LESS_THAN_SIGN: {
        this._err(N.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t);
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), this.currentAttr.name += le;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(Bt(t) ? un(t) : t);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(t) {
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.SOLIDUS: {
        this.state = g.SELF_CLOSING_START_TAG;
        break;
      }
      case p.EQUALS_SIGN: {
        this.state = g.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this.state = g.DATA, this.emitCurrentTagToken();
        break;
      }
      case p.EOF: {
        this._err(N.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = g.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(t) {
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.QUOTATION_MARK: {
        this.state = g.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case p.APOSTROPHE: {
        this.state = g.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(N.missingAttributeValue), this.state = g.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = g.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(t) {
    switch (t) {
      case p.QUOTATION_MARK: {
        this.state = g.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case p.AMPERSAND: {
        this.returnState = g.ATTRIBUTE_VALUE_DOUBLE_QUOTED, this.state = g.CHARACTER_REFERENCE;
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), this.currentAttr.value += le;
        break;
      }
      case p.EOF: {
        this._err(N.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(t) {
    switch (t) {
      case p.APOSTROPHE: {
        this.state = g.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case p.AMPERSAND: {
        this.returnState = g.ATTRIBUTE_VALUE_SINGLE_QUOTED, this.state = g.CHARACTER_REFERENCE;
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), this.currentAttr.value += le;
        break;
      }
      case p.EOF: {
        this._err(N.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(t) {
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this._leaveAttrValue(), this.state = g.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case p.AMPERSAND: {
        this.returnState = g.ATTRIBUTE_VALUE_UNQUOTED, this.state = g.CHARACTER_REFERENCE;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = g.DATA, this.emitCurrentTagToken();
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), this.currentAttr.value += le;
        break;
      }
      case p.QUOTATION_MARK:
      case p.APOSTROPHE:
      case p.LESS_THAN_SIGN:
      case p.EQUALS_SIGN:
      case p.GRAVE_ACCENT: {
        this._err(N.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t);
        break;
      }
      case p.EOF: {
        this._err(N.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(t) {
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this._leaveAttrValue(), this.state = g.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case p.SOLIDUS: {
        this._leaveAttrValue(), this.state = g.SELF_CLOSING_START_TAG;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = g.DATA, this.emitCurrentTagToken();
        break;
      }
      case p.EOF: {
        this._err(N.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingWhitespaceBetweenAttributes), this.state = g.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(t) {
    switch (t) {
      case p.GREATER_THAN_SIGN: {
        const n = this.currentToken;
        n.selfClosing = !0, this.state = g.DATA, this.emitCurrentTagToken();
        break;
      }
      case p.EOF: {
        this._err(N.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.unexpectedSolidusInTag), this.state = g.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(t) {
    const n = this.currentToken;
    switch (t) {
      case p.GREATER_THAN_SIGN: {
        this.state = g.DATA, this.emitCurrentComment(n);
        break;
      }
      case p.EOF: {
        this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), n.data += le;
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(t) {
    this._consumeSequenceIfMatch(_e.DASH_DASH, !0) ? (this._createCommentToken(_e.DASH_DASH.length + 1), this.state = g.COMMENT_START) : this._consumeSequenceIfMatch(_e.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(_e.DOCTYPE.length + 1), this.state = g.DOCTYPE) : this._consumeSequenceIfMatch(_e.CDATA_START, !0) ? this.inForeignNode ? this.state = g.CDATA_SECTION : (this._err(N.cdataInHtmlContent), this._createCommentToken(_e.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = g.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(N.incorrectlyOpenedComment), this._createCommentToken(2), this.state = g.BOGUS_COMMENT, this._stateBogusComment(t));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(t) {
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = g.COMMENT_START_DASH;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(N.abruptClosingOfEmptyComment), this.state = g.DATA;
        const n = this.currentToken;
        this.emitCurrentComment(n);
        break;
      }
      default:
        this.state = g.COMMENT, this._stateComment(t);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(t) {
    const n = this.currentToken;
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = g.COMMENT_END;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(N.abruptClosingOfEmptyComment), this.state = g.DATA, this.emitCurrentComment(n);
        break;
      }
      case p.EOF: {
        this._err(N.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = g.COMMENT, this._stateComment(t);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(t) {
    const n = this.currentToken;
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = g.COMMENT_END_DASH;
        break;
      }
      case p.LESS_THAN_SIGN: {
        n.data += "<", this.state = g.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), n.data += le;
        break;
      }
      case p.EOF: {
        this._err(N.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += String.fromCodePoint(t);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(t) {
    const n = this.currentToken;
    switch (t) {
      case p.EXCLAMATION_MARK: {
        n.data += "!", this.state = g.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case p.LESS_THAN_SIGN: {
        n.data += "<";
        break;
      }
      default:
        this.state = g.COMMENT, this._stateComment(t);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(t) {
    t === p.HYPHEN_MINUS ? this.state = g.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = g.COMMENT, this._stateComment(t));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(t) {
    t === p.HYPHEN_MINUS ? this.state = g.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = g.COMMENT_END_DASH, this._stateCommentEndDash(t));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(t) {
    t !== p.GREATER_THAN_SIGN && t !== p.EOF && this._err(N.nestedComment), this.state = g.COMMENT_END, this._stateCommentEnd(t);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(t) {
    const n = this.currentToken;
    switch (t) {
      case p.HYPHEN_MINUS: {
        this.state = g.COMMENT_END;
        break;
      }
      case p.EOF: {
        this._err(N.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "-", this.state = g.COMMENT, this._stateComment(t);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(t) {
    const n = this.currentToken;
    switch (t) {
      case p.GREATER_THAN_SIGN: {
        this.state = g.DATA, this.emitCurrentComment(n);
        break;
      }
      case p.EXCLAMATION_MARK: {
        this.state = g.COMMENT_END_BANG;
        break;
      }
      case p.HYPHEN_MINUS: {
        n.data += "-";
        break;
      }
      case p.EOF: {
        this._err(N.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--", this.state = g.COMMENT, this._stateComment(t);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(t) {
    const n = this.currentToken;
    switch (t) {
      case p.HYPHEN_MINUS: {
        n.data += "--!", this.state = g.COMMENT_END_DASH;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(N.incorrectlyClosedComment), this.state = g.DATA, this.emitCurrentComment(n);
        break;
      }
      case p.EOF: {
        this._err(N.eofInComment), this.emitCurrentComment(n), this._emitEOFToken();
        break;
      }
      default:
        n.data += "--!", this.state = g.COMMENT, this._stateComment(t);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(t) {
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this.state = g.BEFORE_DOCTYPE_NAME;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this.state = g.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
        break;
      }
      case p.EOF: {
        this._err(N.eofInDoctype), this._createDoctypeToken(null);
        const n = this.currentToken;
        n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingWhitespaceBeforeDoctypeName), this.state = g.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(t) {
    if (Bt(t))
      this._createDoctypeToken(String.fromCharCode(un(t))), this.state = g.DOCTYPE_NAME;
    else
      switch (t) {
        case p.SPACE:
        case p.LINE_FEED:
        case p.TABULATION:
        case p.FORM_FEED:
          break;
        case p.NULL: {
          this._err(N.unexpectedNullCharacter), this._createDoctypeToken(le), this.state = g.DOCTYPE_NAME;
          break;
        }
        case p.GREATER_THAN_SIGN: {
          this._err(N.missingDoctypeName), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = g.DATA;
          break;
        }
        case p.EOF: {
          this._err(N.eofInDoctype), this._createDoctypeToken(null);
          const n = this.currentToken;
          n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(t)), this.state = g.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this.state = g.AFTER_DOCTYPE_NAME;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this.state = g.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), n.name += le;
        break;
      }
      case p.EOF: {
        this._err(N.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.name += String.fromCodePoint(Bt(t) ? un(t) : t);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.GREATER_THAN_SIGN: {
        this.state = g.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case p.EOF: {
        this._err(N.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(_e.PUBLIC, !1) ? this.state = g.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(_e.SYSTEM, !1) ? this.state = g.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(N.invalidCharacterSequenceAfterDoctypeName), n.forceQuirks = !0, this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this.state = g.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case p.QUOTATION_MARK: {
        this._err(N.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = g.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p.APOSTROPHE: {
        this._err(N.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = g.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(N.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = g.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case p.EOF: {
        this._err(N.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.QUOTATION_MARK: {
        n.publicId = "", this.state = g.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p.APOSTROPHE: {
        n.publicId = "", this.state = g.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(N.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = g.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case p.EOF: {
        this._err(N.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case p.QUOTATION_MARK: {
        this.state = g.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), n.publicId += le;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(N.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = g.DATA;
        break;
      }
      case p.EOF: {
        this._err(N.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case p.APOSTROPHE: {
        this.state = g.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), n.publicId += le;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(N.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = g.DATA;
        break;
      }
      case p.EOF: {
        this._err(N.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.publicId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this.state = g.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this.state = g.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case p.QUOTATION_MARK: {
        this._err(N.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p.APOSTROPHE: {
        this._err(N.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p.EOF: {
        this._err(N.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = g.DATA;
        break;
      }
      case p.QUOTATION_MARK: {
        n.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p.APOSTROPHE: {
        n.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p.EOF: {
        this._err(N.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED: {
        this.state = g.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case p.QUOTATION_MARK: {
        this._err(N.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p.APOSTROPHE: {
        this._err(N.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(N.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = g.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case p.EOF: {
        this._err(N.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.QUOTATION_MARK: {
        n.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p.APOSTROPHE: {
        n.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(N.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = g.DATA, this.emitCurrentDoctype(n);
        break;
      }
      case p.EOF: {
        this._err(N.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case p.QUOTATION_MARK: {
        this.state = g.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), n.systemId += le;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(N.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = g.DATA;
        break;
      }
      case p.EOF: {
        this._err(N.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(t) {
    const n = this.currentToken;
    switch (t) {
      case p.APOSTROPHE: {
        this.state = g.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter), n.systemId += le;
        break;
      }
      case p.GREATER_THAN_SIGN: {
        this._err(N.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = g.DATA;
        break;
      }
      case p.EOF: {
        this._err(N.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        n.systemId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(t) {
    const n = this.currentToken;
    switch (t) {
      case p.SPACE:
      case p.LINE_FEED:
      case p.TABULATION:
      case p.FORM_FEED:
        break;
      case p.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = g.DATA;
        break;
      }
      case p.EOF: {
        this._err(N.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(t) {
    const n = this.currentToken;
    switch (t) {
      case p.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n), this.state = g.DATA;
        break;
      }
      case p.NULL: {
        this._err(N.unexpectedNullCharacter);
        break;
      }
      case p.EOF: {
        this.emitCurrentDoctype(n), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(t) {
    switch (t) {
      case p.RIGHT_SQUARE_BRACKET: {
        this.state = g.CDATA_SECTION_BRACKET;
        break;
      }
      case p.EOF: {
        this._err(N.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(t) {
    t === p.RIGHT_SQUARE_BRACKET ? this.state = g.CDATA_SECTION_END : (this._emitChars("]"), this.state = g.CDATA_SECTION, this._stateCdataSection(t));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(t) {
    switch (t) {
      case p.GREATER_THAN_SIGN: {
        this.state = g.DATA;
        break;
      }
      case p.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = g.CDATA_SECTION, this._stateCdataSection(t);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference(t) {
    t === p.NUMBER_SIGN ? this.state = g.NUMERIC_CHARACTER_REFERENCE : pr(t) ? (this.state = g.NAMED_CHARACTER_REFERENCE, this._stateNamedCharacterReference(t)) : (this._flushCodePointConsumedAsCharacterReference(p.AMPERSAND), this._reconsumeInState(this.returnState, t));
  }
  // Named character reference state
  //------------------------------------------------------------------
  _stateNamedCharacterReference(t) {
    const n = this._matchNamedCharacterReference(t);
    if (!this._ensureHibernation()) if (n) {
      for (let r = 0; r < n.length; r++)
        this._flushCodePointConsumedAsCharacterReference(n[r]);
      this.state = this.returnState;
    } else
      this._flushCodePointConsumedAsCharacterReference(p.AMPERSAND), this.state = g.AMBIGUOUS_AMPERSAND;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(t) {
    pr(t) ? this._flushCodePointConsumedAsCharacterReference(t) : (t === p.SEMICOLON && this._err(N.unknownNamedCharacterReference), this._reconsumeInState(this.returnState, t));
  }
  // Numeric character reference state
  //------------------------------------------------------------------
  _stateNumericCharacterReference(t) {
    this.charRefCode = 0, t === p.LATIN_SMALL_X || t === p.LATIN_CAPITAL_X ? this.state = g.HEXADEMICAL_CHARACTER_REFERENCE_START : Ut(t) ? (this.state = g.DECIMAL_CHARACTER_REFERENCE, this._stateDecimalCharacterReference(t)) : (this._err(N.absenceOfDigitsInNumericCharacterReference), this._flushCodePointConsumedAsCharacterReference(p.AMPERSAND), this._flushCodePointConsumedAsCharacterReference(p.NUMBER_SIGN), this._reconsumeInState(this.returnState, t));
  }
  // Hexademical character reference start state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReferenceStart(t) {
    vf(t) ? (this.state = g.HEXADEMICAL_CHARACTER_REFERENCE, this._stateHexademicalCharacterReference(t)) : (this._err(N.absenceOfDigitsInNumericCharacterReference), this._flushCodePointConsumedAsCharacterReference(p.AMPERSAND), this._flushCodePointConsumedAsCharacterReference(p.NUMBER_SIGN), this._unconsume(2), this.state = this.returnState);
  }
  // Hexademical character reference state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReference(t) {
    Iu(t) ? this.charRefCode = this.charRefCode * 16 + t - 55 : Su(t) ? this.charRefCode = this.charRefCode * 16 + t - 87 : Ut(t) ? this.charRefCode = this.charRefCode * 16 + t - 48 : t === p.SEMICOLON ? this.state = g.NUMERIC_CHARACTER_REFERENCE_END : (this._err(N.missingSemicolonAfterCharacterReference), this.state = g.NUMERIC_CHARACTER_REFERENCE_END, this._stateNumericCharacterReferenceEnd(t));
  }
  // Decimal character reference state
  //------------------------------------------------------------------
  _stateDecimalCharacterReference(t) {
    Ut(t) ? this.charRefCode = this.charRefCode * 10 + t - 48 : t === p.SEMICOLON ? this.state = g.NUMERIC_CHARACTER_REFERENCE_END : (this._err(N.missingSemicolonAfterCharacterReference), this.state = g.NUMERIC_CHARACTER_REFERENCE_END, this._stateNumericCharacterReferenceEnd(t));
  }
  // Numeric character reference end state
  //------------------------------------------------------------------
  _stateNumericCharacterReferenceEnd(t) {
    if (this.charRefCode === p.NULL)
      this._err(N.nullCharacterReference), this.charRefCode = p.REPLACEMENT_CHARACTER;
    else if (this.charRefCode > 1114111)
      this._err(N.characterReferenceOutsideUnicodeRange), this.charRefCode = p.REPLACEMENT_CHARACTER;
    else if (Tu(this.charRefCode))
      this._err(N.surrogateCharacterReference), this.charRefCode = p.REPLACEMENT_CHARACTER;
    else if (Au(this.charRefCode))
      this._err(N.noncharacterCharacterReference);
    else if (yu(this.charRefCode) || this.charRefCode === p.CARRIAGE_RETURN) {
      this._err(N.controlCharacterReference);
      const n = Ff.get(this.charRefCode);
      n !== void 0 && (this.charRefCode = n);
    }
    this._flushCodePointConsumedAsCharacterReference(this.charRefCode), this._reconsumeInState(this.returnState, t);
  }
}
const Ru = /* @__PURE__ */ new Set([s.DD, s.DT, s.LI, s.OPTGROUP, s.OPTION, s.P, s.RB, s.RP, s.RT, s.RTC]), Ka = /* @__PURE__ */ new Set([
  ...Ru,
  s.CAPTION,
  s.COLGROUP,
  s.TBODY,
  s.TD,
  s.TFOOT,
  s.TH,
  s.THEAD,
  s.TR
]), sn = /* @__PURE__ */ new Map([
  [s.APPLET, L.HTML],
  [s.CAPTION, L.HTML],
  [s.HTML, L.HTML],
  [s.MARQUEE, L.HTML],
  [s.OBJECT, L.HTML],
  [s.TABLE, L.HTML],
  [s.TD, L.HTML],
  [s.TEMPLATE, L.HTML],
  [s.TH, L.HTML],
  [s.ANNOTATION_XML, L.MATHML],
  [s.MI, L.MATHML],
  [s.MN, L.MATHML],
  [s.MO, L.MATHML],
  [s.MS, L.MATHML],
  [s.MTEXT, L.MATHML],
  [s.DESC, L.SVG],
  [s.FOREIGN_OBJECT, L.SVG],
  [s.TITLE, L.SVG]
]), zf = [s.H1, s.H2, s.H3, s.H4, s.H5, s.H6], Yf = [s.TR, s.TEMPLATE, s.HTML], jf = [s.TBODY, s.TFOOT, s.THEAD, s.TEMPLATE, s.HTML], Gf = [s.TABLE, s.TEMPLATE, s.HTML], qf = [s.TD, s.TH];
class $f {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(t, n, r) {
    this.treeAdapter = n, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = s.UNKNOWN, this.current = t;
  }
  //Index of element
  _indexOf(t) {
    return this.items.lastIndexOf(t, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === s.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === L.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(t, n) {
    this.stackTop++, this.items[this.stackTop] = t, this.current = t, this.tagIDs[this.stackTop] = n, this.currentTagId = n, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t, n, !0);
  }
  pop() {
    const t = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !0);
  }
  replace(t, n) {
    const r = this._indexOf(t);
    this.items[r] = n, r === this.stackTop && (this.current = n);
  }
  insertAfter(t, n, r) {
    const a = this._indexOf(t) + 1;
    this.items.splice(a, 0, n), this.tagIDs.splice(a, 0, r), this.stackTop++, a === this.stackTop && this._updateCurrentElement(), this.handler.onItemPush(this.current, this.currentTagId, a === this.stackTop);
  }
  popUntilTagNamePopped(t) {
    let n = this.stackTop + 1;
    do
      n = this.tagIDs.lastIndexOf(t, n - 1);
    while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== L.HTML);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  shortenToLength(t) {
    for (; this.stackTop >= t; ) {
      const n = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n, this.stackTop < t);
    }
  }
  popUntilElementPopped(t) {
    const n = this._indexOf(t);
    this.shortenToLength(n < 0 ? 0 : n);
  }
  popUntilPopped(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(r < 0 ? 0 : r);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(zf, L.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(qf, L.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(t, n) {
    for (let r = this.stackTop; r >= 0; r--)
      if (t.includes(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n)
        return r;
    return -1;
  }
  clearBackTo(t, n) {
    const r = this._indexOfTagNames(t, n);
    this.shortenToLength(r + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(Gf, L.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(jf, L.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(Yf, L.HTML);
  }
  remove(t) {
    const n = this._indexOf(t);
    n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1), this.tagIDs.splice(n, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !1)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === s.BODY ? this.items[1] : null;
  }
  contains(t) {
    return this._indexOf(t) > -1;
  }
  getCommonAncestor(t) {
    const n = this._indexOf(t) - 1;
    return n >= 0 ? this.items[n] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === s.HTML;
  }
  //Element in scope
  hasInScope(t) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.tagIDs[n], a = this.treeAdapter.getNamespaceURI(this.items[n]);
      if (r === t && a === L.HTML)
        return !0;
      if (sn.get(r) === a)
        return !1;
    }
    return !0;
  }
  hasNumberedHeaderInScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const n = this.tagIDs[t], r = this.treeAdapter.getNamespaceURI(this.items[t]);
      if (ku(n) && r === L.HTML)
        return !0;
      if (sn.get(n) === r)
        return !1;
    }
    return !0;
  }
  hasInListItemScope(t) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.tagIDs[n], a = this.treeAdapter.getNamespaceURI(this.items[n]);
      if (r === t && a === L.HTML)
        return !0;
      if ((r === s.UL || r === s.OL) && a === L.HTML || sn.get(r) === a)
        return !1;
    }
    return !0;
  }
  hasInButtonScope(t) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.tagIDs[n], a = this.treeAdapter.getNamespaceURI(this.items[n]);
      if (r === t && a === L.HTML)
        return !0;
      if (r === s.BUTTON && a === L.HTML || sn.get(r) === a)
        return !1;
    }
    return !0;
  }
  hasInTableScope(t) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.tagIDs[n];
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === L.HTML) {
        if (r === t)
          return !0;
        if (r === s.TABLE || r === s.TEMPLATE || r === s.HTML)
          return !1;
      }
    }
    return !0;
  }
  hasTableBodyContextInTableScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const n = this.tagIDs[t];
      if (this.treeAdapter.getNamespaceURI(this.items[t]) === L.HTML) {
        if (n === s.TBODY || n === s.THEAD || n === s.TFOOT)
          return !0;
        if (n === s.TABLE || n === s.HTML)
          return !1;
      }
    }
    return !0;
  }
  hasInSelectScope(t) {
    for (let n = this.stackTop; n >= 0; n--) {
      const r = this.tagIDs[n];
      if (this.treeAdapter.getNamespaceURI(this.items[n]) === L.HTML) {
        if (r === t)
          return !0;
        if (r !== s.OPTION && r !== s.OPTGROUP)
          return !1;
      }
    }
    return !0;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; Ru.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; Ka.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(t) {
    for (; this.currentTagId !== t && Ka.has(this.currentTagId); )
      this.pop();
  }
}
const Qn = 3;
var we;
(function(e) {
  e[e.Marker = 0] = "Marker", e[e.Element = 1] = "Element";
})(we = we || (we = {}));
const Za = { type: we.Marker };
class Wf {
  constructor(t) {
    this.treeAdapter = t, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(t, n) {
    const r = [], a = n.length, u = this.treeAdapter.getTagName(t), i = this.treeAdapter.getNamespaceURI(t);
    for (let o = 0; o < this.entries.length; o++) {
      const l = this.entries[o];
      if (l.type === we.Marker)
        break;
      const { element: c } = l;
      if (this.treeAdapter.getTagName(c) === u && this.treeAdapter.getNamespaceURI(c) === i) {
        const f = this.treeAdapter.getAttrList(c);
        f.length === a && r.push({ idx: o, attrs: f });
      }
    }
    return r;
  }
  _ensureNoahArkCondition(t) {
    if (this.entries.length < Qn)
      return;
    const n = this.treeAdapter.getAttrList(t), r = this._getNoahArkConditionCandidates(t, n);
    if (r.length < Qn)
      return;
    const a = new Map(n.map((i) => [i.name, i.value]));
    let u = 0;
    for (let i = 0; i < r.length; i++) {
      const o = r[i];
      o.attrs.every((l) => a.get(l.name) === l.value) && (u += 1, u >= Qn && this.entries.splice(o.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(Za);
  }
  pushElement(t, n) {
    this._ensureNoahArkCondition(t), this.entries.unshift({
      type: we.Element,
      element: t,
      token: n
    });
  }
  insertElementAfterBookmark(t, n) {
    const r = this.entries.indexOf(this.bookmark);
    this.entries.splice(r, 0, {
      type: we.Element,
      element: t,
      token: n
    });
  }
  removeEntry(t) {
    const n = this.entries.indexOf(t);
    n >= 0 && this.entries.splice(n, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const t = this.entries.indexOf(Za);
    t >= 0 ? this.entries.splice(0, t + 1) : this.entries.length = 0;
  }
  //Search
  getElementEntryInScopeWithTagName(t) {
    const n = this.entries.find((r) => r.type === we.Marker || this.treeAdapter.getTagName(r.element) === t);
    return n && n.type === we.Element ? n : null;
  }
  getElementEntry(t) {
    return this.entries.find((n) => n.type === we.Element && n.element === t);
  }
}
function Ja(e) {
  return {
    nodeName: "#text",
    value: e,
    parentNode: null
  };
}
const mt = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: Se.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(e, t, n) {
    return {
      nodeName: e,
      tagName: e,
      attrs: n,
      namespaceURI: t,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(e) {
    return {
      nodeName: "#comment",
      data: e,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(e, t) {
    e.childNodes.push(t), t.parentNode = e;
  },
  insertBefore(e, t, n) {
    const r = e.childNodes.indexOf(n);
    e.childNodes.splice(r, 0, t), t.parentNode = e;
  },
  setTemplateContent(e, t) {
    e.content = t;
  },
  getTemplateContent(e) {
    return e.content;
  },
  setDocumentType(e, t, n, r) {
    const a = e.childNodes.find((u) => u.nodeName === "#documentType");
    if (a)
      a.name = t, a.publicId = n, a.systemId = r;
    else {
      const u = {
        nodeName: "#documentType",
        name: t,
        publicId: n,
        systemId: r,
        parentNode: null
      };
      mt.appendChild(e, u);
    }
  },
  setDocumentMode(e, t) {
    e.mode = t;
  },
  getDocumentMode(e) {
    return e.mode;
  },
  detachNode(e) {
    if (e.parentNode) {
      const t = e.parentNode.childNodes.indexOf(e);
      e.parentNode.childNodes.splice(t, 1), e.parentNode = null;
    }
  },
  insertText(e, t) {
    if (e.childNodes.length > 0) {
      const n = e.childNodes[e.childNodes.length - 1];
      if (mt.isTextNode(n)) {
        n.value += t;
        return;
      }
    }
    mt.appendChild(e, Ja(t));
  },
  insertTextBefore(e, t, n) {
    const r = e.childNodes[e.childNodes.indexOf(n) - 1];
    r && mt.isTextNode(r) ? r.value += t : mt.insertBefore(e, Ja(t), n);
  },
  adoptAttributes(e, t) {
    const n = new Set(e.attrs.map((r) => r.name));
    for (let r = 0; r < t.length; r++)
      n.has(t[r].name) || e.attrs.push(t[r]);
  },
  //Tree traversing
  getFirstChild(e) {
    return e.childNodes[0];
  },
  getChildNodes(e) {
    return e.childNodes;
  },
  getParentNode(e) {
    return e.parentNode;
  },
  getAttrList(e) {
    return e.attrs;
  },
  //Node data
  getTagName(e) {
    return e.tagName;
  },
  getNamespaceURI(e) {
    return e.namespaceURI;
  },
  getTextNodeContent(e) {
    return e.value;
  },
  getCommentNodeContent(e) {
    return e.data;
  },
  getDocumentTypeNodeName(e) {
    return e.name;
  },
  getDocumentTypeNodePublicId(e) {
    return e.publicId;
  },
  getDocumentTypeNodeSystemId(e) {
    return e.systemId;
  },
  //Node types
  isTextNode(e) {
    return e.nodeName === "#text";
  },
  isCommentNode(e) {
    return e.nodeName === "#comment";
  },
  isDocumentTypeNode(e) {
    return e.nodeName === "#documentType";
  },
  isElementNode(e) {
    return Object.prototype.hasOwnProperty.call(e, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = t;
  },
  getNodeSourceCodeLocation(e) {
    return e.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(e, t) {
    e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t };
  }
}, Lu = "html", Vf = "about:legacy-compat", Qf = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", Ou = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
], Xf = [
  ...Ou,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
], Kf = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]), wu = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], Zf = [
  ...wu,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function ei(e, t) {
  return t.some((n) => e.startsWith(n));
}
function Jf(e) {
  return e.name === Lu && e.publicId === null && (e.systemId === null || e.systemId === Vf);
}
function eh(e) {
  if (e.name !== Lu)
    return Se.QUIRKS;
  const { systemId: t } = e;
  if (t && t.toLowerCase() === Qf)
    return Se.QUIRKS;
  let { publicId: n } = e;
  if (n !== null) {
    if (n = n.toLowerCase(), Kf.has(n))
      return Se.QUIRKS;
    let r = t === null ? Xf : Ou;
    if (ei(n, r))
      return Se.QUIRKS;
    if (r = t === null ? wu : Zf, ei(n, r))
      return Se.LIMITED_QUIRKS;
  }
  return Se.NO_QUIRKS;
}
const ti = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
}, th = "definitionurl", nh = "definitionURL", rh = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((e) => [e.toLowerCase(), e])), ah = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: L.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: L.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: L.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: L.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: L.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: L.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: L.XLINK }],
  ["xml:base", { prefix: "xml", name: "base", namespace: L.XML }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: L.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: L.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: L.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: L.XMLNS }]
]), ih = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((e) => [e.toLowerCase(), e])), uh = /* @__PURE__ */ new Set([
  s.B,
  s.BIG,
  s.BLOCKQUOTE,
  s.BODY,
  s.BR,
  s.CENTER,
  s.CODE,
  s.DD,
  s.DIV,
  s.DL,
  s.DT,
  s.EM,
  s.EMBED,
  s.H1,
  s.H2,
  s.H3,
  s.H4,
  s.H5,
  s.H6,
  s.HEAD,
  s.HR,
  s.I,
  s.IMG,
  s.LI,
  s.LISTING,
  s.MENU,
  s.META,
  s.NOBR,
  s.OL,
  s.P,
  s.PRE,
  s.RUBY,
  s.S,
  s.SMALL,
  s.SPAN,
  s.STRONG,
  s.STRIKE,
  s.SUB,
  s.SUP,
  s.TABLE,
  s.TT,
  s.U,
  s.UL,
  s.VAR
]);
function sh(e) {
  const t = e.tagID;
  return t === s.FONT && e.attrs.some(({ name: r }) => r === Je.COLOR || r === Je.SIZE || r === Je.FACE) || uh.has(t);
}
function Du(e) {
  for (let t = 0; t < e.attrs.length; t++)
    if (e.attrs[t].name === th) {
      e.attrs[t].name = nh;
      break;
    }
}
function Pu(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = rh.get(e.attrs[t].name);
    n != null && (e.attrs[t].name = n);
  }
}
function Fr(e) {
  for (let t = 0; t < e.attrs.length; t++) {
    const n = ah.get(e.attrs[t].name);
    n && (e.attrs[t].prefix = n.prefix, e.attrs[t].name = n.name, e.attrs[t].namespace = n.namespace);
  }
}
function oh(e) {
  const t = ih.get(e.tagName);
  t != null && (e.tagName = t, e.tagID = Nt(e.tagName));
}
function lh(e, t) {
  return t === L.MATHML && (e === s.MI || e === s.MO || e === s.MN || e === s.MS || e === s.MTEXT);
}
function ch(e, t, n) {
  if (t === L.MATHML && e === s.ANNOTATION_XML) {
    for (let r = 0; r < n.length; r++)
      if (n[r].name === Je.ENCODING) {
        const a = n[r].value.toLowerCase();
        return a === ti.TEXT_HTML || a === ti.APPLICATION_XML;
      }
  }
  return t === L.SVG && (e === s.FOREIGN_OBJECT || e === s.DESC || e === s.TITLE);
}
function dh(e, t, n, r) {
  return (!r || r === L.HTML) && ch(e, t, n) || (!r || r === L.MATHML) && lh(e, t);
}
const fh = "hidden", hh = 8, ph = 3;
var T;
(function(e) {
  e[e.INITIAL = 0] = "INITIAL", e[e.BEFORE_HTML = 1] = "BEFORE_HTML", e[e.BEFORE_HEAD = 2] = "BEFORE_HEAD", e[e.IN_HEAD = 3] = "IN_HEAD", e[e.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e[e.AFTER_HEAD = 5] = "AFTER_HEAD", e[e.IN_BODY = 6] = "IN_BODY", e[e.TEXT = 7] = "TEXT", e[e.IN_TABLE = 8] = "IN_TABLE", e[e.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e[e.IN_CAPTION = 10] = "IN_CAPTION", e[e.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e[e.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e[e.IN_ROW = 13] = "IN_ROW", e[e.IN_CELL = 14] = "IN_CELL", e[e.IN_SELECT = 15] = "IN_SELECT", e[e.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e[e.IN_TEMPLATE = 17] = "IN_TEMPLATE", e[e.AFTER_BODY = 18] = "AFTER_BODY", e[e.IN_FRAMESET = 19] = "IN_FRAMESET", e[e.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e[e.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e[e.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(T || (T = {}));
const mh = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
}, Mu = /* @__PURE__ */ new Set([s.TABLE, s.TBODY, s.TFOOT, s.THEAD, s.TR]), ni = {
  scriptingEnabled: !0,
  sourceCodeLocationInfo: !1,
  treeAdapter: mt,
  onParseError: null
};
class ri {
  constructor(t, n, r = null, a = null) {
    this.fragmentContext = r, this.scriptHandler = a, this.currentToken = null, this.stopped = !1, this.insertionMode = T.INITIAL, this.originalInsertionMode = T.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = {
      ...ni,
      ...t
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = n ?? this.treeAdapter.createDocument(), this.tokenizer = new Uf(this.options, this), this.activeFormattingElements = new Wf(this.treeAdapter), this.fragmentContextID = r ? Nt(this.treeAdapter.getTagName(r)) : s.UNKNOWN, this._setContextModes(r ?? this.document, this.fragmentContextID), this.openElements = new $f(this.document, this.treeAdapter, this);
  }
  // API
  static parse(t, n) {
    const r = new this(n);
    return r.tokenizer.write(t, !0), r.document;
  }
  static getFragmentParser(t, n) {
    const r = {
      ...ni,
      ...n
    };
    t ?? (t = r.treeAdapter.createElement(k.TEMPLATE, L.HTML, []));
    const a = r.treeAdapter.createElement("documentmock", L.HTML, []), u = new this(r, a, t);
    return u.fragmentContextID === s.TEMPLATE && u.tmplInsertionModeStack.unshift(T.IN_TEMPLATE), u._initTokenizerForFragmentParsing(), u._insertFakeRootElement(), u._resetInsertionMode(), u._findFormInFragmentContext(), u;
  }
  getFragment() {
    const t = this.treeAdapter.getFirstChild(this.document), n = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(t, n), n;
  }
  //Errors
  _err(t, n, r) {
    var a;
    if (!this.onParseError)
      return;
    const u = (a = t.location) !== null && a !== void 0 ? a : mh, i = {
      code: n,
      startLine: u.startLine,
      startCol: u.startCol,
      startOffset: u.startOffset,
      endLine: r ? u.startLine : u.endLine,
      endCol: r ? u.startCol : u.endCol,
      endOffset: r ? u.startOffset : u.endOffset
    };
    this.onParseError(i);
  }
  //Stack events
  onItemPush(t, n, r) {
    var a, u;
    (u = (a = this.treeAdapter).onItemPush) === null || u === void 0 || u.call(a, t), r && this.openElements.stackTop > 0 && this._setContextModes(t, n);
  }
  onItemPop(t, n) {
    var r, a;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken), (a = (r = this.treeAdapter).onItemPop) === null || a === void 0 || a.call(r, t, this.openElements.current), n) {
      let u, i;
      this.openElements.stackTop === 0 && this.fragmentContext ? (u = this.fragmentContext, i = this.fragmentContextID) : { current: u, currentTagId: i } = this.openElements, this._setContextModes(u, i);
    }
  }
  _setContextModes(t, n) {
    const r = t === this.document || this.treeAdapter.getNamespaceURI(t) === L.HTML;
    this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && !this._isIntegrationPoint(n, t);
  }
  _switchToTextParsing(t, n) {
    this._insertElement(t, L.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = T.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = T.TEXT, this.originalInsertionMode = T.IN_BODY, this.tokenizer.state = de.PLAINTEXT;
  }
  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let t = this.fragmentContext;
    for (; t; ) {
      if (this.treeAdapter.getTagName(t) === k.FORM) {
        this.formElement = t;
        break;
      }
      t = this.treeAdapter.getParentNode(t);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== L.HTML))
      switch (this.fragmentContextID) {
        case s.TITLE:
        case s.TEXTAREA: {
          this.tokenizer.state = de.RCDATA;
          break;
        }
        case s.STYLE:
        case s.XMP:
        case s.IFRAME:
        case s.NOEMBED:
        case s.NOFRAMES:
        case s.NOSCRIPT: {
          this.tokenizer.state = de.RAWTEXT;
          break;
        }
        case s.SCRIPT: {
          this.tokenizer.state = de.SCRIPT_DATA;
          break;
        }
        case s.PLAINTEXT: {
          this.tokenizer.state = de.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  _setDocumentType(t) {
    const n = t.name || "", r = t.publicId || "", a = t.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, n, r, a), t.location) {
      const i = this.treeAdapter.getChildNodes(this.document).find((o) => this.treeAdapter.isDocumentTypeNode(o));
      i && this.treeAdapter.setNodeSourceCodeLocation(i, t.location);
    }
  }
  _attachElementToTree(t, n) {
    if (this.options.sourceCodeLocationInfo) {
      const r = n && {
        ...n,
        startTag: n
      };
      this.treeAdapter.setNodeSourceCodeLocation(t, r);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(t);
    else {
      const r = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(r, t);
    }
  }
  _appendElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location);
  }
  _insertElement(t, n) {
    const r = this.treeAdapter.createElement(t.tagName, n, t.attrs);
    this._attachElementToTree(r, t.location), this.openElements.push(r, t.tagID);
  }
  _insertFakeElement(t, n) {
    const r = this.treeAdapter.createElement(t, L.HTML, []);
    this._attachElementToTree(r, null), this.openElements.push(r, n);
  }
  _insertTemplate(t) {
    const n = this.treeAdapter.createElement(t.tagName, L.HTML, t.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n, t.location), this.openElements.push(n, t.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null);
  }
  _insertFakeRootElement() {
    const t = this.treeAdapter.createElement(k.HTML, L.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null), this.treeAdapter.appendChild(this.openElements.current, t), this.openElements.push(t, s.HTML);
  }
  _appendCommentNode(t, n) {
    const r = this.treeAdapter.createCommentNode(t.data);
    this.treeAdapter.appendChild(n, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, t.location);
  }
  _insertCharacters(t) {
    let n, r;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: n, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(n, t.chars, r) : this.treeAdapter.insertText(n, t.chars)) : (n = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n, t.chars)), !t.location)
      return;
    const a = this.treeAdapter.getChildNodes(n), u = r ? a.lastIndexOf(r) : a.length, i = a[u - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(i)) {
      const { endLine: l, endCol: c, endOffset: f } = t.location;
      this.treeAdapter.updateNodeSourceCodeLocation(i, { endLine: l, endCol: c, endOffset: f });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(i, t.location);
  }
  _adoptNodes(t, n) {
    for (let r = this.treeAdapter.getFirstChild(t); r; r = this.treeAdapter.getFirstChild(t))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r);
  }
  _setEndLocation(t, n) {
    if (this.treeAdapter.getNodeSourceCodeLocation(t) && n.location) {
      const r = n.location, a = this.treeAdapter.getTagName(t), u = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        n.type === X.END_TAG && a === n.tagName ? {
          endTag: { ...r },
          endLine: r.endLine,
          endCol: r.endCol,
          endOffset: r.endOffset
        } : {
          endLine: r.startLine,
          endCol: r.startCol,
          endOffset: r.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(t, u);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(t) {
    if (!this.currentNotInHTML)
      return !1;
    let n, r;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext, r = this.fragmentContextID) : { current: n, currentTagId: r } = this.openElements, t.tagID === s.SVG && this.treeAdapter.getTagName(n) === k.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === L.MATHML ? !1 : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (t.tagID === s.MGLYPH || t.tagID === s.MALIGNMARK) && !this._isIntegrationPoint(r, n, L.HTML)
    );
  }
  _processToken(t) {
    switch (t.type) {
      case X.CHARACTER: {
        this.onCharacter(t);
        break;
      }
      case X.NULL_CHARACTER: {
        this.onNullCharacter(t);
        break;
      }
      case X.COMMENT: {
        this.onComment(t);
        break;
      }
      case X.DOCTYPE: {
        this.onDoctype(t);
        break;
      }
      case X.START_TAG: {
        this._processStartTag(t);
        break;
      }
      case X.END_TAG: {
        this.onEndTag(t);
        break;
      }
      case X.EOF: {
        this.onEof(t);
        break;
      }
      case X.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(t);
        break;
      }
    }
  }
  //Integration points
  _isIntegrationPoint(t, n, r) {
    const a = this.treeAdapter.getNamespaceURI(n), u = this.treeAdapter.getAttrList(n);
    return dh(t, a, u, r);
  }
  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const t = this.activeFormattingElements.entries.length;
    if (t) {
      const n = this.activeFormattingElements.entries.findIndex((a) => a.type === we.Marker || this.openElements.contains(a.element)), r = n < 0 ? t - 1 : n - 1;
      for (let a = r; a >= 0; a--) {
        const u = this.activeFormattingElements.entries[a];
        this._insertElement(u.token, this.treeAdapter.getNamespaceURI(u.element)), u.element = this.openElements.current;
      }
    }
  }
  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = T.IN_ROW;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(s.P), this.openElements.popUntilTagNamePopped(s.P);
  }
  //Insertion modes
  _resetInsertionMode() {
    for (let t = this.openElements.stackTop; t >= 0; t--)
      switch (t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]) {
        case s.TR: {
          this.insertionMode = T.IN_ROW;
          return;
        }
        case s.TBODY:
        case s.THEAD:
        case s.TFOOT: {
          this.insertionMode = T.IN_TABLE_BODY;
          return;
        }
        case s.CAPTION: {
          this.insertionMode = T.IN_CAPTION;
          return;
        }
        case s.COLGROUP: {
          this.insertionMode = T.IN_COLUMN_GROUP;
          return;
        }
        case s.TABLE: {
          this.insertionMode = T.IN_TABLE;
          return;
        }
        case s.BODY: {
          this.insertionMode = T.IN_BODY;
          return;
        }
        case s.FRAMESET: {
          this.insertionMode = T.IN_FRAMESET;
          return;
        }
        case s.SELECT: {
          this._resetInsertionModeForSelect(t);
          return;
        }
        case s.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case s.HTML: {
          this.insertionMode = this.headElement ? T.AFTER_HEAD : T.BEFORE_HEAD;
          return;
        }
        case s.TD:
        case s.TH: {
          if (t > 0) {
            this.insertionMode = T.IN_CELL;
            return;
          }
          break;
        }
        case s.HEAD: {
          if (t > 0) {
            this.insertionMode = T.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = T.IN_BODY;
  }
  _resetInsertionModeForSelect(t) {
    if (t > 0)
      for (let n = t - 1; n > 0; n--) {
        const r = this.openElements.tagIDs[n];
        if (r === s.TEMPLATE)
          break;
        if (r === s.TABLE) {
          this.insertionMode = T.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = T.IN_SELECT;
  }
  //Foster parenting
  _isElementCausesFosterParenting(t) {
    return Mu.has(t);
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  _findFosterParentingLocation() {
    for (let t = this.openElements.stackTop; t >= 0; t--) {
      const n = this.openElements.items[t];
      switch (this.openElements.tagIDs[t]) {
        case s.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(n) === L.HTML)
            return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null };
          break;
        }
        case s.TABLE: {
          const r = this.treeAdapter.getParentNode(n);
          return r ? { parent: r, beforeElement: n } : { parent: this.openElements.items[t - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  _fosterParentElement(t) {
    const n = this._findFosterParentingLocation();
    n.beforeElement ? this.treeAdapter.insertBefore(n.parent, t, n.beforeElement) : this.treeAdapter.appendChild(n.parent, t);
  }
  //Special elements
  _isSpecialElement(t, n) {
    const r = this.treeAdapter.getNamespaceURI(t);
    return Mf[r].has(n);
  }
  onCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      qp(this, t);
      return;
    }
    switch (this.insertionMode) {
      case T.INITIAL: {
        Mt(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        zt(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Yt(this, t);
        break;
      }
      case T.IN_HEAD: {
        jt(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        Gt(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        qt(this, t);
        break;
      }
      case T.IN_BODY:
      case T.IN_CAPTION:
      case T.IN_CELL:
      case T.IN_TEMPLATE: {
        Bu(this, t);
        break;
      }
      case T.TEXT:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE: {
        this._insertCharacters(t);
        break;
      }
      case T.IN_TABLE:
      case T.IN_TABLE_BODY:
      case T.IN_ROW: {
        Xn(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        ju(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        Tn(this, t);
        break;
      }
      case T.AFTER_BODY: {
        yn(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        fn(this, t);
        break;
      }
    }
  }
  onNullCharacter(t) {
    if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) {
      Gp(this, t);
      return;
    }
    switch (this.insertionMode) {
      case T.INITIAL: {
        Mt(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        zt(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Yt(this, t);
        break;
      }
      case T.IN_HEAD: {
        jt(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        Gt(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        qt(this, t);
        break;
      }
      case T.TEXT: {
        this._insertCharacters(t);
        break;
      }
      case T.IN_TABLE:
      case T.IN_TABLE_BODY:
      case T.IN_ROW: {
        Xn(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        Tn(this, t);
        break;
      }
      case T.AFTER_BODY: {
        yn(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        fn(this, t);
        break;
      }
    }
  }
  onComment(t) {
    if (this.skipNextNewLine = !1, this.currentNotInHTML) {
      mr(this, t);
      return;
    }
    switch (this.insertionMode) {
      case T.INITIAL:
      case T.BEFORE_HTML:
      case T.BEFORE_HEAD:
      case T.IN_HEAD:
      case T.IN_HEAD_NO_SCRIPT:
      case T.AFTER_HEAD:
      case T.IN_BODY:
      case T.IN_TABLE:
      case T.IN_CAPTION:
      case T.IN_COLUMN_GROUP:
      case T.IN_TABLE_BODY:
      case T.IN_ROW:
      case T.IN_CELL:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE:
      case T.IN_TEMPLATE:
      case T.IN_FRAMESET:
      case T.AFTER_FRAMESET: {
        mr(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        Ft(this, t);
        break;
      }
      case T.AFTER_BODY: {
        _h(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY:
      case T.AFTER_AFTER_FRAMESET: {
        Ch(this, t);
        break;
      }
    }
  }
  onDoctype(t) {
    switch (this.skipNextNewLine = !1, this.insertionMode) {
      case T.INITIAL: {
        xh(this, t);
        break;
      }
      case T.BEFORE_HEAD:
      case T.IN_HEAD:
      case T.IN_HEAD_NO_SCRIPT:
      case T.AFTER_HEAD: {
        this._err(t, N.misplacedDoctype);
        break;
      }
      case T.IN_TABLE_TEXT: {
        Ft(this, t);
        break;
      }
    }
  }
  onStartTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this._processStartTag(t), t.selfClosing && !t.ackSelfClosing && this._err(t, N.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   */
  _processStartTag(t) {
    this.shouldProcessStartTagTokenInForeignContent(t) ? $p(this, t) : this._startTagOutsideForeignContent(t);
  }
  _startTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case T.INITIAL: {
        Mt(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        kh(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Sh(this, t);
        break;
      }
      case T.IN_HEAD: {
        Pe(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        Lh(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        wh(this, t);
        break;
      }
      case T.IN_BODY: {
        Ee(this, t);
        break;
      }
      case T.IN_TABLE: {
        Ct(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        Ft(this, t);
        break;
      }
      case T.IN_CAPTION: {
        Np(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        Hr(this, t);
        break;
      }
      case T.IN_TABLE_BODY: {
        On(this, t);
        break;
      }
      case T.IN_ROW: {
        wn(this, t);
        break;
      }
      case T.IN_CELL: {
        Op(this, t);
        break;
      }
      case T.IN_SELECT: {
        $u(this, t);
        break;
      }
      case T.IN_SELECT_IN_TABLE: {
        Dp(this, t);
        break;
      }
      case T.IN_TEMPLATE: {
        Mp(this, t);
        break;
      }
      case T.AFTER_BODY: {
        Bp(this, t);
        break;
      }
      case T.IN_FRAMESET: {
        vp(this, t);
        break;
      }
      case T.AFTER_FRAMESET: {
        Up(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        Yp(this, t);
        break;
      }
      case T.AFTER_AFTER_FRAMESET: {
        jp(this, t);
        break;
      }
    }
  }
  onEndTag(t) {
    this.skipNextNewLine = !1, this.currentToken = t, this.currentNotInHTML ? Wp(this, t) : this._endTagOutsideForeignContent(t);
  }
  _endTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case T.INITIAL: {
        Mt(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        Ih(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Nh(this, t);
        break;
      }
      case T.IN_HEAD: {
        Rh(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        Oh(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        Dh(this, t);
        break;
      }
      case T.IN_BODY: {
        Ln(this, t);
        break;
      }
      case T.TEXT: {
        Ep(this, t);
        break;
      }
      case T.IN_TABLE: {
        Vt(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        Ft(this, t);
        break;
      }
      case T.IN_CAPTION: {
        Rp(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        Lp(this, t);
        break;
      }
      case T.IN_TABLE_BODY: {
        gr(this, t);
        break;
      }
      case T.IN_ROW: {
        qu(this, t);
        break;
      }
      case T.IN_CELL: {
        wp(this, t);
        break;
      }
      case T.IN_SELECT: {
        Wu(this, t);
        break;
      }
      case T.IN_SELECT_IN_TABLE: {
        Pp(this, t);
        break;
      }
      case T.IN_TEMPLATE: {
        Fp(this, t);
        break;
      }
      case T.AFTER_BODY: {
        Qu(this, t);
        break;
      }
      case T.IN_FRAMESET: {
        Hp(this, t);
        break;
      }
      case T.AFTER_FRAMESET: {
        zp(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        fn(this, t);
        break;
      }
    }
  }
  onEof(t) {
    switch (this.insertionMode) {
      case T.INITIAL: {
        Mt(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        zt(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Yt(this, t);
        break;
      }
      case T.IN_HEAD: {
        jt(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        Gt(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        qt(this, t);
        break;
      }
      case T.IN_BODY:
      case T.IN_TABLE:
      case T.IN_CAPTION:
      case T.IN_COLUMN_GROUP:
      case T.IN_TABLE_BODY:
      case T.IN_ROW:
      case T.IN_CELL:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE: {
        zu(this, t);
        break;
      }
      case T.TEXT: {
        Tp(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        Ft(this, t);
        break;
      }
      case T.IN_TEMPLATE: {
        Vu(this, t);
        break;
      }
      case T.AFTER_BODY:
      case T.IN_FRAMESET:
      case T.AFTER_FRAMESET:
      case T.AFTER_AFTER_BODY:
      case T.AFTER_AFTER_FRAMESET: {
        vr(this, t);
        break;
      }
    }
  }
  onWhitespaceCharacter(t) {
    if (this.skipNextNewLine && (this.skipNextNewLine = !1, t.chars.charCodeAt(0) === p.LINE_FEED)) {
      if (t.chars.length === 1)
        return;
      t.chars = t.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(t);
      return;
    }
    switch (this.insertionMode) {
      case T.IN_HEAD:
      case T.IN_HEAD_NO_SCRIPT:
      case T.AFTER_HEAD:
      case T.TEXT:
      case T.IN_COLUMN_GROUP:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE:
      case T.IN_FRAMESET:
      case T.AFTER_FRAMESET: {
        this._insertCharacters(t);
        break;
      }
      case T.IN_BODY:
      case T.IN_CAPTION:
      case T.IN_CELL:
      case T.IN_TEMPLATE:
      case T.AFTER_BODY:
      case T.AFTER_AFTER_BODY:
      case T.AFTER_AFTER_FRAMESET: {
        Fu(this, t);
        break;
      }
      case T.IN_TABLE:
      case T.IN_TABLE_BODY:
      case T.IN_ROW: {
        Xn(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        Yu(this, t);
        break;
      }
    }
  }
}
function gh(e, t) {
  let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);
  return n ? e.openElements.contains(n.element) ? e.openElements.hasInScope(t.tagID) || (n = null) : (e.activeFormattingElements.removeEntry(n), n = null) : Uu(e, t), n;
}
function bh(e, t) {
  let n = null, r = e.openElements.stackTop;
  for (; r >= 0; r--) {
    const a = e.openElements.items[r];
    if (a === t.element)
      break;
    e._isSpecialElement(a, e.openElements.tagIDs[r]) && (n = a);
  }
  return n || (e.openElements.shortenToLength(r < 0 ? 0 : r), e.activeFormattingElements.removeEntry(t)), n;
}
function Eh(e, t, n) {
  let r = t, a = e.openElements.getCommonAncestor(t);
  for (let u = 0, i = a; i !== n; u++, i = a) {
    a = e.openElements.getCommonAncestor(i);
    const o = e.activeFormattingElements.getElementEntry(i), l = o && u >= ph;
    !o || l ? (l && e.activeFormattingElements.removeEntry(o), e.openElements.remove(i)) : (i = Th(e, o), r === t && (e.activeFormattingElements.bookmark = o), e.treeAdapter.detachNode(r), e.treeAdapter.appendChild(i, r), r = i);
  }
  return r;
}
function Th(e, t) {
  const n = e.treeAdapter.getNamespaceURI(t.element), r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs);
  return e.openElements.replace(t.element, r), t.element = r, r;
}
function yh(e, t, n) {
  const r = e.treeAdapter.getTagName(t), a = Nt(r);
  if (e._isElementCausesFosterParenting(a))
    e._fosterParentElement(n);
  else {
    const u = e.treeAdapter.getNamespaceURI(t);
    a === s.TEMPLATE && u === L.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, n);
  }
}
function Ah(e, t, n) {
  const r = e.treeAdapter.getNamespaceURI(n.element), { token: a } = n, u = e.treeAdapter.createElement(a.tagName, r, a.attrs);
  e._adoptNodes(t, u), e.treeAdapter.appendChild(t, u), e.activeFormattingElements.insertElementAfterBookmark(u, a), e.activeFormattingElements.removeEntry(n), e.openElements.remove(n.element), e.openElements.insertAfter(t, u, a.tagID);
}
function Br(e, t) {
  for (let n = 0; n < hh; n++) {
    const r = gh(e, t);
    if (!r)
      break;
    const a = bh(e, r);
    if (!a)
      break;
    e.activeFormattingElements.bookmark = r;
    const u = Eh(e, a, r.element), i = e.openElements.getCommonAncestor(r.element);
    e.treeAdapter.detachNode(u), i && yh(e, i, u), Ah(e, a, r);
  }
}
function mr(e, t) {
  e._appendCommentNode(t, e.openElements.currentTmplContentOrNode);
}
function _h(e, t) {
  e._appendCommentNode(t, e.openElements.items[0]);
}
function Ch(e, t) {
  e._appendCommentNode(t, e.document);
}
function vr(e, t) {
  if (e.stopped = !0, t.location) {
    const n = e.fragmentContext ? 0 : 2;
    for (let r = e.openElements.stackTop; r >= n; r--)
      e._setEndLocation(e.openElements.items[r], t);
    if (!e.fragmentContext && e.openElements.stackTop >= 0) {
      const r = e.openElements.items[0], a = e.treeAdapter.getNodeSourceCodeLocation(r);
      if (a && !a.endTag && (e._setEndLocation(r, t), e.openElements.stackTop >= 1)) {
        const u = e.openElements.items[1], i = e.treeAdapter.getNodeSourceCodeLocation(u);
        i && !i.endTag && e._setEndLocation(u, t);
      }
    }
  }
}
function xh(e, t) {
  e._setDocumentType(t);
  const n = t.forceQuirks ? Se.QUIRKS : eh(t);
  Jf(t) || e._err(t, N.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, n), e.insertionMode = T.BEFORE_HTML;
}
function Mt(e, t) {
  e._err(t, N.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, Se.QUIRKS), e.insertionMode = T.BEFORE_HTML, e._processToken(t);
}
function kh(e, t) {
  t.tagID === s.HTML ? (e._insertElement(t, L.HTML), e.insertionMode = T.BEFORE_HEAD) : zt(e, t);
}
function Ih(e, t) {
  const n = t.tagID;
  (n === s.HTML || n === s.HEAD || n === s.BODY || n === s.BR) && zt(e, t);
}
function zt(e, t) {
  e._insertFakeRootElement(), e.insertionMode = T.BEFORE_HEAD, e._processToken(t);
}
function Sh(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee(e, t);
      break;
    }
    case s.HEAD: {
      e._insertElement(t, L.HTML), e.headElement = e.openElements.current, e.insertionMode = T.IN_HEAD;
      break;
    }
    default:
      Yt(e, t);
  }
}
function Nh(e, t) {
  const n = t.tagID;
  n === s.HEAD || n === s.BODY || n === s.HTML || n === s.BR ? Yt(e, t) : e._err(t, N.endTagWithoutMatchingOpenElement);
}
function Yt(e, t) {
  e._insertFakeElement(k.HEAD, s.HEAD), e.headElement = e.openElements.current, e.insertionMode = T.IN_HEAD, e._processToken(t);
}
function Pe(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee(e, t);
      break;
    }
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META: {
      e._appendElement(t, L.HTML), t.ackSelfClosing = !0;
      break;
    }
    case s.TITLE: {
      e._switchToTextParsing(t, de.RCDATA);
      break;
    }
    case s.NOSCRIPT: {
      e.options.scriptingEnabled ? e._switchToTextParsing(t, de.RAWTEXT) : (e._insertElement(t, L.HTML), e.insertionMode = T.IN_HEAD_NO_SCRIPT);
      break;
    }
    case s.NOFRAMES:
    case s.STYLE: {
      e._switchToTextParsing(t, de.RAWTEXT);
      break;
    }
    case s.SCRIPT: {
      e._switchToTextParsing(t, de.SCRIPT_DATA);
      break;
    }
    case s.TEMPLATE: {
      e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = T.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(T.IN_TEMPLATE);
      break;
    }
    case s.HEAD: {
      e._err(t, N.misplacedStartTagForHeadElement);
      break;
    }
    default:
      jt(e, t);
  }
}
function Rh(e, t) {
  switch (t.tagID) {
    case s.HEAD: {
      e.openElements.pop(), e.insertionMode = T.AFTER_HEAD;
      break;
    }
    case s.BODY:
    case s.BR:
    case s.HTML: {
      jt(e, t);
      break;
    }
    case s.TEMPLATE: {
      dt(e, t);
      break;
    }
    default:
      e._err(t, N.endTagWithoutMatchingOpenElement);
  }
}
function dt(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== s.TEMPLATE && e._err(t, N.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(s.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, N.endTagWithoutMatchingOpenElement);
}
function jt(e, t) {
  e.openElements.pop(), e.insertionMode = T.AFTER_HEAD, e._processToken(t);
}
function Lh(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee(e, t);
      break;
    }
    case s.BASEFONT:
    case s.BGSOUND:
    case s.HEAD:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.STYLE: {
      Pe(e, t);
      break;
    }
    case s.NOSCRIPT: {
      e._err(t, N.nestedNoscriptInHead);
      break;
    }
    default:
      Gt(e, t);
  }
}
function Oh(e, t) {
  switch (t.tagID) {
    case s.NOSCRIPT: {
      e.openElements.pop(), e.insertionMode = T.IN_HEAD;
      break;
    }
    case s.BR: {
      Gt(e, t);
      break;
    }
    default:
      e._err(t, N.endTagWithoutMatchingOpenElement);
  }
}
function Gt(e, t) {
  const n = t.type === X.EOF ? N.openElementsLeftAfterEof : N.disallowedContentInNoscriptInHead;
  e._err(t, n), e.openElements.pop(), e.insertionMode = T.IN_HEAD, e._processToken(t);
}
function wh(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee(e, t);
      break;
    }
    case s.BODY: {
      e._insertElement(t, L.HTML), e.framesetOk = !1, e.insertionMode = T.IN_BODY;
      break;
    }
    case s.FRAMESET: {
      e._insertElement(t, L.HTML), e.insertionMode = T.IN_FRAMESET;
      break;
    }
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.SCRIPT:
    case s.STYLE:
    case s.TEMPLATE:
    case s.TITLE: {
      e._err(t, N.abandonedHeadElementChild), e.openElements.push(e.headElement, s.HEAD), Pe(e, t), e.openElements.remove(e.headElement);
      break;
    }
    case s.HEAD: {
      e._err(t, N.misplacedStartTagForHeadElement);
      break;
    }
    default:
      qt(e, t);
  }
}
function Dh(e, t) {
  switch (t.tagID) {
    case s.BODY:
    case s.HTML:
    case s.BR: {
      qt(e, t);
      break;
    }
    case s.TEMPLATE: {
      dt(e, t);
      break;
    }
    default:
      e._err(t, N.endTagWithoutMatchingOpenElement);
  }
}
function qt(e, t) {
  e._insertFakeElement(k.BODY, s.BODY), e.insertionMode = T.IN_BODY, Rn(e, t);
}
function Rn(e, t) {
  switch (t.type) {
    case X.CHARACTER: {
      Bu(e, t);
      break;
    }
    case X.WHITESPACE_CHARACTER: {
      Fu(e, t);
      break;
    }
    case X.COMMENT: {
      mr(e, t);
      break;
    }
    case X.START_TAG: {
      Ee(e, t);
      break;
    }
    case X.END_TAG: {
      Ln(e, t);
      break;
    }
    case X.EOF: {
      zu(e, t);
      break;
    }
  }
}
function Fu(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t);
}
function Bu(e, t) {
  e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1;
}
function Ph(e, t) {
  e.openElements.tmplCount === 0 && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs);
}
function Mh(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  n && e.openElements.tmplCount === 0 && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(n, t.attrs));
}
function Fh(e, t) {
  const n = e.openElements.tryPeekProperlyNestedBodyElement();
  e.framesetOk && n && (e.treeAdapter.detachNode(n), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, L.HTML), e.insertionMode = T.IN_FRAMESET);
}
function Bh(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, L.HTML);
}
function vh(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), ku(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, L.HTML);
}
function Hh(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, L.HTML), e.skipNextNewLine = !0, e.framesetOk = !1;
}
function Uh(e, t) {
  const n = e.openElements.tmplCount > 0;
  (!e.formElement || n) && (e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, L.HTML), n || (e.formElement = e.openElements.current));
}
function zh(e, t) {
  e.framesetOk = !1;
  const n = t.tagID;
  for (let r = e.openElements.stackTop; r >= 0; r--) {
    const a = e.openElements.tagIDs[r];
    if (n === s.LI && a === s.LI || (n === s.DD || n === s.DT) && (a === s.DD || a === s.DT)) {
      e.openElements.generateImpliedEndTagsWithExclusion(a), e.openElements.popUntilTagNamePopped(a);
      break;
    }
    if (a !== s.ADDRESS && a !== s.DIV && a !== s.P && e._isSpecialElement(e.openElements.items[r], a))
      break;
  }
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, L.HTML);
}
function Yh(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, L.HTML), e.tokenizer.state = de.PLAINTEXT;
}
function jh(e, t) {
  e.openElements.hasInScope(s.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(s.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, L.HTML), e.framesetOk = !1;
}
function Gh(e, t) {
  const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(k.A);
  n && (Br(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)), e._reconstructActiveFormattingElements(), e._insertElement(t, L.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function qh(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, L.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function $h(e, t) {
  e._reconstructActiveFormattingElements(), e.openElements.hasInScope(s.NOBR) && (Br(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, L.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t);
}
function Wh(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, L.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1;
}
function Vh(e, t) {
  e.treeAdapter.getDocumentMode(e.document) !== Se.QUIRKS && e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._insertElement(t, L.HTML), e.framesetOk = !1, e.insertionMode = T.IN_TABLE;
}
function vu(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, L.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function Hu(e) {
  const t = _u(e, Je.TYPE);
  return t != null && t.toLowerCase() === fh;
}
function Qh(e, t) {
  e._reconstructActiveFormattingElements(), e._appendElement(t, L.HTML), Hu(t) || (e.framesetOk = !1), t.ackSelfClosing = !0;
}
function Xh(e, t) {
  e._appendElement(t, L.HTML), t.ackSelfClosing = !0;
}
function Kh(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._appendElement(t, L.HTML), e.framesetOk = !1, t.ackSelfClosing = !0;
}
function Zh(e, t) {
  t.tagName = k.IMG, t.tagID = s.IMG, vu(e, t);
}
function Jh(e, t) {
  e._insertElement(t, L.HTML), e.skipNextNewLine = !0, e.tokenizer.state = de.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = T.TEXT;
}
function ep(e, t) {
  e.openElements.hasInButtonScope(s.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, de.RAWTEXT);
}
function tp(e, t) {
  e.framesetOk = !1, e._switchToTextParsing(t, de.RAWTEXT);
}
function ai(e, t) {
  e._switchToTextParsing(t, de.RAWTEXT);
}
function np(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, L.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === T.IN_TABLE || e.insertionMode === T.IN_CAPTION || e.insertionMode === T.IN_TABLE_BODY || e.insertionMode === T.IN_ROW || e.insertionMode === T.IN_CELL ? T.IN_SELECT_IN_TABLE : T.IN_SELECT;
}
function rp(e, t) {
  e.openElements.currentTagId === s.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, L.HTML);
}
function ap(e, t) {
  e.openElements.hasInScope(s.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, L.HTML);
}
function ip(e, t) {
  e.openElements.hasInScope(s.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(s.RTC), e._insertElement(t, L.HTML);
}
function up(e, t) {
  e._reconstructActiveFormattingElements(), Du(t), Fr(t), t.selfClosing ? e._appendElement(t, L.MATHML) : e._insertElement(t, L.MATHML), t.ackSelfClosing = !0;
}
function sp(e, t) {
  e._reconstructActiveFormattingElements(), Pu(t), Fr(t), t.selfClosing ? e._appendElement(t, L.SVG) : e._insertElement(t, L.SVG), t.ackSelfClosing = !0;
}
function ii(e, t) {
  e._reconstructActiveFormattingElements(), e._insertElement(t, L.HTML);
}
function Ee(e, t) {
  switch (t.tagID) {
    case s.I:
    case s.S:
    case s.B:
    case s.U:
    case s.EM:
    case s.TT:
    case s.BIG:
    case s.CODE:
    case s.FONT:
    case s.SMALL:
    case s.STRIKE:
    case s.STRONG: {
      qh(e, t);
      break;
    }
    case s.A: {
      Gh(e, t);
      break;
    }
    case s.H1:
    case s.H2:
    case s.H3:
    case s.H4:
    case s.H5:
    case s.H6: {
      vh(e, t);
      break;
    }
    case s.P:
    case s.DL:
    case s.OL:
    case s.UL:
    case s.DIV:
    case s.DIR:
    case s.NAV:
    case s.MAIN:
    case s.MENU:
    case s.ASIDE:
    case s.CENTER:
    case s.FIGURE:
    case s.FOOTER:
    case s.HEADER:
    case s.HGROUP:
    case s.DIALOG:
    case s.DETAILS:
    case s.ADDRESS:
    case s.ARTICLE:
    case s.SECTION:
    case s.SUMMARY:
    case s.FIELDSET:
    case s.BLOCKQUOTE:
    case s.FIGCAPTION: {
      Bh(e, t);
      break;
    }
    case s.LI:
    case s.DD:
    case s.DT: {
      zh(e, t);
      break;
    }
    case s.BR:
    case s.IMG:
    case s.WBR:
    case s.AREA:
    case s.EMBED:
    case s.KEYGEN: {
      vu(e, t);
      break;
    }
    case s.HR: {
      Kh(e, t);
      break;
    }
    case s.RB:
    case s.RTC: {
      ap(e, t);
      break;
    }
    case s.RT:
    case s.RP: {
      ip(e, t);
      break;
    }
    case s.PRE:
    case s.LISTING: {
      Hh(e, t);
      break;
    }
    case s.XMP: {
      ep(e, t);
      break;
    }
    case s.SVG: {
      sp(e, t);
      break;
    }
    case s.HTML: {
      Ph(e, t);
      break;
    }
    case s.BASE:
    case s.LINK:
    case s.META:
    case s.STYLE:
    case s.TITLE:
    case s.SCRIPT:
    case s.BGSOUND:
    case s.BASEFONT:
    case s.TEMPLATE: {
      Pe(e, t);
      break;
    }
    case s.BODY: {
      Mh(e, t);
      break;
    }
    case s.FORM: {
      Uh(e, t);
      break;
    }
    case s.NOBR: {
      $h(e, t);
      break;
    }
    case s.MATH: {
      up(e, t);
      break;
    }
    case s.TABLE: {
      Vh(e, t);
      break;
    }
    case s.INPUT: {
      Qh(e, t);
      break;
    }
    case s.PARAM:
    case s.TRACK:
    case s.SOURCE: {
      Xh(e, t);
      break;
    }
    case s.IMAGE: {
      Zh(e, t);
      break;
    }
    case s.BUTTON: {
      jh(e, t);
      break;
    }
    case s.APPLET:
    case s.OBJECT:
    case s.MARQUEE: {
      Wh(e, t);
      break;
    }
    case s.IFRAME: {
      tp(e, t);
      break;
    }
    case s.SELECT: {
      np(e, t);
      break;
    }
    case s.OPTION:
    case s.OPTGROUP: {
      rp(e, t);
      break;
    }
    case s.NOEMBED: {
      ai(e, t);
      break;
    }
    case s.FRAMESET: {
      Fh(e, t);
      break;
    }
    case s.TEXTAREA: {
      Jh(e, t);
      break;
    }
    case s.NOSCRIPT: {
      e.options.scriptingEnabled ? ai(e, t) : ii(e, t);
      break;
    }
    case s.PLAINTEXT: {
      Yh(e, t);
      break;
    }
    case s.COL:
    case s.TH:
    case s.TD:
    case s.TR:
    case s.HEAD:
    case s.FRAME:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.CAPTION:
    case s.COLGROUP:
      break;
    default:
      ii(e, t);
  }
}
function op(e, t) {
  if (e.openElements.hasInScope(s.BODY) && (e.insertionMode = T.AFTER_BODY, e.options.sourceCodeLocationInfo)) {
    const n = e.openElements.tryPeekProperlyNestedBodyElement();
    n && e._setEndLocation(n, t);
  }
}
function lp(e, t) {
  e.openElements.hasInScope(s.BODY) && (e.insertionMode = T.AFTER_BODY, Qu(e, t));
}
function cp(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n));
}
function dp(e) {
  const t = e.openElements.tmplCount > 0, { formElement: n } = e;
  t || (e.formElement = null), (n || t) && e.openElements.hasInScope(s.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(s.FORM) : n && e.openElements.remove(n));
}
function fp(e) {
  e.openElements.hasInButtonScope(s.P) || e._insertFakeElement(k.P, s.P), e._closePElement();
}
function hp(e) {
  e.openElements.hasInListItemScope(s.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(s.LI), e.openElements.popUntilTagNamePopped(s.LI));
}
function pp(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n));
}
function mp(e) {
  e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped());
}
function gp(e, t) {
  const n = t.tagID;
  e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker());
}
function bp(e) {
  e._reconstructActiveFormattingElements(), e._insertFakeElement(k.BR, s.BR), e.openElements.pop(), e.framesetOk = !1;
}
function Uu(e, t) {
  const n = t.tagName, r = t.tagID;
  for (let a = e.openElements.stackTop; a > 0; a--) {
    const u = e.openElements.items[a], i = e.openElements.tagIDs[a];
    if (r === i && (r !== s.UNKNOWN || e.treeAdapter.getTagName(u) === n)) {
      e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.stackTop >= a && e.openElements.shortenToLength(a);
      break;
    }
    if (e._isSpecialElement(u, i))
      break;
  }
}
function Ln(e, t) {
  switch (t.tagID) {
    case s.A:
    case s.B:
    case s.I:
    case s.S:
    case s.U:
    case s.EM:
    case s.TT:
    case s.BIG:
    case s.CODE:
    case s.FONT:
    case s.NOBR:
    case s.SMALL:
    case s.STRIKE:
    case s.STRONG: {
      Br(e, t);
      break;
    }
    case s.P: {
      fp(e);
      break;
    }
    case s.DL:
    case s.UL:
    case s.OL:
    case s.DIR:
    case s.DIV:
    case s.NAV:
    case s.PRE:
    case s.MAIN:
    case s.MENU:
    case s.ASIDE:
    case s.BUTTON:
    case s.CENTER:
    case s.FIGURE:
    case s.FOOTER:
    case s.HEADER:
    case s.HGROUP:
    case s.DIALOG:
    case s.ADDRESS:
    case s.ARTICLE:
    case s.DETAILS:
    case s.SECTION:
    case s.SUMMARY:
    case s.LISTING:
    case s.FIELDSET:
    case s.BLOCKQUOTE:
    case s.FIGCAPTION: {
      cp(e, t);
      break;
    }
    case s.LI: {
      hp(e);
      break;
    }
    case s.DD:
    case s.DT: {
      pp(e, t);
      break;
    }
    case s.H1:
    case s.H2:
    case s.H3:
    case s.H4:
    case s.H5:
    case s.H6: {
      mp(e);
      break;
    }
    case s.BR: {
      bp(e);
      break;
    }
    case s.BODY: {
      op(e, t);
      break;
    }
    case s.HTML: {
      lp(e, t);
      break;
    }
    case s.FORM: {
      dp(e);
      break;
    }
    case s.APPLET:
    case s.OBJECT:
    case s.MARQUEE: {
      gp(e, t);
      break;
    }
    case s.TEMPLATE: {
      dt(e, t);
      break;
    }
    default:
      Uu(e, t);
  }
}
function zu(e, t) {
  e.tmplInsertionModeStack.length > 0 ? Vu(e, t) : vr(e, t);
}
function Ep(e, t) {
  var n;
  t.tagID === s.SCRIPT && ((n = e.scriptHandler) === null || n === void 0 || n.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode;
}
function Tp(e, t) {
  e._err(t, N.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t);
}
function Xn(e, t) {
  if (Mu.has(e.openElements.currentTagId))
    switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = T.IN_TABLE_TEXT, t.type) {
      case X.CHARACTER: {
        ju(e, t);
        break;
      }
      case X.WHITESPACE_CHARACTER: {
        Yu(e, t);
        break;
      }
    }
  else
    en(e, t);
}
function yp(e, t) {
  e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, L.HTML), e.insertionMode = T.IN_CAPTION;
}
function Ap(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, L.HTML), e.insertionMode = T.IN_COLUMN_GROUP;
}
function _p(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(k.COLGROUP, s.COLGROUP), e.insertionMode = T.IN_COLUMN_GROUP, Hr(e, t);
}
function Cp(e, t) {
  e.openElements.clearBackToTableContext(), e._insertElement(t, L.HTML), e.insertionMode = T.IN_TABLE_BODY;
}
function xp(e, t) {
  e.openElements.clearBackToTableContext(), e._insertFakeElement(k.TBODY, s.TBODY), e.insertionMode = T.IN_TABLE_BODY, On(e, t);
}
function kp(e, t) {
  e.openElements.hasInTableScope(s.TABLE) && (e.openElements.popUntilTagNamePopped(s.TABLE), e._resetInsertionMode(), e._processStartTag(t));
}
function Ip(e, t) {
  Hu(t) ? e._appendElement(t, L.HTML) : en(e, t), t.ackSelfClosing = !0;
}
function Sp(e, t) {
  !e.formElement && e.openElements.tmplCount === 0 && (e._insertElement(t, L.HTML), e.formElement = e.openElements.current, e.openElements.pop());
}
function Ct(e, t) {
  switch (t.tagID) {
    case s.TD:
    case s.TH:
    case s.TR: {
      xp(e, t);
      break;
    }
    case s.STYLE:
    case s.SCRIPT:
    case s.TEMPLATE: {
      Pe(e, t);
      break;
    }
    case s.COL: {
      _p(e, t);
      break;
    }
    case s.FORM: {
      Sp(e, t);
      break;
    }
    case s.TABLE: {
      kp(e, t);
      break;
    }
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      Cp(e, t);
      break;
    }
    case s.INPUT: {
      Ip(e, t);
      break;
    }
    case s.CAPTION: {
      yp(e, t);
      break;
    }
    case s.COLGROUP: {
      Ap(e, t);
      break;
    }
    default:
      en(e, t);
  }
}
function Vt(e, t) {
  switch (t.tagID) {
    case s.TABLE: {
      e.openElements.hasInTableScope(s.TABLE) && (e.openElements.popUntilTagNamePopped(s.TABLE), e._resetInsertionMode());
      break;
    }
    case s.TEMPLATE: {
      dt(e, t);
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TBODY:
    case s.TD:
    case s.TFOOT:
    case s.TH:
    case s.THEAD:
    case s.TR:
      break;
    default:
      en(e, t);
  }
}
function en(e, t) {
  const n = e.fosterParentingEnabled;
  e.fosterParentingEnabled = !0, Rn(e, t), e.fosterParentingEnabled = n;
}
function Yu(e, t) {
  e.pendingCharacterTokens.push(t);
}
function ju(e, t) {
  e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0;
}
function Ft(e, t) {
  let n = 0;
  if (e.hasNonWhitespacePendingCharacterToken)
    for (; n < e.pendingCharacterTokens.length; n++)
      en(e, e.pendingCharacterTokens[n]);
  else
    for (; n < e.pendingCharacterTokens.length; n++)
      e._insertCharacters(e.pendingCharacterTokens[n]);
  e.insertionMode = e.originalInsertionMode, e._processToken(t);
}
const Gu = /* @__PURE__ */ new Set([s.CAPTION, s.COL, s.COLGROUP, s.TBODY, s.TD, s.TFOOT, s.TH, s.THEAD, s.TR]);
function Np(e, t) {
  const n = t.tagID;
  Gu.has(n) ? e.openElements.hasInTableScope(s.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(s.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = T.IN_TABLE, Ct(e, t)) : Ee(e, t);
}
function Rp(e, t) {
  const n = t.tagID;
  switch (n) {
    case s.CAPTION:
    case s.TABLE: {
      e.openElements.hasInTableScope(s.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(s.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = T.IN_TABLE, n === s.TABLE && Vt(e, t));
      break;
    }
    case s.BODY:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TBODY:
    case s.TD:
    case s.TFOOT:
    case s.TH:
    case s.THEAD:
    case s.TR:
      break;
    default:
      Ln(e, t);
  }
}
function Hr(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee(e, t);
      break;
    }
    case s.COL: {
      e._appendElement(t, L.HTML), t.ackSelfClosing = !0;
      break;
    }
    case s.TEMPLATE: {
      Pe(e, t);
      break;
    }
    default:
      Tn(e, t);
  }
}
function Lp(e, t) {
  switch (t.tagID) {
    case s.COLGROUP: {
      e.openElements.currentTagId === s.COLGROUP && (e.openElements.pop(), e.insertionMode = T.IN_TABLE);
      break;
    }
    case s.TEMPLATE: {
      dt(e, t);
      break;
    }
    case s.COL:
      break;
    default:
      Tn(e, t);
  }
}
function Tn(e, t) {
  e.openElements.currentTagId === s.COLGROUP && (e.openElements.pop(), e.insertionMode = T.IN_TABLE, e._processToken(t));
}
function On(e, t) {
  switch (t.tagID) {
    case s.TR: {
      e.openElements.clearBackToTableBodyContext(), e._insertElement(t, L.HTML), e.insertionMode = T.IN_ROW;
      break;
    }
    case s.TH:
    case s.TD: {
      e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(k.TR, s.TR), e.insertionMode = T.IN_ROW, wn(e, t);
      break;
    }
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE, Ct(e, t));
      break;
    }
    default:
      Ct(e, t);
  }
}
function gr(e, t) {
  const n = t.tagID;
  switch (t.tagID) {
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e.openElements.hasInTableScope(n) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE);
      break;
    }
    case s.TABLE: {
      e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE, Vt(e, t));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TD:
    case s.TH:
    case s.TR:
      break;
    default:
      Vt(e, t);
  }
}
function wn(e, t) {
  switch (t.tagID) {
    case s.TH:
    case s.TD: {
      e.openElements.clearBackToTableRowContext(), e._insertElement(t, L.HTML), e.insertionMode = T.IN_CELL, e.activeFormattingElements.insertMarker();
      break;
    }
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.TR: {
      e.openElements.hasInTableScope(s.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE_BODY, On(e, t));
      break;
    }
    default:
      Ct(e, t);
  }
}
function qu(e, t) {
  switch (t.tagID) {
    case s.TR: {
      e.openElements.hasInTableScope(s.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE_BODY);
      break;
    }
    case s.TABLE: {
      e.openElements.hasInTableScope(s.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE_BODY, gr(e, t));
      break;
    }
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(s.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = T.IN_TABLE_BODY, gr(e, t));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TD:
    case s.TH:
      break;
    default:
      Vt(e, t);
  }
}
function Op(e, t) {
  const n = t.tagID;
  Gu.has(n) ? (e.openElements.hasInTableScope(s.TD) || e.openElements.hasInTableScope(s.TH)) && (e._closeTableCell(), wn(e, t)) : Ee(e, t);
}
function wp(e, t) {
  const n = t.tagID;
  switch (n) {
    case s.TD:
    case s.TH: {
      e.openElements.hasInTableScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = T.IN_ROW);
      break;
    }
    case s.TABLE:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.TR: {
      e.openElements.hasInTableScope(n) && (e._closeTableCell(), qu(e, t));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
      break;
    default:
      Ln(e, t);
  }
}
function $u(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee(e, t);
      break;
    }
    case s.OPTION: {
      e.openElements.currentTagId === s.OPTION && e.openElements.pop(), e._insertElement(t, L.HTML);
      break;
    }
    case s.OPTGROUP: {
      e.openElements.currentTagId === s.OPTION && e.openElements.pop(), e.openElements.currentTagId === s.OPTGROUP && e.openElements.pop(), e._insertElement(t, L.HTML);
      break;
    }
    case s.INPUT:
    case s.KEYGEN:
    case s.TEXTAREA:
    case s.SELECT: {
      e.openElements.hasInSelectScope(s.SELECT) && (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode(), t.tagID !== s.SELECT && e._processStartTag(t));
      break;
    }
    case s.SCRIPT:
    case s.TEMPLATE: {
      Pe(e, t);
      break;
    }
  }
}
function Wu(e, t) {
  switch (t.tagID) {
    case s.OPTGROUP: {
      e.openElements.stackTop > 0 && e.openElements.currentTagId === s.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === s.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === s.OPTGROUP && e.openElements.pop();
      break;
    }
    case s.OPTION: {
      e.openElements.currentTagId === s.OPTION && e.openElements.pop();
      break;
    }
    case s.SELECT: {
      e.openElements.hasInSelectScope(s.SELECT) && (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode());
      break;
    }
    case s.TEMPLATE: {
      dt(e, t);
      break;
    }
  }
}
function Dp(e, t) {
  const n = t.tagID;
  n === s.CAPTION || n === s.TABLE || n === s.TBODY || n === s.TFOOT || n === s.THEAD || n === s.TR || n === s.TD || n === s.TH ? (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : $u(e, t);
}
function Pp(e, t) {
  const n = t.tagID;
  n === s.CAPTION || n === s.TABLE || n === s.TBODY || n === s.TFOOT || n === s.THEAD || n === s.TR || n === s.TD || n === s.TH ? e.openElements.hasInTableScope(n) && (e.openElements.popUntilTagNamePopped(s.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : Wu(e, t);
}
function Mp(e, t) {
  switch (t.tagID) {
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.SCRIPT:
    case s.STYLE:
    case s.TEMPLATE:
    case s.TITLE: {
      Pe(e, t);
      break;
    }
    case s.CAPTION:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e.tmplInsertionModeStack[0] = T.IN_TABLE, e.insertionMode = T.IN_TABLE, Ct(e, t);
      break;
    }
    case s.COL: {
      e.tmplInsertionModeStack[0] = T.IN_COLUMN_GROUP, e.insertionMode = T.IN_COLUMN_GROUP, Hr(e, t);
      break;
    }
    case s.TR: {
      e.tmplInsertionModeStack[0] = T.IN_TABLE_BODY, e.insertionMode = T.IN_TABLE_BODY, On(e, t);
      break;
    }
    case s.TD:
    case s.TH: {
      e.tmplInsertionModeStack[0] = T.IN_ROW, e.insertionMode = T.IN_ROW, wn(e, t);
      break;
    }
    default:
      e.tmplInsertionModeStack[0] = T.IN_BODY, e.insertionMode = T.IN_BODY, Ee(e, t);
  }
}
function Fp(e, t) {
  t.tagID === s.TEMPLATE && dt(e, t);
}
function Vu(e, t) {
  e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(s.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : vr(e, t);
}
function Bp(e, t) {
  t.tagID === s.HTML ? Ee(e, t) : yn(e, t);
}
function Qu(e, t) {
  var n;
  if (t.tagID === s.HTML) {
    if (e.fragmentContext || (e.insertionMode = T.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === s.HTML) {
      e._setEndLocation(e.openElements.items[0], t);
      const r = e.openElements.items[1];
      r && !(!((n = e.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag) && e._setEndLocation(r, t);
    }
  } else
    yn(e, t);
}
function yn(e, t) {
  e.insertionMode = T.IN_BODY, Rn(e, t);
}
function vp(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee(e, t);
      break;
    }
    case s.FRAMESET: {
      e._insertElement(t, L.HTML);
      break;
    }
    case s.FRAME: {
      e._appendElement(t, L.HTML), t.ackSelfClosing = !0;
      break;
    }
    case s.NOFRAMES: {
      Pe(e, t);
      break;
    }
  }
}
function Hp(e, t) {
  t.tagID === s.FRAMESET && !e.openElements.isRootHtmlElementCurrent() && (e.openElements.pop(), !e.fragmentContext && e.openElements.currentTagId !== s.FRAMESET && (e.insertionMode = T.AFTER_FRAMESET));
}
function Up(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee(e, t);
      break;
    }
    case s.NOFRAMES: {
      Pe(e, t);
      break;
    }
  }
}
function zp(e, t) {
  t.tagID === s.HTML && (e.insertionMode = T.AFTER_AFTER_FRAMESET);
}
function Yp(e, t) {
  t.tagID === s.HTML ? Ee(e, t) : fn(e, t);
}
function fn(e, t) {
  e.insertionMode = T.IN_BODY, Rn(e, t);
}
function jp(e, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee(e, t);
      break;
    }
    case s.NOFRAMES: {
      Pe(e, t);
      break;
    }
  }
}
function Gp(e, t) {
  t.chars = le, e._insertCharacters(t);
}
function qp(e, t) {
  e._insertCharacters(t), e.framesetOk = !1;
}
function Xu(e) {
  for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== L.HTML && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current); )
    e.openElements.pop();
}
function $p(e, t) {
  if (sh(t))
    Xu(e), e._startTagOutsideForeignContent(t);
  else {
    const n = e._getAdjustedCurrentElement(), r = e.treeAdapter.getNamespaceURI(n);
    r === L.MATHML ? Du(t) : r === L.SVG && (oh(t), Pu(t)), Fr(t), t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r), t.ackSelfClosing = !0;
  }
}
function Wp(e, t) {
  if (t.tagID === s.P || t.tagID === s.BR) {
    Xu(e), e._endTagOutsideForeignContent(t);
    return;
  }
  for (let n = e.openElements.stackTop; n > 0; n--) {
    const r = e.openElements.items[n];
    if (e.treeAdapter.getNamespaceURI(r) === L.HTML) {
      e._endTagOutsideForeignContent(t);
      break;
    }
    const a = e.treeAdapter.getTagName(r);
    if (a.toLowerCase() === t.tagName) {
      t.tagName = a, e.openElements.shortenToLength(n);
      break;
    }
  }
}
k.AREA, k.BASE, k.BASEFONT, k.BGSOUND, k.BR, k.COL, k.EMBED, k.FRAME, k.HR, k.IMG, k.INPUT, k.KEYGEN, k.LINK, k.META, k.PARAM, k.SOURCE, k.TRACK, k.WBR;
const Vp = /* @__PURE__ */ new Set([
  "mdxFlowExpression",
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "mdxjsEsm"
]), ui = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 };
function Ku(e, t) {
  const n = am(e), r = bu("type", {
    handlers: { root: Qp, element: Xp, text: Kp, comment: Ju, doctype: Zp, raw: em },
    unknown: tm
  }), a = {
    parser: n ? new ri(ui) : ri.getFragmentParser(void 0, ui),
    handle(o) {
      r(o, a);
    },
    stitches: !1,
    options: t || {}
  };
  r(e, a), Rt(a, Ye());
  const u = n ? a.parser.document : a.parser.getFragment(), i = uf(u, {
    // To do: support `space`?
    file: a.options.file
  });
  return a.stitches && Zt(i, "comment", function(o, l, c) {
    const f = (
      /** @type {Stitch} */
      /** @type {unknown} */
      o
    );
    if (f.value.stitch && c && l !== void 0) {
      const d = c.children;
      return d[l] = f.value.stitch, l;
    }
  }), i.type === "root" && i.children.length === 1 && i.children[0].type === e.type ? i.children[0] : i;
}
function Zu(e, t) {
  let n = -1;
  if (e)
    for (; ++n < e.length; )
      t.handle(e[n]);
}
function Qp(e, t) {
  Zu(e.children, t);
}
function Xp(e, t) {
  nm(e, t), Zu(e.children, t), rm(e, t);
}
function Kp(e, t) {
  t.parser.tokenizer.state > 4 && (t.parser.tokenizer.state = 0);
  const n = {
    type: X.CHARACTER,
    chars: e.value,
    location: tn(e)
  };
  Rt(t, Ye(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken);
}
function Zp(e, t) {
  const n = {
    type: X.DOCTYPE,
    name: "html",
    forceQuirks: !1,
    publicId: "",
    systemId: "",
    location: tn(e)
  };
  Rt(t, Ye(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken);
}
function Jp(e, t) {
  t.stitches = !0;
  const n = im(e);
  if ("children" in e && "children" in n) {
    const r = (
      /** @type {Root} */
      Ku({ type: "root", children: e.children }, t.options)
    );
    n.children = r.children;
  }
  Ju({ type: "comment", value: { stitch: n } }, t);
}
function Ju(e, t) {
  const n = e.value, r = {
    type: X.COMMENT,
    data: n,
    location: tn(e)
  };
  Rt(t, Ye(e)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken);
}
function em(e, t) {
  if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = !1, t.parser.tokenizer.preprocessor.lastChunkWritten = !1, t.parser.tokenizer.preprocessor.endOfChunkHit = !1, t.parser.tokenizer.preprocessor.isEol = !1, es(t, Ye(e)), t.parser.tokenizer.write(e.value, !1), t.parser.tokenizer._runParsingLoop(), t.parser.tokenizer.state === 72 || t.parser.tokenizer.state === 78) {
    t.parser.tokenizer.preprocessor.lastChunkWritten = !0;
    const n = t.parser.tokenizer._consume();
    t.parser.tokenizer._callState(n);
  }
}
function tm(e, t) {
  const n = (
    /** @type {Nodes} */
    e
  );
  if (t.options.passThrough && t.options.passThrough.includes(n.type))
    Jp(n, t);
  else {
    let r = "";
    throw Vp.has(n.type) && (r = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + r);
  }
}
function Rt(e, t) {
  es(e, t);
  const n = e.parser.tokenizer.currentCharacterToken;
  n && n.location && (n.location.endLine = e.parser.tokenizer.preprocessor.line, n.location.endCol = e.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1, e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken)), e.parser.tokenizer.paused = !1, e.parser.tokenizer.inLoop = !1, e.parser.tokenizer.active = !1, e.parser.tokenizer.returnState = de.DATA, e.parser.tokenizer.charRefCode = -1, e.parser.tokenizer.consumedAfterSnapshot = -1, e.parser.tokenizer.currentLocation = null, e.parser.tokenizer.currentCharacterToken = null, e.parser.tokenizer.currentToken = null, e.parser.tokenizer.currentAttr = { name: "", value: "" };
}
function es(e, t) {
  if (t && t.offset !== void 0) {
    const n = {
      startLine: t.line,
      startCol: t.column,
      startOffset: t.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    e.parser.tokenizer.preprocessor.lineStartPos = -t.column + 1, e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e.parser.tokenizer.preprocessor.line = t.line, e.parser.tokenizer.currentLocation = n;
  }
}
function nm(e, t) {
  const n = e.tagName.toLowerCase();
  if (t.parser.tokenizer.state === de.PLAINTEXT) return;
  Rt(t, Ye(e));
  const r = t.parser.openElements.current;
  let a = "namespaceURI" in r ? r.namespaceURI : ot.html;
  a === ot.html && n === "svg" && (a = ot.svg);
  const u = df(
    // Shallow clone to not delve into `children`: we only need the attributes.
    { ...e, children: [] },
    { space: a === ot.svg ? "svg" : "html" }
  ), i = {
    type: X.START_TAG,
    tagName: n,
    tagID: Nt(n),
    // We always send start and end tags.
    selfClosing: !1,
    ackSelfClosing: !1,
    // Always element.
    /* c8 ignore next */
    attrs: "attrs" in u ? u.attrs : [],
    location: tn(e)
  };
  t.parser.currentToken = i, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = n;
}
function rm(e, t) {
  const n = e.tagName.toLowerCase();
  if (!t.parser.tokenizer.inForeignNode && Tf.includes(n) || t.parser.tokenizer.state === de.PLAINTEXT) return;
  Rt(t, Cn(e));
  const r = {
    type: X.END_TAG,
    tagName: n,
    tagID: Nt(n),
    selfClosing: !1,
    ackSelfClosing: !1,
    attrs: [],
    location: tn(e)
  };
  t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken), // Current element is closed.
  n === t.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
  (t.parser.tokenizer.state === de.RCDATA || // `<iframe>`, `<noembed>`, `<style>`, `<xmp>`
  t.parser.tokenizer.state === de.RAWTEXT || // `<script>`
  t.parser.tokenizer.state === de.SCRIPT_DATA) && (t.parser.tokenizer.state = de.DATA);
}
function am(e) {
  const t = e.type === "root" ? e.children[0] : e;
  return !!(t && (t.type === "doctype" || t.type === "element" && t.tagName.toLowerCase() === "html"));
}
function tn(e) {
  const t = Ye(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  }, n = Cn(e) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  return {
    startLine: t.line,
    startCol: t.column,
    startOffset: t.offset,
    endLine: n.line,
    endCol: n.column,
    endOffset: n.offset
  };
}
function im(e) {
  return "children" in e ? _t({ ...e, children: [] }) : _t(e);
}
function um(e) {
  return function(t, n) {
    return (
      /** @type {Root} */
      Ku(t, { ...e, file: n })
    );
  };
}
function si(e, t) {
  const n = String(e);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, a = n.indexOf(t);
  for (; a !== -1; )
    r++, a = n.indexOf(t, a + t.length);
  return r;
}
function sm(e, t, n) {
  const a = Sn((n || {}).ignore || []), u = om(t);
  let i = -1;
  for (; ++i < u.length; )
    du(e, "text", o);
  function o(c, f) {
    let d = -1, b;
    for (; ++d < f.length; ) {
      const m = f[d], h = b ? b.children : void 0;
      if (a(
        m,
        h ? h.indexOf(m) : void 0,
        b
      ))
        return;
      b = m;
    }
    if (b)
      return l(c, f);
  }
  function l(c, f) {
    const d = f[f.length - 1], b = u[i][0], m = u[i][1];
    let h = 0;
    const y = d.children.indexOf(c);
    let _ = !1, x = [];
    b.lastIndex = 0;
    let I = b.exec(c.value);
    for (; I; ) {
      const M = I.index, B = {
        index: I.index,
        input: I.input,
        stack: [...f, c]
      };
      let R = m(...I, B);
      if (typeof R == "string" && (R = R.length > 0 ? { type: "text", value: R } : void 0), R === !1 ? b.lastIndex = M + 1 : (h !== M && x.push({
        type: "text",
        value: c.value.slice(h, M)
      }), Array.isArray(R) ? x.push(...R) : R && x.push(R), h = M + I[0].length, _ = !0), !b.global)
        break;
      I = b.exec(c.value);
    }
    return _ ? (h < c.value.length && x.push({ type: "text", value: c.value.slice(h) }), d.children.splice(y, 1, ...x)) : x = [c], y + x.length;
  }
}
function om(e) {
  const t = [];
  if (!Array.isArray(e))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n = !e[0] || Array.isArray(e[0]) ? e : [e];
  let r = -1;
  for (; ++r < n.length; ) {
    const a = n[r];
    t.push([lm(a[0]), cm(a[1])]);
  }
  return t;
}
function lm(e) {
  return typeof e == "string" ? new RegExp(js(e), "g") : e;
}
function cm(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}
const Kn = "phrasing", Zn = ["autolink", "link", "image", "label"];
function dm() {
  return {
    transforms: [Em],
    enter: {
      literalAutolink: hm,
      literalAutolinkEmail: Jn,
      literalAutolinkHttp: Jn,
      literalAutolinkWww: Jn
    },
    exit: {
      literalAutolink: bm,
      literalAutolinkEmail: gm,
      literalAutolinkHttp: pm,
      literalAutolinkWww: mm
    }
  };
}
function fm() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: Kn,
        notInConstruct: Zn
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: Kn,
        notInConstruct: Zn
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: Kn,
        notInConstruct: Zn
      }
    ]
  };
}
function hm(e) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e);
}
function Jn(e) {
  this.config.enter.autolinkProtocol.call(this, e);
}
function pm(e) {
  this.config.exit.autolinkProtocol.call(this, e);
}
function mm(e) {
  this.config.exit.data.call(this, e);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e);
}
function gm(e) {
  this.config.exit.autolinkEmail.call(this, e);
}
function bm(e) {
  this.exit(e);
}
function Em(e) {
  sm(
    e,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, Tm],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, ym]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function Tm(e, t, n, r, a) {
  let u = "";
  if (!ts(a) || (/^w/i.test(t) && (n = t + n, t = "", u = "http://"), !Am(n)))
    return !1;
  const i = _m(n + r);
  if (!i[0]) return !1;
  const o = {
    type: "link",
    title: null,
    url: u + t + i[0],
    children: [{ type: "text", value: t + i[0] }]
  };
  return i[1] ? [o, { type: "text", value: i[1] }] : o;
}
function ym(e, t, n, r) {
  return (
    // Not an expected previous character.
    !ts(r, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(n) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n,
      children: [{ type: "text", value: t + "@" + n }]
    }
  );
}
function Am(e) {
  const t = e.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function _m(e) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e);
  if (!t)
    return [e, void 0];
  e = e.slice(0, t.index);
  let n = t[0], r = n.indexOf(")");
  const a = si(e, "(");
  let u = si(e, ")");
  for (; r !== -1 && a > u; )
    e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), u++;
  return [e, n];
}
function ts(e, t) {
  const n = e.input.charCodeAt(e.index - 1);
  return (e.index === 0 || lt(n) || xn(n)) && (!t || n !== 47);
}
ns.peek = Dm;
function Cm() {
  return {
    enter: {
      gfmFootnoteDefinition: km,
      gfmFootnoteDefinitionLabelString: Im,
      gfmFootnoteCall: Rm,
      gfmFootnoteCallString: Lm
    },
    exit: {
      gfmFootnoteDefinition: Nm,
      gfmFootnoteDefinitionLabelString: Sm,
      gfmFootnoteCall: wm,
      gfmFootnoteCallString: Om
    }
  };
}
function xm() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: Pm, footnoteReference: ns }
  };
}
function km(e) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e
  );
}
function Im() {
  this.buffer();
}
function Sm(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = De(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function Nm(e) {
  this.exit(e);
}
function Rm(e) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e);
}
function Lm() {
  this.buffer();
}
function Om(e) {
  const t = this.resume(), n = this.stack[this.stack.length - 1];
  n.type, n.label = t, n.identifier = De(
    this.sliceSerialize(e)
  ).toLowerCase();
}
function wm(e) {
  this.exit(e);
}
function ns(e, t, n, r) {
  const a = n.createTracker(r);
  let u = a.move("[^");
  const i = n.enter("footnoteReference"), o = n.enter("reference");
  return u += a.move(
    n.safe(n.associationId(e), {
      ...a.current(),
      before: u,
      after: "]"
    })
  ), o(), i(), u += a.move("]"), u;
}
function Dm() {
  return "[";
}
function Pm(e, t, n, r) {
  const a = n.createTracker(r);
  let u = a.move("[^");
  const i = n.enter("footnoteDefinition"), o = n.enter("label");
  return u += a.move(
    n.safe(n.associationId(e), {
      ...a.current(),
      before: u,
      after: "]"
    })
  ), o(), u += a.move(
    "]:" + (e.children && e.children.length > 0 ? " " : "")
  ), a.shift(4), u += a.move(
    n.indentLines(n.containerFlow(e, a.current()), Mm)
  ), i(), u;
}
function Mm(e, t, n) {
  return t === 0 ? e : (n ? "" : "    ") + e;
}
const Fm = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
rs.peek = zm;
function Bm() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Hm },
    exit: { strikethrough: Um }
  };
}
function vm() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Fm
      }
    ],
    handlers: { delete: rs }
  };
}
function Hm(e) {
  this.enter({ type: "delete", children: [] }, e);
}
function Um(e) {
  this.exit(e);
}
function rs(e, t, n, r) {
  const a = n.createTracker(r), u = n.enter("strikethrough");
  let i = a.move("~~");
  return i += n.containerPhrasing(e, {
    ...a.current(),
    before: i,
    after: "~"
  }), i += a.move("~~"), u(), i;
}
function zm() {
  return "~";
}
function Ym(e, t = {}) {
  const n = (t.align || []).concat(), r = t.stringLength || Gm, a = [], u = [], i = [], o = [];
  let l = 0, c = -1;
  for (; ++c < e.length; ) {
    const h = [], E = [];
    let y = -1;
    for (e[c].length > l && (l = e[c].length); ++y < e[c].length; ) {
      const _ = jm(e[c][y]);
      if (t.alignDelimiters !== !1) {
        const x = r(_);
        E[y] = x, (o[y] === void 0 || x > o[y]) && (o[y] = x);
      }
      h.push(_);
    }
    u[c] = h, i[c] = E;
  }
  let f = -1;
  if (typeof n == "object" && "length" in n)
    for (; ++f < l; )
      a[f] = oi(n[f]);
  else {
    const h = oi(n);
    for (; ++f < l; )
      a[f] = h;
  }
  f = -1;
  const d = [], b = [];
  for (; ++f < l; ) {
    const h = a[f];
    let E = "", y = "";
    h === 99 ? (E = ":", y = ":") : h === 108 ? E = ":" : h === 114 && (y = ":");
    let _ = t.alignDelimiters === !1 ? 1 : Math.max(
      1,
      o[f] - E.length - y.length
    );
    const x = E + "-".repeat(_) + y;
    t.alignDelimiters !== !1 && (_ = E.length + _ + y.length, _ > o[f] && (o[f] = _), b[f] = _), d[f] = x;
  }
  u.splice(1, 0, d), i.splice(1, 0, b), c = -1;
  const m = [];
  for (; ++c < u.length; ) {
    const h = u[c], E = i[c];
    f = -1;
    const y = [];
    for (; ++f < l; ) {
      const _ = h[f] || "";
      let x = "", I = "";
      if (t.alignDelimiters !== !1) {
        const M = o[f] - (E[f] || 0), B = a[f];
        B === 114 ? x = " ".repeat(M) : B === 99 ? M % 2 ? (x = " ".repeat(M / 2 + 0.5), I = " ".repeat(M / 2 - 0.5)) : (x = " ".repeat(M / 2), I = x) : I = " ".repeat(M);
      }
      t.delimiterStart !== !1 && !f && y.push("|"), t.padding !== !1 && // Dont add the opening space if were not aligning and the cell is
      // empty: there will be a closing space.
      !(t.alignDelimiters === !1 && _ === "") && (t.delimiterStart !== !1 || f) && y.push(" "), t.alignDelimiters !== !1 && y.push(x), y.push(_), t.alignDelimiters !== !1 && y.push(I), t.padding !== !1 && y.push(" "), (t.delimiterEnd !== !1 || f !== l - 1) && y.push("|");
    }
    m.push(
      t.delimiterEnd === !1 ? y.join("").replace(/ +$/, "") : y.join("")
    );
  }
  return m.join(`
`);
}
function jm(e) {
  return e == null ? "" : String(e);
}
function Gm(e) {
  return e.length;
}
function oi(e) {
  const t = typeof e == "string" ? e.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function qm(e, t, n, r) {
  const a = n.enter("blockquote"), u = n.createTracker(r);
  u.move("> "), u.shift(2);
  const i = n.indentLines(
    n.containerFlow(e, u.current()),
    $m
  );
  return a(), i;
}
function $m(e, t, n) {
  return ">" + (n ? "" : " ") + e;
}
function Wm(e, t) {
  return li(e, t.inConstruct, !0) && !li(e, t.notInConstruct, !1);
}
function li(e, t, n) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n;
  let r = -1;
  for (; ++r < t.length; )
    if (e.includes(t[r]))
      return !0;
  return !1;
}
function ci(e, t, n, r) {
  let a = -1;
  for (; ++a < n.unsafe.length; )
    if (n.unsafe[a].character === `
` && Wm(n.stack, n.unsafe[a]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function Vm(e, t) {
  const n = String(e);
  let r = n.indexOf(t), a = r, u = 0, i = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === a ? ++u > i && (i = u) : u = 1, a = r + t.length, r = n.indexOf(t, a);
  return i;
}
function Qm(e, t) {
  return !!(t.options.fences === !1 && e.value && // If theres no info
  !e.lang && // And theres a non-whitespace character
  /[^ \r\n]/.test(e.value) && // And the value doesnt start or end in a blank
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value));
}
function Xm(e) {
  const t = e.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function Km(e, t, n, r) {
  const a = Xm(n), u = e.value || "", i = a === "`" ? "GraveAccent" : "Tilde";
  if (Qm(e, n)) {
    const d = n.enter("codeIndented"), b = n.indentLines(u, Zm);
    return d(), b;
  }
  const o = n.createTracker(r), l = a.repeat(Math.max(Vm(u, a) + 1, 3)), c = n.enter("codeFenced");
  let f = o.move(l);
  if (e.lang) {
    const d = n.enter(`codeFencedLang${i}`);
    f += o.move(
      n.safe(e.lang, {
        before: f,
        after: " ",
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  if (e.lang && e.meta) {
    const d = n.enter(`codeFencedMeta${i}`);
    f += o.move(" "), f += o.move(
      n.safe(e.meta, {
        before: f,
        after: `
`,
        encode: ["`"],
        ...o.current()
      })
    ), d();
  }
  return f += o.move(`
`), u && (f += o.move(u + `
`)), f += o.move(l), c(), f;
}
function Zm(e, t, n) {
  return (n ? "" : "    ") + e;
}
function Ur(e) {
  const t = e.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function Jm(e, t, n, r) {
  const a = Ur(n), u = a === '"' ? "Quote" : "Apostrophe", i = n.enter("definition");
  let o = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("[");
  return c += l.move(
    n.safe(n.associationId(e), {
      before: c,
      after: "]",
      ...l.current()
    })
  ), c += l.move("]: "), o(), // If theres no url, or
  !e.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (o = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : `
`,
      ...l.current()
    })
  )), o(), e.title && (o = n.enter(`title${u}`), c += l.move(" " + a), c += l.move(
    n.safe(e.title, {
      before: c,
      after: a,
      ...l.current()
    })
  ), c += l.move(a), o()), i(), c;
}
function eg(e) {
  const t = e.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
as.peek = tg;
function as(e, t, n, r) {
  const a = eg(n), u = n.enter("emphasis"), i = n.createTracker(r);
  let o = i.move(a);
  return o += i.move(
    n.containerPhrasing(e, {
      before: o,
      after: a,
      ...i.current()
    })
  ), o += i.move(a), u(), o;
}
function tg(e, t, n) {
  return n.options.emphasis || "*";
}
function ng(e, t) {
  let n = !1;
  return Zt(e, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n = !0, sr;
  }), !!((!e.depth || e.depth < 3) && Ir(e) && (t.options.setext || n));
}
function rg(e, t, n, r) {
  const a = Math.max(Math.min(6, e.depth || 1), 1), u = n.createTracker(r);
  if (ng(e, n)) {
    const f = n.enter("headingSetext"), d = n.enter("phrasing"), b = n.containerPhrasing(e, {
      ...u.current(),
      before: `
`,
      after: `
`
    });
    return d(), f(), b + `
` + (a === 1 ? "=" : "-").repeat(
      // The whole size
      b.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)
      (Math.max(b.lastIndexOf("\r"), b.lastIndexOf(`
`)) + 1)
    );
  }
  const i = "#".repeat(a), o = n.enter("headingAtx"), l = n.enter("phrasing");
  u.move(i + " ");
  let c = n.containerPhrasing(e, {
    before: "# ",
    after: `
`,
    ...u.current()
  });
  return /^[\t ]/.test(c) && (c = "&#x" + c.charCodeAt(0).toString(16).toUpperCase() + ";" + c.slice(1)), c = c ? i + " " + c : i, n.options.closeAtx && (c += " " + i), l(), o(), c;
}
is.peek = ag;
function is(e) {
  return e.value || "";
}
function ag() {
  return "<";
}
us.peek = ig;
function us(e, t, n, r) {
  const a = Ur(n), u = a === '"' ? "Quote" : "Apostrophe", i = n.enter("image");
  let o = n.enter("label");
  const l = n.createTracker(r);
  let c = l.move("![");
  return c += l.move(
    n.safe(e.alt, { before: c, after: "]", ...l.current() })
  ), c += l.move("]("), o(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(
    n.safe(e.url, { before: c, after: ">", ...l.current() })
  ), c += l.move(">")) : (o = n.enter("destinationRaw"), c += l.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...l.current()
    })
  )), o(), e.title && (o = n.enter(`title${u}`), c += l.move(" " + a), c += l.move(
    n.safe(e.title, {
      before: c,
      after: a,
      ...l.current()
    })
  ), c += l.move(a), o()), c += l.move(")"), i(), c;
}
function ig() {
  return "!";
}
ss.peek = ug;
function ss(e, t, n, r) {
  const a = e.referenceType, u = n.enter("imageReference");
  let i = n.enter("label");
  const o = n.createTracker(r);
  let l = o.move("![");
  const c = n.safe(e.alt, {
    before: l,
    after: "]",
    ...o.current()
  });
  l += o.move(c + "]["), i();
  const f = n.stack;
  n.stack = [], i = n.enter("reference");
  const d = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...o.current()
  });
  return i(), n.stack = f, u(), a === "full" || !c || c !== d ? l += o.move(d + "]") : a === "shortcut" ? l = l.slice(0, -1) : l += o.move("]"), l;
}
function ug() {
  return "!";
}
os.peek = sg;
function os(e, t, n) {
  let r = e.value || "", a = "`", u = -1;
  for (; new RegExp("(^|[^`])" + a + "([^`]|$)").test(r); )
    a += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++u < n.unsafe.length; ) {
    const i = n.unsafe[u], o = n.compilePattern(i);
    let l;
    if (i.atBreak)
      for (; l = o.exec(r); ) {
        let c = l.index;
        r.charCodeAt(c) === 10 && r.charCodeAt(c - 1) === 13 && c--, r = r.slice(0, c) + " " + r.slice(l.index + 1);
      }
  }
  return a + r + a;
}
function sg() {
  return "`";
}
function ls(e, t) {
  const n = Ir(e);
  return !!(!t.options.resourceLink && // If theres a url
  e.url && // And theres a no title
  !e.title && // And the content of `node` is a single text node
  e.children && e.children.length === 1 && e.children[0].type === "text" && // And if the url is the same as the content
  (n === e.url || "mailto:" + n === e.url) && // And that starts w/ a protocol
  /^[a-z][a-z+.-]+:/i.test(e.url) && // And that doesnt contain ASCII control codes (character escapes and
  // references dont work), space, or angle brackets
  !/[\0- <>\u007F]/.test(e.url));
}
cs.peek = og;
function cs(e, t, n, r) {
  const a = Ur(n), u = a === '"' ? "Quote" : "Apostrophe", i = n.createTracker(r);
  let o, l;
  if (ls(e, n)) {
    const f = n.stack;
    n.stack = [], o = n.enter("autolink");
    let d = i.move("<");
    return d += i.move(
      n.containerPhrasing(e, {
        before: d,
        after: ">",
        ...i.current()
      })
    ), d += i.move(">"), o(), n.stack = f, d;
  }
  o = n.enter("link"), l = n.enter("label");
  let c = i.move("[");
  return c += i.move(
    n.containerPhrasing(e, {
      before: c,
      after: "](",
      ...i.current()
    })
  ), c += i.move("]("), l(), // If theres no url but there is a title
  !e.url && e.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), c += i.move("<"), c += i.move(
    n.safe(e.url, { before: c, after: ">", ...i.current() })
  ), c += i.move(">")) : (l = n.enter("destinationRaw"), c += i.move(
    n.safe(e.url, {
      before: c,
      after: e.title ? " " : ")",
      ...i.current()
    })
  )), l(), e.title && (l = n.enter(`title${u}`), c += i.move(" " + a), c += i.move(
    n.safe(e.title, {
      before: c,
      after: a,
      ...i.current()
    })
  ), c += i.move(a), l()), c += i.move(")"), o(), c;
}
function og(e, t, n) {
  return ls(e, n) ? "<" : "[";
}
ds.peek = lg;
function ds(e, t, n, r) {
  const a = e.referenceType, u = n.enter("linkReference");
  let i = n.enter("label");
  const o = n.createTracker(r);
  let l = o.move("[");
  const c = n.containerPhrasing(e, {
    before: l,
    after: "]",
    ...o.current()
  });
  l += o.move(c + "]["), i();
  const f = n.stack;
  n.stack = [], i = n.enter("reference");
  const d = n.safe(n.associationId(e), {
    before: l,
    after: "]",
    ...o.current()
  });
  return i(), n.stack = f, u(), a === "full" || !c || c !== d ? l += o.move(d + "]") : a === "shortcut" ? l = l.slice(0, -1) : l += o.move("]"), l;
}
function lg() {
  return "[";
}
function zr(e) {
  const t = e.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function cg(e) {
  const t = zr(e), n = e.options.bulletOther;
  if (!n)
    return t === "*" ? "-" : "*";
  if (n !== "*" && n !== "+" && n !== "-")
    throw new Error(
      "Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"
    );
  return n;
}
function dg(e) {
  const t = e.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function fs(e) {
  const t = e.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function fg(e, t, n, r) {
  const a = n.enter("list"), u = n.bulletCurrent;
  let i = e.ordered ? dg(n) : zr(n);
  const o = e.ordered ? i === "." ? ")" : "." : cg(n);
  let l = t && n.bulletLastUsed ? i === n.bulletLastUsed : !1;
  if (!e.ordered) {
    const f = e.children ? e.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (i === "*" || i === "-") && // Empty first list item:
      f && (!f.children || !f.children[0]) && // Directly in two other list items:
      n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && // That are each the first child.
      n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (l = !0), fs(n) === i && f
    ) {
      let d = -1;
      for (; ++d < e.children.length; ) {
        const b = e.children[d];
        if (b && b.type === "listItem" && b.children && b.children[0] && b.children[0].type === "thematicBreak") {
          l = !0;
          break;
        }
      }
    }
  }
  l && (i = o), n.bulletCurrent = i;
  const c = n.containerFlow(e, r);
  return n.bulletLastUsed = i, n.bulletCurrent = u, a(), c;
}
function hg(e) {
  const t = e.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function pg(e, t, n, r) {
  const a = hg(n);
  let u = n.bulletCurrent || zr(n);
  t && t.type === "list" && t.ordered && (u = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + u);
  let i = u.length + 1;
  (a === "tab" || a === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (i = Math.ceil(i / 4) * 4);
  const o = n.createTracker(r);
  o.move(u + " ".repeat(i - u.length)), o.shift(i);
  const l = n.enter("listItem"), c = n.indentLines(
    n.containerFlow(e, o.current()),
    f
  );
  return l(), c;
  function f(d, b, m) {
    return b ? (m ? "" : " ".repeat(i)) + d : (m ? u : u + " ".repeat(i - u.length)) + d;
  }
}
function mg(e, t, n, r) {
  const a = n.enter("paragraph"), u = n.enter("phrasing"), i = n.containerPhrasing(e, r);
  return u(), a(), i;
}
const gg = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Sn([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function bg(e, t, n, r) {
  return (e.children.some(function(i) {
    return gg(i);
  }) ? n.containerPhrasing : n.containerFlow).call(n, e, r);
}
function Eg(e) {
  const t = e.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
hs.peek = Tg;
function hs(e, t, n, r) {
  const a = Eg(n), u = n.enter("strong"), i = n.createTracker(r);
  let o = i.move(a + a);
  return o += i.move(
    n.containerPhrasing(e, {
      before: o,
      after: a,
      ...i.current()
    })
  ), o += i.move(a + a), u(), o;
}
function Tg(e, t, n) {
  return n.options.strong || "*";
}
function yg(e, t, n, r) {
  return n.safe(e.value, r);
}
function Ag(e) {
  const t = e.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function _g(e, t, n) {
  const r = (fs(n) + (n.options.ruleSpaces ? " " : "")).repeat(Ag(n));
  return n.options.ruleSpaces ? r.slice(0, -1) : r;
}
const ps = {
  blockquote: qm,
  break: ci,
  code: Km,
  definition: Jm,
  emphasis: as,
  hardBreak: ci,
  heading: rg,
  html: is,
  image: us,
  imageReference: ss,
  inlineCode: os,
  link: cs,
  linkReference: ds,
  list: fg,
  listItem: pg,
  paragraph: mg,
  root: bg,
  strong: hs,
  text: yg,
  thematicBreak: _g
};
function Cg() {
  return {
    enter: {
      table: xg,
      tableData: di,
      tableHeader: di,
      tableRow: Ig
    },
    exit: {
      codeText: Sg,
      table: kg,
      tableData: er,
      tableHeader: er,
      tableRow: er
    }
  };
}
function xg(e) {
  const t = e._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n) {
        return n === "none" ? null : n;
      }),
      children: []
    },
    e
  ), this.data.inTable = !0;
}
function kg(e) {
  this.exit(e), this.data.inTable = void 0;
}
function Ig(e) {
  this.enter({ type: "tableRow", children: [] }, e);
}
function er(e) {
  this.exit(e);
}
function di(e) {
  this.enter({ type: "tableCell", children: [] }, e);
}
function Sg(e) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, Ng));
  const n = this.stack[this.stack.length - 1];
  n.type, n.value = t, this.exit(e);
}
function Ng(e, t) {
  return t === "|" ? t : e;
}
function Rg(e) {
  const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, a = t.stringLength, u = n ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: b,
      table: i,
      tableCell: l,
      tableRow: o
    }
  };
  function i(m, h, E, y) {
    return c(f(m, E, y), m.align);
  }
  function o(m, h, E, y) {
    const _ = d(m, E, y), x = c([_]);
    return x.slice(0, x.indexOf(`
`));
  }
  function l(m, h, E, y) {
    const _ = E.enter("tableCell"), x = E.enter("phrasing"), I = E.containerPhrasing(m, {
      ...y,
      before: u,
      after: u
    });
    return x(), _(), I;
  }
  function c(m, h) {
    return Ym(m, {
      align: h,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: a
    });
  }
  function f(m, h, E) {
    const y = m.children;
    let _ = -1;
    const x = [], I = h.enter("table");
    for (; ++_ < y.length; )
      x[_] = d(y[_], h, E);
    return I(), x;
  }
  function d(m, h, E) {
    const y = m.children;
    let _ = -1;
    const x = [], I = h.enter("tableRow");
    for (; ++_ < y.length; )
      x[_] = l(y[_], m, h, E);
    return I(), x;
  }
  function b(m, h, E) {
    let y = ps.inlineCode(m, h, E);
    return E.stack.includes("tableCell") && (y = y.replace(/\|/g, "\\$&")), y;
  }
}
function Lg() {
  return {
    exit: {
      taskListCheckValueChecked: fi,
      taskListCheckValueUnchecked: fi,
      paragraph: wg
    }
  };
}
function Og() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: Dg }
  };
}
function fi(e) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e.type === "taskListCheckValueChecked";
}
function wg(e) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n = this.stack[this.stack.length - 1];
    n.type;
    const r = n.children[0];
    if (r && r.type === "text") {
      const a = t.children;
      let u = -1, i;
      for (; ++u < a.length; ) {
        const o = a[u];
        if (o.type === "paragraph") {
          i = o;
          break;
        }
      }
      i === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e);
}
function Dg(e, t, n, r) {
  const a = e.children[0], u = typeof e.checked == "boolean" && a && a.type === "paragraph", i = "[" + (e.checked ? "x" : " ") + "] ", o = n.createTracker(r);
  u && o.move(i);
  let l = ps.listItem(e, t, n, {
    ...r,
    ...o.current()
  });
  return u && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c)), l;
  function c(f) {
    return f + i;
  }
}
function Pg() {
  return [
    dm(),
    Cm(),
    Bm(),
    Cg(),
    Lg()
  ];
}
function Mg(e) {
  return {
    extensions: [
      fm(),
      xm(),
      vm(),
      Rg(e),
      Og()
    ]
  };
}
const Fg = {
  tokenize: Yg,
  partial: !0
}, ms = {
  tokenize: jg,
  partial: !0
}, gs = {
  tokenize: Gg,
  partial: !0
}, bs = {
  tokenize: qg,
  partial: !0
}, Bg = {
  tokenize: $g,
  partial: !0
}, Es = {
  tokenize: Ug,
  previous: ys
}, Ts = {
  tokenize: zg,
  previous: As
}, We = {
  tokenize: Hg,
  previous: _s
}, je = {};
function vg() {
  return {
    text: je
  };
}
let it = 48;
for (; it < 123; )
  je[it] = We, it++, it === 58 ? it = 65 : it === 91 && (it = 97);
je[43] = We;
je[45] = We;
je[46] = We;
je[95] = We;
je[72] = [We, Ts];
je[104] = [We, Ts];
je[87] = [We, Es];
je[119] = [We, Es];
function Hg(e, t, n) {
  const r = this;
  let a, u;
  return i;
  function i(d) {
    return !br(d) || !_s.call(r, r.previous) || Yr(r.events) ? n(d) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), o(d));
  }
  function o(d) {
    return br(d) ? (e.consume(d), o) : d === 64 ? (e.consume(d), l) : n(d);
  }
  function l(d) {
    return d === 46 ? e.check(
      Bg,
      f,
      c
    )(d) : d === 45 || d === 95 || ge(d) ? (u = !0, e.consume(d), l) : f(d);
  }
  function c(d) {
    return e.consume(d), a = !0, l;
  }
  function f(d) {
    return u && a && ye(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(d)) : n(d);
  }
}
function Ug(e, t, n) {
  const r = this;
  return a;
  function a(i) {
    return i !== 87 && i !== 119 || !ys.call(r, r.previous) || Yr(r.events) ? n(i) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(
      Fg,
      e.attempt(ms, e.attempt(gs, u), n),
      n
    )(i));
  }
  function u(i) {
    return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(i);
  }
}
function zg(e, t, n) {
  const r = this;
  let a = "", u = !1;
  return i;
  function i(d) {
    return (d === 72 || d === 104) && As.call(r, r.previous) && !Yr(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), a += String.fromCodePoint(d), e.consume(d), o) : n(d);
  }
  function o(d) {
    if (ye(d) && a.length < 5)
      return a += String.fromCodePoint(d), e.consume(d), o;
    if (d === 58) {
      const b = a.toLowerCase();
      if (b === "http" || b === "https")
        return e.consume(d), l;
    }
    return n(d);
  }
  function l(d) {
    return d === 47 ? (e.consume(d), u ? c : (u = !0, l)) : n(d);
  }
  function c(d) {
    return d === null || mn(d) || ie(d) || lt(d) || xn(d) ? n(d) : e.attempt(ms, e.attempt(gs, f), n)(d);
  }
  function f(d) {
    return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(d);
  }
}
function Yg(e, t, n) {
  let r = 0;
  return a;
  function a(i) {
    return (i === 87 || i === 119) && r < 3 ? (r++, e.consume(i), a) : i === 46 && r === 3 ? (e.consume(i), u) : n(i);
  }
  function u(i) {
    return i === null ? n(i) : t(i);
  }
}
function jg(e, t, n) {
  let r, a, u;
  return i;
  function i(c) {
    return c === 46 || c === 95 ? e.check(bs, l, o)(c) : c === null || ie(c) || lt(c) || c !== 45 && xn(c) ? l(c) : (u = !0, e.consume(c), i);
  }
  function o(c) {
    return c === 95 ? r = !0 : (a = r, r = void 0), e.consume(c), i;
  }
  function l(c) {
    return a || r || !u ? n(c) : t(c);
  }
}
function Gg(e, t) {
  let n = 0, r = 0;
  return a;
  function a(i) {
    return i === 40 ? (n++, e.consume(i), a) : i === 41 && r < n ? u(i) : i === 33 || i === 34 || i === 38 || i === 39 || i === 41 || i === 42 || i === 44 || i === 46 || i === 58 || i === 59 || i === 60 || i === 63 || i === 93 || i === 95 || i === 126 ? e.check(bs, t, u)(i) : i === null || ie(i) || lt(i) ? t(i) : (e.consume(i), a);
  }
  function u(i) {
    return i === 41 && r++, e.consume(i), a;
  }
}
function qg(e, t, n) {
  return r;
  function r(o) {
    return o === 33 || o === 34 || o === 39 || o === 41 || o === 42 || o === 44 || o === 46 || o === 58 || o === 59 || o === 63 || o === 95 || o === 126 ? (e.consume(o), r) : o === 38 ? (e.consume(o), u) : o === 93 ? (e.consume(o), a) : (
      // `<` is an end.
      o === 60 || // So is whitespace.
      o === null || ie(o) || lt(o) ? t(o) : n(o)
    );
  }
  function a(o) {
    return o === null || o === 40 || o === 91 || ie(o) || lt(o) ? t(o) : r(o);
  }
  function u(o) {
    return ye(o) ? i(o) : n(o);
  }
  function i(o) {
    return o === 59 ? (e.consume(o), r) : ye(o) ? (e.consume(o), i) : n(o);
  }
}
function $g(e, t, n) {
  return r;
  function r(u) {
    return e.consume(u), a;
  }
  function a(u) {
    return ge(u) ? n(u) : t(u);
  }
}
function ys(e) {
  return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || ie(e);
}
function As(e) {
  return !ye(e);
}
function _s(e) {
  return !(e === 47 || br(e));
}
function br(e) {
  return e === 43 || e === 45 || e === 46 || e === 95 || ge(e);
}
function Yr(e) {
  let t = e.length, n = !1;
  for (; t--; ) {
    const r = e[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n = !0;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n = !1;
      break;
    }
  }
  return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n;
}
const Wg = {
  tokenize: t1,
  partial: !0
};
function Vg() {
  return {
    document: {
      91: {
        tokenize: Zg,
        continuation: {
          tokenize: Jg
        },
        exit: e1
      }
    },
    text: {
      91: {
        tokenize: Kg
      },
      93: {
        add: "after",
        tokenize: Qg,
        resolveTo: Xg
      }
    }
  };
}
function Qg(e, t, n) {
  const r = this;
  let a = r.events.length;
  const u = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i;
  for (; a--; ) {
    const l = r.events[a][1];
    if (l.type === "labelImage") {
      i = l;
      break;
    }
    if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
      break;
  }
  return o;
  function o(l) {
    if (!i || !i._balanced)
      return n(l);
    const c = De(
      r.sliceSerialize({
        start: i.end,
        end: r.now()
      })
    );
    return c.codePointAt(0) !== 94 || !u.includes(c.slice(1)) ? n(l) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(l), e.exit("gfmFootnoteCallLabelMarker"), t(l));
  }
}
function Xg(e, t) {
  let n = e.length;
  for (; n--; )
    if (e[n][1].type === "labelImage" && e[n][0] === "enter") {
      e[n][1];
      break;
    }
  e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e[n + 3][1].start),
    end: Object.assign({}, e[e.length - 1][1].end)
  }, a = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e[n + 3][1].end),
    end: Object.assign({}, e[n + 3][1].end)
  };
  a.end.column++, a.end.offset++, a.end._bufferIndex++;
  const u = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, a.end),
    end: Object.assign({}, e[e.length - 1][1].start)
  }, i = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, u.start),
    end: Object.assign({}, u.end)
  }, o = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e[n + 1],
    e[n + 2],
    ["enter", r, t],
    // The `[`
    e[n + 3],
    e[n + 4],
    // The `^`.
    ["enter", a, t],
    ["exit", a, t],
    // Everything in between.
    ["enter", u, t],
    ["enter", i, t],
    ["exit", i, t],
    ["exit", u, t],
    // The ending (`]`, properly parsed and labelled).
    e[e.length - 2],
    e[e.length - 1],
    ["exit", r, t]
  ];
  return e.splice(n, e.length - n + 1, ...o), e;
}
function Kg(e, t, n) {
  const r = this, a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let u = 0, i;
  return o;
  function o(d) {
    return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), l;
  }
  function l(d) {
    return d !== 94 ? n(d) : (e.enter("gfmFootnoteCallMarker"), e.consume(d), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", c);
  }
  function c(d) {
    if (
      // Too long.
      u > 999 || // Closing brace with nothing.
      d === 93 && !i || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      d === null || d === 91 || ie(d)
    )
      return n(d);
    if (d === 93) {
      e.exit("chunkString");
      const b = e.exit("gfmFootnoteCallString");
      return a.includes(De(r.sliceSerialize(b))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(d);
    }
    return ie(d) || (i = !0), u++, e.consume(d), d === 92 ? f : c;
  }
  function f(d) {
    return d === 91 || d === 92 || d === 93 ? (e.consume(d), u++, c) : c(d);
  }
}
function Zg(e, t, n) {
  const r = this, a = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let u, i = 0, o;
  return l;
  function l(h) {
    return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionLabelMarker"), c;
  }
  function c(h) {
    return h === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", f) : n(h);
  }
  function f(h) {
    if (
      // Too long.
      i > 999 || // Closing brace with nothing.
      h === 93 && !o || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || ie(h)
    )
      return n(h);
    if (h === 93) {
      e.exit("chunkString");
      const E = e.exit("gfmFootnoteDefinitionLabelString");
      return u = De(r.sliceSerialize(E)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(h), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), b;
    }
    return ie(h) || (o = !0), i++, e.consume(h), h === 92 ? d : f;
  }
  function d(h) {
    return h === 91 || h === 92 || h === 93 ? (e.consume(h), i++, f) : f(h);
  }
  function b(h) {
    return h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), a.includes(u) || a.push(u), J(
      e,
      m,
      "gfmFootnoteDefinitionWhitespace"
    )) : n(h);
  }
  function m(h) {
    return t(h);
  }
}
function Jg(e, t, n) {
  return e.check(Kt, t, e.attempt(Wg, t, n));
}
function e1(e) {
  e.exit("gfmFootnoteDefinition");
}
function t1(e, t, n) {
  const r = this;
  return J(
    e,
    a,
    "gfmFootnoteDefinitionIndent",
    5
  );
  function a(u) {
    const i = r.events[r.events.length - 1];
    return i && i[1].type === "gfmFootnoteDefinitionIndent" && i[2].sliceSerialize(i[1], !0).length === 4 ? t(u) : n(u);
  }
}
function n1(e) {
  let n = (e || {}).singleTilde;
  const r = {
    tokenize: u,
    resolveAll: a
  };
  return n == null && (n = !0), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function a(i, o) {
    let l = -1;
    for (; ++l < i.length; )
      if (i[l][0] === "enter" && i[l][1].type === "strikethroughSequenceTemporary" && i[l][1]._close) {
        let c = l;
        for (; c--; )
          if (i[c][0] === "exit" && i[c][1].type === "strikethroughSequenceTemporary" && i[c][1]._open && // If the sizes are the same:
          i[l][1].end.offset - i[l][1].start.offset === i[c][1].end.offset - i[c][1].start.offset) {
            i[l][1].type = "strikethroughSequence", i[c][1].type = "strikethroughSequence";
            const f = {
              type: "strikethrough",
              start: Object.assign({}, i[c][1].start),
              end: Object.assign({}, i[l][1].end)
            }, d = {
              type: "strikethroughText",
              start: Object.assign({}, i[c][1].end),
              end: Object.assign({}, i[l][1].start)
            }, b = [
              ["enter", f, o],
              ["enter", i[c][1], o],
              ["exit", i[c][1], o],
              ["enter", d, o]
            ], m = o.parser.constructs.insideSpan.null;
            m && Ne(
              b,
              b.length,
              0,
              kn(m, i.slice(c + 1, l), o)
            ), Ne(b, b.length, 0, [
              ["exit", d, o],
              ["enter", i[l][1], o],
              ["exit", i[l][1], o],
              ["exit", f, o]
            ]), Ne(i, c - 1, l - c + 3, b), l = c + b.length - 2;
            break;
          }
      }
    for (l = -1; ++l < i.length; )
      i[l][1].type === "strikethroughSequenceTemporary" && (i[l][1].type = "data");
    return i;
  }
  function u(i, o, l) {
    const c = this.previous, f = this.events;
    let d = 0;
    return b;
    function b(h) {
      return c === 126 && f[f.length - 1][1].type !== "characterEscape" ? l(h) : (i.enter("strikethroughSequenceTemporary"), m(h));
    }
    function m(h) {
      const E = gn(c);
      if (h === 126)
        return d > 1 ? l(h) : (i.consume(h), d++, m);
      if (d < 2 && !n) return l(h);
      const y = i.exit("strikethroughSequenceTemporary"), _ = gn(h);
      return y._open = !_ || _ === 2 && !!E, y._close = !E || E === 2 && !!_, o(h);
    }
  }
}
class r1 {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n, r) {
    a1(this, t, n, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImpl(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(u, i) {
      return u[0] - i[0];
    }), this.map.length === 0)
      return;
    let n = this.map.length;
    const r = [];
    for (; n > 0; )
      n -= 1, r.push(
        t.slice(this.map[n][0] + this.map[n][1]),
        this.map[n][2]
      ), t.length = this.map[n][0];
    r.push([...t]), t.length = 0;
    let a = r.pop();
    for (; a; )
      t.push(...a), a = r.pop();
    this.map.length = 0;
  }
}
function a1(e, t, n, r) {
  let a = 0;
  if (!(n === 0 && r.length === 0)) {
    for (; a < e.map.length; ) {
      if (e.map[a][0] === t) {
        e.map[a][1] += n, e.map[a][2].push(...r);
        return;
      }
      a += 1;
    }
    e.map.push([t, n, r]);
  }
}
function i1(e, t) {
  let n = !1;
  const r = [];
  for (; t < e.length; ) {
    const a = e[t];
    if (n) {
      if (a[0] === "enter")
        a[1].type === "tableContent" && r.push(
          e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
        );
      else if (a[1].type === "tableContent") {
        if (e[t - 1][1].type === "tableDelimiterMarker") {
          const u = r.length - 1;
          r[u] = r[u] === "left" ? "center" : "right";
        }
      } else if (a[1].type === "tableDelimiterRow")
        break;
    } else a[0] === "enter" && a[1].type === "tableDelimiterRow" && (n = !0);
    t += 1;
  }
  return r;
}
function u1() {
  return {
    flow: {
      null: {
        tokenize: s1,
        resolveAll: o1
      }
    }
  };
}
function s1(e, t, n) {
  const r = this;
  let a = 0, u = 0, i;
  return o;
  function o(S) {
    let H = r.events.length - 1;
    for (; H > -1; ) {
      const G = r.events[H][1].type;
      if (G === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      G === "linePrefix")
        H--;
      else break;
    }
    const F = H > -1 ? r.events[H][1].type : null, ee = F === "tableHead" || F === "tableRow" ? R : l;
    return ee === R && r.parser.lazy[r.now().line] ? n(S) : ee(S);
  }
  function l(S) {
    return e.enter("tableHead"), e.enter("tableRow"), c(S);
  }
  function c(S) {
    return S === 124 || (i = !0, u += 1), f(S);
  }
  function f(S) {
    return S === null ? n(S) : z(S) ? u > 1 ? (u = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(S), e.exit("lineEnding"), m) : n(S) : K(S) ? J(e, f, "whitespace")(S) : (u += 1, i && (i = !1, a += 1), S === 124 ? (e.enter("tableCellDivider"), e.consume(S), e.exit("tableCellDivider"), i = !0, f) : (e.enter("data"), d(S)));
  }
  function d(S) {
    return S === null || S === 124 || ie(S) ? (e.exit("data"), f(S)) : (e.consume(S), S === 92 ? b : d);
  }
  function b(S) {
    return S === 92 || S === 124 ? (e.consume(S), d) : d(S);
  }
  function m(S) {
    return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(S) : (e.enter("tableDelimiterRow"), i = !1, K(S) ? J(
      e,
      h,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(S) : h(S));
  }
  function h(S) {
    return S === 45 || S === 58 ? y(S) : S === 124 ? (i = !0, e.enter("tableCellDivider"), e.consume(S), e.exit("tableCellDivider"), E) : B(S);
  }
  function E(S) {
    return K(S) ? J(e, y, "whitespace")(S) : y(S);
  }
  function y(S) {
    return S === 58 ? (u += 1, i = !0, e.enter("tableDelimiterMarker"), e.consume(S), e.exit("tableDelimiterMarker"), _) : S === 45 ? (u += 1, _(S)) : S === null || z(S) ? M(S) : B(S);
  }
  function _(S) {
    return S === 45 ? (e.enter("tableDelimiterFiller"), x(S)) : B(S);
  }
  function x(S) {
    return S === 45 ? (e.consume(S), x) : S === 58 ? (i = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(S), e.exit("tableDelimiterMarker"), I) : (e.exit("tableDelimiterFiller"), I(S));
  }
  function I(S) {
    return K(S) ? J(e, M, "whitespace")(S) : M(S);
  }
  function M(S) {
    return S === 124 ? h(S) : S === null || z(S) ? !i || a !== u ? B(S) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(S)) : B(S);
  }
  function B(S) {
    return n(S);
  }
  function R(S) {
    return e.enter("tableRow"), U(S);
  }
  function U(S) {
    return S === 124 ? (e.enter("tableCellDivider"), e.consume(S), e.exit("tableCellDivider"), U) : S === null || z(S) ? (e.exit("tableRow"), t(S)) : K(S) ? J(e, U, "whitespace")(S) : (e.enter("data"), q(S));
  }
  function q(S) {
    return S === null || S === 124 || ie(S) ? (e.exit("data"), U(S)) : (e.consume(S), S === 92 ? Y : q);
  }
  function Y(S) {
    return S === 92 || S === 124 ? (e.consume(S), q) : q(S);
  }
}
function o1(e, t) {
  let n = -1, r = !0, a = 0, u = [0, 0, 0, 0], i = [0, 0, 0, 0], o = !1, l = 0, c, f, d;
  const b = new r1();
  for (; ++n < e.length; ) {
    const m = e[n], h = m[1];
    m[0] === "enter" ? h.type === "tableHead" ? (o = !1, l !== 0 && (hi(b, t, l, c, f), f = void 0, l = 0), c = {
      type: "table",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, b.add(n, 0, [["enter", c, t]])) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (r = !0, d = void 0, u = [0, 0, 0, 0], i = [0, n + 1, 0, 0], o && (o = !1, f = {
      type: "tableBody",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, b.add(n, 0, [["enter", f, t]])), a = h.type === "tableDelimiterRow" ? 2 : f ? 3 : 1) : a && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") ? (r = !1, i[2] === 0 && (u[1] !== 0 && (i[0] = i[1], d = on(
      b,
      t,
      u,
      a,
      void 0,
      d
    ), u = [0, 0, 0, 0]), i[2] = n)) : h.type === "tableCellDivider" && (r ? r = !1 : (u[1] !== 0 && (i[0] = i[1], d = on(
      b,
      t,
      u,
      a,
      void 0,
      d
    )), u = i, i = [u[1], n, 0, 0])) : h.type === "tableHead" ? (o = !0, l = n) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (l = n, u[1] !== 0 ? (i[0] = i[1], d = on(
      b,
      t,
      u,
      a,
      n,
      d
    )) : i[1] !== 0 && (d = on(b, t, i, a, n, d)), a = 0) : a && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") && (i[3] = n);
  }
  for (l !== 0 && hi(b, t, l, c, f), b.consume(t.events), n = -1; ++n < t.events.length; ) {
    const m = t.events[n];
    m[0] === "enter" && m[1].type === "table" && (m[1]._align = i1(t.events, n));
  }
  return e;
}
function on(e, t, n, r, a, u) {
  const i = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", o = "tableContent";
  n[0] !== 0 && (u.end = Object.assign({}, gt(t.events, n[0])), e.add(n[0], 0, [["exit", u, t]]));
  const l = gt(t.events, n[1]);
  if (u = {
    type: i,
    start: Object.assign({}, l),
    // Note: correct end is set later.
    end: Object.assign({}, l)
  }, e.add(n[1], 0, [["enter", u, t]]), n[2] !== 0) {
    const c = gt(t.events, n[2]), f = gt(t.events, n[3]), d = {
      type: o,
      start: Object.assign({}, c),
      end: Object.assign({}, f)
    };
    if (e.add(n[2], 0, [["enter", d, t]]), r !== 2) {
      const b = t.events[n[2]], m = t.events[n[3]];
      if (b[1].end = Object.assign({}, m[1].end), b[1].type = "chunkText", b[1].contentType = "text", n[3] > n[2] + 1) {
        const h = n[2] + 1, E = n[3] - n[2] - 1;
        e.add(h, E, []);
      }
    }
    e.add(n[3] + 1, 0, [["exit", d, t]]);
  }
  return a !== void 0 && (u.end = Object.assign({}, gt(t.events, a)), e.add(a, 0, [["exit", u, t]]), u = void 0), u;
}
function hi(e, t, n, r, a) {
  const u = [], i = gt(t.events, n);
  a && (a.end = Object.assign({}, i), u.push(["exit", a, t])), r.end = Object.assign({}, i), u.push(["exit", r, t]), e.add(n + 1, 0, u);
}
function gt(e, t) {
  const n = e[t], r = n[0] === "enter" ? "start" : "end";
  return n[1][r];
}
const l1 = {
  tokenize: d1
};
function c1() {
  return {
    text: {
      91: l1
    }
  };
}
function d1(e, t, n) {
  const r = this;
  return a;
  function a(l) {
    return (
      // Exit if theres stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n(l) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), u)
    );
  }
  function u(l) {
    return ie(l) ? (e.enter("taskListCheckValueUnchecked"), e.consume(l), e.exit("taskListCheckValueUnchecked"), i) : l === 88 || l === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(l), e.exit("taskListCheckValueChecked"), i) : n(l);
  }
  function i(l) {
    return l === 93 ? (e.enter("taskListCheckMarker"), e.consume(l), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), o) : n(l);
  }
  function o(l) {
    return z(l) ? t(l) : K(l) ? e.check(
      {
        tokenize: f1
      },
      t,
      n
    )(l) : n(l);
  }
}
function f1(e, t, n) {
  return J(e, r, "whitespace");
  function r(a) {
    return a === null ? n(a) : t(a);
  }
}
function h1(e) {
  return $i([
    vg(),
    Vg(),
    n1(e),
    u1(),
    c1()
  ]);
}
const p1 = {};
function m1(e) {
  const t = (
    /** @type {Processor} */
    this
  ), n = e || p1, r = t.data(), a = r.micromarkExtensions || (r.micromarkExtensions = []), u = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), i = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  a.push(h1(n)), u.push(Pg()), i.push(Mg(n));
}
const g1 = ({
  className: e,
  children: t,
  selectOnClick: n
}) => /* @__PURE__ */ Q.jsx(
  "code",
  {
    onClick: (r) => {
      if (!n) return;
      const a = window.getSelection(), u = document.createRange();
      u.selectNodeContents(r.currentTarget), a == null || a.removeAllRanges(), a == null || a.addRange(u);
    },
    className: bt(
      "font-mono border p-1 py-0.5 rounded bg-border/50 dark:bg-border/70 whitespace-nowrap",
      e
    ),
    children: t
  }
);
var b1 = Object.create, Dn = Object.defineProperty, E1 = Object.defineProperties, T1 = Object.getOwnPropertyDescriptor, y1 = Object.getOwnPropertyDescriptors, Cs = Object.getOwnPropertyNames, An = Object.getOwnPropertySymbols, A1 = Object.getPrototypeOf, jr = Object.prototype.hasOwnProperty, xs = Object.prototype.propertyIsEnumerable, pi = (e, t, n) => t in e ? Dn(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n, ze = (e, t) => {
  for (var n in t || (t = {}))
    jr.call(t, n) && pi(e, n, t[n]);
  if (An)
    for (var n of An(t))
      xs.call(t, n) && pi(e, n, t[n]);
  return e;
}, Pn = (e, t) => E1(e, y1(t)), ks = (e, t) => {
  var n = {};
  for (var r in e)
    jr.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && An)
    for (var r of An(e))
      t.indexOf(r) < 0 && xs.call(e, r) && (n[r] = e[r]);
  return n;
}, _1 = (e, t) => function() {
  return t || (0, e[Cs(e)[0]])((t = { exports: {} }).exports, t), t.exports;
}, C1 = (e, t) => {
  for (var n in t)
    Dn(e, n, { get: t[n], enumerable: !0 });
}, x1 = (e, t, n, r) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let a of Cs(t))
      !jr.call(e, a) && a !== n && Dn(e, a, { get: () => t[a], enumerable: !(r = T1(t, a)) || r.enumerable });
  return e;
}, k1 = (e, t, n) => (n = e != null ? b1(A1(e)) : {}, x1(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  !e || !e.__esModule ? Dn(n, "default", { value: e, enumerable: !0 }) : n,
  e
)), I1 = _1({
  "../../node_modules/.pnpm/prismjs@1.29.0_patch_hash=vrxx3pzkik6jpmgpayxfjunetu/node_modules/prismjs/prism.js"(e, t) {
    var n = function() {
      var r = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, a = 0, u = {}, i = {
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function h(E) {
            return E instanceof o ? new o(E.type, h(E.content), E.alias) : Array.isArray(E) ? E.map(h) : E.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(h) {
            return Object.prototype.toString.call(h).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(h) {
            return h.__id || Object.defineProperty(h, "__id", { value: ++a }), h.__id;
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function h(E, y) {
            y = y || {};
            var _, x;
            switch (i.util.type(E)) {
              case "Object":
                if (x = i.util.objId(E), y[x])
                  return y[x];
                _ = /** @type {Record<string, any>} */
                {}, y[x] = _;
                for (var I in E)
                  E.hasOwnProperty(I) && (_[I] = h(E[I], y));
                return (
                  /** @type {any} */
                  _
                );
              case "Array":
                return x = i.util.objId(E), y[x] ? y[x] : (_ = [], y[x] = _, E.forEach(function(M, B) {
                  _[B] = h(M, y);
                }), /** @type {any} */
                _);
              default:
                return E;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(h) {
            for (; h; ) {
              var E = r.exec(h.className);
              if (E)
                return E[1].toLowerCase();
              h = h.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(h, E) {
            h.className = h.className.replace(RegExp(r, "gi"), ""), h.classList.add("language-" + E);
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(h, E, y) {
            for (var _ = "no-" + E; h; ) {
              var x = h.classList;
              if (x.contains(E))
                return !0;
              if (x.contains(_))
                return !1;
              h = h.parentElement;
            }
            return !!y;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: u,
          plaintext: u,
          text: u,
          txt: u,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(h, E) {
            var y = i.util.clone(i.languages[h]);
            for (var _ in E)
              y[_] = E[_];
            return y;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(h, E, y, _) {
            _ = _ || /** @type {any} */
            i.languages;
            var x = _[h], I = {};
            for (var M in x)
              if (x.hasOwnProperty(M)) {
                if (M == E)
                  for (var B in y)
                    y.hasOwnProperty(B) && (I[B] = y[B]);
                y.hasOwnProperty(M) || (I[M] = x[M]);
              }
            var R = _[h];
            return _[h] = I, i.languages.DFS(i.languages, function(U, q) {
              q === R && U != h && (this[U] = I);
            }), I;
          },
          // Traverse a language definition with Depth First Search
          DFS: function h(E, y, _, x) {
            x = x || {};
            var I = i.util.objId;
            for (var M in E)
              if (E.hasOwnProperty(M)) {
                y.call(E, M, E[M], _ || M);
                var B = E[M], R = i.util.type(B);
                R === "Object" && !x[I(B)] ? (x[I(B)] = !0, h(B, y, null, x)) : R === "Array" && !x[I(B)] && (x[I(B)] = !0, h(B, y, M, x));
              }
          }
        },
        plugins: {},
        /**
         * Low-level function, only use if you know what youre doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(h, E, y) {
          var _ = {
            code: h,
            grammar: E,
            language: y
          };
          if (i.hooks.run("before-tokenize", _), !_.grammar)
            throw new Error('The language "' + _.language + '" has no grammar.');
          return _.tokens = i.tokenize(_.code, _.grammar), i.hooks.run("after-tokenize", _), o.stringify(i.util.encode(_.tokens), _.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(h, E) {
          var y = E.rest;
          if (y) {
            for (var _ in y)
              E[_] = y[_];
            delete E.rest;
          }
          var x = new f();
          return d(x, x.head, h), c(h, x, E, x.head, 0), m(x);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(h, E) {
            var y = i.hooks.all;
            y[h] = y[h] || [], y[h].push(E);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(h, E) {
            var y = i.hooks.all[h];
            if (!(!y || !y.length))
              for (var _ = 0, x; x = y[_++]; )
                x(E);
          }
        },
        Token: o
      };
      function o(h, E, y, _) {
        this.type = h, this.content = E, this.alias = y, this.length = (_ || "").length | 0;
      }
      o.stringify = function h(E, y) {
        if (typeof E == "string")
          return E;
        if (Array.isArray(E)) {
          var _ = "";
          return E.forEach(function(R) {
            _ += h(R, y);
          }), _;
        }
        var x = {
          type: E.type,
          content: h(E.content, y),
          tag: "span",
          classes: ["token", E.type],
          attributes: {},
          language: y
        }, I = E.alias;
        I && (Array.isArray(I) ? Array.prototype.push.apply(x.classes, I) : x.classes.push(I)), i.hooks.run("wrap", x);
        var M = "";
        for (var B in x.attributes)
          M += " " + B + '="' + (x.attributes[B] || "").replace(/"/g, "&quot;") + '"';
        return "<" + x.tag + ' class="' + x.classes.join(" ") + '"' + M + ">" + x.content + "</" + x.tag + ">";
      };
      function l(h, E, y, _) {
        h.lastIndex = E;
        var x = h.exec(y);
        if (x && _ && x[1]) {
          var I = x[1].length;
          x.index += I, x[0] = x[0].slice(I);
        }
        return x;
      }
      function c(h, E, y, _, x, I) {
        for (var M in y)
          if (!(!y.hasOwnProperty(M) || !y[M])) {
            var B = y[M];
            B = Array.isArray(B) ? B : [B];
            for (var R = 0; R < B.length; ++R) {
              if (I && I.cause == M + "," + R)
                return;
              var U = B[R], q = U.inside, Y = !!U.lookbehind, S = !!U.greedy, H = U.alias;
              if (S && !U.pattern.global) {
                var F = U.pattern.toString().match(/[imsuy]*$/)[0];
                U.pattern = RegExp(U.pattern.source, F + "g");
              }
              for (var ee = U.pattern || U, G = _.next, j = x; G !== E.tail && !(I && j >= I.reach); j += G.value.length, G = G.next) {
                var te = G.value;
                if (E.length > h.length)
                  return;
                if (!(te instanceof o)) {
                  var se = 1, re;
                  if (S) {
                    if (re = l(ee, j, h, Y), !re || re.index >= h.length)
                      break;
                    var Ae = re.index, me = re.index + re[0].length, A = j;
                    for (A += G.value.length; Ae >= A; )
                      G = G.next, A += G.value.length;
                    if (A -= G.value.length, j = A, G.value instanceof o)
                      continue;
                    for (var ae = G; ae !== E.tail && (A < me || typeof ae.value == "string"); ae = ae.next)
                      se++, A += ae.value.length;
                    se--, te = h.slice(j, A), re.index -= j;
                  } else if (re = l(ee, 0, te, Y), !re)
                    continue;
                  var Ae = re.index, C = re[0], Te = te.slice(0, Ae), Me = te.slice(Ae + C.length), ce = j + te.length;
                  I && ce > I.reach && (I.reach = ce);
                  var Fe = G.prev;
                  Te && (Fe = d(E, Fe, Te), j += Te.length), b(E, Fe, se);
                  var Be = new o(M, q ? i.tokenize(C, q) : C, H, C);
                  if (G = d(E, Fe, Be), Me && d(E, G, Me), se > 1) {
                    var ve = {
                      cause: M + "," + R,
                      reach: ce
                    };
                    c(h, E, y, G.prev, j, ve), I && ve.reach > I.reach && (I.reach = ve.reach);
                  }
                }
              }
            }
          }
      }
      function f() {
        var h = { value: null, prev: null, next: null }, E = { value: null, prev: h, next: null };
        h.next = E, this.head = h, this.tail = E, this.length = 0;
      }
      function d(h, E, y) {
        var _ = E.next, x = { value: y, prev: E, next: _ };
        return E.next = x, _.prev = x, h.length++, x;
      }
      function b(h, E, y) {
        for (var _ = E.next, x = 0; x < y && _ !== h.tail; x++)
          _ = _.next;
        E.next = _, _.prev = E, h.length -= x;
      }
      function m(h) {
        for (var E = [], y = h.head.next; y !== h.tail; )
          E.push(y.value), y = y.next;
        return E;
      }
      return i;
    }();
    t.exports = n, n.default = n;
  }
}), w = k1(I1());
w.languages.markup = { comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: !0 }, prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: !0 }, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i, greedy: !0, inside: { "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: !0, greedy: !0, inside: null }, string: { pattern: /"[^"]*"|'[^']*'/, greedy: !0 }, punctuation: /^<!|>$|[[\]]/, "doctype-tag": /^DOCTYPE/i, name: /[^\s<>'"]+/ } }, cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: !0 }, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: !0, inside: { tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "special-attr": [], "attr-value": { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: "attr-equals" }, { pattern: /^(\s*)["']|["']$/, lookbehind: !0 }] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i] }, w.languages.markup.tag.inside["attr-value"].inside.entity = w.languages.markup.entity, w.languages.markup.doctype.inside["internal-subset"].inside = w.languages.markup, w.hooks.add("wrap", function(e) {
  e.type === "entity" && (e.attributes.title = e.content.replace(/&amp;/, "&"));
}), Object.defineProperty(w.languages.markup.tag, "addInlined", { value: function(e, r) {
  var n = {}, n = (n["language-" + r] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: !0, inside: w.languages[r] }, n.cdata = /^<!\[CDATA\[|\]\]>$/i, { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: n } }), r = (n["language-" + r] = { pattern: /[\s\S]+/, inside: w.languages[r] }, {});
  r[e] = { pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
    return e;
  }), "i"), lookbehind: !0, greedy: !0, inside: n }, w.languages.insertBefore("markup", "cdata", r);
} }), Object.defineProperty(w.languages.markup.tag, "addAttribute", { value: function(e, t) {
  w.languages.markup.tag.inside["special-attr"].push({ pattern: RegExp(/(^|["'\s])/.source + "(?:" + e + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"), lookbehind: !0, inside: { "attr-name": /^[^\s=]+/, "attr-value": { pattern: /=[\s\S]+/, inside: { value: { pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/, lookbehind: !0, alias: [t, "language-" + t], inside: w.languages[t] }, punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } } } });
} }), w.languages.html = w.languages.markup, w.languages.mathml = w.languages.markup, w.languages.svg = w.languages.markup, w.languages.xml = w.languages.extend("markup", {}), w.languages.ssml = w.languages.xml, w.languages.atom = w.languages.xml, w.languages.rss = w.languages.xml, function(e) {
  var t = { pattern: /\\[\\(){}[\]^$+*?|.]/, alias: "escape" }, n = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/, r = "(?:[^\\\\-]|" + n.source + ")", r = RegExp(r + "-" + r), a = { pattern: /(<|')[^<>']+(?=[>']$)/, lookbehind: !0, alias: "variable" };
  e.languages.regex = { "char-class": { pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/, lookbehind: !0, inside: { "char-class-negation": { pattern: /(^\[)\^/, lookbehind: !0, alias: "operator" }, "char-class-punctuation": { pattern: /^\[|\]$/, alias: "punctuation" }, range: { pattern: r, inside: { escape: n, "range-punctuation": { pattern: /-/, alias: "operator" } } }, "special-escape": t, "char-set": { pattern: /\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" }, escape: n } }, "special-escape": t, "char-set": { pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" }, backreference: [{ pattern: /\\(?![123][0-7]{2})[1-9]/, alias: "keyword" }, { pattern: /\\k<[^<>']+>/, alias: "keyword", inside: { "group-name": a } }], anchor: { pattern: /[$^]|\\[ABbGZz]/, alias: "function" }, escape: n, group: [{ pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/, alias: "punctuation", inside: { "group-name": a } }, { pattern: /\)/, alias: "punctuation" }], quantifier: { pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/, alias: "number" }, alternation: { pattern: /\|/, alias: "keyword" } };
}(w), w.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0, greedy: !0 }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 }, "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: !0, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/, boolean: /\b(?:false|true)\b/, function: /\b\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/, punctuation: /[{}[\];(),.:]/ }, w.languages.javascript = w.languages.extend("clike", { "class-name": [w.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/, lookbehind: !0 }], keyword: [{ pattern: /((?:^|\})\s*)catch\b/, lookbehind: !0 }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: !0 }], function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, number: { pattern: RegExp(/(^|[^\w$])/.source + "(?:" + /NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source + ")" + /(?![\w$])/.source), lookbehind: !0 }, operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/ }), w.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, w.languages.insertBefore("javascript", "keyword", { regex: { pattern: RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source), lookbehind: !0, greedy: !0, inside: { "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: !0, alias: "language-regex", inside: w.languages.regex }, "regex-delimiter": /^\/|\/$/, "regex-flags": /^[a-z]+$/ } }, "function-variable": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/, lookbehind: !0, inside: w.languages.javascript }, { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i, lookbehind: !0, inside: w.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: !0, inside: w.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/, lookbehind: !0, inside: w.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ }), w.languages.insertBefore("javascript", "string", { hashbang: { pattern: /^#!.*/, greedy: !0, alias: "comment" }, "template-string": { pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/, greedy: !0, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/, lookbehind: !0, inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: w.languages.javascript } }, string: /[\s\S]+/ } }, "string-property": { pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m, lookbehind: !0, greedy: !0, alias: "property" } }), w.languages.insertBefore("javascript", "operator", { "literal-property": { pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m, lookbehind: !0, alias: "property" } }), w.languages.markup && (w.languages.markup.tag.addInlined("script", "javascript"), w.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript")), w.languages.js = w.languages.javascript, w.languages.actionscript = w.languages.extend("javascript", { keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/, operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/ }), w.languages.actionscript["class-name"].alias = "function", delete w.languages.actionscript.parameter, delete w.languages.actionscript["literal-property"], w.languages.markup && w.languages.insertBefore("actionscript", "string", { xml: { pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/, lookbehind: !0, inside: w.languages.markup } }), function(e) {
  var t = /#(?!\{).+/, n = { pattern: /#\{[^}]+\}/, alias: "variable" };
  e.languages.coffeescript = e.languages.extend("javascript", { comment: t, string: [{ pattern: /'(?:\\[\s\S]|[^\\'])*'/, greedy: !0 }, { pattern: /"(?:\\[\s\S]|[^\\"])*"/, greedy: !0, inside: { interpolation: n } }], keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/, "class-member": { pattern: /@(?!\d)\w+/, alias: "variable" } }), e.languages.insertBefore("coffeescript", "comment", { "multiline-comment": { pattern: /###[\s\S]+?###/, alias: "comment" }, "block-regex": { pattern: /\/{3}[\s\S]*?\/{3}/, alias: "regex", inside: { comment: t, interpolation: n } } }), e.languages.insertBefore("coffeescript", "string", { "inline-javascript": { pattern: /`(?:\\[\s\S]|[^\\`])*`/, inside: { delimiter: { pattern: /^`|`$/, alias: "punctuation" }, script: { pattern: /[\s\S]+/, alias: "language-javascript", inside: e.languages.javascript } } }, "multiline-string": [{ pattern: /'''[\s\S]*?'''/, greedy: !0, alias: "string" }, { pattern: /"""[\s\S]*?"""/, greedy: !0, alias: "string", inside: { interpolation: n } }] }), e.languages.insertBefore("coffeescript", "keyword", { property: /(?!\d)\w+(?=\s*:(?!:))/ }), delete e.languages.coffeescript["template-string"], e.languages.coffee = e.languages.coffeescript;
}(w), function(e) {
  var t = e.languages.javadoclike = { parameter: { pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m, lookbehind: !0 }, keyword: { pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m, lookbehind: !0 }, punctuation: /[{}]/ };
  Object.defineProperty(t, "addSupport", { value: function(n, r) {
    (n = typeof n == "string" ? [n] : n).forEach(function(a) {
      var u = function(d) {
        d.inside || (d.inside = {}), d.inside.rest = r;
      }, i = "doc-comment";
      if (o = e.languages[a]) {
        var o, l = o[i];
        if ((l = l || (o = e.languages.insertBefore(a, "comment", { "doc-comment": { pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/, lookbehind: !0, alias: "comment" } }))[i]) instanceof RegExp && (l = o[i] = { pattern: l }), Array.isArray(l))
          for (var c = 0, f = l.length; c < f; c++)
            l[c] instanceof RegExp && (l[c] = { pattern: l[c] }), u(l[c]);
        else
          u(l);
      }
    });
  } }), t.addSupport(["java", "javascript", "php"], t);
}(w), function(e) {
  var t = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/, t = (e.languages.css = { comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + t.source + ")*?" + /(?:;|(?=\s*\{))/.source), inside: { rule: /^@[\w-]+/, "selector-function-argument": { pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/, lookbehind: !0, alias: "selector" }, keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: !0 } } }, url: { pattern: RegExp("\\burl\\((?:" + t.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"), greedy: !0, inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + t.source + "$"), alias: "url" } } }, selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + t.source + ")*(?=\\s*\\{)"), lookbehind: !0 }, string: { pattern: t, greedy: !0 }, property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: !0 }, important: /!important\b/i, function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: !0 }, punctuation: /[(){};:,]/ }, e.languages.css.atrule.inside.rest = e.languages.css, e.languages.markup);
  t && (t.tag.addInlined("style", "css"), t.tag.addAttribute("style", "css"));
}(w), function(e) {
  var t = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, t = (e.languages.css.selector = { pattern: e.languages.css.selector.pattern, lookbehind: !0, inside: t = { "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/, "pseudo-class": /:[-\w]+/, class: /\.[-\w]+/, id: /#[-\w]+/, attribute: { pattern: RegExp(`\\[(?:[^[\\]"']|` + t.source + ")*\\]"), greedy: !0, inside: { punctuation: /^\[|\]$/, "case-sensitivity": { pattern: /(\s)[si]$/i, lookbehind: !0, alias: "keyword" }, namespace: { pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/, lookbehind: !0, inside: { punctuation: /\|$/ } }, "attr-name": { pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/, lookbehind: !0 }, "attr-value": [t, { pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/, lookbehind: !0 }], operator: /[|~*^$]?=/ } }, "n-th": [{ pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/, lookbehind: !0, inside: { number: /[\dn]+/, operator: /[+-]/ } }, { pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i, lookbehind: !0 }], combinator: />|\+|~|\|\|/, punctuation: /[(),]/ } }, e.languages.css.atrule.inside["selector-function-argument"].inside = t, e.languages.insertBefore("css", "property", { variable: { pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i, lookbehind: !0 } }), { pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/, lookbehind: !0 }), n = { pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/, lookbehind: !0 };
  e.languages.insertBefore("css", "function", { operator: { pattern: /(\s)[+\-*\/](?=\s)/, lookbehind: !0 }, hexcode: { pattern: /\B#[\da-f]{3,8}\b/i, alias: "color" }, color: [{ pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|RebeccaPurple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i, lookbehind: !0 }, { pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i, inside: { unit: t, number: n, function: /[\w-]+(?=\()/, punctuation: /[(),]/ } }], entity: /\\[\da-f]{1,8}/i, unit: t, number: n });
}(w), function(e) {
  var t = /[*&][^\s[\]{},]+/, n = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, r = "(?:" + n.source + "(?:[ 	]+" + t.source + ")?|" + t.source + "(?:[ 	]+" + n.source + ")?)", a = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  }), u = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function i(o, l) {
    l = (l || "").replace(/m/g, "") + "m";
    var c = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return r;
    }).replace(/<<value>>/g, function() {
      return o;
    });
    return RegExp(c, l);
  }
  e.languages.yaml = { scalar: { pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
    return r;
  })), lookbehind: !0, alias: "string" }, comment: /#.*/, key: { pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
    return r;
  }).replace(/<<key>>/g, function() {
    return "(?:" + a + "|" + u + ")";
  })), lookbehind: !0, greedy: !0, alias: "atrule" }, directive: { pattern: /(^[ \t]*)%.+/m, lookbehind: !0, alias: "important" }, datetime: { pattern: i(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source), lookbehind: !0, alias: "number" }, boolean: { pattern: i(/false|true/.source, "i"), lookbehind: !0, alias: "important" }, null: { pattern: i(/null|~/.source, "i"), lookbehind: !0, alias: "important" }, string: { pattern: i(u), lookbehind: !0, greedy: !0 }, number: { pattern: i(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"), lookbehind: !0 }, tag: n, important: t, punctuation: /---|[:[\]{}\-,|>?]|\.\.\./ }, e.languages.yml = e.languages.yaml;
}(w), function(e) {
  var t = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function n(c) {
    return c = c.replace(/<inner>/g, function() {
      return t;
    }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + c + ")");
  }
  var r = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, a = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return r;
  }), u = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source, i = (e.languages.markdown = e.languages.extend("markup", {}), e.languages.insertBefore("markdown", "prolog", { "front-matter-block": { pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/, lookbehind: !0, greedy: !0, inside: { punctuation: /^---|---$/, "front-matter": { pattern: /\S+(?:\s+\S+)*/, alias: ["yaml", "language-yaml"], inside: e.languages.yaml } } }, blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" }, table: { pattern: RegExp("^" + a + u + "(?:" + a + ")*", "m"), inside: { "table-data-rows": { pattern: RegExp("^(" + a + u + ")(?:" + a + ")*$"), lookbehind: !0, inside: { "table-data": { pattern: RegExp(r), inside: e.languages.markdown }, punctuation: /\|/ } }, "table-line": { pattern: RegExp("^(" + a + ")" + u + "$"), lookbehind: !0, inside: { punctuation: /\||:?-{3,}:?/ } }, "table-header-row": { pattern: RegExp("^" + a + "$"), inside: { "table-header": { pattern: RegExp(r), alias: "important", inside: e.languages.markdown }, punctuation: /\|/ } } } }, code: [{ pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/, lookbehind: !0, alias: "keyword" }, { pattern: /^```[\s\S]*?^```$/m, greedy: !0, inside: { "code-block": { pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m, lookbehind: !0 }, "code-language": { pattern: /^(```).+/, lookbehind: !0 }, punctuation: /```/ } }], title: [{ pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m, alias: "important", inside: { punctuation: /==+$|--+$/ } }, { pattern: /(^\s*)#.+/m, lookbehind: !0, alias: "important", inside: { punctuation: /^#+|#+$/ } }], hr: { pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m, lookbehind: !0, alias: "punctuation" }, list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: !0, alias: "punctuation" }, "url-reference": { pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/, inside: { variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: !0 }, string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/, punctuation: /^[\[\]!:]|[<>]/ }, alias: "url" }, bold: { pattern: n(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source), lookbehind: !0, greedy: !0, inside: { content: { pattern: /(^..)[\s\S]+(?=..$)/, lookbehind: !0, inside: {} }, punctuation: /\*\*|__/ } }, italic: { pattern: n(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source), lookbehind: !0, greedy: !0, inside: { content: { pattern: /(^.)[\s\S]+(?=.$)/, lookbehind: !0, inside: {} }, punctuation: /[*_]/ } }, strike: { pattern: n(/(~~?)(?:(?!~)<inner>)+\2/.source), lookbehind: !0, greedy: !0, inside: { content: { pattern: /(^~~?)[\s\S]+(?=\1$)/, lookbehind: !0, inside: {} }, punctuation: /~~?/ } }, "code-snippet": { pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/, lookbehind: !0, greedy: !0, alias: ["code", "keyword"] }, url: { pattern: n(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source), lookbehind: !0, greedy: !0, inside: { operator: /^!/, content: { pattern: /(^\[)[^\]]+(?=\])/, lookbehind: !0, inside: {} }, variable: { pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/, lookbehind: !0 }, url: { pattern: /(^\]\()[^\s)]+/, lookbehind: !0 }, string: { pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/, lookbehind: !0 } } } }), ["url", "bold", "italic", "strike"].forEach(function(c) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(f) {
      c !== f && (e.languages.markdown[c].inside.content.inside[f] = e.languages.markdown[f]);
    });
  }), e.hooks.add("after-tokenize", function(c) {
    c.language !== "markdown" && c.language !== "md" || function f(d) {
      if (d && typeof d != "string")
        for (var b = 0, m = d.length; b < m; b++) {
          var h, E = d[b];
          E.type !== "code" ? f(E.content) : (h = E.content[1], E = E.content[3], h && E && h.type === "code-language" && E.type === "code-block" && typeof h.content == "string" && (h = h.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp"), h = "language-" + (h = (/[a-z][\w-]*/i.exec(h) || [""])[0].toLowerCase()), E.alias ? typeof E.alias == "string" ? E.alias = [E.alias, h] : E.alias.push(h) : E.alias = [h]));
        }
    }(c.tokens);
  }), e.hooks.add("wrap", function(c) {
    if (c.type === "code-block") {
      for (var f = "", d = 0, b = c.classes.length; d < b; d++) {
        var m = c.classes[d], m = /language-(.+)/.exec(m);
        if (m) {
          f = m[1];
          break;
        }
      }
      var h, E = e.languages[f];
      E ? c.content = e.highlight(function(y) {
        return y = y.replace(i, ""), y = y.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(_, x) {
          var I;
          return (x = x.toLowerCase())[0] === "#" ? (I = x[1] === "x" ? parseInt(x.slice(2), 16) : Number(x.slice(1)), l(I)) : o[x] || _;
        });
      }(c.content), E, f) : f && f !== "none" && e.plugins.autoloader && (h = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(1e16 * Math.random()), c.attributes.id = h, e.plugins.autoloader.loadLanguages(f, function() {
        var y = document.getElementById(h);
        y && (y.innerHTML = e.highlight(y.textContent, e.languages[f], f));
      }));
    }
  }), RegExp(e.languages.markup.tag.pattern.source, "gi")), o = { amp: "&", lt: "<", gt: ">", quot: '"' }, l = String.fromCodePoint || String.fromCharCode;
  e.languages.md = e.languages.markdown;
}(w), w.languages.graphql = { comment: /#.*/, description: { pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i, greedy: !0, alias: "string", inside: { "language-markdown": { pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/, lookbehind: !0, inside: w.languages.markdown } } }, string: { pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/, greedy: !0 }, number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, boolean: /\b(?:false|true)\b/, variable: /\$[a-z_]\w*/i, directive: { pattern: /@[a-z_]\w*/i, alias: "function" }, "attr-name": { pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i, greedy: !0 }, "atom-input": { pattern: /\b[A-Z]\w*Input\b/, alias: "class-name" }, scalar: /\b(?:Boolean|Float|ID|Int|String)\b/, constant: /\b[A-Z][A-Z_\d]*\b/, "class-name": { pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/, lookbehind: !0 }, fragment: { pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/, lookbehind: !0, alias: "function" }, "definition-mutation": { pattern: /(\bmutation\s+)[a-zA-Z_]\w*/, lookbehind: !0, alias: "function" }, "definition-query": { pattern: /(\bquery\s+)[a-zA-Z_]\w*/, lookbehind: !0, alias: "function" }, keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/, operator: /[!=|&]|\.{3}/, "property-query": /\w+(?=\s*\()/, object: /\w+(?=\s*\{)/, punctuation: /[!(){}\[\]:=,]/, property: /\w+/ }, w.hooks.add("after-tokenize", function(e) {
  if (e.language === "graphql")
    for (var t = e.tokens.filter(function(h) {
      return typeof h != "string" && h.type !== "comment" && h.type !== "scalar";
    }), n = 0; n < t.length; ) {
      var r = t[n++];
      if (r.type === "keyword" && r.content === "mutation") {
        var a = [];
        if (d(["definition-mutation", "punctuation"]) && f(1).content === "(") {
          n += 2;
          var u = b(/^\($/, /^\)$/);
          if (u === -1)
            continue;
          for (; n < u; n++) {
            var i = f(0);
            i.type === "variable" && (m(i, "variable-input"), a.push(i.content));
          }
          n = u + 1;
        }
        if (d(["punctuation", "property-query"]) && f(0).content === "{" && (n++, m(f(0), "property-mutation"), 0 < a.length)) {
          var o = b(/^\{$/, /^\}$/);
          if (o !== -1)
            for (var l = n; l < o; l++) {
              var c = t[l];
              c.type === "variable" && 0 <= a.indexOf(c.content) && m(c, "variable-input");
            }
        }
      }
    }
  function f(h) {
    return t[n + h];
  }
  function d(h, E) {
    E = E || 0;
    for (var y = 0; y < h.length; y++) {
      var _ = f(y + E);
      if (!_ || _.type !== h[y])
        return;
    }
    return 1;
  }
  function b(h, E) {
    for (var y = 1, _ = n; _ < t.length; _++) {
      var x = t[_], I = x.content;
      if (x.type === "punctuation" && typeof I == "string") {
        if (h.test(I))
          y++;
        else if (E.test(I) && --y === 0)
          return _;
      }
    }
    return -1;
  }
  function m(h, E) {
    var y = h.alias;
    y ? Array.isArray(y) || (h.alias = y = [y]) : h.alias = y = [], y.push(E);
  }
}), w.languages.sql = { comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/, lookbehind: !0 }, variable: [{ pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/, greedy: !0 }, /@[\w.$]+/], string: { pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/, greedy: !0, lookbehind: !0 }, identifier: { pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/, greedy: !0, lookbehind: !0, inside: { punctuation: /^`|`$/ } }, function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i, keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i, boolean: /\b(?:FALSE|NULL|TRUE)\b/i, number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i, operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i, punctuation: /[;[\]()`,.]/ }, function(e) {
  var t = e.languages.javascript["template-string"], n = t.pattern.source, r = t.inside.interpolation, a = r.inside["interpolation-punctuation"], u = r.pattern.source;
  function i(d, b) {
    if (e.languages[d])
      return { pattern: RegExp("((?:" + b + ")\\s*)" + n), lookbehind: !0, greedy: !0, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, "embedded-code": { pattern: /[\s\S]+/, alias: d } } };
  }
  function o(d, b, m) {
    return d = { code: d, grammar: b, language: m }, e.hooks.run("before-tokenize", d), d.tokens = e.tokenize(d.code, d.grammar), e.hooks.run("after-tokenize", d), d.tokens;
  }
  function l(d, b, m) {
    var y = e.tokenize(d, { interpolation: { pattern: RegExp(u), lookbehind: !0 } }), h = 0, E = {}, y = o(y.map(function(x) {
      if (typeof x == "string")
        return x;
      for (var I, M, x = x.content; d.indexOf((M = h++, I = "___" + m.toUpperCase() + "_" + M + "___")) !== -1; )
        ;
      return E[I] = x, I;
    }).join(""), b, m), _ = Object.keys(E);
    return h = 0, function x(I) {
      for (var M = 0; M < I.length; M++) {
        if (h >= _.length)
          return;
        var B, R, U, q, Y, S, H, F = I[M];
        typeof F == "string" || typeof F.content == "string" ? (B = _[h], (H = (S = typeof F == "string" ? F : F.content).indexOf(B)) !== -1 && (++h, R = S.substring(0, H), Y = E[B], U = void 0, (q = {})["interpolation-punctuation"] = a, (q = e.tokenize(Y, q)).length === 3 && ((U = [1, 1]).push.apply(U, o(q[1], e.languages.javascript, "javascript")), q.splice.apply(q, U)), U = new e.Token("interpolation", q, r.alias, Y), q = S.substring(H + B.length), Y = [], R && Y.push(R), Y.push(U), q && (x(S = [q]), Y.push.apply(Y, S)), typeof F == "string" ? (I.splice.apply(I, [M, 1].concat(Y)), M += Y.length - 1) : F.content = Y)) : (H = F.content, Array.isArray(H) ? x(H) : x([H]));
      }
    }(y), new e.Token(m, y, "language-" + m, d);
  }
  e.languages.javascript["template-string"] = [i("css", /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source), i("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source), i("svg", /\bsvg/.source), i("markdown", /\b(?:markdown|md)/.source), i("graphql", /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source), i("sql", /\bsql/.source), t].filter(Boolean);
  var c = { javascript: !0, js: !0, typescript: !0, ts: !0, jsx: !0, tsx: !0 };
  function f(d) {
    return typeof d == "string" ? d : Array.isArray(d) ? d.map(f).join("") : f(d.content);
  }
  e.hooks.add("after-tokenize", function(d) {
    d.language in c && function b(m) {
      for (var h = 0, E = m.length; h < E; h++) {
        var y, _, x, I = m[h];
        typeof I != "string" && (y = I.content, Array.isArray(y) ? I.type === "template-string" ? (I = y[1], y.length === 3 && typeof I != "string" && I.type === "embedded-code" && (_ = f(I), I = I.alias, I = Array.isArray(I) ? I[0] : I, x = e.languages[I]) && (y[1] = l(_, x, I))) : b(y) : typeof y != "string" && b([y]));
      }
    }(d.tokens);
  });
}(w), function(e) {
  e.languages.typescript = e.languages.extend("javascript", { "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/, lookbehind: !0, greedy: !0, inside: null }, builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/ }), e.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/, /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, /\btype\b(?=\s*(?:[\{*]|$))/), delete e.languages.typescript.parameter, delete e.languages.typescript["literal-property"];
  var t = e.languages.extend("typescript", {});
  delete t["class-name"], e.languages.typescript["class-name"].inside = t, e.languages.insertBefore("typescript", "function", { decorator: { pattern: /@[$\w\xA0-\uFFFF]+/, inside: { at: { pattern: /^@/, alias: "operator" }, function: /^[\s\S]+/ } }, "generic-function": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/, greedy: !0, inside: { function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: t } } } }), e.languages.ts = e.languages.typescript;
}(w), function(e) {
  var t = e.languages.javascript, n = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source, r = "(@(?:arg|argument|param|property)\\s+(?:" + n + "\\s+)?)";
  e.languages.jsdoc = e.languages.extend("javadoclike", { parameter: { pattern: RegExp(r + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source), lookbehind: !0, inside: { punctuation: /\./ } } }), e.languages.insertBefore("jsdoc", "keyword", { "optional-parameter": { pattern: RegExp(r + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source), lookbehind: !0, inside: { parameter: { pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/, lookbehind: !0, inside: { punctuation: /\./ } }, code: { pattern: /(=)[\s\S]*(?=\]$)/, lookbehind: !0, inside: t, alias: "language-javascript" }, punctuation: /[=[\]]/ } }, "class-name": [{ pattern: RegExp(/(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(/<TYPE>/g, function() {
    return n;
  })), lookbehind: !0, inside: { punctuation: /\./ } }, { pattern: RegExp("(@[a-z]+\\s+)" + n), lookbehind: !0, inside: { string: t.string, number: t.number, boolean: t.boolean, keyword: e.languages.typescript.keyword, operator: /=>|\.\.\.|[&|?:*]/, punctuation: /[.,;=<>{}()[\]]/ } }], example: { pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/, lookbehind: !0, inside: { code: { pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m, lookbehind: !0, inside: t, alias: "language-javascript" } } } }), e.languages.javadoclike.addSupport("javascript", e.languages.jsdoc);
}(w), function(e) {
  e.languages.flow = e.languages.extend("javascript", {}), e.languages.insertBefore("flow", "keyword", { type: [{ pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|[Ss]ymbol|any|mixed|null|void)\b/, alias: "class-name" }] }), e.languages.flow["function-variable"].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i, delete e.languages.flow.parameter, e.languages.insertBefore("flow", "operator", { "flow-punctuation": { pattern: /\{\||\|\}/, alias: "punctuation" } }), Array.isArray(e.languages.flow.keyword) || (e.languages.flow.keyword = [e.languages.flow.keyword]), e.languages.flow.keyword.unshift({ pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/, lookbehind: !0 }, { pattern: /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/, lookbehind: !0 });
}(w), w.languages.n4js = w.languages.extend("javascript", { keyword: /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/ }), w.languages.insertBefore("n4js", "constant", { annotation: { pattern: /@+\w+/, alias: "operator" } }), w.languages.n4jsd = w.languages.n4js, function(e) {
  function t(i, o) {
    return RegExp(i.replace(/<ID>/g, function() {
      return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
    }), o);
  }
  e.languages.insertBefore("javascript", "function-variable", { "method-variable": { pattern: RegExp("(\\.\\s*)" + e.languages.javascript["function-variable"].pattern.source), lookbehind: !0, alias: ["function-variable", "method", "function", "property-access"] } }), e.languages.insertBefore("javascript", "function", { method: { pattern: RegExp("(\\.\\s*)" + e.languages.javascript.function.source), lookbehind: !0, alias: ["function", "property-access"] } }), e.languages.insertBefore("javascript", "constant", { "known-class-name": [{ pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/, alias: "class-name" }, { pattern: /\b(?:[A-Z]\w*)Error\b/, alias: "class-name" }] }), e.languages.insertBefore("javascript", "keyword", { imports: { pattern: t(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source), lookbehind: !0, inside: e.languages.javascript }, exports: { pattern: t(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source), lookbehind: !0, inside: e.languages.javascript } }), e.languages.javascript.keyword.unshift({ pattern: /\b(?:as|default|export|from|import)\b/, alias: "module" }, { pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/, alias: "control-flow" }, { pattern: /\bnull\b/, alias: ["null", "nil"] }, { pattern: /\bundefined\b/, alias: "nil" }), e.languages.insertBefore("javascript", "operator", { spread: { pattern: /\.{3}/, alias: "operator" }, arrow: { pattern: /=>/, alias: "operator" } }), e.languages.insertBefore("javascript", "punctuation", { "property-access": { pattern: t(/(\.\s*)#?<ID>/.source), lookbehind: !0 }, "maybe-class-name": { pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/, lookbehind: !0 }, dom: { pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/, alias: "variable" }, console: { pattern: /\bconsole(?=\s*\.)/, alias: "class-name" } });
  for (var n = ["function", "function-variable", "method", "method-variable", "property-access"], r = 0; r < n.length; r++) {
    var u = n[r], a = e.languages.javascript[u], u = (a = e.util.type(a) === "RegExp" ? e.languages.javascript[u] = { pattern: a } : a).inside || {};
    (a.inside = u)["maybe-class-name"] = /^[A-Z][\s\S]*/;
  }
}(w), function(e) {
  var t = e.util.clone(e.languages.javascript), n = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source, r = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source, a = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  function u(l, c) {
    return l = l.replace(/<S>/g, function() {
      return n;
    }).replace(/<BRACES>/g, function() {
      return r;
    }).replace(/<SPREAD>/g, function() {
      return a;
    }), RegExp(l, c);
  }
  a = u(a).source, e.languages.jsx = e.languages.extend("markup", t), e.languages.jsx.tag.pattern = u(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source), e.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/, e.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/, e.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, e.languages.jsx.tag.inside.comment = t.comment, e.languages.insertBefore("inside", "attr-name", { spread: { pattern: u(/<SPREAD>/.source), inside: e.languages.jsx } }, e.languages.jsx.tag), e.languages.insertBefore("inside", "special-attr", { script: { pattern: u(/=<BRACES>/.source), alias: "language-javascript", inside: { "script-punctuation": { pattern: /^=(?=\{)/, alias: "punctuation" }, rest: e.languages.jsx } } }, e.languages.jsx.tag);
  function i(l) {
    for (var c = [], f = 0; f < l.length; f++) {
      var d = l[f], b = !1;
      typeof d != "string" && (d.type === "tag" && d.content[0] && d.content[0].type === "tag" ? d.content[0].content[0].content === "</" ? 0 < c.length && c[c.length - 1].tagName === o(d.content[0].content[1]) && c.pop() : d.content[d.content.length - 1].content !== "/>" && c.push({ tagName: o(d.content[0].content[1]), openedBraces: 0 }) : 0 < c.length && d.type === "punctuation" && d.content === "{" ? c[c.length - 1].openedBraces++ : 0 < c.length && 0 < c[c.length - 1].openedBraces && d.type === "punctuation" && d.content === "}" ? c[c.length - 1].openedBraces-- : b = !0), (b || typeof d == "string") && 0 < c.length && c[c.length - 1].openedBraces === 0 && (b = o(d), f < l.length - 1 && (typeof l[f + 1] == "string" || l[f + 1].type === "plain-text") && (b += o(l[f + 1]), l.splice(f + 1, 1)), 0 < f && (typeof l[f - 1] == "string" || l[f - 1].type === "plain-text") && (b = o(l[f - 1]) + b, l.splice(f - 1, 1), f--), l[f] = new e.Token("plain-text", b, null, b)), d.content && typeof d.content != "string" && i(d.content);
    }
  }
  var o = function(l) {
    return l ? typeof l == "string" ? l : typeof l.content == "string" ? l.content : l.content.map(o).join("") : "";
  };
  e.hooks.add("after-tokenize", function(l) {
    l.language !== "jsx" && l.language !== "tsx" || i(l.tokens);
  });
}(w), function(e) {
  var t = e.util.clone(e.languages.typescript), t = (e.languages.tsx = e.languages.extend("jsx", t), delete e.languages.tsx.parameter, delete e.languages.tsx["literal-property"], e.languages.tsx.tag);
  t.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + t.pattern.source + ")", t.pattern.flags), t.lookbehind = !0;
}(w), w.languages.swift = { comment: { pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/, lookbehind: !0, greedy: !0 }, "string-literal": [{ pattern: RegExp(/(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source), lookbehind: !0, greedy: !0, inside: { interpolation: { pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: !0, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\\($/, alias: "punctuation" }, punctuation: /\\(?=[\r\n])/, string: /[\s\S]+/ } }, { pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"), lookbehind: !0, greedy: !0, inside: { interpolation: { pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: !0, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\#+\($/, alias: "punctuation" }, string: /[\s\S]+/ } }], directive: { pattern: RegExp(/#/.source + "(?:" + /(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+|" + /(?:else|endif)\b/.source + ")"), alias: "property", inside: { "directive-name": /^#\w+/, boolean: /\b(?:false|true)\b/, number: /\b\d+(?:\.\d+)*\b/, operator: /!|&&|\|\||[<>]=?/, punctuation: /[(),]/ } }, literal: { pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/, alias: "constant" }, "other-directive": { pattern: /#\w+\b/, alias: "property" }, attribute: { pattern: /@\w+/, alias: "atrule" }, "function-definition": { pattern: /(\bfunc\s+)\w+/, lookbehind: !0, alias: "function" }, label: { pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/, lookbehind: !0, alias: "important" }, keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/, boolean: /\b(?:false|true)\b/, nil: { pattern: /\bnil\b/, alias: "constant" }, "short-argument": /\$\d+\b/, omit: { pattern: /\b_\b/, alias: "keyword" }, number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i, "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/, function: /\b[a-z_]\w*(?=\s*\()/i, constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/, operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/, punctuation: /[{}[\]();,.:\\]/ }, w.languages.swift["string-literal"].forEach(function(e) {
  e.inside.interpolation.inside = w.languages.swift;
}), function(e) {
  e.languages.kotlin = e.languages.extend("clike", { keyword: { pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/, lookbehind: !0 }, function: [{ pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/, greedy: !0 }, { pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/, lookbehind: !0, greedy: !0 }], number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/, operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/ }), delete e.languages.kotlin["class-name"];
  var t = { "interpolation-punctuation": { pattern: /^\$\{?|\}$/, alias: "punctuation" }, expression: { pattern: /[\s\S]+/, inside: e.languages.kotlin } };
  e.languages.insertBefore("kotlin", "string", { "string-literal": [{ pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/, alias: "multiline", inside: { interpolation: { pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i, inside: t }, string: /[\s\S]+/ } }, { pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/, alias: "singleline", inside: { interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i, lookbehind: !0, inside: t }, string: /[\s\S]+/ } }], char: { pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/, greedy: !0 } }), delete e.languages.kotlin.string, e.languages.insertBefore("kotlin", "keyword", { annotation: { pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/, alias: "builtin" } }), e.languages.insertBefore("kotlin", "function", { label: { pattern: /\b\w+@|@\w+\b/, alias: "symbol" } }), e.languages.kt = e.languages.kotlin, e.languages.kts = e.languages.kotlin;
}(w), w.languages.c = w.languages.extend("clike", { comment: { pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: !0 }, string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: !0 }, "class-name": { pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/, lookbehind: !0 }, keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/, function: /\b[a-z_]\w*(?=\s*\()/i, number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i, operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/ }), w.languages.insertBefore("c", "string", { char: { pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/, greedy: !0 } }), w.languages.insertBefore("c", "string", { macro: { pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im, lookbehind: !0, greedy: !0, alias: "property", inside: { string: [{ pattern: /^(#\s*include\s*)<[^>]+>/, lookbehind: !0 }, w.languages.c.string], char: w.languages.c.char, comment: w.languages.c.comment, "macro-name": [{ pattern: /(^#\s*define\s+)\w+\b(?!\()/i, lookbehind: !0 }, { pattern: /(^#\s*define\s+)\w+\b(?=\()/i, lookbehind: !0, alias: "function" }], directive: { pattern: /^(#\s*)[a-z]+/, lookbehind: !0, alias: "keyword" }, "directive-hash": /^#/, punctuation: /##|\\(?=[\r\n])/, expression: { pattern: /\S[\s\S]*/, inside: w.languages.c } } } }), w.languages.insertBefore("c", "function", { constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/ }), delete w.languages.c.boolean, w.languages.objectivec = w.languages.extend("c", { string: { pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: !0 }, keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/, operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/ }), delete w.languages.objectivec["class-name"], w.languages.objc = w.languages.objectivec, w.languages.reason = w.languages.extend("clike", { string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/, greedy: !0 }, "class-name": /\b[A-Z]\w*/, keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/, operator: /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/ }), w.languages.insertBefore("reason", "class-name", { char: { pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/, greedy: !0 }, constructor: /\b[A-Z]\w*\b(?!\s*\.)/, label: { pattern: /\b[a-z]\w*(?=::)/, alias: "symbol" } }), delete w.languages.reason.function, function(e) {
  for (var t = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, n = 0; n < 2; n++)
    t = t.replace(/<self>/g, function() {
      return t;
    });
  t = t.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  }), e.languages.rust = { comment: [{ pattern: RegExp(/(^|[^\\])/.source + t), lookbehind: !0, greedy: !0 }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 }], string: { pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/, greedy: !0 }, char: { pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/, greedy: !0 }, attribute: { pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/, greedy: !0, alias: "attr-name", inside: { string: null } }, "closure-params": { pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/, lookbehind: !0, greedy: !0, inside: { "closure-punctuation": { pattern: /^\||\|$/, alias: "punctuation" }, rest: null } }, "lifetime-annotation": { pattern: /'\w+/, alias: "symbol" }, "fragment-specifier": { pattern: /(\$\w+:)[a-z]+/, lookbehind: !0, alias: "punctuation" }, variable: /\$\w+/, "function-definition": { pattern: /(\bfn\s+)\w+/, lookbehind: !0, alias: "function" }, "type-definition": { pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/, lookbehind: !0, alias: "class-name" }, "module-declaration": [{ pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/, lookbehind: !0, alias: "namespace" }, { pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/, lookbehind: !0, alias: "namespace", inside: { punctuation: /::/ } }], keyword: [/\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/, /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/], function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/, macro: { pattern: /\b\w+!/, alias: "property" }, constant: /\b[A-Z_][A-Z_\d]+\b/, "class-name": /\b[A-Z]\w*\b/, namespace: { pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/, inside: { punctuation: /::/ } }, number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/, boolean: /\b(?:false|true)\b/, punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/, operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/ }, e.languages.rust["closure-params"].inside.rest = e.languages.rust, e.languages.rust.attribute.inside.string = e.languages.rust.string;
}(w), w.languages.go = w.languages.extend("clike", { string: { pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/, lookbehind: !0, greedy: !0 }, keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/, boolean: /\b(?:_|false|iota|nil|true)\b/, number: [/\b0(?:b[01_]+|o[0-7_]+)i?\b/i, /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i, /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i], operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./, builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/ }), w.languages.insertBefore("go", "string", { char: { pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/, greedy: !0 } }), delete w.languages.go["class-name"], function(e) {
  var t = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, n = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return t.source;
  });
  e.languages.cpp = e.languages.extend("c", { "class-name": [{ pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
    return t.source;
  })), lookbehind: !0 }, /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/, /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i, /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/], keyword: t, number: { pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i, greedy: !0 }, operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/, boolean: /\b(?:false|true)\b/ }), e.languages.insertBefore("cpp", "string", { module: { pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
    return n;
  }) + ")"), lookbehind: !0, greedy: !0, inside: { string: /^[<"][\s\S]+/, operator: /:/, punctuation: /\./ } }, "raw-string": { pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/, alias: "string", greedy: !0 } }), e.languages.insertBefore("cpp", "keyword", { "generic-function": { pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i, inside: { function: /^\w+/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: e.languages.cpp } } } }), e.languages.insertBefore("cpp", "operator", { "double-colon": { pattern: /::/, alias: "punctuation" } }), e.languages.insertBefore("cpp", "class-name", { "base-clause": { pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/, lookbehind: !0, greedy: !0, inside: e.languages.extend("cpp", {}) } }), e.languages.insertBefore("inside", "double-colon", { "class-name": /\b[a-z_]\w*\b(?!\s*::)/i }, e.languages.cpp["base-clause"]);
}(w), w.languages.python = { comment: { pattern: /(^|[^\\])#.*/, lookbehind: !0, greedy: !0 }, "string-interpolation": { pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i, greedy: !0, inside: { interpolation: { pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/, lookbehind: !0, inside: { "format-spec": { pattern: /(:)[^:(){}]+(?=\}$)/, lookbehind: !0 }, "conversion-option": { pattern: /![sra](?=[:}]$)/, alias: "punctuation" }, rest: null } }, string: /[\s\S]+/ } }, "triple-quoted-string": { pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i, greedy: !0, alias: "string" }, string: { pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i, greedy: !0 }, function: { pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g, lookbehind: !0 }, "class-name": { pattern: /(\bclass\s+)\w+/i, lookbehind: !0 }, decorator: { pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m, lookbehind: !0, alias: ["annotation", "punctuation"], inside: { punctuation: /\./ } }, keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/, builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/, boolean: /\b(?:False|None|True)\b/, number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i, operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/, punctuation: /[{}[\];(),.:]/ }, w.languages.python["string-interpolation"].inside.interpolation.inside.rest = w.languages.python, w.languages.py = w.languages.python, w.languages.json = { property: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/, lookbehind: !0, greedy: !0 }, string: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/, lookbehind: !0, greedy: !0 }, comment: { pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: !0 }, number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, punctuation: /[{}[\],]/, operator: /:/, boolean: /\b(?:false|true)\b/, null: { pattern: /\bnull\b/, alias: "keyword" } }, w.languages.webmanifest = w.languages.json;
var Er = {};
C1(Er, {
  dracula: () => N1,
  duotoneDark: () => L1,
  duotoneLight: () => w1,
  github: () => P1,
  gruvboxMaterialDark: () => lb,
  gruvboxMaterialLight: () => db,
  jettwaveDark: () => tb,
  jettwaveLight: () => rb,
  nightOwl: () => F1,
  nightOwlLight: () => v1,
  oceanicNext: () => U1,
  okaidia: () => Y1,
  oneDark: () => ib,
  oneLight: () => sb,
  palenight: () => G1,
  shadesOfPurple: () => $1,
  synthwave84: () => V1,
  ultramin: () => X1,
  vsDark: () => Is,
  vsLight: () => J1
});
var S1 = {
  plain: {
    color: "#F8F8F2",
    backgroundColor: "#282A36"
  },
  styles: [
    {
      types: ["prolog", "constant", "builtin"],
      style: {
        color: "rgb(189, 147, 249)"
      }
    },
    {
      types: ["inserted", "function"],
      style: {
        color: "rgb(80, 250, 123)"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgb(255, 85, 85)"
      }
    },
    {
      types: ["changed"],
      style: {
        color: "rgb(255, 184, 108)"
      }
    },
    {
      types: ["punctuation", "symbol"],
      style: {
        color: "rgb(248, 248, 242)"
      }
    },
    {
      types: ["string", "char", "tag", "selector"],
      style: {
        color: "rgb(255, 121, 198)"
      }
    },
    {
      types: ["keyword", "variable"],
      style: {
        color: "rgb(189, 147, 249)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(98, 114, 164)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(241, 250, 140)"
      }
    }
  ]
}, N1 = S1, R1 = {
  plain: {
    backgroundColor: "#2a2734",
    color: "#9a86fd"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
      style: {
        color: "#6c6783"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["tag", "operator", "number"],
      style: {
        color: "#e09142"
      }
    },
    {
      types: ["property", "function"],
      style: {
        color: "#9a86fd"
      }
    },
    {
      types: ["tag-id", "selector", "atrule-id"],
      style: {
        color: "#eeebff"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#c4b9fe"
      }
    },
    {
      types: [
        "boolean",
        "string",
        "entity",
        "url",
        "attr-value",
        "keyword",
        "control",
        "directive",
        "unit",
        "statement",
        "regex",
        "atrule",
        "placeholder",
        "variable"
      ],
      style: {
        color: "#ffcc99"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "#c4b9fe"
      }
    }
  ]
}, L1 = R1, O1 = {
  plain: {
    backgroundColor: "#faf8f5",
    color: "#728fcb"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
      style: {
        color: "#b6ad9a"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["tag", "operator", "number"],
      style: {
        color: "#063289"
      }
    },
    {
      types: ["property", "function"],
      style: {
        color: "#b29762"
      }
    },
    {
      types: ["tag-id", "selector", "atrule-id"],
      style: {
        color: "#2d2006"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#896724"
      }
    },
    {
      types: [
        "boolean",
        "string",
        "entity",
        "url",
        "attr-value",
        "keyword",
        "control",
        "directive",
        "unit",
        "statement",
        "regex",
        "atrule"
      ],
      style: {
        color: "#728fcb"
      }
    },
    {
      types: ["placeholder", "variable"],
      style: {
        color: "#93abdc"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "#896724"
      }
    }
  ]
}, w1 = O1, D1 = {
  plain: {
    color: "#393A34",
    backgroundColor: "#f6f8fa"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata"],
      style: {
        color: "#999988",
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["string", "attr-value"],
      style: {
        color: "#e3116c"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#393A34"
      }
    },
    {
      types: [
        "entity",
        "url",
        "symbol",
        "number",
        "boolean",
        "variable",
        "constant",
        "property",
        "regex",
        "inserted"
      ],
      style: {
        color: "#36acaa"
      }
    },
    {
      types: ["atrule", "keyword", "attr-name", "selector"],
      style: {
        color: "#00a4db"
      }
    },
    {
      types: ["function", "deleted", "tag"],
      style: {
        color: "#d73a49"
      }
    },
    {
      types: ["function-variable"],
      style: {
        color: "#6f42c1"
      }
    },
    {
      types: ["tag", "selector", "keyword"],
      style: {
        color: "#00009f"
      }
    }
  ]
}, P1 = D1, M1 = {
  plain: {
    color: "#d6deeb",
    backgroundColor: "#011627"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted", "attr-name"],
      style: {
        color: "rgb(173, 219, 103)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(99, 119, 119)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "rgb(173, 219, 103)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(214, 222, 235)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(247, 140, 108)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function"],
      style: {
        color: "rgb(130, 170, 255)"
      }
    },
    {
      // This was manually added after the auto-generation
      // so that punctuations are not italicised
      types: ["punctuation"],
      style: {
        color: "rgb(199, 146, 234)"
      }
    },
    {
      types: ["selector", "doctype"],
      style: {
        color: "rgb(199, 146, 234)",
        fontStyle: "italic"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(255, 203, 139)"
      }
    },
    {
      types: ["tag", "operator", "keyword"],
      style: {
        color: "rgb(127, 219, 202)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(255, 88, 116)"
      }
    },
    {
      types: ["property"],
      style: {
        color: "rgb(128, 203, 196)"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)"
      }
    }
  ]
}, F1 = M1, B1 = {
  plain: {
    color: "#403f53",
    backgroundColor: "#FBFBFB"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted", "attr-name"],
      style: {
        color: "rgb(72, 118, 214)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(152, 159, 177)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "builtin", "char", "constant", "url"],
      style: {
        color: "rgb(72, 118, 214)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(201, 103, 101)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(170, 9, 130)"
      }
    },
    {
      // This was manually added after the auto-generation
      // so that punctuations are not italicised
      types: ["punctuation"],
      style: {
        color: "rgb(153, 76, 195)"
      }
    },
    {
      types: ["function", "selector", "doctype"],
      style: {
        color: "rgb(153, 76, 195)",
        fontStyle: "italic"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(17, 17, 17)"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "rgb(153, 76, 195)"
      }
    },
    {
      types: ["operator", "property", "keyword", "namespace"],
      style: {
        color: "rgb(12, 150, 155)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(188, 84, 84)"
      }
    }
  ]
}, v1 = B1, ke = {
  char: "#D8DEE9",
  comment: "#999999",
  keyword: "#c5a5c5",
  primitive: "#5a9bcf",
  string: "#8dc891",
  variable: "#d7deea",
  boolean: "#ff8b50",
  punctuation: "#5FB3B3",
  tag: "#fc929e",
  function: "#79b6f2",
  className: "#FAC863",
  method: "#6699CC",
  operator: "#fc929e"
}, H1 = {
  plain: {
    backgroundColor: "#282c34",
    color: "#ffffff"
  },
  styles: [
    {
      types: ["attr-name"],
      style: {
        color: ke.keyword
      }
    },
    {
      types: ["attr-value"],
      style: {
        color: ke.string
      }
    },
    {
      types: [
        "comment",
        "block-comment",
        "prolog",
        "doctype",
        "cdata",
        "shebang"
      ],
      style: {
        color: ke.comment
      }
    },
    {
      types: [
        "property",
        "number",
        "function-name",
        "constant",
        "symbol",
        "deleted"
      ],
      style: {
        color: ke.primitive
      }
    },
    {
      types: ["boolean"],
      style: {
        color: ke.boolean
      }
    },
    {
      types: ["tag"],
      style: {
        color: ke.tag
      }
    },
    {
      types: ["string"],
      style: {
        color: ke.string
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: ke.string
      }
    },
    {
      types: ["selector", "char", "builtin", "inserted"],
      style: {
        color: ke.char
      }
    },
    {
      types: ["function"],
      style: {
        color: ke.function
      }
    },
    {
      types: ["operator", "entity", "url", "variable"],
      style: {
        color: ke.variable
      }
    },
    {
      types: ["keyword"],
      style: {
        color: ke.keyword
      }
    },
    {
      types: ["atrule", "class-name"],
      style: {
        color: ke.className
      }
    },
    {
      types: ["important"],
      style: {
        fontWeight: "400"
      }
    },
    {
      types: ["bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    }
  ]
}, U1 = H1, z1 = {
  plain: {
    color: "#f8f8f2",
    backgroundColor: "#272822"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "#f92672",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "rgb(173, 219, 103)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#8292a2",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "#a6e22e"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "#f8f8f2"
      }
    },
    {
      types: ["number"],
      style: {
        color: "#ae81ff"
      }
    },
    {
      types: ["builtin", "char", "constant", "function", "class-name"],
      style: {
        color: "#e6db74"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "#f8f8f2"
      }
    },
    {
      types: ["selector", "doctype"],
      style: {
        color: "#a6e22e",
        fontStyle: "italic"
      }
    },
    {
      types: ["tag", "operator", "keyword"],
      style: {
        color: "#66d9ef"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "#ae81ff"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)",
        opacity: 0.7
      }
    },
    {
      types: ["tag", "property"],
      style: {
        color: "#f92672"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#a6e22e !important"
      }
    },
    {
      types: ["doctype"],
      style: {
        color: "#8292a2"
      }
    },
    {
      types: ["rule"],
      style: {
        color: "#e6db74"
      }
    }
  ]
}, Y1 = z1, j1 = {
  plain: {
    color: "#bfc7d5",
    backgroundColor: "#292d3e"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(105, 112, 152)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "inserted"],
      style: {
        color: "rgb(195, 232, 141)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(247, 140, 108)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function"],
      style: {
        color: "rgb(130, 170, 255)"
      }
    },
    {
      types: ["punctuation", "selector"],
      style: {
        color: "rgb(199, 146, 234)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(191, 199, 213)"
      }
    },
    {
      types: ["class-name", "attr-name"],
      style: {
        color: "rgb(255, 203, 107)"
      }
    },
    {
      types: ["tag", "deleted"],
      style: {
        color: "rgb(255, 85, 114)"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "rgb(137, 221, 255)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(255, 88, 116)"
      }
    },
    {
      types: ["keyword"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["doctype"],
      style: {
        color: "rgb(199, 146, 234)",
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "rgb(221, 221, 221)"
      }
    }
  ]
}, G1 = j1, q1 = {
  plain: {
    color: "#9EFEFF",
    backgroundColor: "#2D2A55"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(255, 238, 128)"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "rgb(173, 219, 103)"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(179, 98, 255)",
        fontStyle: "italic"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "rgb(255, 255, 255)"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "rgb(255, 98, 140)"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "rgb(165, 255, 144)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(255, 238, 128)"
      }
    },
    {
      types: ["number", "boolean"],
      style: {
        color: "rgb(255, 98, 140)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(255, 180, 84)"
      }
    },
    {
      types: [
        "keyword",
        "operator",
        "property",
        "namespace",
        "tag",
        "selector",
        "doctype"
      ],
      style: {
        color: "rgb(255, 157, 0)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function", "class-name"],
      style: {
        color: "rgb(250, 208, 0)"
      }
    }
  ]
}, $1 = q1, W1 = {
  plain: {
    backgroundColor: "linear-gradient(to bottom, #2a2139 75%, #34294f)",
    backgroundImage: "#34294f",
    color: "#f92aad",
    textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
  },
  styles: [
    {
      types: ["comment", "block-comment", "prolog", "doctype", "cdata"],
      style: {
        color: "#495495",
        fontStyle: "italic"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "#ccc"
      }
    },
    {
      types: [
        "tag",
        "attr-name",
        "namespace",
        "number",
        "unit",
        "hexcode",
        "deleted"
      ],
      style: {
        color: "#e2777a"
      }
    },
    {
      types: ["property", "selector"],
      style: {
        color: "#72f1b8",
        textShadow: "0 0 2px #100c0f, 0 0 10px #257c5575, 0 0 35px #21272475"
      }
    },
    {
      types: ["function-name"],
      style: {
        color: "#6196cc"
      }
    },
    {
      types: ["boolean", "selector-id", "function"],
      style: {
        color: "#fdfdfd",
        textShadow: "0 0 2px #001716, 0 0 3px #03edf975, 0 0 5px #03edf975, 0 0 8px #03edf975"
      }
    },
    {
      types: ["class-name", "maybe-class-name", "builtin"],
      style: {
        color: "#fff5f6",
        textShadow: "0 0 2px #000, 0 0 10px #fc1f2c75, 0 0 5px #fc1f2c75, 0 0 25px #fc1f2c75"
      }
    },
    {
      types: ["constant", "symbol"],
      style: {
        color: "#f92aad",
        textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
      }
    },
    {
      types: ["important", "atrule", "keyword", "selector-class"],
      style: {
        color: "#f4eee4",
        textShadow: "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"
      }
    },
    {
      types: ["string", "char", "attr-value", "regex", "variable"],
      style: {
        color: "#f87c32"
      }
    },
    {
      types: ["parameter"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["entity", "url"],
      style: {
        color: "#67cdcc"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "ffffffee"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["entity"],
      style: {
        cursor: "help"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "green"
      }
    }
  ]
}, V1 = W1, Q1 = {
  plain: {
    color: "#282a2e",
    backgroundColor: "#ffffff"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(197, 200, 198)"
      }
    },
    {
      types: ["string", "number", "builtin", "variable"],
      style: {
        color: "rgb(150, 152, 150)"
      }
    },
    {
      types: ["class-name", "function", "tag", "attr-name"],
      style: {
        color: "rgb(40, 42, 46)"
      }
    }
  ]
}, X1 = Q1, K1 = {
  plain: {
    color: "#9CDCFE",
    backgroundColor: "#1E1E1E"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "rgb(0, 0, 128)"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(106, 153, 85)"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "rgb(86, 156, 214)"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "rgb(181, 206, 168)"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "rgb(100, 102, 149)"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "rgb(156, 220, 254)"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "rgb(206, 145, 120)"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "rgb(215, 186, 125)"
      }
    },
    {
      // Fix tag color
      types: ["tag"],
      style: {
        color: "rgb(78, 201, 176)"
      }
    },
    {
      // Fix tag color for HTML
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "rgb(86, 156, 214)"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "rgb(212, 212, 212)"
      }
    },
    {
      // Fix punctuation color for HTML
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "rgb(220, 220, 170)"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(78, 201, 176)"
      }
    },
    {
      types: ["char"],
      style: {
        color: "rgb(209, 105, 105)"
      }
    }
  ]
}, Is = K1, Z1 = {
  plain: {
    color: "#000000",
    backgroundColor: "#ffffff"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(0, 128, 0)"
      }
    },
    {
      types: ["builtin"],
      style: {
        color: "rgb(0, 112, 193)"
      }
    },
    {
      types: ["number", "variable", "inserted"],
      style: {
        color: "rgb(9, 134, 88)"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "rgb(0, 0, 0)"
      }
    },
    {
      types: ["constant", "char"],
      style: {
        color: "rgb(129, 31, 63)"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "rgb(128, 0, 0)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(255, 0, 0)"
      }
    },
    {
      types: ["deleted", "string"],
      style: {
        color: "rgb(163, 21, 21)"
      }
    },
    {
      types: ["changed", "punctuation"],
      style: {
        color: "rgb(4, 81, 165)"
      }
    },
    {
      types: ["function", "keyword"],
      style: {
        color: "rgb(0, 0, 255)"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(38, 127, 153)"
      }
    }
  ]
}, J1 = Z1, eb = {
  plain: {
    color: "#f8fafc",
    backgroundColor: "#011627"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "#000080"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#6A9955"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "#569CD6"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "#B5CEA8"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "#f8fafc"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "#9CDCFE"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "#cbd5e1"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "#D7BA7D"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#D4D4D4"
      }
    },
    {
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "#7dd3fc"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["char"],
      style: {
        color: "#D16969"
      }
    }
  ]
}, tb = eb, nb = {
  plain: {
    color: "#0f172a",
    backgroundColor: "#f1f5f9"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "#000080"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#6A9955"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "#0c4a6e"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "#B5CEA8"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "#0f172a"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "#0c4a6e"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "#64748b"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "#D7BA7D"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#475569"
      }
    },
    {
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "#0e7490"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["char"],
      style: {
        color: "#D16969"
      }
    }
  ]
}, rb = nb, ab = {
  plain: {
    backgroundColor: "hsl(220, 13%, 18%)",
    color: "hsl(220, 14%, 71%)",
    textShadow: "0 1px rgba(0, 0, 0, 0.3)"
  },
  styles: [
    {
      types: ["comment", "prolog", "cdata"],
      style: {
        color: "hsl(220, 10%, 40%)"
      }
    },
    {
      types: ["doctype", "punctuation", "entity"],
      style: {
        color: "hsl(220, 14%, 71%)"
      }
    },
    {
      types: [
        "attr-name",
        "class-name",
        "maybe-class-name",
        "boolean",
        "constant",
        "number",
        "atrule"
      ],
      style: { color: "hsl(29, 54%, 61%)" }
    },
    {
      types: ["keyword"],
      style: { color: "hsl(286, 60%, 67%)" }
    },
    {
      types: ["property", "tag", "symbol", "deleted", "important"],
      style: {
        color: "hsl(355, 65%, 65%)"
      }
    },
    {
      types: [
        "selector",
        "string",
        "char",
        "builtin",
        "inserted",
        "regex",
        "attr-value"
      ],
      style: {
        color: "hsl(95, 38%, 62%)"
      }
    },
    {
      types: ["variable", "operator", "function"],
      style: {
        color: "hsl(207, 82%, 66%)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "hsl(187, 47%, 55%)"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "hsl(220, 14%, 71%)"
      }
    }
  ]
}, ib = ab, ub = {
  plain: {
    backgroundColor: "hsl(230, 1%, 98%)",
    color: "hsl(230, 8%, 24%)"
  },
  styles: [
    {
      types: ["comment", "prolog", "cdata"],
      style: {
        color: "hsl(230, 4%, 64%)"
      }
    },
    {
      types: ["doctype", "punctuation", "entity"],
      style: {
        color: "hsl(230, 8%, 24%)"
      }
    },
    {
      types: [
        "attr-name",
        "class-name",
        "boolean",
        "constant",
        "number",
        "atrule"
      ],
      style: {
        color: "hsl(35, 99%, 36%)"
      }
    },
    {
      types: ["keyword"],
      style: {
        color: "hsl(301, 63%, 40%)"
      }
    },
    {
      types: ["property", "tag", "symbol", "deleted", "important"],
      style: {
        color: "hsl(5, 74%, 59%)"
      }
    },
    {
      types: [
        "selector",
        "string",
        "char",
        "builtin",
        "inserted",
        "regex",
        "attr-value",
        "punctuation"
      ],
      style: {
        color: "hsl(119, 34%, 47%)"
      }
    },
    {
      types: ["variable", "operator", "function"],
      style: {
        color: "hsl(221, 87%, 60%)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "hsl(198, 99%, 37%)"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "hsl(230, 8%, 24%)"
      }
    }
  ]
}, sb = ub, ob = {
  plain: {
    color: "#ebdbb2",
    backgroundColor: "#292828"
  },
  styles: [
    {
      types: [
        "imports",
        "class-name",
        "maybe-class-name",
        "constant",
        "doctype",
        "builtin",
        "function"
      ],
      style: {
        color: "#d8a657"
      }
    },
    {
      types: ["property-access"],
      style: {
        color: "#7daea3"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#e78a4e"
      }
    },
    {
      types: ["attr-name", "char", "url", "regex"],
      style: {
        color: "#a9b665"
      }
    },
    {
      types: ["attr-value", "string"],
      style: {
        color: "#89b482"
      }
    },
    {
      types: ["comment", "prolog", "cdata", "operator", "inserted"],
      style: {
        color: "#a89984"
      }
    },
    {
      types: [
        "delimiter",
        "boolean",
        "keyword",
        "selector",
        "important",
        "atrule",
        "property",
        "variable",
        "deleted"
      ],
      style: {
        color: "#ea6962"
      }
    },
    {
      types: ["entity", "number", "symbol"],
      style: {
        color: "#d3869b"
      }
    }
  ]
}, lb = ob, cb = {
  plain: {
    color: "#654735",
    backgroundColor: "#f9f5d7"
  },
  styles: [
    {
      types: [
        "delimiter",
        "boolean",
        "keyword",
        "selector",
        "important",
        "atrule",
        "property",
        "variable",
        "deleted"
      ],
      style: {
        color: "#af2528"
      }
    },
    {
      types: [
        "imports",
        "class-name",
        "maybe-class-name",
        "constant",
        "doctype",
        "builtin"
      ],
      style: {
        color: "#b4730e"
      }
    },
    {
      types: ["string", "attr-value"],
      style: {
        color: "#477a5b"
      }
    },
    {
      types: ["property-access"],
      style: {
        color: "#266b79"
      }
    },
    {
      types: ["function", "attr-name", "char", "url"],
      style: {
        color: "#72761e"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#b94c07"
      }
    },
    {
      types: ["comment", "prolog", "cdata", "operator", "inserted"],
      style: {
        color: "#a89984"
      }
    },
    {
      types: ["entity", "number", "symbol"],
      style: {
        color: "#924f79"
      }
    }
  ]
}, db = cb, fb = (e, t) => {
  const { plain: n } = e, r = e.styles.reduce((a, u) => {
    const { languages: i, style: o } = u;
    return i && !i.includes(t) || u.types.forEach((l) => {
      const c = ze(ze({}, a[l]), o);
      a[l] = c;
    }), a;
  }, {});
  return r.root = n, r.plain = Pn(ze({}, n), { backgroundColor: void 0 }), r;
}, mi = fb, hb = (e, t) => {
  const [n, r] = Tr(
    mi(t, e)
  ), a = At(), u = At();
  return hn(() => {
    (t !== a.current || e !== u.current) && (a.current = t, u.current = e, r(mi(t, e)));
  }, [e, t]), n;
}, pb = (e) => pn(
  (t) => {
    var n = t, { className: r, style: a, line: u } = n, i = ks(n, ["className", "style", "line"]);
    const o = Pn(ze({}, i), {
      className: yr("token-line", r)
    });
    return typeof e == "object" && "plain" in e && (o.style = e.plain), typeof a == "object" && (o.style = ze(ze({}, o.style || {}), a)), o;
  },
  [e]
), mb = (e) => {
  const t = pn(
    ({ types: n, empty: r }) => {
      if (e != null) {
        {
          if (n.length === 1 && n[0] === "plain")
            return r != null ? { display: "inline-block" } : void 0;
          if (n.length === 1 && r != null)
            return e[n[0]];
        }
        return Object.assign(
          r != null ? { display: "inline-block" } : {},
          ...n.map((a) => e[a])
        );
      }
    },
    [e]
  );
  return pn(
    (n) => {
      var r = n, { token: a, className: u, style: i } = r, o = ks(r, ["token", "className", "style"]);
      const l = Pn(ze({}, o), {
        className: yr("token", ...a.types, u),
        children: a.content,
        style: t(a)
      });
      return i != null && (l.style = ze(ze({}, l.style || {}), i)), l;
    },
    [t]
  );
}, gb = /\r\n|\r|\n/, gi = (e) => {
  e.length === 0 ? e.push({
    types: ["plain"],
    content: `
`,
    empty: !0
  }) : e.length === 1 && e[0].content === "" && (e[0].content = `
`, e[0].empty = !0);
}, bi = (e, t) => {
  const n = e.length;
  return n > 0 && e[n - 1] === t ? e : e.concat(t);
}, bb = (e) => {
  const t = [[]], n = [e], r = [0], a = [e.length];
  let u = 0, i = 0, o = [];
  const l = [o];
  for (; i > -1; ) {
    for (; (u = r[i]++) < a[i]; ) {
      let c, f = t[i];
      const b = n[i][u];
      if (typeof b == "string" ? (f = i > 0 ? f : ["plain"], c = b) : (f = bi(f, b.type), b.alias && (f = bi(f, b.alias)), c = b.content), typeof c != "string") {
        i++, t.push(f), n.push(c), r.push(0), a.push(c.length);
        continue;
      }
      const m = c.split(gb), h = m.length;
      o.push({
        types: f,
        content: m[0]
      });
      for (let E = 1; E < h; E++)
        gi(o), l.push(o = []), o.push({
          types: f,
          content: m[E]
        });
    }
    i--, t.pop(), n.pop(), r.pop(), a.pop();
  }
  return gi(o), l;
}, Ei = bb, Eb = ({ prism: e, code: t, grammar: n, language: r }) => {
  const a = At(e);
  return tr(() => {
    if (n == null)
      return Ei([t]);
    const u = {
      code: t,
      grammar: n,
      language: r,
      tokens: []
    };
    return a.current.hooks.run("before-tokenize", u), u.tokens = a.current.tokenize(t, n), a.current.hooks.run("after-tokenize", u), Ei(u.tokens);
  }, [t, n, r]);
}, Tb = ({
  children: e,
  language: t,
  code: n,
  theme: r,
  prism: a
}) => {
  const u = t.toLowerCase(), i = hb(u, r), o = pb(i), l = mb(i), c = a.languages[u], f = Eb({ prism: a, language: u, code: n, grammar: c });
  return e({
    tokens: f,
    className: `prism-code language-${u}`,
    style: i != null ? i.root : {},
    getLineProps: o,
    getTokenProps: l
  });
}, yb = (e) => Fs(Tb, Pn(ze({}, e), {
  prism: e.prism || w,
  theme: e.theme || Is,
  code: e.code,
  language: e.language
}));
/*! Bundled license information:

prismjs/prism.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)
*/
const Ab = Ti([
  !1,
  () => {
  }
]), _b = () => yi(Ab);
globalThis.Prism = w;
import("./prism-bash.min-DadFsM4Z.js");
import("./prism-ruby.min-C7LwcKyz.js");
import("./prism-markup-templating-DZrrEs0A.js");
import("./prism-markup-BNGj0Tvm.js");
import("./prism-php.min-o7FpoMP_.js");
import("./prism-json.min-B1GJqK1k.js");
import("./prism-java.min-d5iT_mOd.js");
import("./prism-csharp.min-Yizuc34Y.js");
import("./prism-objectivec.min-BXSWqpJJ.js");
import("./prism-markdown.min-F3U-vPBi.js");
import("./prism-javascript.min-CEqHqgbm.js");
import("./prism-typescript.min-oSVeWCAd.js");
const Cb = ({
  copyable: e = !0,
  language: t = "plain",
  ...n
}) => {
  const [r] = _b(), [a, u] = Tr(!1);
  return n.code ? /* @__PURE__ */ Q.jsx(
    yb,
    {
      theme: r ? Er.vsDark : Er.github,
      language: t,
      ...n,
      children: ({ className: i, style: o, tokens: l, getLineProps: c, getTokenProps: f }) => /* @__PURE__ */ Q.jsxs("div", { className: "relative group", children: [
        /* @__PURE__ */ Q.jsx(
          "pre",
          {
            className: bt(
              "relative scrollbar overflow-x-auto",
              i,
              n.className,
              n.noBackground && "!bg-transparent",
              n.wrapLines && "whitespace-pre-wrap break-words"
            ),
            style: o,
            children: l.map((d, b) => (
              // eslint-disable-next-line react/no-array-index-key
              /* @__PURE__ */ Q.jsx("div", { ...c({ line: d }), children: d.map((m, h) => (
                // eslint-disable-next-line react/no-array-index-key
                /* @__PURE__ */ Q.jsx("span", { ...f({ token: m }) }, h)
              )) }, b)
            ))
          }
        ),
        n.showLanguageIndicator && /* @__PURE__ */ Q.jsx("span", { className: "absolute top-1.5 right-3 text-[11px] font-mono text-muted-foreground transition group-hover:opacity-0", children: t }),
        e && /* @__PURE__ */ Q.jsx(
          "button",
          {
            type: "button",
            "aria-label": "Copy code",
            title: "Copy code",
            className: "absolute top-2 right-2 p-2 opacity-0 group-hover:opacity-100 group-hover:bg-zinc-100 group-hover:dark:bg-zinc-700 hover:outline hover:outline-border/75 dark:hover:outline-border rounded-md text-sm text-gray-400 hover:text-gray-600 dark:text-gray-500 dark:hover:text-gray-400 transition",
            disabled: a,
            onClick: () => {
              u(!0), navigator.clipboard.writeText(
                l.map((d) => d.map(({ content: b }) => b).join("")).join(`
`)
              ), setTimeout(() => u(!1), 2e3);
            },
            children: a ? /* @__PURE__ */ Q.jsx(Us, { className: "text-emerald-600", size: 16 }) : /* @__PURE__ */ Q.jsx(zs, { size: 16 })
          }
        )
      ] })
    }
  ) : null;
}, xb = {
  // @ts-expect-error Node is not in types but still gets passed
  img: ({ node: e, ...t }) => /\.(mp4|webm|mov|avi)$/.test(t.src ?? "") ? /* @__PURE__ */ Q.jsx("video", { src: t.src, controls: !0, playsInline: !0, autoPlay: !0, loop: !0 }) : /* @__PURE__ */ Q.jsx("img", { ...t, className: "rounded-md" }),
  h1: ({ children: e, id: t }) => /* @__PURE__ */ Q.jsx(ht, { level: 1, id: t, children: e }),
  h2: ({ children: e, id: t }) => /* @__PURE__ */ Q.jsx(ht, { level: 2, id: t, children: e }),
  h3: ({ children: e, id: t }) => /* @__PURE__ */ Q.jsx(ht, { level: 3, id: t, children: e }),
  h4: ({ children: e, id: t }) => /* @__PURE__ */ Q.jsx(ht, { level: 4, id: t, children: e }),
  h5: ({ children: e, id: t }) => /* @__PURE__ */ Q.jsx(ht, { level: 5, id: t, children: e }),
  h6: ({ children: e, id: t }) => /* @__PURE__ */ Q.jsx(ht, { level: 6, id: t, children: e }),
  // @ts-expect-error Node is not in types but still gets passed
  a: ({ href: e, node: t, ...n }) => e && !e.startsWith("http") ? /* @__PURE__ */ Q.jsx(Ms, { to: e, relative: "path", ...n }) : /* @__PURE__ */ Q.jsx("a", { href: e, target: "_blank", ...n, rel: "noreferrer" }),
  Callout: at,
  tip: (e) => /* @__PURE__ */ Q.jsx(at, { type: "tip", ...e }),
  info: (e) => /* @__PURE__ */ Q.jsx(at, { type: "info", ...e }),
  note: (e) => /* @__PURE__ */ Q.jsx(at, { type: "note", ...e }),
  caution: (e) => /* @__PURE__ */ Q.jsx(at, { type: "caution", ...e }),
  warning: (e) => /* @__PURE__ */ Q.jsx(at, { type: "caution", ...e }),
  danger: (e) => /* @__PURE__ */ Q.jsx(at, { type: "danger", ...e }),
  pre: ({ children: e }) => /* @__PURE__ */ Q.jsx(Q.Fragment, { children: e }),
  code: ({ className: e, children: t, ...n }) => {
    const r = n.inline;
    if (r === !0 || r === "true")
      return /* @__PURE__ */ Q.jsx(g1, { className: e, children: t });
    const a = e == null ? void 0 : e.match(/language?-(\w+)/);
    return /* @__PURE__ */ Q.jsx(
      Cb,
      {
        language: a == null ? void 0 : a[1],
        className: "rounded-xl p-4 border dark:!bg-foreground/10 dark:border-transparent",
        showLanguageIndicator: !0,
        code: String(t).trim()
      }
    );
  }
}, kb = () => (e) => {
  Zt(e, "element", (t, n, r) => {
    t.tagName === "code" && (t.properties.inline = String((r == null ? void 0 : r.tagName) !== "pre"));
  });
}, Ib = [m1], Sb = [kb, um], Pb = "prose dark:prose-invert prose-neutral", Mb = ({
  content: e,
  className: t
}) => /* @__PURE__ */ Q.jsx(
  $0,
  {
    remarkPlugins: Ib,
    rehypePlugins: Sb,
    components: xb,
    className: t,
    children: e
  }
);
export {
  at as C,
  ht as H,
  g1 as I,
  Mb as M,
  Pb as P,
  Cb as S,
  Ab as T,
  Db as V,
  bt as a,
  _b as b,
  Zr as c,
  xb as d,
  qs as e,
  Io as u
};
//# sourceMappingURL=Markdown-CWI6lU11.js.map
