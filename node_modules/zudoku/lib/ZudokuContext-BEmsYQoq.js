var Le = (t) => {
  throw TypeError(t);
};
var pe = (t, e, s) => e.has(t) || Le("Cannot " + s);
var i = (t, e, s) => (pe(t, e, "read from private field"), s ? s.call(t) : e.get(t)), y = (t, e, s) => e.has(t) ? Le("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, s), c = (t, e, s, r) => (pe(t, e, "write to private field"), r ? r.call(t, s) : e.set(t, s), s), b = (t, e, s) => (pe(t, e, "access private method"), s);
import * as P from "react";
import { createContext as ut, useContext as ht } from "react";
import { j as ct } from "./jsx-runtime-B6kdoens.js";
import { u as Je } from "./index-BRCiYFaL.js";
var xe = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
}, V = typeof window > "u" || "Deno" in globalThis;
function be() {
}
function Gt(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function me(t) {
  return typeof t == "number" && t >= 0 && t !== 1 / 0;
}
function Ze(t, e) {
  return Math.max(t + (e || 0) - Date.now(), 0);
}
function de(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function I(t, e) {
  return typeof t == "function" ? t(e) : t;
}
function zt(t, e) {
  const {
    type: s = "all",
    exact: r,
    fetchStatus: n,
    predicate: o,
    queryKey: a,
    stale: h
  } = t;
  if (a) {
    if (r) {
      if (e.queryHash !== lt(a, e.options))
        return !1;
    } else if (!Qe(e.queryKey, a))
      return !1;
  }
  if (s !== "all") {
    const l = e.isActive();
    if (s === "active" && !l || s === "inactive" && l)
      return !1;
  }
  return !(typeof h == "boolean" && e.isStale() !== h || n && n !== e.state.fetchStatus || o && !o(e));
}
function Vt(t, e) {
  const { exact: s, status: r, predicate: n, mutationKey: o } = t;
  if (o) {
    if (!e.options.mutationKey)
      return !1;
    if (s) {
      if (ge(e.options.mutationKey) !== ge(o))
        return !1;
    } else if (!Qe(e.options.mutationKey, o))
      return !1;
  }
  return !(r && e.state.status !== r || n && !n(e));
}
function lt(t, e) {
  return ((e == null ? void 0 : e.queryKeyHashFn) || ge)(t);
}
function ge(t) {
  return JSON.stringify(
    t,
    (e, s) => Ce(s) ? Object.keys(s).sort().reduce((r, n) => (r[n] = s[n], r), {}) : s
  );
}
function Qe(t, e) {
  return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? !Object.keys(e).some((s) => !Qe(t[s], e[s])) : !1;
}
function Re(t, e) {
  if (t === e)
    return t;
  const s = Ne(t) && Ne(e);
  if (s || Ce(t) && Ce(e)) {
    const r = s ? t : Object.keys(t), n = r.length, o = s ? e : Object.keys(e), a = o.length, h = s ? [] : {};
    let l = 0;
    for (let R = 0; R < a; R++) {
      const v = s ? R : o[R];
      (!s && r.includes(v) || s) && t[v] === void 0 && e[v] === void 0 ? (h[v] = void 0, l++) : (h[v] = Re(t[v], e[v]), h[v] === t[v] && t[v] !== void 0 && l++);
    }
    return n === a && l === n ? t : h;
  }
  return e;
}
function Se(t, e) {
  if (!e || Object.keys(t).length !== Object.keys(e).length)
    return !1;
  for (const s in t)
    if (t[s] !== e[s])
      return !1;
  return !0;
}
function Ne(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length;
}
function Ce(t) {
  if (!Ke(t))
    return !1;
  const e = t.constructor;
  if (e === void 0)
    return !0;
  const s = e.prototype;
  return !(!Ke(s) || !s.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype);
}
function Ke(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function dt(t) {
  return new Promise((e) => {
    setTimeout(e, t);
  });
}
function we(t, e, s) {
  if (typeof s.structuralSharing == "function")
    return s.structuralSharing(t, e);
  if (s.structuralSharing !== !1) {
    if (process.env.NODE_ENV !== "production")
      try {
        return Re(t, e);
      } catch (r) {
        console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${s.queryHash}]: ${r}`
        );
      }
    return Re(t, e);
  }
  return e;
}
function $t(t, e, s = 0) {
  const r = [...t, e];
  return s && r.length > s ? r.slice(1) : r;
}
function Wt(t, e, s = 0) {
  const r = [e, ...t];
  return s && r.length > s ? r.slice(0, -1) : r;
}
var fe = Symbol();
function ft(t, e) {
  return process.env.NODE_ENV !== "production" && t.queryFn === fe && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${t.queryHash}'`
  ), !t.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !t.queryFn || t.queryFn === fe ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn;
}
var K, A, J, Ge, yt = (Ge = class extends xe {
  constructor() {
    super();
    y(this, K);
    y(this, A);
    y(this, J);
    c(this, J, (e) => {
      if (!V && window.addEventListener) {
        const s = () => e();
        return window.addEventListener("visibilitychange", s, !1), () => {
          window.removeEventListener("visibilitychange", s);
        };
      }
    });
  }
  onSubscribe() {
    i(this, A) || this.setEventListener(i(this, J));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = i(this, A)) == null || e.call(this), c(this, A, void 0));
  }
  setEventListener(e) {
    var s;
    c(this, J, e), (s = i(this, A)) == null || s.call(this), c(this, A, e((r) => {
      typeof r == "boolean" ? this.setFocused(r) : this.onFocus();
    }));
  }
  setFocused(e) {
    i(this, K) !== e && (c(this, K, e), this.onFocus());
  }
  onFocus() {
    const e = this.isFocused();
    this.listeners.forEach((s) => {
      s(e);
    });
  }
  isFocused() {
    var e;
    return typeof i(this, K) == "boolean" ? i(this, K) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== "hidden";
  }
}, K = new WeakMap(), A = new WeakMap(), J = new WeakMap(), Ge), Xe = new yt(), Z, k, X, ze, pt = (ze = class extends xe {
  constructor() {
    super();
    y(this, Z, !0);
    y(this, k);
    y(this, X);
    c(this, X, (e) => {
      if (!V && window.addEventListener) {
        const s = () => e(!0), r = () => e(!1);
        return window.addEventListener("online", s, !1), window.addEventListener("offline", r, !1), () => {
          window.removeEventListener("online", s), window.removeEventListener("offline", r);
        };
      }
    });
  }
  onSubscribe() {
    i(this, k) || this.setEventListener(i(this, X));
  }
  onUnsubscribe() {
    var e;
    this.hasListeners() || ((e = i(this, k)) == null || e.call(this), c(this, k, void 0));
  }
  setEventListener(e) {
    var s;
    c(this, X, e), (s = i(this, k)) == null || s.call(this), c(this, k, e(this.setOnline.bind(this)));
  }
  setOnline(e) {
    i(this, Z) !== e && (c(this, Z, e), this.listeners.forEach((r) => {
      r(e);
    }));
  }
  isOnline() {
    return i(this, Z);
  }
}, Z = new WeakMap(), k = new WeakMap(), X = new WeakMap(), ze), Ye = new pt();
function Ee() {
  let t, e;
  const s = new Promise((n, o) => {
    t = n, e = o;
  });
  s.status = "pending", s.catch(() => {
  });
  function r(n) {
    Object.assign(s, n), delete s.resolve, delete s.reject;
  }
  return s.resolve = (n) => {
    r({
      status: "fulfilled",
      value: n
    }), t(n);
  }, s.reject = (n) => {
    r({
      status: "rejected",
      reason: n
    }), e(n);
  }, s;
}
function vt(t) {
  return Math.min(1e3 * 2 ** t, 3e4);
}
function et(t) {
  return (t ?? "online") === "online" ? Ye.isOnline() : !0;
}
var tt = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent;
  }
};
function ve(t) {
  return t instanceof tt;
}
function bt(t) {
  let e = !1, s = 0, r = !1, n;
  const o = Ee(), a = (f) => {
    var g;
    r || (m(new tt(f)), (g = t.abort) == null || g.call(t));
  }, h = () => {
    e = !0;
  }, l = () => {
    e = !1;
  }, R = () => Xe.isFocused() && (t.networkMode === "always" || Ye.isOnline()) && t.canRun(), v = () => et(t.networkMode) && t.canRun(), u = (f) => {
    var g;
    r || (r = !0, (g = t.onSuccess) == null || g.call(t, f), n == null || n(), o.resolve(f));
  }, m = (f) => {
    var g;
    r || (r = !0, (g = t.onError) == null || g.call(t, f), n == null || n(), o.reject(f));
  }, S = () => new Promise((f) => {
    var g;
    n = (T) => {
      (r || R()) && f(T);
    }, (g = t.onPause) == null || g.call(t);
  }).then(() => {
    var f;
    n = void 0, r || (f = t.onContinue) == null || f.call(t);
  }), w = () => {
    if (r)
      return;
    let f;
    const g = s === 0 ? t.initialPromise : void 0;
    try {
      f = g ?? t.fn();
    } catch (T) {
      f = Promise.reject(T);
    }
    Promise.resolve(f).then(u).catch((T) => {
      var ye;
      if (r)
        return;
      const Q = t.retry ?? (V ? 0 : 3), N = t.retryDelay ?? vt, he = typeof N == "function" ? N(s, T) : N, ce = Q === !0 || typeof Q == "number" && s < Q || typeof Q == "function" && Q(s, T);
      if (e || !ce) {
        m(T);
        return;
      }
      s++, (ye = t.onFail) == null || ye.call(t, s, T), dt(he).then(() => R() ? void 0 : S()).then(() => {
        e ? m(T) : w();
      });
    });
  };
  return {
    promise: o,
    cancel: a,
    continue: () => (n == null || n(), o),
    cancelRetry: h,
    continueRetry: l,
    canStart: v,
    start: () => (v() ? w() : S().then(w), o)
  };
}
function mt() {
  let t = [], e = 0, s = (h) => {
    h();
  }, r = (h) => {
    h();
  }, n = (h) => setTimeout(h, 0);
  const o = (h) => {
    e ? t.push(h) : n(() => {
      s(h);
    });
  }, a = () => {
    const h = t;
    t = [], h.length && n(() => {
      r(() => {
        h.forEach((l) => {
          s(l);
        });
      });
    });
  };
  return {
    batch: (h) => {
      let l;
      e++;
      try {
        l = h();
      } finally {
        e--, e || a();
      }
      return l;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (h) => (...l) => {
      o(() => {
        h(...l);
      });
    },
    schedule: o,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (h) => {
      s = h;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (h) => {
      r = h;
    },
    setScheduler: (h) => {
      n = h;
    }
  };
}
var je = mt(), _, Ve, gt = (Ve = class {
  constructor() {
    y(this, _);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), me(this.gcTime) && c(this, _, setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (V ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    i(this, _) && (clearTimeout(i(this, _)), c(this, _, void 0));
  }
}, _ = new WeakMap(), Ve), Y, ee, D, C, ae, H, q, j, $e, Jt = ($e = class extends gt {
  constructor(e) {
    super();
    y(this, q);
    y(this, Y);
    y(this, ee);
    y(this, D);
    y(this, C);
    y(this, ae);
    y(this, H);
    c(this, H, !1), c(this, ae, e.defaultOptions), this.setOptions(e.options), this.observers = [], c(this, D, e.cache), this.queryKey = e.queryKey, this.queryHash = e.queryHash, c(this, Y, Rt(this.options)), this.state = e.state ?? i(this, Y), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var e;
    return (e = i(this, C)) == null ? void 0 : e.promise;
  }
  setOptions(e) {
    this.options = { ...i(this, ae), ...e }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && i(this, D).remove(this);
  }
  setData(e, s) {
    const r = we(this.state.data, e, this.options);
    return b(this, q, j).call(this, {
      data: r,
      type: "success",
      dataUpdatedAt: s == null ? void 0 : s.updatedAt,
      manual: s == null ? void 0 : s.manual
    }), r;
  }
  setState(e, s) {
    b(this, q, j).call(this, { type: "setState", state: e, setStateOptions: s });
  }
  cancel(e) {
    var r, n;
    const s = (r = i(this, C)) == null ? void 0 : r.promise;
    return (n = i(this, C)) == null || n.cancel(e), s ? s.then(be).catch(be) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: !0 });
  }
  reset() {
    this.destroy(), this.setState(i(this, Y));
  }
  isActive() {
    return this.observers.some(
      (e) => I(e.options.enabled, this) !== !1
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === fe || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStale() {
    return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some(
      (e) => e.getCurrentResult().isStale
    ) : this.state.data === void 0;
  }
  isStaleByTime(e = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !Ze(this.state.dataUpdatedAt, e);
  }
  onFocus() {
    var s;
    const e = this.observers.find((r) => r.shouldFetchOnWindowFocus());
    e == null || e.refetch({ cancelRefetch: !1 }), (s = i(this, C)) == null || s.continue();
  }
  onOnline() {
    var s;
    const e = this.observers.find((r) => r.shouldFetchOnReconnect());
    e == null || e.refetch({ cancelRefetch: !1 }), (s = i(this, C)) == null || s.continue();
  }
  addObserver(e) {
    this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), i(this, D).notify({ type: "observerAdded", query: this, observer: e }));
  }
  removeObserver(e) {
    this.observers.includes(e) && (this.observers = this.observers.filter((s) => s !== e), this.observers.length || (i(this, C) && (i(this, H) ? i(this, C).cancel({ revert: !0 }) : i(this, C).cancelRetry()), this.scheduleGc()), i(this, D).notify({ type: "observerRemoved", query: this, observer: e }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || b(this, q, j).call(this, { type: "invalidate" });
  }
  fetch(e, s) {
    var l, R, v;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (s != null && s.cancelRefetch))
        this.cancel({ silent: !0 });
      else if (i(this, C))
        return i(this, C).continueRetry(), i(this, C).promise;
    }
    if (e && this.setOptions(e), !this.options.queryFn) {
      const u = this.observers.find((m) => m.options.queryFn);
      u && this.setOptions(u.options);
    }
    process.env.NODE_ENV !== "production" && (Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    ));
    const r = new AbortController(), n = (u) => {
      Object.defineProperty(u, "signal", {
        enumerable: !0,
        get: () => (c(this, H, !0), r.signal)
      });
    }, o = () => {
      const u = ft(this.options, s), m = {
        queryKey: this.queryKey,
        meta: this.meta
      };
      return n(m), c(this, H, !1), this.options.persister ? this.options.persister(
        u,
        m,
        this
      ) : u(m);
    }, a = {
      fetchOptions: s,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn: o
    };
    n(a), (l = this.options.behavior) == null || l.onFetch(
      a,
      this
    ), c(this, ee, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((R = a.fetchOptions) == null ? void 0 : R.meta)) && b(this, q, j).call(this, { type: "fetch", meta: (v = a.fetchOptions) == null ? void 0 : v.meta });
    const h = (u) => {
      var m, S, w, f;
      ve(u) && u.silent || b(this, q, j).call(this, {
        type: "error",
        error: u
      }), ve(u) || ((S = (m = i(this, D).config).onError) == null || S.call(
        m,
        u,
        this
      ), (f = (w = i(this, D).config).onSettled) == null || f.call(
        w,
        this.state.data,
        u,
        this
      )), this.scheduleGc();
    };
    return c(this, C, bt({
      initialPromise: s == null ? void 0 : s.initialPromise,
      fn: a.fetchFn,
      abort: r.abort.bind(r),
      onSuccess: (u) => {
        var m, S, w, f;
        if (u === void 0) {
          process.env.NODE_ENV !== "production" && console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), h(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(u);
        } catch (g) {
          h(g);
          return;
        }
        (S = (m = i(this, D).config).onSuccess) == null || S.call(m, u, this), (f = (w = i(this, D).config).onSettled) == null || f.call(
          w,
          u,
          this.state.error,
          this
        ), this.scheduleGc();
      },
      onError: h,
      onFail: (u, m) => {
        b(this, q, j).call(this, { type: "failed", failureCount: u, error: m });
      },
      onPause: () => {
        b(this, q, j).call(this, { type: "pause" });
      },
      onContinue: () => {
        b(this, q, j).call(this, { type: "continue" });
      },
      retry: a.options.retry,
      retryDelay: a.options.retryDelay,
      networkMode: a.options.networkMode,
      canRun: () => !0
    })), i(this, C).start();
  }
}, Y = new WeakMap(), ee = new WeakMap(), D = new WeakMap(), C = new WeakMap(), ae = new WeakMap(), H = new WeakMap(), q = new WeakSet(), j = function(e) {
  const s = (r) => {
    switch (e.type) {
      case "failed":
        return {
          ...r,
          fetchFailureCount: e.failureCount,
          fetchFailureReason: e.error
        };
      case "pause":
        return {
          ...r,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...r,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...r,
          ...st(r.data, this.options),
          fetchMeta: e.meta ?? null
        };
      case "success":
        return {
          ...r,
          data: e.data,
          dataUpdateCount: r.dataUpdateCount + 1,
          dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: !1,
          status: "success",
          ...!e.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const n = e.error;
        return ve(n) && n.revert && i(this, ee) ? { ...i(this, ee), fetchStatus: "idle" } : {
          ...r,
          error: n,
          errorUpdateCount: r.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: r.fetchFailureCount + 1,
          fetchFailureReason: n,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...r,
          isInvalidated: !0
        };
      case "setState":
        return {
          ...r,
          ...e.state
        };
    }
  };
  this.state = s(this.state), je.batch(() => {
    this.observers.forEach((r) => {
      r.onQueryUpdate();
    }), i(this, D).notify({ query: this, type: "updated", action: e });
  });
}, $e);
function st(t, e) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: et(e.networkMode) ? "fetching" : "paused",
    ...t === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function Rt(t) {
  const e = typeof t.initialData == "function" ? t.initialData() : t.initialData, s = e !== void 0, r = s ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
  return {
    data: e,
    dataUpdateCount: 0,
    dataUpdatedAt: s ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: !1,
    status: s ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var O, d, oe, F, B, te, M, x, ue, se, re, G, z, L, ie, p, ne, Fe, Oe, Te, De, Pe, qe, Ie, it, We, rt = (We = class extends xe {
  constructor(e, s) {
    super();
    y(this, p);
    y(this, O);
    y(this, d);
    y(this, oe);
    y(this, F);
    y(this, B);
    y(this, te);
    y(this, M);
    y(this, x);
    y(this, ue);
    y(this, se);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    y(this, re);
    y(this, G);
    y(this, z);
    y(this, L);
    y(this, ie, /* @__PURE__ */ new Set());
    this.options = s, c(this, O, e), c(this, x, null), c(this, M, Ee()), this.options.experimental_prefetchInRender || i(this, M).reject(
      new Error("experimental_prefetchInRender feature flag is not enabled")
    ), this.bindMethods(), this.setOptions(s);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (i(this, d).addObserver(this), _e(i(this, d), this.options) ? b(this, p, ne).call(this) : this.updateResult(), b(this, p, De).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return Ue(
      i(this, d),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return Ue(
      i(this, d),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), b(this, p, Pe).call(this), b(this, p, qe).call(this), i(this, d).removeObserver(this);
  }
  setOptions(e, s) {
    const r = this.options, n = i(this, d);
    if (this.options = i(this, O).defaultQueryOptions(e), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof I(this.options.enabled, i(this, d)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    b(this, p, Ie).call(this), i(this, d).setOptions(this.options), r._defaulted && !Se(this.options, r) && i(this, O).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: i(this, d),
      observer: this
    });
    const o = this.hasListeners();
    o && He(
      i(this, d),
      n,
      this.options,
      r
    ) && b(this, p, ne).call(this), this.updateResult(s), o && (i(this, d) !== n || I(this.options.enabled, i(this, d)) !== I(r.enabled, i(this, d)) || de(this.options.staleTime, i(this, d)) !== de(r.staleTime, i(this, d))) && b(this, p, Fe).call(this);
    const a = b(this, p, Oe).call(this);
    o && (i(this, d) !== n || I(this.options.enabled, i(this, d)) !== I(r.enabled, i(this, d)) || a !== i(this, L)) && b(this, p, Te).call(this, a);
  }
  getOptimisticResult(e) {
    const s = i(this, O).getQueryCache().build(i(this, O), e), r = this.createResult(s, e);
    return Ct(this, r) && (c(this, F, r), c(this, te, this.options), c(this, B, i(this, d).state)), r;
  }
  getCurrentResult() {
    return i(this, F);
  }
  trackResult(e, s) {
    const r = {};
    return Object.keys(e).forEach((n) => {
      Object.defineProperty(r, n, {
        configurable: !1,
        enumerable: !0,
        get: () => (this.trackProp(n), s == null || s(n), e[n])
      });
    }), r;
  }
  trackProp(e) {
    i(this, ie).add(e);
  }
  getCurrentQuery() {
    return i(this, d);
  }
  refetch({ ...e } = {}) {
    return this.fetch({
      ...e
    });
  }
  fetchOptimistic(e) {
    const s = i(this, O).defaultQueryOptions(e), r = i(this, O).getQueryCache().build(i(this, O), s);
    return r.fetch().then(() => this.createResult(r, s));
  }
  fetch(e) {
    return b(this, p, ne).call(this, {
      ...e,
      cancelRefetch: e.cancelRefetch ?? !0
    }).then(() => (this.updateResult(), i(this, F)));
  }
  createResult(e, s) {
    var Me;
    const r = i(this, d), n = this.options, o = i(this, F), a = i(this, B), h = i(this, te), R = e !== r ? e.state : i(this, oe), { state: v } = e;
    let u = { ...v }, m = !1, S;
    if (s._optimisticResults) {
      const E = this.hasListeners(), $ = !E && _e(e, s), W = E && He(e, r, s, n);
      ($ || W) && (u = {
        ...u,
        ...st(v.data, e.options)
      }), s._optimisticResults === "isRestoring" && (u.fetchStatus = "idle");
    }
    let { error: w, errorUpdatedAt: f, status: g } = u;
    if (s.select && u.data !== void 0)
      if (o && u.data === (a == null ? void 0 : a.data) && s.select === i(this, ue))
        S = i(this, se);
      else
        try {
          c(this, ue, s.select), S = s.select(u.data), S = we(o == null ? void 0 : o.data, S, s), c(this, se, S), c(this, x, null);
        } catch (E) {
          c(this, x, E);
        }
    else
      S = u.data;
    if (s.placeholderData !== void 0 && S === void 0 && g === "pending") {
      let E;
      if (o != null && o.isPlaceholderData && s.placeholderData === (h == null ? void 0 : h.placeholderData))
        E = o.data;
      else if (E = typeof s.placeholderData == "function" ? s.placeholderData(
        (Me = i(this, re)) == null ? void 0 : Me.state.data,
        i(this, re)
      ) : s.placeholderData, s.select && E !== void 0)
        try {
          E = s.select(E), c(this, x, null);
        } catch ($) {
          c(this, x, $);
        }
      E !== void 0 && (g = "success", S = we(
        o == null ? void 0 : o.data,
        E,
        s
      ), m = !0);
    }
    i(this, x) && (w = i(this, x), S = i(this, se), f = Date.now(), g = "error");
    const T = u.fetchStatus === "fetching", Q = g === "pending", N = g === "error", he = Q && T, ce = S !== void 0, U = {
      status: g,
      fetchStatus: u.fetchStatus,
      isPending: Q,
      isSuccess: g === "success",
      isError: N,
      isInitialLoading: he,
      isLoading: he,
      data: S,
      dataUpdatedAt: u.dataUpdatedAt,
      error: w,
      errorUpdatedAt: f,
      failureCount: u.fetchFailureCount,
      failureReason: u.fetchFailureReason,
      errorUpdateCount: u.errorUpdateCount,
      isFetched: u.dataUpdateCount > 0 || u.errorUpdateCount > 0,
      isFetchedAfterMount: u.dataUpdateCount > R.dataUpdateCount || u.errorUpdateCount > R.errorUpdateCount,
      isFetching: T,
      isRefetching: T && !Q,
      isLoadingError: N && !ce,
      isPaused: u.fetchStatus === "paused",
      isPlaceholderData: m,
      isRefetchError: N && ce,
      isStale: Ae(e, s),
      refetch: this.refetch,
      promise: i(this, M)
    };
    if (this.options.experimental_prefetchInRender) {
      const E = (le) => {
        U.status === "error" ? le.reject(U.error) : U.data !== void 0 && le.resolve(U.data);
      }, $ = () => {
        const le = c(this, M, U.promise = Ee());
        E(le);
      }, W = i(this, M);
      switch (W.status) {
        case "pending":
          e.queryHash === r.queryHash && E(W);
          break;
        case "fulfilled":
          (U.status === "error" || U.data !== W.value) && $();
          break;
        case "rejected":
          (U.status !== "error" || U.error !== W.reason) && $();
          break;
      }
    }
    return U;
  }
  updateResult(e) {
    const s = i(this, F), r = this.createResult(i(this, d), this.options);
    if (c(this, B, i(this, d).state), c(this, te, this.options), i(this, B).data !== void 0 && c(this, re, i(this, d)), Se(r, s))
      return;
    c(this, F, r);
    const n = {}, o = () => {
      if (!s)
        return !0;
      const { notifyOnChangeProps: a } = this.options, h = typeof a == "function" ? a() : a;
      if (h === "all" || !h && !i(this, ie).size)
        return !0;
      const l = new Set(
        h ?? i(this, ie)
      );
      return this.options.throwOnError && l.add("error"), Object.keys(i(this, F)).some((R) => {
        const v = R;
        return i(this, F)[v] !== s[v] && l.has(v);
      });
    };
    (e == null ? void 0 : e.listeners) !== !1 && o() && (n.listeners = !0), b(this, p, it).call(this, { ...n, ...e });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && b(this, p, De).call(this);
  }
}, O = new WeakMap(), d = new WeakMap(), oe = new WeakMap(), F = new WeakMap(), B = new WeakMap(), te = new WeakMap(), M = new WeakMap(), x = new WeakMap(), ue = new WeakMap(), se = new WeakMap(), re = new WeakMap(), G = new WeakMap(), z = new WeakMap(), L = new WeakMap(), ie = new WeakMap(), p = new WeakSet(), ne = function(e) {
  b(this, p, Ie).call(this);
  let s = i(this, d).fetch(
    this.options,
    e
  );
  return e != null && e.throwOnError || (s = s.catch(be)), s;
}, Fe = function() {
  b(this, p, Pe).call(this);
  const e = de(
    this.options.staleTime,
    i(this, d)
  );
  if (V || i(this, F).isStale || !me(e))
    return;
  const r = Ze(i(this, F).dataUpdatedAt, e) + 1;
  c(this, G, setTimeout(() => {
    i(this, F).isStale || this.updateResult();
  }, r));
}, Oe = function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(i(this, d)) : this.options.refetchInterval) ?? !1;
}, Te = function(e) {
  b(this, p, qe).call(this), c(this, L, e), !(V || I(this.options.enabled, i(this, d)) === !1 || !me(i(this, L)) || i(this, L) === 0) && c(this, z, setInterval(() => {
    (this.options.refetchIntervalInBackground || Xe.isFocused()) && b(this, p, ne).call(this);
  }, i(this, L)));
}, De = function() {
  b(this, p, Fe).call(this), b(this, p, Te).call(this, b(this, p, Oe).call(this));
}, Pe = function() {
  i(this, G) && (clearTimeout(i(this, G)), c(this, G, void 0));
}, qe = function() {
  i(this, z) && (clearInterval(i(this, z)), c(this, z, void 0));
}, Ie = function() {
  const e = i(this, O).getQueryCache().build(i(this, O), this.options);
  if (e === i(this, d))
    return;
  const s = i(this, d);
  c(this, d, e), c(this, oe, e.state), this.hasListeners() && (s == null || s.removeObserver(this), e.addObserver(this));
}, it = function(e) {
  je.batch(() => {
    e.listeners && this.listeners.forEach((s) => {
      s(i(this, F));
    }), i(this, O).getQueryCache().notify({
      query: i(this, d),
      type: "observerResultsUpdated"
    });
  });
}, We);
function St(t, e) {
  return I(e.enabled, t) !== !1 && t.state.data === void 0 && !(t.state.status === "error" && e.retryOnMount === !1);
}
function _e(t, e) {
  return St(t, e) || t.state.data !== void 0 && Ue(t, e, e.refetchOnMount);
}
function Ue(t, e, s) {
  if (I(e.enabled, t) !== !1) {
    const r = typeof s == "function" ? s(t) : s;
    return r === "always" || r !== !1 && Ae(t, e);
  }
  return !1;
}
function He(t, e, s, r) {
  return (t !== e || I(r.enabled, t) === !1) && (!s.suspense || t.state.status !== "error") && Ae(t, s);
}
function Ae(t, e) {
  return I(e.enabled, t) !== !1 && t.isStaleByTime(de(e.staleTime, t));
}
function Ct(t, e) {
  return !Se(t.getCurrentResult(), e);
}
var nt = P.createContext(
  void 0
), wt = (t) => {
  const e = P.useContext(nt);
  if (!e)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return e;
}, Zt = ({
  client: t,
  children: e
}) => (P.useEffect(() => (t.mount(), () => {
  t.unmount();
}), [t]), /* @__PURE__ */ ct.jsx(nt.Provider, { value: t, children: e })), at = P.createContext(!1), Et = () => P.useContext(at);
at.Provider;
function Ft() {
  let t = !1;
  return {
    clearReset: () => {
      t = !1;
    },
    reset: () => {
      t = !0;
    },
    isReset: () => t
  };
}
var Ot = P.createContext(Ft()), Tt = () => P.useContext(Ot);
function Dt(t, e) {
  return typeof t == "function" ? t(...e) : !!t;
}
function Pt() {
}
var qt = (t, e) => {
  (t.suspense || t.throwOnError) && (e.isReset() || (t.retryOnMount = !1));
}, It = (t) => {
  P.useEffect(() => {
    t.clearReset();
  }, [t]);
}, Ut = ({
  result: t,
  errorResetBoundary: e,
  throwOnError: s,
  query: r
}) => t.isError && !e.isReset() && !t.isFetching && r && Dt(s, [t.error, r]), xt = (t, e) => e.state.data === void 0, Qt = (t) => {
  t.suspense && (typeof t.staleTime != "number" && (t.staleTime = 1e3), typeof t.gcTime == "number" && (t.gcTime = Math.max(t.gcTime, 1e3)));
}, jt = (t, e) => t.isLoading && t.isFetching && !e, At = (t, e) => (t == null ? void 0 : t.suspense) && e.isPending, Be = (t, e, s) => e.fetchOptimistic(t).catch(() => {
  s.clearReset();
});
function ot(t, e, s) {
  var v, u, m, S, w;
  if (process.env.NODE_ENV !== "production" && (typeof t != "object" || Array.isArray(t)))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const r = wt(), n = Et(), o = Tt(), a = r.defaultQueryOptions(t);
  (u = (v = r.getDefaultOptions().queries) == null ? void 0 : v._experimental_beforeQuery) == null || u.call(
    v,
    a
  ), a._optimisticResults = n ? "isRestoring" : "optimistic", Qt(a), qt(a, o), It(o);
  const h = !r.getQueryCache().get(a.queryHash), [l] = P.useState(
    () => new e(
      r,
      a
    )
  ), R = l.getOptimisticResult(a);
  if (P.useSyncExternalStore(
    P.useCallback(
      (f) => {
        const g = n ? () => {
        } : l.subscribe(je.batchCalls(f));
        return l.updateResult(), g;
      },
      [l, n]
    ),
    () => l.getCurrentResult(),
    () => l.getCurrentResult()
  ), P.useEffect(() => {
    l.setOptions(a, { listeners: !1 });
  }, [a, l]), At(a, R))
    throw Be(a, l, o);
  if (Ut({
    result: R,
    errorResetBoundary: o,
    throwOnError: a.throwOnError,
    query: r.getQueryCache().get(a.queryHash)
  }))
    throw R.error;
  if ((S = (m = r.getDefaultOptions().queries) == null ? void 0 : m._experimental_afterQuery) == null || S.call(
    m,
    a,
    R
  ), a.experimental_prefetchInRender && !V && jt(R, n)) {
    const f = h ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      Be(a, l, o)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (w = r.getQueryCache().get(a.queryHash)) == null ? void 0 : w.promise
    );
    f == null || f.catch(Pt).finally(() => {
      l.hasListeners() || l.updateResult();
    });
  }
  return a.notifyOnChangeProps ? R : l.trackResult(R);
}
function kt(t, e) {
  return ot(t, rt);
}
function Mt(t, e) {
  return process.env.NODE_ENV !== "production" && t.queryFn === fe && console.error("skipToken is not allowed for useSuspenseQuery"), ot(
    {
      ...t,
      enabled: !0,
      suspense: !0,
      throwOnError: xt,
      placeholderData: void 0
    },
    rt
  );
}
const Lt = ut(
  void 0
), ke = () => {
  const t = ht(Lt);
  if (!t)
    throw new Error("useDevPortal must be used within a DevPortalProvider.");
  return t;
}, Xt = () => {
  const { getApiIdentities: t } = ke();
  return kt({
    queryFn: t,
    queryKey: ["api-identities"]
  });
}, Nt = () => {
  const { topNavigation: t } = ke(), s = Je().pathname.split("/").at(1);
  if (s)
    return t.find((r) => r.id === s);
}, Yt = () => {
  const { getPluginSidebar: t, sidebars: e } = ke(), s = Nt(), r = s == null ? void 0 : s.id, n = r ? e[r] ?? [] : [], o = Je();
  return Mt({
    queryFn: async () => {
      const a = r ? await t(r) : await t(o.pathname);
      return {
        items: [...n, ...a],
        currentTopNavItem: s
      };
    },
    queryKey: ["navigation", r]
  });
};
export {
  kt as A,
  Jt as Q,
  gt as R,
  xe as S,
  Lt as Z,
  wt as a,
  Mt as b,
  Nt as c,
  Pt as d,
  Dt as e,
  lt as f,
  Vt as g,
  ge as h,
  be as i,
  ft as j,
  Wt as k,
  $t as l,
  zt as m,
  je as n,
  Xe as o,
  Ye as p,
  Gt as q,
  de as r,
  Se as s,
  Qe as t,
  ke as u,
  fe as v,
  Zt as w,
  Yt as x,
  bt as y,
  Xt as z
};
//# sourceMappingURL=ZudokuContext-BEmsYQoq.js.map
