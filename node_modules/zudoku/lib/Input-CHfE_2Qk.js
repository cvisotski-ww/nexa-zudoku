var zt = (e) => {
  throw TypeError(e);
};
var _t = (e, r, t) => r.has(e) || zt("Cannot " + t);
var Z = (e, r, t) => (_t(e, r, "read from private field"), t ? t.call(e) : r.get(e)), Ue = (e, r, t) => r.has(e) ? zt("Cannot add the same private member more than once") : r instanceof WeakSet ? r.add(e) : r.set(e, t), He = (e, r, t, s) => (_t(e, r, "write to private field"), s ? s.call(e, t) : r.set(e, t), t), We = (e, r, t) => (_t(e, r, "access private method"), t);
import * as p from "react";
import I from "react";
import { o as ps, f as hs, c as ms, p as ir, d as _e, A as ys, P as me, b as oe, e as De, j as gs, k as vs, R as xs, S as _s, F as Ss, D as bs, C as ws, a as Bt, q as Cs, V as As, i as Vs, m as Fs, h as Es, u as Yt, r as Ts } from "./index-Do_BBSIs.js";
import { S as Is, s as Rs, h as Xt, n as ar, a as Ns, d as Ds, e as Ps } from "./ZudokuContext-BEmsYQoq.js";
import { j as b } from "./jsx-runtime-B6kdoens.js";
import * as lr from "react-dom";
import { ChevronDown as cr, ChevronUp as ks, Check as Ms } from "lucide-react";
import { a as Ee } from "./Markdown-CWI6lU11.js";
var Re, Ne, de, Ae, Fe, nt, Nt, nr, Os = (nr = class extends Is {
  constructor(r, t) {
    super();
    Ue(this, Fe);
    Ue(this, Re);
    Ue(this, Ne);
    Ue(this, de);
    Ue(this, Ae);
    He(this, Re, r), this.setOptions(t), this.bindMethods(), We(this, Fe, nt).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this);
  }
  setOptions(r) {
    var s;
    const t = this.options;
    this.options = Z(this, Re).defaultMutationOptions(r), Rs(this.options, t) || Z(this, Re).getMutationCache().notify({
      type: "observerOptionsUpdated",
      mutation: Z(this, de),
      observer: this
    }), t != null && t.mutationKey && this.options.mutationKey && Xt(t.mutationKey) !== Xt(this.options.mutationKey) ? this.reset() : ((s = Z(this, de)) == null ? void 0 : s.state.status) === "pending" && Z(this, de).setOptions(this.options);
  }
  onUnsubscribe() {
    var r;
    this.hasListeners() || (r = Z(this, de)) == null || r.removeObserver(this);
  }
  onMutationUpdate(r) {
    We(this, Fe, nt).call(this), We(this, Fe, Nt).call(this, r);
  }
  getCurrentResult() {
    return Z(this, Ne);
  }
  reset() {
    var r;
    (r = Z(this, de)) == null || r.removeObserver(this), He(this, de, void 0), We(this, Fe, nt).call(this), We(this, Fe, Nt).call(this);
  }
  mutate(r, t) {
    var s;
    return He(this, Ae, t), (s = Z(this, de)) == null || s.removeObserver(this), He(this, de, Z(this, Re).getMutationCache().build(Z(this, Re), this.options)), Z(this, de).addObserver(this), Z(this, de).execute(r);
  }
}, Re = new WeakMap(), Ne = new WeakMap(), de = new WeakMap(), Ae = new WeakMap(), Fe = new WeakSet(), nt = function() {
  var t;
  const r = ((t = Z(this, de)) == null ? void 0 : t.state) ?? ps();
  He(this, Ne, {
    ...r,
    isPending: r.status === "pending",
    isSuccess: r.status === "success",
    isError: r.status === "error",
    isIdle: r.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, Nt = function(r) {
  ar.batch(() => {
    var t, s, n, i, l, c, d, _;
    if (Z(this, Ae) && this.hasListeners()) {
      const m = Z(this, Ne).variables, g = Z(this, Ne).context;
      (r == null ? void 0 : r.type) === "success" ? ((s = (t = Z(this, Ae)).onSuccess) == null || s.call(t, r.data, m, g), (i = (n = Z(this, Ae)).onSettled) == null || i.call(n, r.data, null, m, g)) : (r == null ? void 0 : r.type) === "error" && ((c = (l = Z(this, Ae)).onError) == null || c.call(l, r.error, m, g), (_ = (d = Z(this, Ae)).onSettled) == null || _.call(
        d,
        void 0,
        r.error,
        m,
        g
      ));
    }
    this.listeners.forEach((m) => {
      m(Z(this, Ne));
    });
  });
}, nr);
function Ho(e, r) {
  const t = Ns(), [s] = p.useState(
    () => new Os(
      t,
      e
    )
  );
  p.useEffect(() => {
    s.setOptions(e);
  }, [s, e]);
  const n = p.useSyncExternalStore(
    p.useCallback(
      (l) => s.subscribe(ar.batchCalls(l)),
      [s]
    ),
    () => s.getCurrentResult(),
    () => s.getCurrentResult()
  ), i = p.useCallback(
    (l, c) => {
      s.mutate(l, c).catch(Ds);
    },
    [s]
  );
  if (n.error && Ps(s.options.throwOnError, [n.error]))
    throw n.error;
  return { ...n, mutate: i, mutateAsync: n.mutate };
}
var Qe = (e) => e.type === "checkbox", $e = (e) => e instanceof Date, le = (e) => e == null;
const ur = (e) => typeof e == "object";
var ee = (e) => !le(e) && !Array.isArray(e) && ur(e) && !$e(e), dr = (e) => ee(e) && e.target ? Qe(e.target) ? e.target.checked : e.target.value : e, js = (e) => e.substring(0, e.search(/\.\d+(\.|$)/)) || e, fr = (e, r) => e.has(js(r)), Ls = (e) => {
  const r = e.constructor && e.constructor.prototype;
  return ee(r) && r.hasOwnProperty("isPrototypeOf");
}, Ut = typeof window < "u" && typeof window.HTMLElement < "u" && typeof document < "u";
function te(e) {
  let r;
  const t = Array.isArray(e);
  if (e instanceof Date)
    r = new Date(e);
  else if (e instanceof Set)
    r = new Set(e);
  else if (!(Ut && (e instanceof Blob || e instanceof FileList)) && (t || ee(e)))
    if (r = t ? [] : {}, !t && !Ls(e))
      r = e;
    else
      for (const s in e)
        e.hasOwnProperty(s) && (r[s] = te(e[s]));
  else
    return e;
  return r;
}
var Je = (e) => Array.isArray(e) ? e.filter(Boolean) : [], q = (e) => e === void 0, h = (e, r, t) => {
  if (!r || !ee(e))
    return t;
  const s = Je(r.split(/[,[\].]+?/)).reduce((n, i) => le(n) ? n : n[i], e);
  return q(s) || s === e ? q(e[r]) ? t : e[r] : s;
}, pe = (e) => typeof e == "boolean", Ht = (e) => /^\w*$/.test(e), pr = (e) => Je(e.replace(/["|']|\]/g, "").split(/\.|\[/)), U = (e, r, t) => {
  let s = -1;
  const n = Ht(r) ? [r] : pr(r), i = n.length, l = i - 1;
  for (; ++s < i; ) {
    const c = n[s];
    let d = t;
    if (s !== l) {
      const _ = e[c];
      d = ee(_) || Array.isArray(_) ? _ : isNaN(+n[s + 1]) ? {} : [];
    }
    if (c === "__proto__")
      return;
    e[c] = d, e = e[c];
  }
  return e;
};
const at = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
}, he = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
}, Ce = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
}, hr = I.createContext(null), pt = () => I.useContext(hr), Wo = (e) => {
  const { children: r, ...t } = e;
  return I.createElement(hr.Provider, { value: t }, r);
};
var mr = (e, r, t, s = !0) => {
  const n = {
    defaultValues: r._defaultValues
  };
  for (const i in e)
    Object.defineProperty(n, i, {
      get: () => {
        const l = i;
        return r._proxyFormState[l] !== he.all && (r._proxyFormState[l] = !s || he.all), t && (t[l] = !0), e[l];
      }
    });
  return n;
}, ae = (e) => ee(e) && !Object.keys(e).length, yr = (e, r, t, s) => {
  t(e);
  const { name: n, ...i } = e;
  return ae(i) || Object.keys(i).length >= Object.keys(r).length || Object.keys(i).find((l) => r[l] === (!s || he.all));
}, fe = (e) => Array.isArray(e) ? e : [e], gr = (e, r, t) => !e || !r || e === r || fe(e).some((s) => s && (t ? s === r : s.startsWith(r) || r.startsWith(s)));
function ht(e) {
  const r = I.useRef(e);
  r.current = e, I.useEffect(() => {
    const t = !e.disabled && r.current.subject && r.current.subject.subscribe({
      next: r.current.next
    });
    return () => {
      t && t.unsubscribe();
    };
  }, [e.disabled]);
}
function Bs(e) {
  const r = pt(), { control: t = r.control, disabled: s, name: n, exact: i } = e || {}, [l, c] = I.useState(t._formState), d = I.useRef(!0), _ = I.useRef({
    isDirty: !1,
    isLoading: !1,
    dirtyFields: !1,
    touchedFields: !1,
    validatingFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  }), m = I.useRef(n);
  return m.current = n, ht({
    disabled: s,
    next: (g) => d.current && gr(m.current, g.name, i) && yr(g, _.current, t._updateFormState) && c({
      ...t._formState,
      ...g
    }),
    subject: t._subjects.state
  }), I.useEffect(() => (d.current = !0, _.current.isValid && t._updateValid(!0), () => {
    d.current = !1;
  }), [t]), mr(l, t, _.current, !1);
}
var xe = (e) => typeof e == "string", vr = (e, r, t, s, n) => xe(e) ? (s && r.watch.add(e), h(t, e, n)) : Array.isArray(e) ? e.map((i) => (s && r.watch.add(i), h(t, i))) : (s && (r.watchAll = !0), t);
function Us(e) {
  const r = pt(), { control: t = r.control, name: s, defaultValue: n, disabled: i, exact: l } = e || {}, c = I.useRef(s);
  c.current = s, ht({
    disabled: i,
    subject: t._subjects.values,
    next: (m) => {
      gr(c.current, m.name, l) && _(te(vr(c.current, t._names, m.values || t._formValues, !1, n)));
    }
  });
  const [d, _] = I.useState(t._getWatch(s, n));
  return I.useEffect(() => t._removeUnmounted()), d;
}
function Hs(e) {
  const r = pt(), { name: t, disabled: s, control: n = r.control, shouldUnregister: i } = e, l = fr(n._names.array, t), c = Us({
    control: n,
    name: t,
    defaultValue: h(n._formValues, t, h(n._defaultValues, t, e.defaultValue)),
    exact: !0
  }), d = Bs({
    control: n,
    name: t,
    exact: !0
  }), _ = I.useRef(n.register(t, {
    ...e.rules,
    value: c,
    ...pe(e.disabled) ? { disabled: e.disabled } : {}
  }));
  return I.useEffect(() => {
    const m = n._options.shouldUnregister || i, g = (E, O) => {
      const D = h(n._fields, E);
      D && D._f && (D._f.mount = O);
    };
    if (g(t, !0), m) {
      const E = te(h(n._options.defaultValues, t));
      U(n._defaultValues, t, E), q(h(n._formValues, t)) && U(n._formValues, t, E);
    }
    return () => {
      (l ? m && !n._state.action : m) ? n.unregister(t) : g(t, !1);
    };
  }, [t, n, l, i]), I.useEffect(() => {
    h(n._fields, t) && n._updateDisabledField({
      disabled: s,
      fields: n._fields,
      name: t,
      value: h(n._fields, t)._f.value
    });
  }, [s, t, n]), {
    field: {
      name: t,
      value: c,
      ...pe(s) || d.disabled ? { disabled: d.disabled || s } : {},
      onChange: I.useCallback((m) => _.current.onChange({
        target: {
          value: dr(m),
          name: t
        },
        type: at.CHANGE
      }), [t]),
      onBlur: I.useCallback(() => _.current.onBlur({
        target: {
          value: h(n._formValues, t),
          name: t
        },
        type: at.BLUR
      }), [t, n]),
      ref: I.useCallback((m) => {
        const g = h(n._fields, t);
        g && m && (g._f.ref = {
          focus: () => m.focus(),
          select: () => m.select(),
          setCustomValidity: (E) => m.setCustomValidity(E),
          reportValidity: () => m.reportValidity()
        });
      }, [n._fields, t])
    },
    formState: d,
    fieldState: Object.defineProperties({}, {
      invalid: {
        enumerable: !0,
        get: () => !!h(d.errors, t)
      },
      isDirty: {
        enumerable: !0,
        get: () => !!h(d.dirtyFields, t)
      },
      isTouched: {
        enumerable: !0,
        get: () => !!h(d.touchedFields, t)
      },
      isValidating: {
        enumerable: !0,
        get: () => !!h(d.validatingFields, t)
      },
      error: {
        enumerable: !0,
        get: () => h(d.errors, t)
      }
    })
  };
}
const Ko = (e) => e.render(Hs(e));
var Ws = (e, r, t, s, n) => r ? {
  ...t[e],
  types: {
    ...t[e] && t[e].types ? t[e].types : {},
    [s]: n || !0
  }
} : {}, Te = () => {
  const e = typeof performance > "u" ? Date.now() : performance.now() * 1e3;
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (r) => {
    const t = (Math.random() * 16 + e) % 16 | 0;
    return (r == "x" ? t : t & 3 | 8).toString(16);
  });
}, St = (e, r, t = {}) => t.shouldFocus || q(t.shouldFocus) ? t.focusName || `${e}.${q(t.focusIndex) ? r : t.focusIndex}.` : "", Ze = (e) => ({
  isOnSubmit: !e || e === he.onSubmit,
  isOnBlur: e === he.onBlur,
  isOnChange: e === he.onChange,
  isOnAll: e === he.all,
  isOnTouch: e === he.onTouched
}), Dt = (e, r, t) => !t && (r.watchAll || r.watch.has(e) || [...r.watch].some((s) => e.startsWith(s) && /^\.\w+/.test(e.slice(s.length))));
const qe = (e, r, t, s) => {
  for (const n of t || Object.keys(e)) {
    const i = h(e, n);
    if (i) {
      const { _f: l, ...c } = i;
      if (l) {
        if (l.refs && l.refs[0] && r(l.refs[0], n) && !s)
          return !0;
        if (l.ref && r(l.ref, l.name) && !s)
          return !0;
        if (qe(c, r))
          break;
      } else if (ee(c) && qe(c, r))
        break;
    }
  }
};
var xr = (e, r, t) => {
  const s = fe(h(e, t));
  return U(s, "root", r[t]), U(e, t, s), e;
}, Wt = (e) => e.type === "file", Ve = (e) => typeof e == "function", lt = (e) => {
  if (!Ut)
    return !1;
  const r = e ? e.ownerDocument : 0;
  return e instanceof (r && r.defaultView ? r.defaultView.HTMLElement : HTMLElement);
}, it = (e) => xe(e), Kt = (e) => e.type === "radio", ct = (e) => e instanceof RegExp;
const Zt = {
  value: !1,
  isValid: !1
}, Qt = { value: !0, isValid: !0 };
var _r = (e) => {
  if (Array.isArray(e)) {
    if (e.length > 1) {
      const r = e.filter((t) => t && t.checked && !t.disabled).map((t) => t.value);
      return { value: r, isValid: !!r.length };
    }
    return e[0].checked && !e[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      e[0].attributes && !q(e[0].attributes.value) ? q(e[0].value) || e[0].value === "" ? Qt : { value: e[0].value, isValid: !0 } : Qt
    ) : Zt;
  }
  return Zt;
};
const Jt = {
  isValid: !1,
  value: null
};
var Sr = (e) => Array.isArray(e) ? e.reduce((r, t) => t && t.checked && !t.disabled ? {
  isValid: !0,
  value: t.value
} : r, Jt) : Jt;
function er(e, r, t = "validate") {
  if (it(e) || Array.isArray(e) && e.every(it) || pe(e) && !e)
    return {
      type: t,
      message: it(e) ? e : "",
      ref: r
    };
}
var Ke = (e) => ee(e) && !ct(e) ? e : {
  value: e,
  message: ""
}, Pt = async (e, r, t, s, n) => {
  const { ref: i, refs: l, required: c, maxLength: d, minLength: _, min: m, max: g, pattern: E, validate: O, name: D, valueAsNumber: C, mount: R, disabled: M } = e._f, y = h(r, D);
  if (!R || M)
    return {};
  const V = l ? l[0] : i, z = (T) => {
    s && V.reportValidity && (V.setCustomValidity(pe(T) ? "" : T || ""), V.reportValidity());
  }, x = {}, w = Kt(i), F = Qe(i), k = w || F, Q = (C || Wt(i)) && q(i.value) && q(y) || lt(i) && i.value === "" || y === "" || Array.isArray(y) && !y.length, Y = Ws.bind(null, D, t, x), ce = (T, P, L, W = Ce.maxLength, K = Ce.minLength) => {
    const X = T ? P : L;
    x[D] = {
      type: T ? W : K,
      message: X,
      ref: i,
      ...Y(T ? W : K, X)
    };
  };
  if (n ? !Array.isArray(y) || !y.length : c && (!k && (Q || le(y)) || pe(y) && !y || F && !_r(l).isValid || w && !Sr(l).isValid)) {
    const { value: T, message: P } = it(c) ? { value: !!c, message: c } : Ke(c);
    if (T && (x[D] = {
      type: Ce.required,
      message: P,
      ref: V,
      ...Y(Ce.required, P)
    }, !t))
      return z(P), x;
  }
  if (!Q && (!le(m) || !le(g))) {
    let T, P;
    const L = Ke(g), W = Ke(m);
    if (!le(y) && !isNaN(y)) {
      const K = i.valueAsNumber || y && +y;
      le(L.value) || (T = K > L.value), le(W.value) || (P = K < W.value);
    } else {
      const K = i.valueAsDate || new Date(y), X = (Se) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + Se), ie = i.type == "time", ue = i.type == "week";
      xe(L.value) && y && (T = ie ? X(y) > X(L.value) : ue ? y > L.value : K > new Date(L.value)), xe(W.value) && y && (P = ie ? X(y) < X(W.value) : ue ? y < W.value : K < new Date(W.value));
    }
    if ((T || P) && (ce(!!T, L.message, W.message, Ce.max, Ce.min), !t))
      return z(x[D].message), x;
  }
  if ((d || _) && !Q && (xe(y) || n && Array.isArray(y))) {
    const T = Ke(d), P = Ke(_), L = !le(T.value) && y.length > +T.value, W = !le(P.value) && y.length < +P.value;
    if ((L || W) && (ce(L, T.message, P.message), !t))
      return z(x[D].message), x;
  }
  if (E && !Q && xe(y)) {
    const { value: T, message: P } = Ke(E);
    if (ct(T) && !y.match(T) && (x[D] = {
      type: Ce.pattern,
      message: P,
      ref: i,
      ...Y(Ce.pattern, P)
    }, !t))
      return z(P), x;
  }
  if (O) {
    if (Ve(O)) {
      const T = await O(y, r), P = er(T, V);
      if (P && (x[D] = {
        ...P,
        ...Y(Ce.validate, P.message)
      }, !t))
        return z(P.message), x;
    } else if (ee(O)) {
      let T = {};
      for (const P in O) {
        if (!ae(T) && !t)
          break;
        const L = er(await O[P](y, r), V, P);
        L && (T = {
          ...L,
          ...Y(P, L.message)
        }, z(L.message), t && (x[D] = T));
      }
      if (!ae(T) && (x[D] = {
        ref: V,
        ...T
      }, !t))
        return x;
    }
  }
  return z(!0), x;
}, bt = (e, r) => [
  ...e,
  ...fe(r)
], wt = (e) => Array.isArray(e) ? e.map(() => {
}) : void 0;
function Ct(e, r, t) {
  return [
    ...e.slice(0, r),
    ...fe(t),
    ...e.slice(r)
  ];
}
var At = (e, r, t) => Array.isArray(e) ? (q(e[t]) && (e[t] = void 0), e.splice(t, 0, e.splice(r, 1)[0]), e) : [], Vt = (e, r) => [
  ...fe(r),
  ...fe(e)
];
function Ks(e, r) {
  let t = 0;
  const s = [...e];
  for (const n of r)
    s.splice(n - t, 1), t++;
  return Je(s).length ? s : [];
}
var Ft = (e, r) => q(r) ? [] : Ks(e, fe(r).sort((t, s) => t - s)), Et = (e, r, t) => {
  [e[r], e[t]] = [e[t], e[r]];
};
function $s(e, r) {
  const t = r.slice(0, -1).length;
  let s = 0;
  for (; s < t; )
    e = q(e) ? s++ : e[r[s++]];
  return e;
}
function qs(e) {
  for (const r in e)
    if (e.hasOwnProperty(r) && !q(e[r]))
      return !1;
  return !0;
}
function J(e, r) {
  const t = Array.isArray(r) ? r : Ht(r) ? [r] : pr(r), s = t.length === 1 ? e : $s(e, t), n = t.length - 1, i = t[n];
  return s && delete s[i], n !== 0 && (ee(s) && ae(s) || Array.isArray(s) && qs(s)) && J(e, t.slice(0, -1)), e;
}
var tr = (e, r, t) => (e[r] = t, e);
function $o(e) {
  const r = pt(), { control: t = r.control, name: s, keyName: n = "id", shouldUnregister: i } = e, [l, c] = I.useState(t._getFieldArray(s)), d = I.useRef(t._getFieldArray(s).map(Te)), _ = I.useRef(l), m = I.useRef(s), g = I.useRef(!1);
  m.current = s, _.current = l, t._names.array.add(s), e.rules && t.register(s, e.rules), ht({
    next: ({ values: x, name: w }) => {
      if (w === m.current || !w) {
        const F = h(x, m.current);
        Array.isArray(F) && (c(F), d.current = F.map(Te));
      }
    },
    subject: t._subjects.array
  });
  const E = I.useCallback((x) => {
    g.current = !0, t._updateFieldArray(s, x);
  }, [t, s]), O = (x, w) => {
    const F = fe(te(x)), k = bt(t._getFieldArray(s), F);
    t._names.focus = St(s, k.length - 1, w), d.current = bt(d.current, F.map(Te)), E(k), c(k), t._updateFieldArray(s, k, bt, {
      argA: wt(x)
    });
  }, D = (x, w) => {
    const F = fe(te(x)), k = Vt(t._getFieldArray(s), F);
    t._names.focus = St(s, 0, w), d.current = Vt(d.current, F.map(Te)), E(k), c(k), t._updateFieldArray(s, k, Vt, {
      argA: wt(x)
    });
  }, C = (x) => {
    const w = Ft(t._getFieldArray(s), x);
    d.current = Ft(d.current, x), E(w), c(w), t._updateFieldArray(s, w, Ft, {
      argA: x
    });
  }, R = (x, w, F) => {
    const k = fe(te(w)), Q = Ct(t._getFieldArray(s), x, k);
    t._names.focus = St(s, x, F), d.current = Ct(d.current, x, k.map(Te)), E(Q), c(Q), t._updateFieldArray(s, Q, Ct, {
      argA: x,
      argB: wt(w)
    });
  }, M = (x, w) => {
    const F = t._getFieldArray(s);
    Et(F, x, w), Et(d.current, x, w), E(F), c(F), t._updateFieldArray(s, F, Et, {
      argA: x,
      argB: w
    }, !1);
  }, y = (x, w) => {
    const F = t._getFieldArray(s);
    At(F, x, w), At(d.current, x, w), E(F), c(F), t._updateFieldArray(s, F, At, {
      argA: x,
      argB: w
    }, !1);
  }, V = (x, w) => {
    const F = te(w), k = tr(t._getFieldArray(s), x, F);
    d.current = [...k].map((Q, Y) => !Q || Y === x ? Te() : d.current[Y]), E(k), c([...k]), t._updateFieldArray(s, k, tr, {
      argA: x,
      argB: F
    }, !0, !1);
  }, z = (x) => {
    const w = fe(te(x));
    d.current = w.map(Te), E([...w]), c([...w]), t._updateFieldArray(s, [...w], (F) => F, {}, !0, !1);
  };
  return I.useEffect(() => {
    if (t._state.action = !1, Dt(s, t._names) && t._subjects.state.next({
      ...t._formState
    }), g.current && (!Ze(t._options.mode).isOnSubmit || t._formState.isSubmitted))
      if (t._options.resolver)
        t._executeSchema([s]).then((x) => {
          const w = h(x.errors, s), F = h(t._formState.errors, s);
          (F ? !w && F.type || w && (F.type !== w.type || F.message !== w.message) : w && w.type) && (w ? U(t._formState.errors, s, w) : J(t._formState.errors, s), t._subjects.state.next({
            errors: t._formState.errors
          }));
        });
      else {
        const x = h(t._fields, s);
        x && x._f && !(Ze(t._options.reValidateMode).isOnSubmit && Ze(t._options.mode).isOnSubmit) && Pt(x, t._formValues, t._options.criteriaMode === he.all, t._options.shouldUseNativeValidation, !0).then((w) => !ae(w) && t._subjects.state.next({
          errors: xr(t._formState.errors, w, s)
        }));
      }
    t._subjects.values.next({
      name: s,
      values: { ...t._formValues }
    }), t._names.focus && qe(t._fields, (x, w) => {
      if (t._names.focus && w.startsWith(t._names.focus) && x.focus)
        return x.focus(), 1;
    }), t._names.focus = "", t._updateValid(), g.current = !1;
  }, [l, s, t]), I.useEffect(() => (!h(t._formValues, s) && t._updateFieldArray(s), () => {
    (t._options.shouldUnregister || i) && t.unregister(s);
  }), [s, t, n, i]), {
    swap: I.useCallback(M, [E, s, t]),
    move: I.useCallback(y, [E, s, t]),
    prepend: I.useCallback(D, [E, s, t]),
    append: I.useCallback(O, [E, s, t]),
    remove: I.useCallback(C, [E, s, t]),
    insert: I.useCallback(R, [E, s, t]),
    update: I.useCallback(V, [E, s, t]),
    replace: I.useCallback(z, [E, s, t]),
    fields: I.useMemo(() => l.map((x, w) => ({
      ...x,
      [n]: d.current[w] || Te()
    })), [l, n])
  };
}
var Tt = () => {
  let e = [];
  return {
    get observers() {
      return e;
    },
    next: (n) => {
      for (const i of e)
        i.next && i.next(n);
    },
    subscribe: (n) => (e.push(n), {
      unsubscribe: () => {
        e = e.filter((i) => i !== n);
      }
    }),
    unsubscribe: () => {
      e = [];
    }
  };
}, ut = (e) => le(e) || !ur(e);
function Ie(e, r) {
  if (ut(e) || ut(r))
    return e === r;
  if ($e(e) && $e(r))
    return e.getTime() === r.getTime();
  const t = Object.keys(e), s = Object.keys(r);
  if (t.length !== s.length)
    return !1;
  for (const n of t) {
    const i = e[n];
    if (!s.includes(n))
      return !1;
    if (n !== "ref") {
      const l = r[n];
      if ($e(i) && $e(l) || ee(i) && ee(l) || Array.isArray(i) && Array.isArray(l) ? !Ie(i, l) : i !== l)
        return !1;
    }
  }
  return !0;
}
var br = (e) => e.type === "select-multiple", Gs = (e) => Kt(e) || Qe(e), It = (e) => lt(e) && e.isConnected, wr = (e) => {
  for (const r in e)
    if (Ve(e[r]))
      return !0;
  return !1;
};
function dt(e, r = {}) {
  const t = Array.isArray(e);
  if (ee(e) || t)
    for (const s in e)
      Array.isArray(e[s]) || ee(e[s]) && !wr(e[s]) ? (r[s] = Array.isArray(e[s]) ? [] : {}, dt(e[s], r[s])) : le(e[s]) || (r[s] = !0);
  return r;
}
function Cr(e, r, t) {
  const s = Array.isArray(e);
  if (ee(e) || s)
    for (const n in e)
      Array.isArray(e[n]) || ee(e[n]) && !wr(e[n]) ? q(r) || ut(t[n]) ? t[n] = Array.isArray(e[n]) ? dt(e[n], []) : { ...dt(e[n]) } : Cr(e[n], le(r) ? {} : r[n], t[n]) : t[n] = !Ie(e[n], r[n]);
  return t;
}
var ot = (e, r) => Cr(e, r, dt(r)), Ar = (e, { valueAsNumber: r, valueAsDate: t, setValueAs: s }) => q(e) ? e : r ? e === "" ? NaN : e && +e : t && xe(e) ? new Date(e) : s ? s(e) : e;
function Rt(e) {
  const r = e.ref;
  if (!(e.refs ? e.refs.every((t) => t.disabled) : r.disabled))
    return Wt(r) ? r.files : Kt(r) ? Sr(e.refs).value : br(r) ? [...r.selectedOptions].map(({ value: t }) => t) : Qe(r) ? _r(e.refs).value : Ar(q(r.value) ? e.ref.value : r.value, e);
}
var zs = (e, r, t, s) => {
  const n = {};
  for (const i of e) {
    const l = h(r, i);
    l && U(n, i, l._f);
  }
  return {
    criteriaMode: t,
    names: [...e],
    fields: n,
    shouldUseNativeValidation: s
  };
}, Ye = (e) => q(e) ? e : ct(e) ? e.source : ee(e) ? ct(e.value) ? e.value.source : e.value : e;
const rr = "AsyncFunction";
var Ys = (e) => (!e || !e.validate) && !!(Ve(e.validate) && e.validate.constructor.name === rr || ee(e.validate) && Object.values(e.validate).find((r) => r.constructor.name === rr)), Xs = (e) => e.mount && (e.required || e.min || e.max || e.maxLength || e.minLength || e.pattern || e.validate);
function sr(e, r, t) {
  const s = h(e, t);
  if (s || Ht(t))
    return {
      error: s,
      name: t
    };
  const n = t.split(".");
  for (; n.length; ) {
    const i = n.join("."), l = h(r, i), c = h(e, i);
    if (l && !Array.isArray(l) && t !== i)
      return { name: t };
    if (c && c.type)
      return {
        name: i,
        error: c
      };
    n.pop();
  }
  return {
    name: t
  };
}
var Zs = (e, r, t, s, n) => n.isOnAll ? !1 : !t && n.isOnTouch ? !(r || e) : (t ? s.isOnBlur : n.isOnBlur) ? !e : (t ? s.isOnChange : n.isOnChange) ? e : !0, Qs = (e, r) => !Je(h(e, r)).length && J(e, r);
const Js = {
  mode: he.onSubmit,
  reValidateMode: he.onChange,
  shouldFocusError: !0
};
function eo(e = {}) {
  let r = {
    ...Js,
    ...e
  }, t = {
    submitCount: 0,
    isDirty: !1,
    isLoading: Ve(r.defaultValues),
    isValidating: !1,
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: r.errors || {},
    disabled: r.disabled || !1
  }, s = {}, n = ee(r.defaultValues) || ee(r.values) ? te(r.defaultValues || r.values) || {} : {}, i = r.shouldUnregister ? {} : te(n), l = {
    action: !1,
    mount: !1,
    watch: !1
  }, c = {
    mount: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  }, d, _ = 0;
  const m = {
    isDirty: !1,
    dirtyFields: !1,
    validatingFields: !1,
    touchedFields: !1,
    isValidating: !1,
    isValid: !1,
    errors: !1
  }, g = {
    values: Tt(),
    array: Tt(),
    state: Tt()
  }, E = Ze(r.mode), O = Ze(r.reValidateMode), D = r.criteriaMode === he.all, C = (o) => (a) => {
    clearTimeout(_), _ = setTimeout(o, a);
  }, R = async (o) => {
    if (m.isValid || o) {
      const a = r.resolver ? ae((await k()).errors) : await Y(s, !0);
      a !== t.isValid && g.state.next({
        isValid: a
      });
    }
  }, M = (o, a) => {
    (m.isValidating || m.validatingFields) && ((o || Array.from(c.mount)).forEach((u) => {
      u && (a ? U(t.validatingFields, u, a) : J(t.validatingFields, u));
    }), g.state.next({
      validatingFields: t.validatingFields,
      isValidating: !ae(t.validatingFields)
    }));
  }, y = (o, a = [], u, S, v = !0, f = !0) => {
    if (S && u) {
      if (l.action = !0, f && Array.isArray(h(s, o))) {
        const A = u(h(s, o), S.argA, S.argB);
        v && U(s, o, A);
      }
      if (f && Array.isArray(h(t.errors, o))) {
        const A = u(h(t.errors, o), S.argA, S.argB);
        v && U(t.errors, o, A), Qs(t.errors, o);
      }
      if (m.touchedFields && f && Array.isArray(h(t.touchedFields, o))) {
        const A = u(h(t.touchedFields, o), S.argA, S.argB);
        v && U(t.touchedFields, o, A);
      }
      m.dirtyFields && (t.dirtyFields = ot(n, i)), g.state.next({
        name: o,
        isDirty: T(o, a),
        dirtyFields: t.dirtyFields,
        errors: t.errors,
        isValid: t.isValid
      });
    } else
      U(i, o, a);
  }, V = (o, a) => {
    U(t.errors, o, a), g.state.next({
      errors: t.errors
    });
  }, z = (o) => {
    t.errors = o, g.state.next({
      errors: t.errors,
      isValid: !1
    });
  }, x = (o, a, u, S) => {
    const v = h(s, o);
    if (v) {
      const f = h(i, o, q(u) ? h(n, o) : u);
      q(f) || S && S.defaultChecked || a ? U(i, o, a ? f : Rt(v._f)) : W(o, f), l.mount && R();
    }
  }, w = (o, a, u, S, v) => {
    let f = !1, A = !1;
    const j = {
      name: o
    }, re = !!(h(s, o) && h(s, o)._f && h(s, o)._f.disabled);
    if (!u || S) {
      m.isDirty && (A = t.isDirty, t.isDirty = j.isDirty = T(), f = A !== j.isDirty);
      const se = re || Ie(h(n, o), a);
      A = !!(!re && h(t.dirtyFields, o)), se || re ? J(t.dirtyFields, o) : U(t.dirtyFields, o, !0), j.dirtyFields = t.dirtyFields, f = f || m.dirtyFields && A !== !se;
    }
    if (u) {
      const se = h(t.touchedFields, o);
      se || (U(t.touchedFields, o, u), j.touchedFields = t.touchedFields, f = f || m.touchedFields && se !== u);
    }
    return f && v && g.state.next(j), f ? j : {};
  }, F = (o, a, u, S) => {
    const v = h(t.errors, o), f = m.isValid && pe(a) && t.isValid !== a;
    if (e.delayError && u ? (d = C(() => V(o, u)), d(e.delayError)) : (clearTimeout(_), d = null, u ? U(t.errors, o, u) : J(t.errors, o)), (u ? !Ie(v, u) : v) || !ae(S) || f) {
      const A = {
        ...S,
        ...f && pe(a) ? { isValid: a } : {},
        errors: t.errors,
        name: o
      };
      t = {
        ...t,
        ...A
      }, g.state.next(A);
    }
  }, k = async (o) => {
    M(o, !0);
    const a = await r.resolver(i, r.context, zs(o || c.mount, s, r.criteriaMode, r.shouldUseNativeValidation));
    return M(o), a;
  }, Q = async (o) => {
    const { errors: a } = await k(o);
    if (o)
      for (const u of o) {
        const S = h(a, u);
        S ? U(t.errors, u, S) : J(t.errors, u);
      }
    else
      t.errors = a;
    return a;
  }, Y = async (o, a, u = {
    valid: !0
  }) => {
    for (const S in o) {
      const v = o[S];
      if (v) {
        const { _f: f, ...A } = v;
        if (f) {
          const j = c.array.has(f.name), re = v._f && Ys(v._f);
          re && m.validatingFields && M([S], !0);
          const se = await Pt(v, i, D, r.shouldUseNativeValidation && !a, j);
          if (re && m.validatingFields && M([S]), se[f.name] && (u.valid = !1, a))
            break;
          !a && (h(se, f.name) ? j ? xr(t.errors, se, f.name) : U(t.errors, f.name, se[f.name]) : J(t.errors, f.name));
        }
        !ae(A) && await Y(A, a, u);
      }
    }
    return u.valid;
  }, ce = () => {
    for (const o of c.unMount) {
      const a = h(s, o);
      a && (a._f.refs ? a._f.refs.every((u) => !It(u)) : !It(a._f.ref)) && we(o);
    }
    c.unMount = /* @__PURE__ */ new Set();
  }, T = (o, a) => (o && a && U(i, o, a), !Ie(Me(), n)), P = (o, a, u) => vr(o, c, {
    ...l.mount ? i : q(a) ? n : xe(o) ? { [o]: a } : a
  }, u, a), L = (o) => Je(h(l.mount ? i : n, o, e.shouldUnregister ? h(n, o, []) : [])), W = (o, a, u = {}) => {
    const S = h(s, o);
    let v = a;
    if (S) {
      const f = S._f;
      f && (!f.disabled && U(i, o, Ar(a, f)), v = lt(f.ref) && le(a) ? "" : a, br(f.ref) ? [...f.ref.options].forEach((A) => A.selected = v.includes(A.value)) : f.refs ? Qe(f.ref) ? f.refs.length > 1 ? f.refs.forEach((A) => (!A.defaultChecked || !A.disabled) && (A.checked = Array.isArray(v) ? !!v.find((j) => j === A.value) : v === A.value)) : f.refs[0] && (f.refs[0].checked = !!v) : f.refs.forEach((A) => A.checked = A.value === v) : Wt(f.ref) ? f.ref.value = "" : (f.ref.value = v, f.ref.type || g.values.next({
        name: o,
        values: { ...i }
      })));
    }
    (u.shouldDirty || u.shouldTouch) && w(o, v, u.shouldTouch, u.shouldDirty, !0), u.shouldValidate && Se(o);
  }, K = (o, a, u) => {
    for (const S in a) {
      const v = a[S], f = `${o}.${S}`, A = h(s, f);
      (c.array.has(o) || !ut(v) || A && !A._f) && !$e(v) ? K(f, v, u) : W(f, v, u);
    }
  }, X = (o, a, u = {}) => {
    const S = h(s, o), v = c.array.has(o), f = te(a);
    U(i, o, f), v ? (g.array.next({
      name: o,
      values: { ...i }
    }), (m.isDirty || m.dirtyFields) && u.shouldDirty && g.state.next({
      name: o,
      dirtyFields: ot(n, i),
      isDirty: T(o, f)
    })) : S && !S._f && !le(f) ? K(o, f, u) : W(o, f, u), Dt(o, c) && g.state.next({ ...t }), g.values.next({
      name: l.mount ? o : void 0,
      values: { ...i }
    });
  }, ie = async (o) => {
    l.mount = !0;
    const a = o.target;
    let u = a.name, S = !0;
    const v = h(s, u), f = () => a.type ? Rt(v._f) : dr(o), A = (j) => {
      S = Number.isNaN(j) || Ie(j, h(i, u, j));
    };
    if (v) {
      let j, re;
      const se = f(), Oe = o.type === at.BLUR || o.type === at.FOCUS_OUT, us = !Xs(v._f) && !r.resolver && !h(t.errors, u) && !v._f.deps || Zs(Oe, h(t.touchedFields, u), t.isSubmitted, O, E), vt = Dt(u, c, Oe);
      U(i, u, se), Oe ? (v._f.onBlur && v._f.onBlur(o), d && d(0)) : v._f.onChange && v._f.onChange(o);
      const xt = w(u, se, Oe, !1), ds = !ae(xt) || vt;
      if (!Oe && g.values.next({
        name: u,
        type: o.type,
        values: { ...i }
      }), us)
        return m.isValid && (e.mode === "onBlur" ? Oe && R() : R()), ds && g.state.next({ name: u, ...vt ? {} : xt });
      if (!Oe && vt && g.state.next({ ...t }), r.resolver) {
        const { errors: qt } = await k([u]);
        if (A(se), S) {
          const fs = sr(t.errors, s, u), Gt = sr(qt, s, fs.name || u);
          j = Gt.error, u = Gt.name, re = ae(qt);
        }
      } else
        M([u], !0), j = (await Pt(v, i, D, r.shouldUseNativeValidation))[u], M([u]), A(se), S && (j ? re = !1 : m.isValid && (re = await Y(s, !0)));
      S && (v._f.deps && Se(v._f.deps), F(u, re, j, xt));
    }
  }, ue = (o, a) => {
    if (h(t.errors, a) && o.focus)
      return o.focus(), 1;
  }, Se = async (o, a = {}) => {
    let u, S;
    const v = fe(o);
    if (r.resolver) {
      const f = await Q(q(o) ? o : v);
      u = ae(f), S = o ? !v.some((A) => h(f, A)) : u;
    } else o ? (S = (await Promise.all(v.map(async (f) => {
      const A = h(s, f);
      return await Y(A && A._f ? { [f]: A } : A);
    }))).every(Boolean), !(!S && !t.isValid) && R()) : S = u = await Y(s);
    return g.state.next({
      ...!xe(o) || m.isValid && u !== t.isValid ? {} : { name: o },
      ...r.resolver || !o ? { isValid: u } : {},
      errors: t.errors
    }), a.shouldFocus && !S && qe(s, ue, o ? v : c.mount), S;
  }, Me = (o) => {
    const a = {
      ...l.mount ? i : n
    };
    return q(o) ? a : xe(o) ? h(a, o) : o.map((u) => h(a, u));
  }, Le = (o, a) => ({
    invalid: !!h((a || t).errors, o),
    isDirty: !!h((a || t).dirtyFields, o),
    error: h((a || t).errors, o),
    isValidating: !!h(t.validatingFields, o),
    isTouched: !!h((a || t).touchedFields, o)
  }), ze = (o) => {
    o && fe(o).forEach((a) => J(t.errors, a)), g.state.next({
      errors: o ? t.errors : {}
    });
  }, be = (o, a, u) => {
    const S = (h(s, o, { _f: {} })._f || {}).ref, v = h(t.errors, o) || {}, { ref: f, message: A, type: j, ...re } = v;
    U(t.errors, o, {
      ...re,
      ...a,
      ref: S
    }), g.state.next({
      name: o,
      errors: t.errors,
      isValid: !1
    }), u && u.shouldFocus && S && S.focus && S.focus();
  }, Be = (o, a) => Ve(o) ? g.values.subscribe({
    next: (u) => o(P(void 0, a), u)
  }) : P(o, a, !0), we = (o, a = {}) => {
    for (const u of o ? fe(o) : c.mount)
      c.mount.delete(u), c.array.delete(u), a.keepValue || (J(s, u), J(i, u)), !a.keepError && J(t.errors, u), !a.keepDirty && J(t.dirtyFields, u), !a.keepTouched && J(t.touchedFields, u), !a.keepIsValidating && J(t.validatingFields, u), !r.shouldUnregister && !a.keepDefaultValue && J(n, u);
    g.values.next({
      values: { ...i }
    }), g.state.next({
      ...t,
      ...a.keepDirty ? { isDirty: T() } : {}
    }), !a.keepIsValid && R();
  }, N = ({ disabled: o, name: a, field: u, fields: S, value: v }) => {
    if (pe(o) && l.mount || o) {
      const f = o ? void 0 : q(v) ? Rt(u ? u._f : h(S, a)._f) : v;
      U(i, a, f), w(a, f, !1, !1, !0);
    }
  }, $ = (o, a = {}) => {
    let u = h(s, o);
    const S = pe(a.disabled) || pe(e.disabled);
    return U(s, o, {
      ...u || {},
      _f: {
        ...u && u._f ? u._f : { ref: { name: o } },
        name: o,
        mount: !0,
        ...a
      }
    }), c.mount.add(o), u ? N({
      field: u,
      disabled: pe(a.disabled) ? a.disabled : e.disabled,
      name: o,
      value: a.value
    }) : x(o, !0, a.value), {
      ...S ? { disabled: a.disabled || e.disabled } : {},
      ...r.progressive ? {
        required: !!a.required,
        min: Ye(a.min),
        max: Ye(a.max),
        minLength: Ye(a.minLength),
        maxLength: Ye(a.maxLength),
        pattern: Ye(a.pattern)
      } : {},
      name: o,
      onChange: ie,
      onBlur: ie,
      ref: (v) => {
        if (v) {
          $(o, a), u = h(s, o);
          const f = q(v.value) && v.querySelectorAll && v.querySelectorAll("input,select,textarea")[0] || v, A = Gs(f), j = u._f.refs || [];
          if (A ? j.find((re) => re === f) : f === u._f.ref)
            return;
          U(s, o, {
            _f: {
              ...u._f,
              ...A ? {
                refs: [
                  ...j.filter(It),
                  f,
                  ...Array.isArray(h(n, o)) ? [{}] : []
                ],
                ref: { type: f.type, name: o }
              } : { ref: f }
            }
          }), x(o, !1, void 0, f);
        } else
          u = h(s, o, {}), u._f && (u._f.mount = !1), (r.shouldUnregister || a.shouldUnregister) && !(fr(c.array, o) && l.action) && c.unMount.add(o);
      }
    };
  }, ne = () => r.shouldFocusError && qe(s, ue, c.mount), G = (o) => {
    pe(o) && (g.state.next({ disabled: o }), qe(s, (a, u) => {
      const S = h(s, u);
      S && (a.disabled = S._f.disabled || o, Array.isArray(S._f.refs) && S._f.refs.forEach((v) => {
        v.disabled = S._f.disabled || o;
      }));
    }, 0, !1));
  }, B = (o, a) => async (u) => {
    let S;
    u && (u.preventDefault && u.preventDefault(), u.persist && u.persist());
    let v = te(i);
    if (g.state.next({
      isSubmitting: !0
    }), r.resolver) {
      const { errors: f, values: A } = await k();
      t.errors = f, v = A;
    } else
      await Y(s);
    if (J(t.errors, "root"), ae(t.errors)) {
      g.state.next({
        errors: {}
      });
      try {
        await o(v, u);
      } catch (f) {
        S = f;
      }
    } else
      a && await a({ ...t.errors }, u), ne(), setTimeout(ne);
    if (g.state.next({
      isSubmitted: !0,
      isSubmitting: !1,
      isSubmitSuccessful: ae(t.errors) && !S,
      submitCount: t.submitCount + 1,
      errors: t.errors
    }), S)
      throw S;
  }, H = (o, a = {}) => {
    h(s, o) && (q(a.defaultValue) ? X(o, te(h(n, o))) : (X(o, a.defaultValue), U(n, o, te(a.defaultValue))), a.keepTouched || J(t.touchedFields, o), a.keepDirty || (J(t.dirtyFields, o), t.isDirty = a.defaultValue ? T(o, te(h(n, o))) : T()), a.keepError || (J(t.errors, o), m.isValid && R()), g.state.next({ ...t }));
  }, ge = (o, a = {}) => {
    const u = o ? te(o) : n, S = te(u), v = ae(o), f = v ? n : S;
    if (a.keepDefaultValues || (n = u), !a.keepValues) {
      if (a.keepDirtyValues)
        for (const A of c.mount)
          h(t.dirtyFields, A) ? U(f, A, h(i, A)) : X(A, h(f, A));
      else {
        if (Ut && q(o))
          for (const A of c.mount) {
            const j = h(s, A);
            if (j && j._f) {
              const re = Array.isArray(j._f.refs) ? j._f.refs[0] : j._f.ref;
              if (lt(re)) {
                const se = re.closest("form");
                if (se) {
                  se.reset();
                  break;
                }
              }
            }
          }
        s = {};
      }
      i = e.shouldUnregister ? a.keepDefaultValues ? te(n) : {} : te(f), g.array.next({
        values: { ...f }
      }), g.values.next({
        values: { ...f }
      });
    }
    c = {
      mount: a.keepDirtyValues ? c.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: !1,
      focus: ""
    }, l.mount = !m.isValid || !!a.keepIsValid || !!a.keepDirtyValues, l.watch = !!e.shouldUnregister, g.state.next({
      submitCount: a.keepSubmitCount ? t.submitCount : 0,
      isDirty: v ? !1 : a.keepDirty ? t.isDirty : !!(a.keepDefaultValues && !Ie(o, n)),
      isSubmitted: a.keepIsSubmitted ? t.isSubmitted : !1,
      dirtyFields: v ? {} : a.keepDirtyValues ? a.keepDefaultValues && i ? ot(n, i) : t.dirtyFields : a.keepDefaultValues && o ? ot(n, o) : a.keepDirty ? t.dirtyFields : {},
      touchedFields: a.keepTouched ? t.touchedFields : {},
      errors: a.keepErrors ? t.errors : {},
      isSubmitSuccessful: a.keepIsSubmitSuccessful ? t.isSubmitSuccessful : !1,
      isSubmitting: !1
    });
  }, ve = (o, a) => ge(Ve(o) ? o(i) : o, a);
  return {
    control: {
      register: $,
      unregister: we,
      getFieldState: Le,
      handleSubmit: B,
      setError: be,
      _executeSchema: k,
      _getWatch: P,
      _getDirty: T,
      _updateValid: R,
      _removeUnmounted: ce,
      _updateFieldArray: y,
      _updateDisabledField: N,
      _getFieldArray: L,
      _reset: ge,
      _resetDefaultValues: () => Ve(r.defaultValues) && r.defaultValues().then((o) => {
        ve(o, r.resetOptions), g.state.next({
          isLoading: !1
        });
      }),
      _updateFormState: (o) => {
        t = {
          ...t,
          ...o
        };
      },
      _disableForm: G,
      _subjects: g,
      _proxyFormState: m,
      _setErrors: z,
      get _fields() {
        return s;
      },
      get _formValues() {
        return i;
      },
      get _state() {
        return l;
      },
      set _state(o) {
        l = o;
      },
      get _defaultValues() {
        return n;
      },
      get _names() {
        return c;
      },
      set _names(o) {
        c = o;
      },
      get _formState() {
        return t;
      },
      set _formState(o) {
        t = o;
      },
      get _options() {
        return r;
      },
      set _options(o) {
        r = {
          ...r,
          ...o
        };
      }
    },
    trigger: Se,
    register: $,
    handleSubmit: B,
    watch: Be,
    setValue: X,
    getValues: Me,
    reset: ve,
    resetField: H,
    clearErrors: ze,
    unregister: we,
    setError: be,
    setFocus: (o, a = {}) => {
      const u = h(s, o), S = u && u._f;
      if (S) {
        const v = S.refs ? S.refs[0] : S.ref;
        v.focus && (v.focus(), a.shouldSelect && v.select());
      }
    },
    getFieldState: Le
  };
}
function qo(e = {}) {
  const r = I.useRef(), t = I.useRef(), [s, n] = I.useState({
    isDirty: !1,
    isValidating: !1,
    isLoading: Ve(e.defaultValues),
    isSubmitted: !1,
    isSubmitting: !1,
    isSubmitSuccessful: !1,
    isValid: !1,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: e.errors || {},
    disabled: e.disabled || !1,
    defaultValues: Ve(e.defaultValues) ? void 0 : e.defaultValues
  });
  r.current || (r.current = {
    ...eo(e),
    formState: s
  });
  const i = r.current.control;
  return i._options = e, ht({
    subject: i._subjects.state,
    next: (l) => {
      yr(l, i._proxyFormState, i._updateFormState, !0) && n({ ...i._formState });
    }
  }), I.useEffect(() => i._disableForm(e.disabled), [i, e.disabled]), I.useEffect(() => {
    if (i._proxyFormState.isDirty) {
      const l = i._getDirty();
      l !== s.isDirty && i._subjects.state.next({
        isDirty: l
      });
    }
  }, [i, s.isDirty]), I.useEffect(() => {
    e.values && !Ie(e.values, t.current) ? (i._reset(e.values, i._options.resetOptions), t.current = e.values, n((l) => ({ ...l }))) : i._resetDefaultValues();
  }, [e.values, i]), I.useEffect(() => {
    e.errors && i._setErrors(e.errors);
  }, [e.errors, i]), I.useEffect(() => {
    i._state.mount || (i._updateValid(), i._state.mount = !0), i._state.watch && (i._state.watch = !1, i._subjects.state.next({ ...i._formState })), i._removeUnmounted();
  }), I.useEffect(() => {
    e.shouldUnregister && i._subjects.values.next({
      values: i._getWatch()
    });
  }, [e.shouldUnregister, i]), r.current.formState = mr(s, i), r.current;
}
function or(e, [r, t]) {
  return Math.min(t, Math.max(r, e));
}
function to(e) {
  const r = p.useRef({ value: e, previous: e });
  return p.useMemo(() => (r.current.value !== e && (r.current.previous = r.current.value, r.current.value = e), r.current.previous), [e]);
}
var ro = [" ", "Enter", "ArrowUp", "ArrowDown"], so = [" ", "Enter"], et = "Select", [mt, yt, oo] = hs(et), [Ge, Go] = ms(et, [
  oo,
  ir
]), gt = ir(), [no, Pe] = Ge(et), [io, ao] = Ge(et), Vr = (e) => {
  const {
    __scopeSelect: r,
    children: t,
    open: s,
    defaultOpen: n,
    onOpenChange: i,
    value: l,
    defaultValue: c,
    onValueChange: d,
    dir: _,
    name: m,
    autoComplete: g,
    disabled: E,
    required: O,
    form: D
  } = e, C = gt(r), [R, M] = p.useState(null), [y, V] = p.useState(null), [z, x] = p.useState(!1), w = Es(_), [F = !1, k] = Yt({
    prop: s,
    defaultProp: n,
    onChange: i
  }), [Q, Y] = Yt({
    prop: l,
    defaultProp: c,
    onChange: d
  }), ce = p.useRef(null), T = R ? D || !!R.closest("form") : !0, [P, L] = p.useState(/* @__PURE__ */ new Set()), W = Array.from(P).map((K) => K.props.value).join(";");
  return /* @__PURE__ */ b.jsx(Ts, { ...C, children: /* @__PURE__ */ b.jsxs(
    no,
    {
      required: O,
      scope: r,
      trigger: R,
      onTriggerChange: M,
      valueNode: y,
      onValueNodeChange: V,
      valueNodeHasChildren: z,
      onValueNodeHasChildrenChange: x,
      contentId: Bt(),
      value: Q,
      onValueChange: Y,
      open: F,
      onOpenChange: k,
      dir: w,
      triggerPointerDownPosRef: ce,
      disabled: E,
      children: [
        /* @__PURE__ */ b.jsx(mt.Provider, { scope: r, children: /* @__PURE__ */ b.jsx(
          io,
          {
            scope: e.__scopeSelect,
            onNativeOptionAdd: p.useCallback((K) => {
              L((X) => new Set(X).add(K));
            }, []),
            onNativeOptionRemove: p.useCallback((K) => {
              L((X) => {
                const ie = new Set(X);
                return ie.delete(K), ie;
              });
            }, []),
            children: t
          }
        ) }),
        T ? /* @__PURE__ */ b.jsxs(
          Qr,
          {
            "aria-hidden": !0,
            required: O,
            tabIndex: -1,
            name: m,
            autoComplete: g,
            value: Q,
            onChange: (K) => Y(K.target.value),
            disabled: E,
            form: D,
            children: [
              Q === void 0 ? /* @__PURE__ */ b.jsx("option", { value: "" }) : null,
              Array.from(P)
            ]
          },
          W
        ) : null
      ]
    }
  ) });
};
Vr.displayName = et;
var Fr = "SelectTrigger", Er = p.forwardRef(
  (e, r) => {
    const { __scopeSelect: t, disabled: s = !1, ...n } = e, i = gt(t), l = Pe(Fr, t), c = l.disabled || s, d = _e(r, l.onTriggerChange), _ = yt(t), m = p.useRef("touch"), [g, E, O] = Jr((C) => {
      const R = _().filter((V) => !V.disabled), M = R.find((V) => V.value === l.value), y = es(R, C, M);
      y !== void 0 && l.onValueChange(y.value);
    }), D = (C) => {
      c || (l.onOpenChange(!0), O()), C && (l.triggerPointerDownPosRef.current = {
        x: Math.round(C.pageX),
        y: Math.round(C.pageY)
      });
    };
    return /* @__PURE__ */ b.jsx(ys, { asChild: !0, ...i, children: /* @__PURE__ */ b.jsx(
      me.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": l.contentId,
        "aria-expanded": l.open,
        "aria-required": l.required,
        "aria-autocomplete": "none",
        dir: l.dir,
        "data-state": l.open ? "open" : "closed",
        disabled: c,
        "data-disabled": c ? "" : void 0,
        "data-placeholder": Zr(l.value) ? "" : void 0,
        ...n,
        ref: d,
        onClick: oe(n.onClick, (C) => {
          C.currentTarget.focus(), m.current !== "mouse" && D(C);
        }),
        onPointerDown: oe(n.onPointerDown, (C) => {
          m.current = C.pointerType;
          const R = C.target;
          R.hasPointerCapture(C.pointerId) && R.releasePointerCapture(C.pointerId), C.button === 0 && C.ctrlKey === !1 && C.pointerType === "mouse" && (D(C), C.preventDefault());
        }),
        onKeyDown: oe(n.onKeyDown, (C) => {
          const R = g.current !== "";
          !(C.ctrlKey || C.altKey || C.metaKey) && C.key.length === 1 && E(C.key), !(R && C.key === " ") && ro.includes(C.key) && (D(), C.preventDefault());
        })
      }
    ) });
  }
);
Er.displayName = Fr;
var Tr = "SelectValue", Ir = p.forwardRef(
  (e, r) => {
    const { __scopeSelect: t, className: s, style: n, children: i, placeholder: l = "", ...c } = e, d = Pe(Tr, t), { onValueNodeHasChildrenChange: _ } = d, m = i !== void 0, g = _e(r, d.onValueNodeChange);
    return De(() => {
      _(m);
    }, [_, m]), /* @__PURE__ */ b.jsx(
      me.span,
      {
        ...c,
        ref: g,
        style: { pointerEvents: "none" },
        children: Zr(d.value) ? /* @__PURE__ */ b.jsx(b.Fragment, { children: l }) : i
      }
    );
  }
);
Ir.displayName = Tr;
var lo = "SelectIcon", Rr = p.forwardRef(
  (e, r) => {
    const { __scopeSelect: t, children: s, ...n } = e;
    return /* @__PURE__ */ b.jsx(me.span, { "aria-hidden": !0, ...n, ref: r, children: s || "â–¼" });
  }
);
Rr.displayName = lo;
var co = "SelectPortal", Nr = (e) => /* @__PURE__ */ b.jsx(Fs, { asChild: !0, ...e });
Nr.displayName = co;
var je = "SelectContent", Dr = p.forwardRef(
  (e, r) => {
    const t = Pe(je, e.__scopeSelect), [s, n] = p.useState();
    if (De(() => {
      n(new DocumentFragment());
    }, []), !t.open) {
      const i = s;
      return i ? lr.createPortal(
        /* @__PURE__ */ b.jsx(Pr, { scope: e.__scopeSelect, children: /* @__PURE__ */ b.jsx(mt.Slot, { scope: e.__scopeSelect, children: /* @__PURE__ */ b.jsx("div", { children: e.children }) }) }),
        i
      ) : null;
    }
    return /* @__PURE__ */ b.jsx(kr, { ...e, ref: r });
  }
);
Dr.displayName = je;
var ye = 10, [Pr, ke] = Ge(je), uo = "SelectContentImpl", kr = p.forwardRef(
  (e, r) => {
    const {
      __scopeSelect: t,
      position: s = "item-aligned",
      onCloseAutoFocus: n,
      onEscapeKeyDown: i,
      onPointerDownOutside: l,
      //
      // PopperContent props
      side: c,
      sideOffset: d,
      align: _,
      alignOffset: m,
      arrowPadding: g,
      collisionBoundary: E,
      collisionPadding: O,
      sticky: D,
      hideWhenDetached: C,
      avoidCollisions: R,
      //
      ...M
    } = e, y = Pe(je, t), [V, z] = p.useState(null), [x, w] = p.useState(null), F = _e(r, (N) => z(N)), [k, Q] = p.useState(null), [Y, ce] = p.useState(
      null
    ), T = yt(t), [P, L] = p.useState(!1), W = p.useRef(!1);
    p.useEffect(() => {
      if (V) return gs(V);
    }, [V]), vs();
    const K = p.useCallback(
      (N) => {
        const [$, ...ne] = T().map((H) => H.ref.current), [G] = ne.slice(-1), B = document.activeElement;
        for (const H of N)
          if (H === B || (H == null || H.scrollIntoView({ block: "nearest" }), H === $ && x && (x.scrollTop = 0), H === G && x && (x.scrollTop = x.scrollHeight), H == null || H.focus(), document.activeElement !== B)) return;
      },
      [T, x]
    ), X = p.useCallback(
      () => K([k, V]),
      [K, k, V]
    );
    p.useEffect(() => {
      P && X();
    }, [P, X]);
    const { onOpenChange: ie, triggerPointerDownPosRef: ue } = y;
    p.useEffect(() => {
      if (V) {
        let N = { x: 0, y: 0 };
        const $ = (G) => {
          var B, H;
          N = {
            x: Math.abs(Math.round(G.pageX) - (((B = ue.current) == null ? void 0 : B.x) ?? 0)),
            y: Math.abs(Math.round(G.pageY) - (((H = ue.current) == null ? void 0 : H.y) ?? 0))
          };
        }, ne = (G) => {
          N.x <= 10 && N.y <= 10 ? G.preventDefault() : V.contains(G.target) || ie(!1), document.removeEventListener("pointermove", $), ue.current = null;
        };
        return ue.current !== null && (document.addEventListener("pointermove", $), document.addEventListener("pointerup", ne, { capture: !0, once: !0 })), () => {
          document.removeEventListener("pointermove", $), document.removeEventListener("pointerup", ne, { capture: !0 });
        };
      }
    }, [V, ie, ue]), p.useEffect(() => {
      const N = () => ie(!1);
      return window.addEventListener("blur", N), window.addEventListener("resize", N), () => {
        window.removeEventListener("blur", N), window.removeEventListener("resize", N);
      };
    }, [ie]);
    const [Se, Me] = Jr((N) => {
      const $ = T().filter((B) => !B.disabled), ne = $.find((B) => B.ref.current === document.activeElement), G = es($, N, ne);
      G && setTimeout(() => G.ref.current.focus());
    }), Le = p.useCallback(
      (N, $, ne) => {
        const G = !W.current && !ne;
        (y.value !== void 0 && y.value === $ || G) && (Q(N), G && (W.current = !0));
      },
      [y.value]
    ), ze = p.useCallback(() => V == null ? void 0 : V.focus(), [V]), be = p.useCallback(
      (N, $, ne) => {
        const G = !W.current && !ne;
        (y.value !== void 0 && y.value === $ || G) && ce(N);
      },
      [y.value]
    ), Be = s === "popper" ? kt : Mr, we = Be === kt ? {
      side: c,
      sideOffset: d,
      align: _,
      alignOffset: m,
      arrowPadding: g,
      collisionBoundary: E,
      collisionPadding: O,
      sticky: D,
      hideWhenDetached: C,
      avoidCollisions: R
    } : {};
    return /* @__PURE__ */ b.jsx(
      Pr,
      {
        scope: t,
        content: V,
        viewport: x,
        onViewportChange: w,
        itemRefCallback: Le,
        selectedItem: k,
        onItemLeave: ze,
        itemTextRefCallback: be,
        focusSelectedItem: X,
        selectedItemText: Y,
        position: s,
        isPositioned: P,
        searchRef: Se,
        children: /* @__PURE__ */ b.jsx(xs, { as: _s, allowPinchZoom: !0, children: /* @__PURE__ */ b.jsx(
          Ss,
          {
            asChild: !0,
            trapped: y.open,
            onMountAutoFocus: (N) => {
              N.preventDefault();
            },
            onUnmountAutoFocus: oe(n, (N) => {
              var $;
              ($ = y.trigger) == null || $.focus({ preventScroll: !0 }), N.preventDefault();
            }),
            children: /* @__PURE__ */ b.jsx(
              bs,
              {
                asChild: !0,
                disableOutsidePointerEvents: !0,
                onEscapeKeyDown: i,
                onPointerDownOutside: l,
                onFocusOutside: (N) => N.preventDefault(),
                onDismiss: () => y.onOpenChange(!1),
                children: /* @__PURE__ */ b.jsx(
                  Be,
                  {
                    role: "listbox",
                    id: y.contentId,
                    "data-state": y.open ? "open" : "closed",
                    dir: y.dir,
                    onContextMenu: (N) => N.preventDefault(),
                    ...M,
                    ...we,
                    onPlaced: () => L(!0),
                    ref: F,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...M.style
                    },
                    onKeyDown: oe(M.onKeyDown, (N) => {
                      const $ = N.ctrlKey || N.altKey || N.metaKey;
                      if (N.key === "Tab" && N.preventDefault(), !$ && N.key.length === 1 && Me(N.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(N.key)) {
                        let G = T().filter((B) => !B.disabled).map((B) => B.ref.current);
                        if (["ArrowUp", "End"].includes(N.key) && (G = G.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(N.key)) {
                          const B = N.target, H = G.indexOf(B);
                          G = G.slice(H + 1);
                        }
                        setTimeout(() => K(G)), N.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
kr.displayName = uo;
var fo = "SelectItemAlignedPosition", Mr = p.forwardRef((e, r) => {
  const { __scopeSelect: t, onPlaced: s, ...n } = e, i = Pe(je, t), l = ke(je, t), [c, d] = p.useState(null), [_, m] = p.useState(null), g = _e(r, (F) => m(F)), E = yt(t), O = p.useRef(!1), D = p.useRef(!0), { viewport: C, selectedItem: R, selectedItemText: M, focusSelectedItem: y } = l, V = p.useCallback(() => {
    if (i.trigger && i.valueNode && c && _ && C && R && M) {
      const F = i.trigger.getBoundingClientRect(), k = _.getBoundingClientRect(), Q = i.valueNode.getBoundingClientRect(), Y = M.getBoundingClientRect();
      if (i.dir !== "rtl") {
        const B = Y.left - k.left, H = Q.left - B, ge = F.left - H, ve = F.width + ge, tt = Math.max(ve, k.width), rt = window.innerWidth - ye, st = or(H, [
          ye,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(ye, rt - tt)
        ]);
        c.style.minWidth = ve + "px", c.style.left = st + "px";
      } else {
        const B = k.right - Y.right, H = window.innerWidth - Q.right - B, ge = window.innerWidth - F.right - H, ve = F.width + ge, tt = Math.max(ve, k.width), rt = window.innerWidth - ye, st = or(H, [
          ye,
          Math.max(ye, rt - tt)
        ]);
        c.style.minWidth = ve + "px", c.style.right = st + "px";
      }
      const ce = E(), T = window.innerHeight - ye * 2, P = C.scrollHeight, L = window.getComputedStyle(_), W = parseInt(L.borderTopWidth, 10), K = parseInt(L.paddingTop, 10), X = parseInt(L.borderBottomWidth, 10), ie = parseInt(L.paddingBottom, 10), ue = W + K + P + ie + X, Se = Math.min(R.offsetHeight * 5, ue), Me = window.getComputedStyle(C), Le = parseInt(Me.paddingTop, 10), ze = parseInt(Me.paddingBottom, 10), be = F.top + F.height / 2 - ye, Be = T - be, we = R.offsetHeight / 2, N = R.offsetTop + we, $ = W + K + N, ne = ue - $;
      if ($ <= be) {
        const B = ce.length > 0 && R === ce[ce.length - 1].ref.current;
        c.style.bottom = "0px";
        const H = _.clientHeight - C.offsetTop - C.offsetHeight, ge = Math.max(
          Be,
          we + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (B ? ze : 0) + H + X
        ), ve = $ + ge;
        c.style.height = ve + "px";
      } else {
        const B = ce.length > 0 && R === ce[0].ref.current;
        c.style.top = "0px";
        const ge = Math.max(
          be,
          W + C.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (B ? Le : 0) + we
        ) + ne;
        c.style.height = ge + "px", C.scrollTop = $ - be + C.offsetTop;
      }
      c.style.margin = `${ye}px 0`, c.style.minHeight = Se + "px", c.style.maxHeight = T + "px", s == null || s(), requestAnimationFrame(() => O.current = !0);
    }
  }, [
    E,
    i.trigger,
    i.valueNode,
    c,
    _,
    C,
    R,
    M,
    i.dir,
    s
  ]);
  De(() => V(), [V]);
  const [z, x] = p.useState();
  De(() => {
    _ && x(window.getComputedStyle(_).zIndex);
  }, [_]);
  const w = p.useCallback(
    (F) => {
      F && D.current === !0 && (V(), y == null || y(), D.current = !1);
    },
    [V, y]
  );
  return /* @__PURE__ */ b.jsx(
    ho,
    {
      scope: t,
      contentWrapper: c,
      shouldExpandOnScrollRef: O,
      onScrollButtonChange: w,
      children: /* @__PURE__ */ b.jsx(
        "div",
        {
          ref: d,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: z
          },
          children: /* @__PURE__ */ b.jsx(
            me.div,
            {
              ...n,
              ref: g,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...n.style
              }
            }
          )
        }
      )
    }
  );
});
Mr.displayName = fo;
var po = "SelectPopperPosition", kt = p.forwardRef((e, r) => {
  const {
    __scopeSelect: t,
    align: s = "start",
    collisionPadding: n = ye,
    ...i
  } = e, l = gt(t);
  return /* @__PURE__ */ b.jsx(
    ws,
    {
      ...l,
      ...i,
      ref: r,
      align: s,
      collisionPadding: n,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...i.style,
        "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-select-content-available-width": "var(--radix-popper-available-width)",
        "--radix-select-content-available-height": "var(--radix-popper-available-height)",
        "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
kt.displayName = po;
var [ho, $t] = Ge(je, {}), Mt = "SelectViewport", Or = p.forwardRef(
  (e, r) => {
    const { __scopeSelect: t, nonce: s, ...n } = e, i = ke(Mt, t), l = $t(Mt, t), c = _e(r, i.onViewportChange), d = p.useRef(0);
    return /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
      /* @__PURE__ */ b.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
          },
          nonce: s
        }
      ),
      /* @__PURE__ */ b.jsx(mt.Slot, { scope: t, children: /* @__PURE__ */ b.jsx(
        me.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...n,
          ref: c,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...n.style
          },
          onScroll: oe(n.onScroll, (_) => {
            const m = _.currentTarget, { contentWrapper: g, shouldExpandOnScrollRef: E } = l;
            if (E != null && E.current && g) {
              const O = Math.abs(d.current - m.scrollTop);
              if (O > 0) {
                const D = window.innerHeight - ye * 2, C = parseFloat(g.style.minHeight), R = parseFloat(g.style.height), M = Math.max(C, R);
                if (M < D) {
                  const y = M + O, V = Math.min(D, y), z = y - V;
                  g.style.height = V + "px", g.style.bottom === "0px" && (m.scrollTop = z > 0 ? z : 0, g.style.justifyContent = "flex-end");
                }
              }
            }
            d.current = m.scrollTop;
          })
        }
      ) })
    ] });
  }
);
Or.displayName = Mt;
var jr = "SelectGroup", [mo, yo] = Ge(jr), Lr = p.forwardRef(
  (e, r) => {
    const { __scopeSelect: t, ...s } = e, n = Bt();
    return /* @__PURE__ */ b.jsx(mo, { scope: t, id: n, children: /* @__PURE__ */ b.jsx(me.div, { role: "group", "aria-labelledby": n, ...s, ref: r }) });
  }
);
Lr.displayName = jr;
var Br = "SelectLabel", Ur = p.forwardRef(
  (e, r) => {
    const { __scopeSelect: t, ...s } = e, n = yo(Br, t);
    return /* @__PURE__ */ b.jsx(me.div, { id: n.id, ...s, ref: r });
  }
);
Ur.displayName = Br;
var ft = "SelectItem", [go, Hr] = Ge(ft), Wr = p.forwardRef(
  (e, r) => {
    const {
      __scopeSelect: t,
      value: s,
      disabled: n = !1,
      textValue: i,
      ...l
    } = e, c = Pe(ft, t), d = ke(ft, t), _ = c.value === s, [m, g] = p.useState(i ?? ""), [E, O] = p.useState(!1), D = _e(
      r,
      (y) => {
        var V;
        return (V = d.itemRefCallback) == null ? void 0 : V.call(d, y, s, n);
      }
    ), C = Bt(), R = p.useRef("touch"), M = () => {
      n || (c.onValueChange(s), c.onOpenChange(!1));
    };
    if (s === "")
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    return /* @__PURE__ */ b.jsx(
      go,
      {
        scope: t,
        value: s,
        disabled: n,
        textId: C,
        isSelected: _,
        onItemTextChange: p.useCallback((y) => {
          g((V) => V || ((y == null ? void 0 : y.textContent) ?? "").trim());
        }, []),
        children: /* @__PURE__ */ b.jsx(
          mt.ItemSlot,
          {
            scope: t,
            value: s,
            disabled: n,
            textValue: m,
            children: /* @__PURE__ */ b.jsx(
              me.div,
              {
                role: "option",
                "aria-labelledby": C,
                "data-highlighted": E ? "" : void 0,
                "aria-selected": _ && E,
                "data-state": _ ? "checked" : "unchecked",
                "aria-disabled": n || void 0,
                "data-disabled": n ? "" : void 0,
                tabIndex: n ? void 0 : -1,
                ...l,
                ref: D,
                onFocus: oe(l.onFocus, () => O(!0)),
                onBlur: oe(l.onBlur, () => O(!1)),
                onClick: oe(l.onClick, () => {
                  R.current !== "mouse" && M();
                }),
                onPointerUp: oe(l.onPointerUp, () => {
                  R.current === "mouse" && M();
                }),
                onPointerDown: oe(l.onPointerDown, (y) => {
                  R.current = y.pointerType;
                }),
                onPointerMove: oe(l.onPointerMove, (y) => {
                  var V;
                  R.current = y.pointerType, n ? (V = d.onItemLeave) == null || V.call(d) : R.current === "mouse" && y.currentTarget.focus({ preventScroll: !0 });
                }),
                onPointerLeave: oe(l.onPointerLeave, (y) => {
                  var V;
                  y.currentTarget === document.activeElement && ((V = d.onItemLeave) == null || V.call(d));
                }),
                onKeyDown: oe(l.onKeyDown, (y) => {
                  var z;
                  ((z = d.searchRef) == null ? void 0 : z.current) !== "" && y.key === " " || (so.includes(y.key) && M(), y.key === " " && y.preventDefault());
                })
              }
            )
          }
        )
      }
    );
  }
);
Wr.displayName = ft;
var Xe = "SelectItemText", Kr = p.forwardRef(
  (e, r) => {
    const { __scopeSelect: t, className: s, style: n, ...i } = e, l = Pe(Xe, t), c = ke(Xe, t), d = Hr(Xe, t), _ = ao(Xe, t), [m, g] = p.useState(null), E = _e(
      r,
      (M) => g(M),
      d.onItemTextChange,
      (M) => {
        var y;
        return (y = c.itemTextRefCallback) == null ? void 0 : y.call(c, M, d.value, d.disabled);
      }
    ), O = m == null ? void 0 : m.textContent, D = p.useMemo(
      () => /* @__PURE__ */ b.jsx("option", { value: d.value, disabled: d.disabled, children: O }, d.value),
      [d.disabled, d.value, O]
    ), { onNativeOptionAdd: C, onNativeOptionRemove: R } = _;
    return De(() => (C(D), () => R(D)), [C, R, D]), /* @__PURE__ */ b.jsxs(b.Fragment, { children: [
      /* @__PURE__ */ b.jsx(me.span, { id: d.textId, ...i, ref: E }),
      d.isSelected && l.valueNode && !l.valueNodeHasChildren ? lr.createPortal(i.children, l.valueNode) : null
    ] });
  }
);
Kr.displayName = Xe;
var $r = "SelectItemIndicator", qr = p.forwardRef(
  (e, r) => {
    const { __scopeSelect: t, ...s } = e;
    return Hr($r, t).isSelected ? /* @__PURE__ */ b.jsx(me.span, { "aria-hidden": !0, ...s, ref: r }) : null;
  }
);
qr.displayName = $r;
var Ot = "SelectScrollUpButton", Gr = p.forwardRef((e, r) => {
  const t = ke(Ot, e.__scopeSelect), s = $t(Ot, e.__scopeSelect), [n, i] = p.useState(!1), l = _e(r, s.onScrollButtonChange);
  return De(() => {
    if (t.viewport && t.isPositioned) {
      let c = function() {
        const _ = d.scrollTop > 0;
        i(_);
      };
      const d = t.viewport;
      return c(), d.addEventListener("scroll", c), () => d.removeEventListener("scroll", c);
    }
  }, [t.viewport, t.isPositioned]), n ? /* @__PURE__ */ b.jsx(
    Yr,
    {
      ...e,
      ref: l,
      onAutoScroll: () => {
        const { viewport: c, selectedItem: d } = t;
        c && d && (c.scrollTop = c.scrollTop - d.offsetHeight);
      }
    }
  ) : null;
});
Gr.displayName = Ot;
var jt = "SelectScrollDownButton", zr = p.forwardRef((e, r) => {
  const t = ke(jt, e.__scopeSelect), s = $t(jt, e.__scopeSelect), [n, i] = p.useState(!1), l = _e(r, s.onScrollButtonChange);
  return De(() => {
    if (t.viewport && t.isPositioned) {
      let c = function() {
        const _ = d.scrollHeight - d.clientHeight, m = Math.ceil(d.scrollTop) < _;
        i(m);
      };
      const d = t.viewport;
      return c(), d.addEventListener("scroll", c), () => d.removeEventListener("scroll", c);
    }
  }, [t.viewport, t.isPositioned]), n ? /* @__PURE__ */ b.jsx(
    Yr,
    {
      ...e,
      ref: l,
      onAutoScroll: () => {
        const { viewport: c, selectedItem: d } = t;
        c && d && (c.scrollTop = c.scrollTop + d.offsetHeight);
      }
    }
  ) : null;
});
zr.displayName = jt;
var Yr = p.forwardRef((e, r) => {
  const { __scopeSelect: t, onAutoScroll: s, ...n } = e, i = ke("SelectScrollButton", t), l = p.useRef(null), c = yt(t), d = p.useCallback(() => {
    l.current !== null && (window.clearInterval(l.current), l.current = null);
  }, []);
  return p.useEffect(() => () => d(), [d]), De(() => {
    var m;
    const _ = c().find((g) => g.ref.current === document.activeElement);
    (m = _ == null ? void 0 : _.ref.current) == null || m.scrollIntoView({ block: "nearest" });
  }, [c]), /* @__PURE__ */ b.jsx(
    me.div,
    {
      "aria-hidden": !0,
      ...n,
      ref: r,
      style: { flexShrink: 0, ...n.style },
      onPointerDown: oe(n.onPointerDown, () => {
        l.current === null && (l.current = window.setInterval(s, 50));
      }),
      onPointerMove: oe(n.onPointerMove, () => {
        var _;
        (_ = i.onItemLeave) == null || _.call(i), l.current === null && (l.current = window.setInterval(s, 50));
      }),
      onPointerLeave: oe(n.onPointerLeave, () => {
        d();
      })
    }
  );
}), vo = "SelectSeparator", Xr = p.forwardRef(
  (e, r) => {
    const { __scopeSelect: t, ...s } = e;
    return /* @__PURE__ */ b.jsx(me.div, { "aria-hidden": !0, ...s, ref: r });
  }
);
Xr.displayName = vo;
var Lt = "SelectArrow", xo = p.forwardRef(
  (e, r) => {
    const { __scopeSelect: t, ...s } = e, n = gt(t), i = Pe(Lt, t), l = ke(Lt, t);
    return i.open && l.position === "popper" ? /* @__PURE__ */ b.jsx(Cs, { ...n, ...s, ref: r }) : null;
  }
);
xo.displayName = Lt;
function Zr(e) {
  return e === "" || e === void 0;
}
var Qr = p.forwardRef(
  (e, r) => {
    const { value: t, ...s } = e, n = p.useRef(null), i = _e(r, n), l = to(t);
    return p.useEffect(() => {
      const c = n.current, d = window.HTMLSelectElement.prototype, m = Object.getOwnPropertyDescriptor(
        d,
        "value"
      ).set;
      if (l !== t && m) {
        const g = new Event("change", { bubbles: !0 });
        m.call(c, t), c.dispatchEvent(g);
      }
    }, [l, t]), /* @__PURE__ */ b.jsx(As, { asChild: !0, children: /* @__PURE__ */ b.jsx("select", { ...s, ref: i, defaultValue: t }) });
  }
);
Qr.displayName = "BubbleSelect";
function Jr(e) {
  const r = Vs(e), t = p.useRef(""), s = p.useRef(0), n = p.useCallback(
    (l) => {
      const c = t.current + l;
      r(c), function d(_) {
        t.current = _, window.clearTimeout(s.current), _ !== "" && (s.current = window.setTimeout(() => d(""), 1e3));
      }(c);
    },
    [r]
  ), i = p.useCallback(() => {
    t.current = "", window.clearTimeout(s.current);
  }, []);
  return p.useEffect(() => () => window.clearTimeout(s.current), []), [t, n, i];
}
function es(e, r, t) {
  const n = r.length > 1 && Array.from(r).every((_) => _ === r[0]) ? r[0] : r, i = t ? e.indexOf(t) : -1;
  let l = _o(e, Math.max(i, 0));
  n.length === 1 && (l = l.filter((_) => _ !== t));
  const d = l.find(
    (_) => _.textValue.toLowerCase().startsWith(n.toLowerCase())
  );
  return d !== t ? d : void 0;
}
function _o(e, r) {
  return e.map((t, s) => e[(r + s) % e.length]);
}
var So = Vr, ts = Er, bo = Ir, wo = Rr, Co = Nr, rs = Dr, Ao = Or, Vo = Lr, ss = Ur, os = Wr, Fo = Kr, Eo = qr, ns = Gr, is = zr, as = Xr;
const zo = So, Yo = Vo, Xo = bo, To = p.forwardRef(({ className: e, children: r, ...t }, s) => /* @__PURE__ */ b.jsxs(
  ts,
  {
    ref: s,
    className: Ee(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
      e
    ),
    ...t,
    children: [
      /* @__PURE__ */ b.jsx("span", { className: "truncate", children: r }),
      /* @__PURE__ */ b.jsx(wo, { asChild: !0, children: /* @__PURE__ */ b.jsx(cr, { className: "flex-shrink-0 h-4 w-4 opacity-50" }) })
    ]
  }
));
To.displayName = ts.displayName;
const ls = p.forwardRef(({ className: e, ...r }, t) => /* @__PURE__ */ b.jsx(
  ns,
  {
    ref: t,
    className: Ee(
      "flex cursor-default items-center justify-center py-1",
      e
    ),
    ...r,
    children: /* @__PURE__ */ b.jsx(ks, { className: "h-4 w-4" })
  }
));
ls.displayName = ns.displayName;
const cs = p.forwardRef(({ className: e, ...r }, t) => /* @__PURE__ */ b.jsx(
  is,
  {
    ref: t,
    className: Ee(
      "flex cursor-default items-center justify-center py-1",
      e
    ),
    ...r,
    children: /* @__PURE__ */ b.jsx(cr, { className: "h-4 w-4" })
  }
));
cs.displayName = is.displayName;
const Io = p.forwardRef(({ className: e, children: r, position: t = "popper", ...s }, n) => /* @__PURE__ */ b.jsx(Co, { children: /* @__PURE__ */ b.jsxs(
  rs,
  {
    ref: n,
    className: Ee(
      "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      t === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
      e
    ),
    position: t,
    ...s,
    children: [
      /* @__PURE__ */ b.jsx(ls, {}),
      /* @__PURE__ */ b.jsx(
        Ao,
        {
          className: Ee(
            "p-1",
            t === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
          ),
          children: r
        }
      ),
      /* @__PURE__ */ b.jsx(cs, {})
    ]
  }
) }));
Io.displayName = rs.displayName;
const Ro = p.forwardRef(({ className: e, ...r }, t) => /* @__PURE__ */ b.jsx(
  ss,
  {
    ref: t,
    className: Ee("py-1.5 pl-8 pr-2 text-sm font-semibold", e),
    ...r
  }
));
Ro.displayName = ss.displayName;
const No = p.forwardRef(({ className: e, children: r, ...t }, s) => /* @__PURE__ */ b.jsxs(
  os,
  {
    ref: s,
    className: Ee(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      e
    ),
    ...t,
    children: [
      /* @__PURE__ */ b.jsx("span", { className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ b.jsx(Eo, { children: /* @__PURE__ */ b.jsx(Ms, { className: "h-4 w-4" }) }) }),
      /* @__PURE__ */ b.jsx(Fo, { children: r })
    ]
  }
));
No.displayName = os.displayName;
const Do = p.forwardRef(({ className: e, ...r }, t) => /* @__PURE__ */ b.jsx(
  as,
  {
    ref: t,
    className: Ee("-mx-1 my-1 h-px bg-muted", e),
    ...r
  }
));
Do.displayName = as.displayName;
const Po = p.forwardRef(
  ({ className: e, type: r, ...t }, s) => /* @__PURE__ */ b.jsx(
    "input",
    {
      type: r,
      className: Ee(
        "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
        e
      ),
      ref: s,
      ...t
    }
  )
);
Po.displayName = "Input";
export {
  Ko as C,
  Wo as F,
  Po as I,
  zo as S,
  Ho as a,
  To as b,
  Xo as c,
  Io as d,
  Yo as e,
  No as f,
  $o as g,
  pt as h,
  qo as u
};
//# sourceMappingURL=Input-CHfE_2Qk.js.map
