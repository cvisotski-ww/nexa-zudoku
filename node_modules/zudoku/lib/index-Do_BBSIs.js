var wt = (e) => {
  throw TypeError(e);
};
var He = (e, t, n) => t.has(e) || wt("Cannot " + n);
var L = (e, t, n) => (He(e, t, "read from private field"), n ? n.call(e) : t.get(e)), we = (e, t, n) => t.has(e) ? wt("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n), xe = (e, t, n, r) => (He(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n), q = (e, t, n) => (He(e, t, "access private method"), n);
import { j as R } from "./jsx-runtime-B6kdoens.js";
import { a as Nn, e as Dn } from "./Markdown-CWI6lU11.js";
import * as f from "react";
import ie, { useLayoutEffect as kn, useEffect as Fn, useState as In } from "react";
import { R as _n, y as Wn, n as Bn, u as jn } from "./ZudokuContext-BEmsYQoq.js";
import { u as $n } from "./state-CsuHT8ZO.js";
import * as Ht from "react-dom";
import Hn from "react-dom";
function Vn(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function Vt(...e) {
  return (t) => e.forEach((n) => Vn(n, t));
}
function ce(...e) {
  return f.useCallback(Vt(...e), e);
}
var be = f.forwardRef((e, t) => {
  const { children: n, ...r } = e, o = f.Children.toArray(n), i = o.find(Un);
  if (i) {
    const s = i.props.children, c = o.map((a) => a === i ? f.Children.count(s) > 1 ? f.Children.only(null) : f.isValidElement(s) ? s.props.children : null : a);
    return /* @__PURE__ */ R.jsx(Qe, { ...r, ref: t, children: f.isValidElement(s) ? f.cloneElement(s, void 0, c) : null });
  }
  return /* @__PURE__ */ R.jsx(Qe, { ...r, ref: t, children: n });
});
be.displayName = "Slot";
var Qe = f.forwardRef((e, t) => {
  const { children: n, ...r } = e;
  if (f.isValidElement(n)) {
    const o = Xn(n);
    return f.cloneElement(n, {
      ...Yn(r, n.props),
      // @ts-ignore
      ref: t ? Vt(t, o) : o
    });
  }
  return f.Children.count(n) > 1 ? f.Children.only(null) : null;
});
Qe.displayName = "SlotClone";
var zn = ({ children: e }) => /* @__PURE__ */ R.jsx(R.Fragment, { children: e });
function Un(e) {
  return f.isValidElement(e) && e.type === zn;
}
function Yn(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], i = t[r];
    /^on[A-Z]/.test(r) ? o && i ? n[r] = (...c) => {
      i(...c), o(...c);
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...i } : r === "className" && (n[r] = [o, i].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function Xn(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
const Kn = Dn(
  "not-prose inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        xl: "h-14 rounded-lg px-10 text-lg",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
), Gn = f.forwardRef(
  ({ className: e, variant: t, size: n, asChild: r = !1, ...o }, i) => {
    const s = r ? be : "button";
    return /* @__PURE__ */ R.jsx(
      s,
      {
        className: Nn(Kn({ variant: t, size: n, className: e })),
        ref: i,
        ...o
      }
    );
  }
);
Gn.displayName = "Button";
var H, F, se, V, Q, $t, xi = ($t = class extends _n {
  constructor(t) {
    super();
    we(this, V);
    we(this, H);
    we(this, F);
    we(this, se);
    this.mutationId = t.mutationId, xe(this, F, t.mutationCache), xe(this, H, []), this.state = t.state || Zn(), this.setOptions(t.options), this.scheduleGc();
  }
  setOptions(t) {
    this.options = t, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(t) {
    L(this, H).includes(t) || (L(this, H).push(t), this.clearGcTimeout(), L(this, F).notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }));
  }
  removeObserver(t) {
    xe(this, H, L(this, H).filter((n) => n !== t)), this.scheduleGc(), L(this, F).notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    });
  }
  optionalRemove() {
    L(this, H).length || (this.state.status === "pending" ? this.scheduleGc() : L(this, F).remove(this));
  }
  continue() {
    var t;
    return ((t = L(this, se)) == null ? void 0 : t.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(t) {
    var o, i, s, c, a, l, h, d, p, m, v, u, g, y, w, b, x, E, C, S;
    xe(this, se, Wn({
      fn: () => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")),
      onFail: (A, O) => {
        q(this, V, Q).call(this, { type: "failed", failureCount: A, error: O });
      },
      onPause: () => {
        q(this, V, Q).call(this, { type: "pause" });
      },
      onContinue: () => {
        q(this, V, Q).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => L(this, F).canRun(this)
    }));
    const n = this.state.status === "pending", r = !L(this, se).canStart();
    try {
      if (!n) {
        q(this, V, Q).call(this, { type: "pending", variables: t, isPaused: r }), await ((i = (o = L(this, F).config).onMutate) == null ? void 0 : i.call(
          o,
          t,
          this
        ));
        const O = await ((c = (s = this.options).onMutate) == null ? void 0 : c.call(s, t));
        O !== this.state.context && q(this, V, Q).call(this, {
          type: "pending",
          context: O,
          variables: t,
          isPaused: r
        });
      }
      const A = await L(this, se).start();
      return await ((l = (a = L(this, F).config).onSuccess) == null ? void 0 : l.call(
        a,
        A,
        t,
        this.state.context,
        this
      )), await ((d = (h = this.options).onSuccess) == null ? void 0 : d.call(h, A, t, this.state.context)), await ((m = (p = L(this, F).config).onSettled) == null ? void 0 : m.call(
        p,
        A,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((u = (v = this.options).onSettled) == null ? void 0 : u.call(v, A, null, t, this.state.context)), q(this, V, Q).call(this, { type: "success", data: A }), A;
    } catch (A) {
      try {
        throw await ((y = (g = L(this, F).config).onError) == null ? void 0 : y.call(
          g,
          A,
          t,
          this.state.context,
          this
        )), await ((b = (w = this.options).onError) == null ? void 0 : b.call(
          w,
          A,
          t,
          this.state.context
        )), await ((E = (x = L(this, F).config).onSettled) == null ? void 0 : E.call(
          x,
          void 0,
          A,
          this.state.variables,
          this.state.context,
          this
        )), await ((S = (C = this.options).onSettled) == null ? void 0 : S.call(
          C,
          void 0,
          A,
          t,
          this.state.context
        )), A;
      } finally {
        q(this, V, Q).call(this, { type: "error", error: A });
      }
    } finally {
      L(this, F).runNext(this);
    }
  }
}, H = new WeakMap(), F = new WeakMap(), se = new WeakMap(), V = new WeakSet(), Q = function(t) {
  const n = (r) => {
    switch (t.type) {
      case "failed":
        return {
          ...r,
          failureCount: t.failureCount,
          failureReason: t.error
        };
      case "pause":
        return {
          ...r,
          isPaused: !0
        };
      case "continue":
        return {
          ...r,
          isPaused: !1
        };
      case "pending":
        return {
          ...r,
          context: t.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: t.isPaused,
          status: "pending",
          variables: t.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...r,
          data: t.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: !1
        };
      case "error":
        return {
          ...r,
          data: void 0,
          error: t.error,
          failureCount: r.failureCount + 1,
          failureReason: t.error,
          isPaused: !1,
          status: "error"
        };
    }
  };
  this.state = n(this.state), Bn.batch(() => {
    L(this, H).forEach((r) => {
      r.onMutationUpdate(t);
    }), L(this, F).notify({
      mutation: this,
      type: "updated",
      action: t
    });
  });
}, $t);
function Zn() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: !1,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
const bi = () => {
  const { authentication: e } = jn(), t = $n(), n = typeof e < "u";
  return {
    isAuthEnabled: n,
    isPending: t.isPending,
    profile: t.profile,
    isAuthenticated: t.profile,
    login: async () => {
      if (!n)
        throw new Error("Authentication is not enabled.");
      await e.signIn();
    },
    logout: async () => {
      if (!n)
        throw new Error("Authentication is not enabled.");
      await e.signOut(), window.location.href = "/";
    }
  };
};
function Ve(e, t, { checkForDefaultPrevented: n = !0 } = {}) {
  return function(o) {
    if (e == null || e(o), n === !1 || !o.defaultPrevented)
      return t == null ? void 0 : t(o);
  };
}
function Ei(e, t) {
  const n = f.createContext(t), r = (i) => {
    const { children: s, ...c } = i, a = f.useMemo(() => c, Object.values(c));
    return /* @__PURE__ */ R.jsx(n.Provider, { value: a, children: s });
  };
  r.displayName = e + "Provider";
  function o(i) {
    const s = f.useContext(n);
    if (s) return s;
    if (t !== void 0) return t;
    throw new Error(`\`${i}\` must be used within \`${e}\``);
  }
  return [r, o];
}
function Ci(e, t = []) {
  let n = [];
  function r(i, s) {
    const c = f.createContext(s), a = n.length;
    n = [...n, s];
    const l = (d) => {
      var y;
      const { scope: p, children: m, ...v } = d, u = ((y = p == null ? void 0 : p[e]) == null ? void 0 : y[a]) || c, g = f.useMemo(() => v, Object.values(v));
      return /* @__PURE__ */ R.jsx(u.Provider, { value: g, children: m });
    };
    l.displayName = i + "Provider";
    function h(d, p) {
      var u;
      const m = ((u = p == null ? void 0 : p[e]) == null ? void 0 : u[a]) || c, v = f.useContext(m);
      if (v) return v;
      if (s !== void 0) return s;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return [l, h];
  }
  const o = () => {
    const i = n.map((s) => f.createContext(s));
    return function(c) {
      const a = (c == null ? void 0 : c[e]) || i;
      return f.useMemo(
        () => ({ [`__scope${e}`]: { ...c, [e]: a } }),
        [c, a]
      );
    };
  };
  return o.scopeName = e, [r, qn(o, ...t)];
}
function qn(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((o) => ({
      useScope: o(),
      scopeName: o.scopeName
    }));
    return function(i) {
      const s = r.reduce((c, { useScope: a, scopeName: l }) => {
        const d = a(i)[`__scope${l}`];
        return { ...c, ...d };
      }, {});
      return f.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function ee(e) {
  const t = f.useRef(e);
  return f.useEffect(() => {
    t.current = e;
  }), f.useMemo(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
function Si({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  }
}) {
  const [r, o] = Qn({ defaultProp: t, onChange: n }), i = e !== void 0, s = i ? e : r, c = ee(n), a = f.useCallback(
    (l) => {
      if (i) {
        const d = typeof l == "function" ? l(e) : l;
        d !== e && c(d);
      } else
        o(l);
    },
    [i, e, o, c]
  );
  return [s, a];
}
function Qn({
  defaultProp: e,
  onChange: t
}) {
  const n = f.useState(e), [r] = n, o = f.useRef(r), i = ee(t);
  return f.useEffect(() => {
    o.current !== r && (i(r), o.current = r);
  }, [r, o, i]), n;
}
var Jn = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], oe = Jn.reduce((e, t) => {
  const n = f.forwardRef((r, o) => {
    const { asChild: i, ...s } = r, c = i ? be : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ R.jsx(c, { ...s, ref: o });
  });
  return n.displayName = `Primitive.${t}`, { ...e, [t]: n };
}, {});
function er(e, t) {
  e && Ht.flushSync(() => e.dispatchEvent(t));
}
function zt(e, t = []) {
  let n = [];
  function r(i, s) {
    const c = f.createContext(s), a = n.length;
    n = [...n, s];
    function l(d) {
      const { scope: p, children: m, ...v } = d, u = (p == null ? void 0 : p[e][a]) || c, g = f.useMemo(() => v, Object.values(v));
      return /* @__PURE__ */ R.jsx(u.Provider, { value: g, children: m });
    }
    function h(d, p) {
      const m = (p == null ? void 0 : p[e][a]) || c, v = f.useContext(m);
      if (v) return v;
      if (s !== void 0) return s;
      throw new Error(`\`${d}\` must be used within \`${i}\``);
    }
    return l.displayName = i + "Provider", [l, h];
  }
  const o = () => {
    const i = n.map((s) => f.createContext(s));
    return function(c) {
      const a = (c == null ? void 0 : c[e]) || i;
      return f.useMemo(
        () => ({ [`__scope${e}`]: { ...c, [e]: a } }),
        [c, a]
      );
    };
  };
  return o.scopeName = e, [r, tr(o, ...t)];
}
function tr(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((o) => ({
      useScope: o(),
      scopeName: o.scopeName
    }));
    return function(i) {
      const s = r.reduce((c, { useScope: a, scopeName: l }) => {
        const d = a(i)[`__scope${l}`];
        return { ...c, ...d };
      }, {});
      return f.useMemo(() => ({ [`__scope${t.scopeName}`]: s }), [s]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function Ai(e) {
  const t = e + "CollectionProvider", [n, r] = zt(t), [o, i] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), s = (m) => {
    const { scope: v, children: u } = m, g = ie.useRef(null), y = ie.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ R.jsx(o, { scope: v, itemMap: y, collectionRef: g, children: u });
  };
  s.displayName = t;
  const c = e + "CollectionSlot", a = ie.forwardRef(
    (m, v) => {
      const { scope: u, children: g } = m, y = i(c, u), w = ce(v, y.collectionRef);
      return /* @__PURE__ */ R.jsx(be, { ref: w, children: g });
    }
  );
  a.displayName = c;
  const l = e + "CollectionItemSlot", h = "data-radix-collection-item", d = ie.forwardRef(
    (m, v) => {
      const { scope: u, children: g, ...y } = m, w = ie.useRef(null), b = ce(v, w), x = i(l, u);
      return ie.useEffect(() => (x.itemMap.set(w, { ref: w, ...y }), () => void x.itemMap.delete(w))), /* @__PURE__ */ R.jsx(be, { [h]: "", ref: b, children: g });
    }
  );
  d.displayName = l;
  function p(m) {
    const v = i(e + "CollectionConsumer", m);
    return ie.useCallback(() => {
      const g = v.collectionRef.current;
      if (!g) return [];
      const y = Array.from(g.querySelectorAll(`[${h}]`));
      return Array.from(v.itemMap.values()).sort(
        (x, E) => y.indexOf(x.ref.current) - y.indexOf(E.ref.current)
      );
    }, [v.collectionRef, v.itemMap]);
  }
  return [
    { Provider: s, Slot: a, ItemSlot: d },
    p,
    r
  ];
}
var nr = f.createContext(void 0);
function Pi(e) {
  const t = f.useContext(nr);
  return e || t || "ltr";
}
function rr(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = ee(e);
  f.useEffect(() => {
    const r = (o) => {
      o.key === "Escape" && n(o);
    };
    return t.addEventListener("keydown", r, { capture: !0 }), () => t.removeEventListener("keydown", r, { capture: !0 });
  }, [n, t]);
}
var or = "DismissableLayer", Je = "dismissableLayer.update", ir = "dismissableLayer.pointerDownOutside", sr = "dismissableLayer.focusOutside", xt, Ut = f.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), cr = f.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: o,
      onFocusOutside: i,
      onInteractOutside: s,
      onDismiss: c,
      ...a
    } = e, l = f.useContext(Ut), [h, d] = f.useState(null), p = (h == null ? void 0 : h.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, m] = f.useState({}), v = ce(t, (S) => d(S)), u = Array.from(l.layers), [g] = [...l.layersWithOutsidePointerEventsDisabled].slice(-1), y = u.indexOf(g), w = h ? u.indexOf(h) : -1, b = l.layersWithOutsidePointerEventsDisabled.size > 0, x = w >= y, E = ur((S) => {
      const A = S.target, O = [...l.branches].some((D) => D.contains(A));
      !x || O || (o == null || o(S), s == null || s(S), S.defaultPrevented || c == null || c());
    }, p), C = fr((S) => {
      const A = S.target;
      [...l.branches].some((D) => D.contains(A)) || (i == null || i(S), s == null || s(S), S.defaultPrevented || c == null || c());
    }, p);
    return rr((S) => {
      w === l.layers.size - 1 && (r == null || r(S), !S.defaultPrevented && c && (S.preventDefault(), c()));
    }, p), f.useEffect(() => {
      if (h)
        return n && (l.layersWithOutsidePointerEventsDisabled.size === 0 && (xt = p.body.style.pointerEvents, p.body.style.pointerEvents = "none"), l.layersWithOutsidePointerEventsDisabled.add(h)), l.layers.add(h), bt(), () => {
          n && l.layersWithOutsidePointerEventsDisabled.size === 1 && (p.body.style.pointerEvents = xt);
        };
    }, [h, p, n, l]), f.useEffect(() => () => {
      h && (l.layers.delete(h), l.layersWithOutsidePointerEventsDisabled.delete(h), bt());
    }, [h, l]), f.useEffect(() => {
      const S = () => m({});
      return document.addEventListener(Je, S), () => document.removeEventListener(Je, S);
    }, []), /* @__PURE__ */ R.jsx(
      oe.div,
      {
        ...a,
        ref: v,
        style: {
          pointerEvents: b ? x ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: Ve(e.onFocusCapture, C.onFocusCapture),
        onBlurCapture: Ve(e.onBlurCapture, C.onBlurCapture),
        onPointerDownCapture: Ve(
          e.onPointerDownCapture,
          E.onPointerDownCapture
        )
      }
    );
  }
);
cr.displayName = or;
var ar = "DismissableLayerBranch", lr = f.forwardRef((e, t) => {
  const n = f.useContext(Ut), r = f.useRef(null), o = ce(t, r);
  return f.useEffect(() => {
    const i = r.current;
    if (i)
      return n.branches.add(i), () => {
        n.branches.delete(i);
      };
  }, [n.branches]), /* @__PURE__ */ R.jsx(oe.div, { ...e, ref: o });
});
lr.displayName = ar;
function ur(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = ee(e), r = f.useRef(!1), o = f.useRef(() => {
  });
  return f.useEffect(() => {
    const i = (c) => {
      if (c.target && !r.current) {
        let a = function() {
          Yt(
            ir,
            n,
            l,
            { discrete: !0 }
          );
        };
        const l = { originalEvent: c };
        c.pointerType === "touch" ? (t.removeEventListener("click", o.current), o.current = a, t.addEventListener("click", o.current, { once: !0 })) : a();
      } else
        t.removeEventListener("click", o.current);
      r.current = !1;
    }, s = window.setTimeout(() => {
      t.addEventListener("pointerdown", i);
    }, 0);
    return () => {
      window.clearTimeout(s), t.removeEventListener("pointerdown", i), t.removeEventListener("click", o.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function fr(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = ee(e), r = f.useRef(!1);
  return f.useEffect(() => {
    const o = (i) => {
      i.target && !r.current && Yt(sr, n, { originalEvent: i }, {
        discrete: !1
      });
    };
    return t.addEventListener("focusin", o), () => t.removeEventListener("focusin", o);
  }, [t, n]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function bt() {
  const e = new CustomEvent(Je);
  document.dispatchEvent(e);
}
function Yt(e, t, n, { discrete: r }) {
  const o = n.originalEvent.target, i = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: n });
  t && o.addEventListener(e, t, { once: !0 }), r ? er(o, i) : o.dispatchEvent(i);
}
var ze = 0;
function Ri() {
  f.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? Et()), document.body.insertAdjacentElement("beforeend", e[1] ?? Et()), ze++, () => {
      ze === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), ze--;
    };
  }, []);
}
function Et() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var Ue = "focusScope.autoFocusOnMount", Ye = "focusScope.autoFocusOnUnmount", Ct = { bubbles: !1, cancelable: !0 }, dr = "FocusScope", hr = f.forwardRef((e, t) => {
  const {
    loop: n = !1,
    trapped: r = !1,
    onMountAutoFocus: o,
    onUnmountAutoFocus: i,
    ...s
  } = e, [c, a] = f.useState(null), l = ee(o), h = ee(i), d = f.useRef(null), p = ce(t, (u) => a(u)), m = f.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  f.useEffect(() => {
    if (r) {
      let u = function(b) {
        if (m.paused || !c) return;
        const x = b.target;
        c.contains(x) ? d.current = x : J(d.current, { select: !0 });
      }, g = function(b) {
        if (m.paused || !c) return;
        const x = b.relatedTarget;
        x !== null && (c.contains(x) || J(d.current, { select: !0 }));
      }, y = function(b) {
        if (document.activeElement === document.body)
          for (const E of b)
            E.removedNodes.length > 0 && J(c);
      };
      document.addEventListener("focusin", u), document.addEventListener("focusout", g);
      const w = new MutationObserver(y);
      return c && w.observe(c, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", u), document.removeEventListener("focusout", g), w.disconnect();
      };
    }
  }, [r, c, m.paused]), f.useEffect(() => {
    if (c) {
      At.add(m);
      const u = document.activeElement;
      if (!c.contains(u)) {
        const y = new CustomEvent(Ue, Ct);
        c.addEventListener(Ue, l), c.dispatchEvent(y), y.defaultPrevented || (mr(wr(Xt(c)), { select: !0 }), document.activeElement === u && J(c));
      }
      return () => {
        c.removeEventListener(Ue, l), setTimeout(() => {
          const y = new CustomEvent(Ye, Ct);
          c.addEventListener(Ye, h), c.dispatchEvent(y), y.defaultPrevented || J(u ?? document.body, { select: !0 }), c.removeEventListener(Ye, h), At.remove(m);
        }, 0);
      };
    }
  }, [c, l, h, m]);
  const v = f.useCallback(
    (u) => {
      if (!n && !r || m.paused) return;
      const g = u.key === "Tab" && !u.altKey && !u.ctrlKey && !u.metaKey, y = document.activeElement;
      if (g && y) {
        const w = u.currentTarget, [b, x] = pr(w);
        b && x ? !u.shiftKey && y === x ? (u.preventDefault(), n && J(b, { select: !0 })) : u.shiftKey && y === b && (u.preventDefault(), n && J(x, { select: !0 })) : y === w && u.preventDefault();
      }
    },
    [n, r, m.paused]
  );
  return /* @__PURE__ */ R.jsx(oe.div, { tabIndex: -1, ...s, ref: p, onKeyDown: v });
});
hr.displayName = dr;
function mr(e, { select: t = !1 } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (J(r, { select: t }), document.activeElement !== n) return;
}
function pr(e) {
  const t = Xt(e), n = St(t, e), r = St(t.reverse(), e);
  return [n, r];
}
function Xt(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function St(e, t) {
  for (const n of e)
    if (!vr(n, { upTo: t })) return n;
}
function vr(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return !0;
  for (; e; ) {
    if (t !== void 0 && e === t) return !1;
    if (getComputedStyle(e).display === "none") return !0;
    e = e.parentElement;
  }
  return !1;
}
function gr(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function J(e, { select: t = !1 } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: !0 }), e !== n && gr(e) && t && e.select();
  }
}
var At = yr();
function yr() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = Pt(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = Pt(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function Pt(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function wr(e) {
  return e.filter((t) => t.tagName !== "A");
}
var Ee = globalThis != null && globalThis.document ? f.useLayoutEffect : () => {
}, xr = f.useId || (() => {
}), br = 0;
function Oi(e) {
  const [t, n] = f.useState(xr());
  return Ee(() => {
    n((r) => r ?? String(br++));
  }, [e]), t ? `radix-${t}` : "";
}
const Er = ["top", "right", "bottom", "left"], te = Math.min, W = Math.max, Ie = Math.round, Oe = Math.floor, ne = (e) => ({
  x: e,
  y: e
}), Cr = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Sr = {
  start: "end",
  end: "start"
};
function et(e, t, n) {
  return W(e, te(t, n));
}
function K(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function G(e) {
  return e.split("-")[0];
}
function pe(e) {
  return e.split("-")[1];
}
function rt(e) {
  return e === "x" ? "y" : "x";
}
function ot(e) {
  return e === "y" ? "height" : "width";
}
function ve(e) {
  return ["top", "bottom"].includes(G(e)) ? "y" : "x";
}
function it(e) {
  return rt(ve(e));
}
function Ar(e, t, n) {
  n === void 0 && (n = !1);
  const r = pe(e), o = it(e), i = ot(o);
  let s = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[i] > t.floating[i] && (s = _e(s)), [s, _e(s)];
}
function Pr(e) {
  const t = _e(e);
  return [tt(e), t, tt(t)];
}
function tt(e) {
  return e.replace(/start|end/g, (t) => Sr[t]);
}
function Rr(e, t, n) {
  const r = ["left", "right"], o = ["right", "left"], i = ["top", "bottom"], s = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? o : r : t ? r : o;
    case "left":
    case "right":
      return t ? i : s;
    default:
      return [];
  }
}
function Or(e, t, n, r) {
  const o = pe(e);
  let i = Rr(G(e), n === "start", r);
  return o && (i = i.map((s) => s + "-" + o), t && (i = i.concat(i.map(tt)))), i;
}
function _e(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Cr[t]);
}
function Mr(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function Kt(e) {
  return typeof e != "number" ? Mr(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function We(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: o
  } = e;
  return {
    width: r,
    height: o,
    top: n,
    left: t,
    right: t + r,
    bottom: n + o,
    x: t,
    y: n
  };
}
function Rt(e, t, n) {
  let {
    reference: r,
    floating: o
  } = e;
  const i = ve(t), s = it(t), c = ot(s), a = G(t), l = i === "y", h = r.x + r.width / 2 - o.width / 2, d = r.y + r.height / 2 - o.height / 2, p = r[c] / 2 - o[c] / 2;
  let m;
  switch (a) {
    case "top":
      m = {
        x: h,
        y: r.y - o.height
      };
      break;
    case "bottom":
      m = {
        x: h,
        y: r.y + r.height
      };
      break;
    case "right":
      m = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      m = {
        x: r.x - o.width,
        y: d
      };
      break;
    default:
      m = {
        x: r.x,
        y: r.y
      };
  }
  switch (pe(t)) {
    case "start":
      m[s] -= p * (n && l ? -1 : 1);
      break;
    case "end":
      m[s] += p * (n && l ? -1 : 1);
      break;
  }
  return m;
}
const Tr = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: i = [],
    platform: s
  } = n, c = i.filter(Boolean), a = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let l = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: h,
    y: d
  } = Rt(l, r, a), p = r, m = {}, v = 0;
  for (let u = 0; u < c.length; u++) {
    const {
      name: g,
      fn: y
    } = c[u], {
      x: w,
      y: b,
      data: x,
      reset: E
    } = await y({
      x: h,
      y: d,
      initialPlacement: r,
      placement: p,
      strategy: o,
      middlewareData: m,
      rects: l,
      platform: s,
      elements: {
        reference: e,
        floating: t
      }
    });
    h = w ?? h, d = b ?? d, m = {
      ...m,
      [g]: {
        ...m[g],
        ...x
      }
    }, E && v <= 50 && (v++, typeof E == "object" && (E.placement && (p = E.placement), E.rects && (l = E.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }) : E.rects), {
      x: h,
      y: d
    } = Rt(l, p, a)), u = -1);
  }
  return {
    x: h,
    y: d,
    placement: p,
    strategy: o,
    middlewareData: m
  };
};
async function Ce(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: o,
    platform: i,
    rects: s,
    elements: c,
    strategy: a
  } = e, {
    boundary: l = "clippingAncestors",
    rootBoundary: h = "viewport",
    elementContext: d = "floating",
    altBoundary: p = !1,
    padding: m = 0
  } = K(t, e), v = Kt(m), g = c[p ? d === "floating" ? "reference" : "floating" : d], y = We(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(g))) == null || n ? g : g.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(c.floating)),
    boundary: l,
    rootBoundary: h,
    strategy: a
  })), w = d === "floating" ? {
    x: r,
    y: o,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, b = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(c.floating)), x = await (i.isElement == null ? void 0 : i.isElement(b)) ? await (i.getScale == null ? void 0 : i.getScale(b)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, E = We(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: c,
    rect: w,
    offsetParent: b,
    strategy: a
  }) : w);
  return {
    top: (y.top - E.top + v.top) / x.y,
    bottom: (E.bottom - y.bottom + v.bottom) / x.y,
    left: (y.left - E.left + v.left) / x.x,
    right: (E.right - y.right + v.right) / x.x
  };
}
const Lr = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: i,
      platform: s,
      elements: c,
      middlewareData: a
    } = t, {
      element: l,
      padding: h = 0
    } = K(e, t) || {};
    if (l == null)
      return {};
    const d = Kt(h), p = {
      x: n,
      y: r
    }, m = it(o), v = ot(m), u = await s.getDimensions(l), g = m === "y", y = g ? "top" : "left", w = g ? "bottom" : "right", b = g ? "clientHeight" : "clientWidth", x = i.reference[v] + i.reference[m] - p[m] - i.floating[v], E = p[m] - i.reference[m], C = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(l));
    let S = C ? C[b] : 0;
    (!S || !await (s.isElement == null ? void 0 : s.isElement(C))) && (S = c.floating[b] || i.floating[v]);
    const A = x / 2 - E / 2, O = S / 2 - u[v] / 2 - 1, D = te(d[y], O), j = te(d[w], O), T = D, I = S - u[v] - j, N = S / 2 - u[v] / 2 + A, M = et(T, N, I), k = !a.arrow && pe(o) != null && N !== M && i.reference[v] / 2 - (N < T ? D : j) - u[v] / 2 < 0, P = k ? N < T ? N - T : N - I : 0;
    return {
      [m]: p[m] + P,
      data: {
        [m]: M,
        centerOffset: N - M - P,
        ...k && {
          alignmentOffset: P
        }
      },
      reset: k
    };
  }
}), Nr = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        middlewareData: i,
        rects: s,
        initialPlacement: c,
        platform: a,
        elements: l
      } = t, {
        mainAxis: h = !0,
        crossAxis: d = !0,
        fallbackPlacements: p,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: v = "none",
        flipAlignment: u = !0,
        ...g
      } = K(e, t);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const y = G(o), w = G(c) === c, b = await (a.isRTL == null ? void 0 : a.isRTL(l.floating)), x = p || (w || !u ? [_e(c)] : Pr(c));
      !p && v !== "none" && x.push(...Or(c, u, v, b));
      const E = [c, ...x], C = await Ce(t, g), S = [];
      let A = ((r = i.flip) == null ? void 0 : r.overflows) || [];
      if (h && S.push(C[y]), d) {
        const T = Ar(o, s, b);
        S.push(C[T[0]], C[T[1]]);
      }
      if (A = [...A, {
        placement: o,
        overflows: S
      }], !S.every((T) => T <= 0)) {
        var O, D;
        const T = (((O = i.flip) == null ? void 0 : O.index) || 0) + 1, I = E[T];
        if (I)
          return {
            data: {
              index: T,
              overflows: A
            },
            reset: {
              placement: I
            }
          };
        let N = (D = A.filter((M) => M.overflows[0] <= 0).sort((M, k) => M.overflows[1] - k.overflows[1])[0]) == null ? void 0 : D.placement;
        if (!N)
          switch (m) {
            case "bestFit": {
              var j;
              const M = (j = A.map((k) => [k.placement, k.overflows.filter((P) => P > 0).reduce((P, _) => P + _, 0)]).sort((k, P) => k[1] - P[1])[0]) == null ? void 0 : j[0];
              M && (N = M);
              break;
            }
            case "initialPlacement":
              N = c;
              break;
          }
        if (o !== N)
          return {
            reset: {
              placement: N
            }
          };
      }
      return {};
    }
  };
};
function Ot(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function Mt(e) {
  return Er.some((t) => e[t] >= 0);
}
const Dr = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...o
      } = K(e, t);
      switch (r) {
        case "referenceHidden": {
          const i = await Ce(t, {
            ...o,
            elementContext: "reference"
          }), s = Ot(i, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s,
              referenceHidden: Mt(s)
            }
          };
        }
        case "escaped": {
          const i = await Ce(t, {
            ...o,
            altBoundary: !0
          }), s = Ot(i, n.floating);
          return {
            data: {
              escapedOffsets: s,
              escaped: Mt(s)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function kr(e, t) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = e, i = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), s = G(n), c = pe(n), a = ve(n) === "y", l = ["left", "top"].includes(s) ? -1 : 1, h = i && a ? -1 : 1, d = K(t, e);
  let {
    mainAxis: p,
    crossAxis: m,
    alignmentAxis: v
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...d
  };
  return c && typeof v == "number" && (m = c === "end" ? v * -1 : v), a ? {
    x: m * h,
    y: p * l
  } : {
    x: p * l,
    y: m * h
  };
}
const Fr = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: o,
        y: i,
        placement: s,
        middlewareData: c
      } = t, a = await kr(t, e);
      return s === ((n = c.offset) == null ? void 0 : n.placement) && (r = c.arrow) != null && r.alignmentOffset ? {} : {
        x: o + a.x,
        y: i + a.y,
        data: {
          ...a,
          placement: s
        }
      };
    }
  };
}, Ir = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o
      } = t, {
        mainAxis: i = !0,
        crossAxis: s = !1,
        limiter: c = {
          fn: (g) => {
            let {
              x: y,
              y: w
            } = g;
            return {
              x: y,
              y: w
            };
          }
        },
        ...a
      } = K(e, t), l = {
        x: n,
        y: r
      }, h = await Ce(t, a), d = ve(G(o)), p = rt(d);
      let m = l[p], v = l[d];
      if (i) {
        const g = p === "y" ? "top" : "left", y = p === "y" ? "bottom" : "right", w = m + h[g], b = m - h[y];
        m = et(w, m, b);
      }
      if (s) {
        const g = d === "y" ? "top" : "left", y = d === "y" ? "bottom" : "right", w = v + h[g], b = v - h[y];
        v = et(w, v, b);
      }
      const u = c.fn({
        ...t,
        [p]: m,
        [d]: v
      });
      return {
        ...u,
        data: {
          x: u.x - n,
          y: u.y - r
        }
      };
    }
  };
}, _r = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: o,
        rects: i,
        middlewareData: s
      } = t, {
        offset: c = 0,
        mainAxis: a = !0,
        crossAxis: l = !0
      } = K(e, t), h = {
        x: n,
        y: r
      }, d = ve(o), p = rt(d);
      let m = h[p], v = h[d];
      const u = K(c, t), g = typeof u == "number" ? {
        mainAxis: u,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...u
      };
      if (a) {
        const b = p === "y" ? "height" : "width", x = i.reference[p] - i.floating[b] + g.mainAxis, E = i.reference[p] + i.reference[b] - g.mainAxis;
        m < x ? m = x : m > E && (m = E);
      }
      if (l) {
        var y, w;
        const b = p === "y" ? "width" : "height", x = ["top", "left"].includes(G(o)), E = i.reference[d] - i.floating[b] + (x && ((y = s.offset) == null ? void 0 : y[d]) || 0) + (x ? 0 : g.crossAxis), C = i.reference[d] + i.reference[b] + (x ? 0 : ((w = s.offset) == null ? void 0 : w[d]) || 0) - (x ? g.crossAxis : 0);
        v < E ? v = E : v > C && (v = C);
      }
      return {
        [p]: m,
        [d]: v
      };
    }
  };
}, Wr = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      const {
        placement: n,
        rects: r,
        platform: o,
        elements: i
      } = t, {
        apply: s = () => {
        },
        ...c
      } = K(e, t), a = await Ce(t, c), l = G(n), h = pe(n), d = ve(n) === "y", {
        width: p,
        height: m
      } = r.floating;
      let v, u;
      l === "top" || l === "bottom" ? (v = l, u = h === (await (o.isRTL == null ? void 0 : o.isRTL(i.floating)) ? "start" : "end") ? "left" : "right") : (u = l, v = h === "end" ? "top" : "bottom");
      const g = m - a[v], y = p - a[u], w = !t.middlewareData.shift;
      let b = g, x = y;
      if (d) {
        const C = p - a.left - a.right;
        x = h || w ? te(y, C) : C;
      } else {
        const C = m - a.top - a.bottom;
        b = h || w ? te(g, C) : C;
      }
      if (w && !h) {
        const C = W(a.left, 0), S = W(a.right, 0), A = W(a.top, 0), O = W(a.bottom, 0);
        d ? x = p - 2 * (C !== 0 || S !== 0 ? C + S : W(a.left, a.right)) : b = m - 2 * (A !== 0 || O !== 0 ? A + O : W(a.top, a.bottom));
      }
      await s({
        ...t,
        availableWidth: x,
        availableHeight: b
      });
      const E = await o.getDimensions(i.floating);
      return p !== E.width || m !== E.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function ge(e) {
  return Gt(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function B(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Z(e) {
  var t;
  return (t = (Gt(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Gt(e) {
  return e instanceof Node || e instanceof B(e).Node;
}
function U(e) {
  return e instanceof Element || e instanceof B(e).Element;
}
function Y(e) {
  return e instanceof HTMLElement || e instanceof B(e).HTMLElement;
}
function Tt(e) {
  return typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof B(e).ShadowRoot;
}
function Ae(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: o
  } = $(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(o);
}
function Br(e) {
  return ["table", "td", "th"].includes(ge(e));
}
function st(e) {
  const t = ct(), n = $(e);
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function jr(e) {
  let t = re(e);
  for (; Y(t) && !me(t); ) {
    if (st(t))
      return t;
    t = re(t);
  }
  return null;
}
function ct() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function me(e) {
  return ["html", "body", "#document"].includes(ge(e));
}
function $(e) {
  return B(e).getComputedStyle(e);
}
function je(e) {
  return U(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
function re(e) {
  if (ge(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Tt(e) && e.host || // Fallback.
    Z(e)
  );
  return Tt(t) ? t.host : t;
}
function Zt(e) {
  const t = re(e);
  return me(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Y(t) && Ae(t) ? t : Zt(t);
}
function Se(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const o = Zt(e), i = o === ((r = e.ownerDocument) == null ? void 0 : r.body), s = B(o);
  return i ? t.concat(s, s.visualViewport || [], Ae(o) ? o : [], s.frameElement && n ? Se(s.frameElement) : []) : t.concat(o, Se(o, [], n));
}
function qt(e) {
  const t = $(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const o = Y(e), i = o ? e.offsetWidth : n, s = o ? e.offsetHeight : r, c = Ie(n) !== i || Ie(r) !== s;
  return c && (n = i, r = s), {
    width: n,
    height: r,
    $: c
  };
}
function at(e) {
  return U(e) ? e : e.contextElement;
}
function de(e) {
  const t = at(e);
  if (!Y(t))
    return ne(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: o,
    $: i
  } = qt(t);
  let s = (i ? Ie(n.width) : n.width) / r, c = (i ? Ie(n.height) : n.height) / o;
  return (!s || !Number.isFinite(s)) && (s = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: s,
    y: c
  };
}
const $r = /* @__PURE__ */ ne(0);
function Qt(e) {
  const t = B(e);
  return !ct() || !t.visualViewport ? $r : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Hr(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== B(e) ? !1 : t;
}
function ae(e, t, n, r) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const o = e.getBoundingClientRect(), i = at(e);
  let s = ne(1);
  t && (r ? U(r) && (s = de(r)) : s = de(e));
  const c = Hr(i, n, r) ? Qt(i) : ne(0);
  let a = (o.left + c.x) / s.x, l = (o.top + c.y) / s.y, h = o.width / s.x, d = o.height / s.y;
  if (i) {
    const p = B(i), m = r && U(r) ? B(r) : r;
    let v = p, u = v.frameElement;
    for (; u && r && m !== v; ) {
      const g = de(u), y = u.getBoundingClientRect(), w = $(u), b = y.left + (u.clientLeft + parseFloat(w.paddingLeft)) * g.x, x = y.top + (u.clientTop + parseFloat(w.paddingTop)) * g.y;
      a *= g.x, l *= g.y, h *= g.x, d *= g.y, a += b, l += x, v = B(u), u = v.frameElement;
    }
  }
  return We({
    width: h,
    height: d,
    x: a,
    y: l
  });
}
const Vr = [":popover-open", ":modal"];
function lt(e) {
  return Vr.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
function zr(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: o
  } = e;
  const i = o === "fixed", s = Z(r), c = t ? lt(t.floating) : !1;
  if (r === s || c && i)
    return n;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = ne(1);
  const h = ne(0), d = Y(r);
  if ((d || !d && !i) && ((ge(r) !== "body" || Ae(s)) && (a = je(r)), Y(r))) {
    const p = ae(r);
    l = de(r), h.x = p.x + r.clientLeft, h.y = p.y + r.clientTop;
  }
  return {
    width: n.width * l.x,
    height: n.height * l.y,
    x: n.x * l.x - a.scrollLeft * l.x + h.x,
    y: n.y * l.y - a.scrollTop * l.y + h.y
  };
}
function Ur(e) {
  return Array.from(e.getClientRects());
}
function Jt(e) {
  return ae(Z(e)).left + je(e).scrollLeft;
}
function Yr(e) {
  const t = Z(e), n = je(e), r = e.ownerDocument.body, o = W(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), i = W(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s = -n.scrollLeft + Jt(e);
  const c = -n.scrollTop;
  return $(r).direction === "rtl" && (s += W(t.clientWidth, r.clientWidth) - o), {
    width: o,
    height: i,
    x: s,
    y: c
  };
}
function Xr(e, t) {
  const n = B(e), r = Z(e), o = n.visualViewport;
  let i = r.clientWidth, s = r.clientHeight, c = 0, a = 0;
  if (o) {
    i = o.width, s = o.height;
    const l = ct();
    (!l || l && t === "fixed") && (c = o.offsetLeft, a = o.offsetTop);
  }
  return {
    width: i,
    height: s,
    x: c,
    y: a
  };
}
function Kr(e, t) {
  const n = ae(e, !0, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, i = Y(e) ? de(e) : ne(1), s = e.clientWidth * i.x, c = e.clientHeight * i.y, a = o * i.x, l = r * i.y;
  return {
    width: s,
    height: c,
    x: a,
    y: l
  };
}
function Lt(e, t, n) {
  let r;
  if (t === "viewport")
    r = Xr(e, n);
  else if (t === "document")
    r = Yr(Z(e));
  else if (U(t))
    r = Kr(t, n);
  else {
    const o = Qt(e);
    r = {
      ...t,
      x: t.x - o.x,
      y: t.y - o.y
    };
  }
  return We(r);
}
function en(e, t) {
  const n = re(e);
  return n === t || !U(n) || me(n) ? !1 : $(n).position === "fixed" || en(n, t);
}
function Gr(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = Se(e, [], !1).filter((c) => U(c) && ge(c) !== "body"), o = null;
  const i = $(e).position === "fixed";
  let s = i ? re(e) : e;
  for (; U(s) && !me(s); ) {
    const c = $(s), a = st(s);
    !a && c.position === "fixed" && (o = null), (i ? !a && !o : !a && c.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || Ae(s) && !a && en(e, s)) ? r = r.filter((h) => h !== s) : o = c, s = re(s);
  }
  return t.set(e, r), r;
}
function Zr(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = e;
  const s = [...n === "clippingAncestors" ? lt(t) ? [] : Gr(t, this._c) : [].concat(n), r], c = s[0], a = s.reduce((l, h) => {
    const d = Lt(t, h, o);
    return l.top = W(d.top, l.top), l.right = te(d.right, l.right), l.bottom = te(d.bottom, l.bottom), l.left = W(d.left, l.left), l;
  }, Lt(t, c, o));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function qr(e) {
  const {
    width: t,
    height: n
  } = qt(e);
  return {
    width: t,
    height: n
  };
}
function Qr(e, t, n) {
  const r = Y(t), o = Z(t), i = n === "fixed", s = ae(e, !0, i, t);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = ne(0);
  if (r || !r && !i)
    if ((ge(t) !== "body" || Ae(o)) && (c = je(t)), r) {
      const d = ae(t, !0, i, t);
      a.x = d.x + t.clientLeft, a.y = d.y + t.clientTop;
    } else o && (a.x = Jt(o));
  const l = s.left + c.scrollLeft - a.x, h = s.top + c.scrollTop - a.y;
  return {
    x: l,
    y: h,
    width: s.width,
    height: s.height
  };
}
function Xe(e) {
  return $(e).position === "static";
}
function Nt(e, t) {
  return !Y(e) || $(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
function tn(e, t) {
  const n = B(e);
  if (lt(e))
    return n;
  if (!Y(e)) {
    let o = re(e);
    for (; o && !me(o); ) {
      if (U(o) && !Xe(o))
        return o;
      o = re(o);
    }
    return n;
  }
  let r = Nt(e, t);
  for (; r && Br(r) && Xe(r); )
    r = Nt(r, t);
  return r && me(r) && Xe(r) && !st(r) ? n : r || jr(e) || n;
}
const Jr = async function(e) {
  const t = this.getOffsetParent || tn, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: Qr(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function eo(e) {
  return $(e).direction === "rtl";
}
const to = {
  convertOffsetParentRelativeRectToViewportRelativeRect: zr,
  getDocumentElement: Z,
  getClippingRect: Zr,
  getOffsetParent: tn,
  getElementRects: Jr,
  getClientRects: Ur,
  getDimensions: qr,
  getScale: de,
  isElement: U,
  isRTL: eo
};
function no(e, t) {
  let n = null, r;
  const o = Z(e);
  function i() {
    var c;
    clearTimeout(r), (c = n) == null || c.disconnect(), n = null;
  }
  function s(c, a) {
    c === void 0 && (c = !1), a === void 0 && (a = 1), i();
    const {
      left: l,
      top: h,
      width: d,
      height: p
    } = e.getBoundingClientRect();
    if (c || t(), !d || !p)
      return;
    const m = Oe(h), v = Oe(o.clientWidth - (l + d)), u = Oe(o.clientHeight - (h + p)), g = Oe(l), w = {
      rootMargin: -m + "px " + -v + "px " + -u + "px " + -g + "px",
      threshold: W(0, te(1, a)) || 1
    };
    let b = !0;
    function x(E) {
      const C = E[0].intersectionRatio;
      if (C !== a) {
        if (!b)
          return s();
        C ? s(!1, C) : r = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      b = !1;
    }
    try {
      n = new IntersectionObserver(x, {
        ...w,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(x, w);
    }
    n.observe(e);
  }
  return s(!0), i;
}
function ro(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = !0,
    ancestorResize: i = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: a = !1
  } = r, l = at(e), h = o || i ? [...l ? Se(l) : [], ...Se(t)] : [];
  h.forEach((y) => {
    o && y.addEventListener("scroll", n, {
      passive: !0
    }), i && y.addEventListener("resize", n);
  });
  const d = l && c ? no(l, n) : null;
  let p = -1, m = null;
  s && (m = new ResizeObserver((y) => {
    let [w] = y;
    w && w.target === l && m && (m.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var b;
      (b = m) == null || b.observe(t);
    })), n();
  }), l && !a && m.observe(l), m.observe(t));
  let v, u = a ? ae(e) : null;
  a && g();
  function g() {
    const y = ae(e);
    u && (y.x !== u.x || y.y !== u.y || y.width !== u.width || y.height !== u.height) && n(), u = y, v = requestAnimationFrame(g);
  }
  return n(), () => {
    var y;
    h.forEach((w) => {
      o && w.removeEventListener("scroll", n), i && w.removeEventListener("resize", n);
    }), d == null || d(), (y = m) == null || y.disconnect(), m = null, a && cancelAnimationFrame(v);
  };
}
const oo = Fr, io = Ir, so = Nr, co = Wr, ao = Dr, Dt = Lr, lo = _r, uo = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: to,
    ...n
  }, i = {
    ...o.platform,
    _c: r
  };
  return Tr(e, t, {
    ...o,
    platform: i
  });
}, fo = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: o
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? Dt({
        element: r.current,
        padding: o
      }).fn(n) : {} : r ? Dt({
        element: r,
        padding: o
      }).fn(n) : {};
    }
  };
};
var De = typeof document < "u" ? kn : Fn;
function Be(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, r, o;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (r = n; r-- !== 0; )
        if (!Be(e[r], t[r]))
          return !1;
      return !0;
    }
    if (o = Object.keys(e), n = o.length, n !== Object.keys(t).length)
      return !1;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, o[r]))
        return !1;
    for (r = n; r-- !== 0; ) {
      const i = o[r];
      if (!(i === "_owner" && e.$$typeof) && !Be(e[i], t[i]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function nn(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function kt(e, t) {
  const n = nn(e);
  return Math.round(t * n) / n;
}
function Ft(e) {
  const t = f.useRef(e);
  return De(() => {
    t.current = e;
  }), t;
}
function ho(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o,
    elements: {
      reference: i,
      floating: s
    } = {},
    transform: c = !0,
    whileElementsMounted: a,
    open: l
  } = e, [h, d] = f.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [p, m] = f.useState(r);
  Be(p, r) || m(r);
  const [v, u] = f.useState(null), [g, y] = f.useState(null), w = f.useCallback((P) => {
    P !== C.current && (C.current = P, u(P));
  }, []), b = f.useCallback((P) => {
    P !== S.current && (S.current = P, y(P));
  }, []), x = i || v, E = s || g, C = f.useRef(null), S = f.useRef(null), A = f.useRef(h), O = a != null, D = Ft(a), j = Ft(o), T = f.useCallback(() => {
    if (!C.current || !S.current)
      return;
    const P = {
      placement: t,
      strategy: n,
      middleware: p
    };
    j.current && (P.platform = j.current), uo(C.current, S.current, P).then((_) => {
      const X = {
        ..._,
        isPositioned: !0
      };
      I.current && !Be(A.current, X) && (A.current = X, Ht.flushSync(() => {
        d(X);
      }));
    });
  }, [p, t, n, j]);
  De(() => {
    l === !1 && A.current.isPositioned && (A.current.isPositioned = !1, d((P) => ({
      ...P,
      isPositioned: !1
    })));
  }, [l]);
  const I = f.useRef(!1);
  De(() => (I.current = !0, () => {
    I.current = !1;
  }), []), De(() => {
    if (x && (C.current = x), E && (S.current = E), x && E) {
      if (D.current)
        return D.current(x, E, T);
      T();
    }
  }, [x, E, T, D, O]);
  const N = f.useMemo(() => ({
    reference: C,
    floating: S,
    setReference: w,
    setFloating: b
  }), [w, b]), M = f.useMemo(() => ({
    reference: x,
    floating: E
  }), [x, E]), k = f.useMemo(() => {
    const P = {
      position: n,
      left: 0,
      top: 0
    };
    if (!M.floating)
      return P;
    const _ = kt(M.floating, h.x), X = kt(M.floating, h.y);
    return c ? {
      ...P,
      transform: "translate(" + _ + "px, " + X + "px)",
      ...nn(M.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: _,
      top: X
    };
  }, [n, c, M.floating, h.x, h.y]);
  return f.useMemo(() => ({
    ...h,
    update: T,
    refs: N,
    elements: M,
    floatingStyles: k
  }), [h, T, N, M, k]);
}
var mo = "Arrow", rn = f.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: o = 5, ...i } = e;
  return /* @__PURE__ */ R.jsx(
    oe.svg,
    {
      ...i,
      ref: t,
      width: r,
      height: o,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : /* @__PURE__ */ R.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
rn.displayName = mo;
var po = rn;
function vo(e) {
  const [t, n] = f.useState(void 0);
  return Ee(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((o) => {
        if (!Array.isArray(o) || !o.length)
          return;
        const i = o[0];
        let s, c;
        if ("borderBoxSize" in i) {
          const a = i.borderBoxSize, l = Array.isArray(a) ? a[0] : a;
          s = l.inlineSize, c = l.blockSize;
        } else
          s = e.offsetWidth, c = e.offsetHeight;
        n({ width: s, height: c });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var ut = "Popper", [on, Mi] = zt(ut), [go, sn] = on(ut), cn = (e) => {
  const { __scopePopper: t, children: n } = e, [r, o] = f.useState(null);
  return /* @__PURE__ */ R.jsx(go, { scope: t, anchor: r, onAnchorChange: o, children: n });
};
cn.displayName = ut;
var an = "PopperAnchor", ln = f.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...o } = e, i = sn(an, n), s = f.useRef(null), c = ce(t, s);
    return f.useEffect(() => {
      i.onAnchorChange((r == null ? void 0 : r.current) || s.current);
    }), r ? null : /* @__PURE__ */ R.jsx(oe.div, { ...o, ref: c });
  }
);
ln.displayName = an;
var ft = "PopperContent", [yo, wo] = on(ft), un = f.forwardRef(
  (e, t) => {
    var dt, ht, mt, pt, vt, gt;
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: o = 0,
      align: i = "center",
      alignOffset: s = 0,
      arrowPadding: c = 0,
      avoidCollisions: a = !0,
      collisionBoundary: l = [],
      collisionPadding: h = 0,
      sticky: d = "partial",
      hideWhenDetached: p = !1,
      updatePositionStrategy: m = "optimized",
      onPlaced: v,
      ...u
    } = e, g = sn(ft, n), [y, w] = f.useState(null), b = ce(t, (ye) => w(ye)), [x, E] = f.useState(null), C = vo(x), S = (C == null ? void 0 : C.width) ?? 0, A = (C == null ? void 0 : C.height) ?? 0, O = r + (i !== "center" ? "-" + i : ""), D = typeof h == "number" ? h : { top: 0, right: 0, bottom: 0, left: 0, ...h }, j = Array.isArray(l) ? l : [l], T = j.length > 0, I = {
      padding: D,
      boundary: j.filter(bo),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: T
    }, { refs: N, floatingStyles: M, placement: k, isPositioned: P, middlewareData: _ } = ho({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: O,
      whileElementsMounted: (...ye) => ro(...ye, {
        animationFrame: m === "always"
      }),
      elements: {
        reference: g.anchor
      },
      middleware: [
        oo({ mainAxis: o + A, alignmentAxis: s }),
        a && io({
          mainAxis: !0,
          crossAxis: !1,
          limiter: d === "partial" ? lo() : void 0,
          ...I
        }),
        a && so({ ...I }),
        co({
          ...I,
          apply: ({ elements: ye, rects: yt, availableWidth: On, availableHeight: Mn }) => {
            const { width: Tn, height: Ln } = yt.reference, Re = ye.floating.style;
            Re.setProperty("--radix-popper-available-width", `${On}px`), Re.setProperty("--radix-popper-available-height", `${Mn}px`), Re.setProperty("--radix-popper-anchor-width", `${Tn}px`), Re.setProperty("--radix-popper-anchor-height", `${Ln}px`);
          }
        }),
        x && fo({ element: x, padding: c }),
        Eo({ arrowWidth: S, arrowHeight: A }),
        p && ao({ strategy: "referenceHidden", ...I })
      ]
    }), [X, En] = hn(k), Pe = ee(v);
    Ee(() => {
      P && (Pe == null || Pe());
    }, [P, Pe]);
    const Cn = (dt = _.arrow) == null ? void 0 : dt.x, Sn = (ht = _.arrow) == null ? void 0 : ht.y, An = ((mt = _.arrow) == null ? void 0 : mt.centerOffset) !== 0, [Pn, Rn] = f.useState();
    return Ee(() => {
      y && Rn(window.getComputedStyle(y).zIndex);
    }, [y]), /* @__PURE__ */ R.jsx(
      "div",
      {
        ref: N.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...M,
          transform: P ? M.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: Pn,
          "--radix-popper-transform-origin": [
            (pt = _.transformOrigin) == null ? void 0 : pt.x,
            (vt = _.transformOrigin) == null ? void 0 : vt.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((gt = _.hide) == null ? void 0 : gt.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: /* @__PURE__ */ R.jsx(
          yo,
          {
            scope: n,
            placedSide: X,
            onArrowChange: E,
            arrowX: Cn,
            arrowY: Sn,
            shouldHideArrow: An,
            children: /* @__PURE__ */ R.jsx(
              oe.div,
              {
                "data-side": X,
                "data-align": En,
                ...u,
                ref: b,
                style: {
                  ...u.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: P ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
un.displayName = ft;
var fn = "PopperArrow", xo = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, dn = f.forwardRef(function(t, n) {
  const { __scopePopper: r, ...o } = t, i = wo(fn, r), s = xo[i.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ R.jsx(
      "span",
      {
        ref: i.onArrowChange,
        style: {
          position: "absolute",
          left: i.arrowX,
          top: i.arrowY,
          [s]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[i.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[i.placedSide],
          visibility: i.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ R.jsx(
          po,
          {
            ...o,
            ref: n,
            style: {
              ...o.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
dn.displayName = fn;
function bo(e) {
  return e !== null;
}
var Eo = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var g, y, w;
    const { placement: n, rects: r, middlewareData: o } = t, s = ((g = o.arrow) == null ? void 0 : g.centerOffset) !== 0, c = s ? 0 : e.arrowWidth, a = s ? 0 : e.arrowHeight, [l, h] = hn(n), d = { start: "0%", center: "50%", end: "100%" }[h], p = (((y = o.arrow) == null ? void 0 : y.x) ?? 0) + c / 2, m = (((w = o.arrow) == null ? void 0 : w.y) ?? 0) + a / 2;
    let v = "", u = "";
    return l === "bottom" ? (v = s ? d : `${p}px`, u = `${-a}px`) : l === "top" ? (v = s ? d : `${p}px`, u = `${r.floating.height + a}px`) : l === "right" ? (v = `${-a}px`, u = s ? d : `${m}px`) : l === "left" && (v = `${r.floating.width + a}px`, u = s ? d : `${m}px`), { data: { x: v, y: u } };
  }
});
function hn(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var Ti = cn, Li = ln, Ni = un, Di = dn, Co = "Portal", So = f.forwardRef((e, t) => {
  var c;
  const { container: n, ...r } = e, [o, i] = f.useState(!1);
  Ee(() => i(!0), []);
  const s = n || o && ((c = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : c.body);
  return s ? Hn.createPortal(/* @__PURE__ */ R.jsx(oe.div, { ...r, ref: t }), s) : null;
});
So.displayName = Co;
var Ao = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
}, le = /* @__PURE__ */ new WeakMap(), Me = /* @__PURE__ */ new WeakMap(), Te = {}, Ke = 0, mn = function(e) {
  return e && (e.host || mn(e.parentNode));
}, Po = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = mn(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
}, Ro = function(e, t, n, r) {
  var o = Po(t, Array.isArray(e) ? e : [e]);
  Te[n] || (Te[n] = /* @__PURE__ */ new WeakMap());
  var i = Te[n], s = [], c = /* @__PURE__ */ new Set(), a = new Set(o), l = function(d) {
    !d || c.has(d) || (c.add(d), l(d.parentNode));
  };
  o.forEach(l);
  var h = function(d) {
    !d || a.has(d) || Array.prototype.forEach.call(d.children, function(p) {
      if (c.has(p))
        h(p);
      else
        try {
          var m = p.getAttribute(r), v = m !== null && m !== "false", u = (le.get(p) || 0) + 1, g = (i.get(p) || 0) + 1;
          le.set(p, u), i.set(p, g), s.push(p), u === 1 && v && Me.set(p, !0), g === 1 && p.setAttribute(n, "true"), v || p.setAttribute(r, "true");
        } catch (y) {
          console.error("aria-hidden: cannot operate on ", p, y);
        }
    });
  };
  return h(t), c.clear(), Ke++, function() {
    s.forEach(function(d) {
      var p = le.get(d) - 1, m = i.get(d) - 1;
      le.set(d, p), i.set(d, m), p || (Me.has(d) || d.removeAttribute(r), Me.delete(d)), m || d.removeAttribute(n);
    }), Ke--, Ke || (le = /* @__PURE__ */ new WeakMap(), le = /* @__PURE__ */ new WeakMap(), Me = /* @__PURE__ */ new WeakMap(), Te = {});
  };
}, ki = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), o = Ao(e);
  return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live]"))), Ro(r, o, n, "aria-hidden")) : function() {
    return null;
  };
}, z = function() {
  return z = Object.assign || function(t) {
    for (var n, r = 1, o = arguments.length; r < o; r++) {
      n = arguments[r];
      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  }, z.apply(this, arguments);
};
function pn(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function Oo(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, o = t.length, i; r < o; r++)
    (i || !(r in t)) && (i || (i = Array.prototype.slice.call(t, 0, r)), i[r] = t[r]);
  return e.concat(i || Array.prototype.slice.call(t));
}
var ke = "right-scroll-bar-position", Fe = "width-before-scroll-bar", Mo = "with-scroll-bars-hidden", To = "--removed-body-scroll-bar-size";
function Ge(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function Lo(e, t) {
  var n = In(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var o = n.value;
          o !== r && (n.value = r, n.callback(r, o));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var No = typeof window < "u" ? f.useLayoutEffect : f.useEffect, It = /* @__PURE__ */ new WeakMap();
function Do(e, t) {
  var n = Lo(null, function(r) {
    return e.forEach(function(o) {
      return Ge(o, r);
    });
  });
  return No(function() {
    var r = It.get(n);
    if (r) {
      var o = new Set(r), i = new Set(e), s = n.current;
      o.forEach(function(c) {
        i.has(c) || Ge(c, null);
      }), i.forEach(function(c) {
        o.has(c) || Ge(c, s);
      });
    }
    It.set(n, e);
  }, [e]), n;
}
function ko(e) {
  return e;
}
function Fo(e, t) {
  t === void 0 && (t = ko);
  var n = [], r = !1, o = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(i) {
      var s = t(i, r);
      return n.push(s), function() {
        n = n.filter(function(c) {
          return c !== s;
        });
      };
    },
    assignSyncMedium: function(i) {
      for (r = !0; n.length; ) {
        var s = n;
        n = [], s.forEach(i);
      }
      n = {
        push: function(c) {
          return i(c);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(i) {
      r = !0;
      var s = [];
      if (n.length) {
        var c = n;
        n = [], c.forEach(i), s = n;
      }
      var a = function() {
        var h = s;
        s = [], h.forEach(i);
      }, l = function() {
        return Promise.resolve().then(a);
      };
      l(), n = {
        push: function(h) {
          s.push(h), l();
        },
        filter: function(h) {
          return s = s.filter(h), n;
        }
      };
    }
  };
  return o;
}
function Io(e) {
  e === void 0 && (e = {});
  var t = Fo(null);
  return t.options = z({ async: !0, ssr: !1 }, e), t;
}
var vn = function(e) {
  var t = e.sideCar, n = pn(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return f.createElement(r, z({}, n));
};
vn.isSideCarExport = !0;
function _o(e, t) {
  return e.useMedium(t), vn;
}
var gn = Io(), Ze = function() {
}, $e = f.forwardRef(function(e, t) {
  var n = f.useRef(null), r = f.useState({
    onScrollCapture: Ze,
    onWheelCapture: Ze,
    onTouchMoveCapture: Ze
  }), o = r[0], i = r[1], s = e.forwardProps, c = e.children, a = e.className, l = e.removeScrollBar, h = e.enabled, d = e.shards, p = e.sideCar, m = e.noIsolation, v = e.inert, u = e.allowPinchZoom, g = e.as, y = g === void 0 ? "div" : g, w = e.gapMode, b = pn(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), x = p, E = Do([n, t]), C = z(z({}, b), o);
  return f.createElement(
    f.Fragment,
    null,
    h && f.createElement(x, { sideCar: gn, removeScrollBar: l, shards: d, noIsolation: m, inert: v, setCallbacks: i, allowPinchZoom: !!u, lockRef: n, gapMode: w }),
    s ? f.cloneElement(f.Children.only(c), z(z({}, C), { ref: E })) : f.createElement(y, z({}, C, { className: a, ref: E }), c)
  );
});
$e.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
$e.classNames = {
  fullWidth: Fe,
  zeroRight: ke
};
var Wo = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Bo() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = Wo();
  return t && e.setAttribute("nonce", t), e;
}
function jo(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function $o(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var Ho = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = Bo()) && (jo(t, n), $o(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
}, Vo = function() {
  var e = Ho();
  return function(t, n) {
    f.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
}, yn = function() {
  var e = Vo(), t = function(n) {
    var r = n.styles, o = n.dynamic;
    return e(r, o), null;
  };
  return t;
}, zo = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, qe = function(e) {
  return parseInt(e || "", 10) || 0;
}, Uo = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], o = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [qe(n), qe(r), qe(o)];
}, Yo = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return zo;
  var t = Uo(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
}, Xo = yn(), he = "data-scroll-locked", Ko = function(e, t, n, r) {
  var o = e.left, i = e.top, s = e.right, c = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(Mo, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(c, "px ").concat(r, `;
  }
  body[`).concat(he, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(i, `px;
    padding-right: `).concat(s, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(c, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(c, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(ke, ` {
    right: `).concat(c, "px ").concat(r, `;
  }
  
  .`).concat(Fe, ` {
    margin-right: `).concat(c, "px ").concat(r, `;
  }
  
  .`).concat(ke, " .").concat(ke, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Fe, " .").concat(Fe, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(he, `] {
    `).concat(To, ": ").concat(c, `px;
  }
`);
}, _t = function() {
  var e = parseInt(document.body.getAttribute(he) || "0", 10);
  return isFinite(e) ? e : 0;
}, Go = function() {
  f.useEffect(function() {
    return document.body.setAttribute(he, (_t() + 1).toString()), function() {
      var e = _t() - 1;
      e <= 0 ? document.body.removeAttribute(he) : document.body.setAttribute(he, e.toString());
    };
  }, []);
}, Zo = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, o = r === void 0 ? "margin" : r;
  Go();
  var i = f.useMemo(function() {
    return Yo(o);
  }, [o]);
  return f.createElement(Xo, { styles: Ko(i, !t, o, n ? "" : "!important") });
}, nt = !1;
if (typeof window < "u")
  try {
    var Le = Object.defineProperty({}, "passive", {
      get: function() {
        return nt = !0, !0;
      }
    });
    window.addEventListener("test", Le, Le), window.removeEventListener("test", Le, Le);
  } catch {
    nt = !1;
  }
var ue = nt ? { passive: !1 } : !1, qo = function(e) {
  return e.tagName === "TEXTAREA";
}, wn = function(e, t) {
  if (!(e instanceof Element))
    return !1;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !qo(e) && n[t] === "visible")
  );
}, Qo = function(e) {
  return wn(e, "overflowY");
}, Jo = function(e) {
  return wn(e, "overflowX");
}, Wt = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var o = xn(e, r);
    if (o) {
      var i = bn(e, r), s = i[1], c = i[2];
      if (s > c)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return !1;
}, ei = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
}, ti = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
}, xn = function(e, t) {
  return e === "v" ? Qo(t) : Jo(t);
}, bn = function(e, t) {
  return e === "v" ? ei(t) : ti(t);
}, ni = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
}, ri = function(e, t, n, r, o) {
  var i = ni(e, window.getComputedStyle(t).direction), s = i * r, c = n.target, a = t.contains(c), l = !1, h = s > 0, d = 0, p = 0;
  do {
    var m = bn(e, c), v = m[0], u = m[1], g = m[2], y = u - g - i * v;
    (v || y) && xn(e, c) && (d += y, p += v), c instanceof ShadowRoot ? c = c.host : c = c.parentNode;
  } while (
    // portaled content
    !a && c !== document.body || // self content
    a && (t.contains(c) || t === c)
  );
  return (h && (Math.abs(d) < 1 || !o) || !h && (Math.abs(p) < 1 || !o)) && (l = !0), l;
}, Ne = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
}, Bt = function(e) {
  return [e.deltaX, e.deltaY];
}, jt = function(e) {
  return e && "current" in e ? e.current : e;
}, oi = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}, ii = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
}, si = 0, fe = [];
function ci(e) {
  var t = f.useRef([]), n = f.useRef([0, 0]), r = f.useRef(), o = f.useState(si++)[0], i = f.useState(yn)[0], s = f.useRef(e);
  f.useEffect(function() {
    s.current = e;
  }, [e]), f.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(o));
      var u = Oo([e.lockRef.current], (e.shards || []).map(jt), !0).filter(Boolean);
      return u.forEach(function(g) {
        return g.classList.add("allow-interactivity-".concat(o));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(o)), u.forEach(function(g) {
          return g.classList.remove("allow-interactivity-".concat(o));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var c = f.useCallback(function(u, g) {
    if ("touches" in u && u.touches.length === 2 || u.type === "wheel" && u.ctrlKey)
      return !s.current.allowPinchZoom;
    var y = Ne(u), w = n.current, b = "deltaX" in u ? u.deltaX : w[0] - y[0], x = "deltaY" in u ? u.deltaY : w[1] - y[1], E, C = u.target, S = Math.abs(b) > Math.abs(x) ? "h" : "v";
    if ("touches" in u && S === "h" && C.type === "range")
      return !1;
    var A = Wt(S, C);
    if (!A)
      return !0;
    if (A ? E = S : (E = S === "v" ? "h" : "v", A = Wt(S, C)), !A)
      return !1;
    if (!r.current && "changedTouches" in u && (b || x) && (r.current = E), !E)
      return !0;
    var O = r.current || E;
    return ri(O, g, u, O === "h" ? b : x, !0);
  }, []), a = f.useCallback(function(u) {
    var g = u;
    if (!(!fe.length || fe[fe.length - 1] !== i)) {
      var y = "deltaY" in g ? Bt(g) : Ne(g), w = t.current.filter(function(E) {
        return E.name === g.type && (E.target === g.target || g.target === E.shadowParent) && oi(E.delta, y);
      })[0];
      if (w && w.should) {
        g.cancelable && g.preventDefault();
        return;
      }
      if (!w) {
        var b = (s.current.shards || []).map(jt).filter(Boolean).filter(function(E) {
          return E.contains(g.target);
        }), x = b.length > 0 ? c(g, b[0]) : !s.current.noIsolation;
        x && g.cancelable && g.preventDefault();
      }
    }
  }, []), l = f.useCallback(function(u, g, y, w) {
    var b = { name: u, delta: g, target: y, should: w, shadowParent: ai(y) };
    t.current.push(b), setTimeout(function() {
      t.current = t.current.filter(function(x) {
        return x !== b;
      });
    }, 1);
  }, []), h = f.useCallback(function(u) {
    n.current = Ne(u), r.current = void 0;
  }, []), d = f.useCallback(function(u) {
    l(u.type, Bt(u), u.target, c(u, e.lockRef.current));
  }, []), p = f.useCallback(function(u) {
    l(u.type, Ne(u), u.target, c(u, e.lockRef.current));
  }, []);
  f.useEffect(function() {
    return fe.push(i), e.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: p
    }), document.addEventListener("wheel", a, ue), document.addEventListener("touchmove", a, ue), document.addEventListener("touchstart", h, ue), function() {
      fe = fe.filter(function(u) {
        return u !== i;
      }), document.removeEventListener("wheel", a, ue), document.removeEventListener("touchmove", a, ue), document.removeEventListener("touchstart", h, ue);
    };
  }, []);
  var m = e.removeScrollBar, v = e.inert;
  return f.createElement(
    f.Fragment,
    null,
    v ? f.createElement(i, { styles: ii(o) }) : null,
    m ? f.createElement(Zo, { gapMode: e.gapMode }) : null
  );
}
function ai(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
const li = _o(gn, ci);
var ui = f.forwardRef(function(e, t) {
  return f.createElement($e, z({}, e, { ref: t, sideCar: li }));
});
ui.classNames = $e.classNames;
var fi = "VisuallyHidden", di = f.forwardRef(
  (e, t) => /* @__PURE__ */ R.jsx(
    oe.span,
    {
      ...e,
      ref: t,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...e.style
      }
    }
  )
);
di.displayName = fi;
export {
  Li as A,
  Gn as B,
  Ni as C,
  cr as D,
  hr as F,
  xi as M,
  oe as P,
  ui as R,
  be as S,
  di as V,
  Oi as a,
  Ve as b,
  Ci as c,
  ce as d,
  Ee as e,
  Ai as f,
  zt as g,
  Pi as h,
  ee as i,
  ki as j,
  Ri as k,
  Ei as l,
  So as m,
  bi as n,
  Zn as o,
  Mi as p,
  Di as q,
  Ti as r,
  Vt as s,
  er as t,
  Si as u
};
//# sourceMappingURL=index-Do_BBSIs.js.map
