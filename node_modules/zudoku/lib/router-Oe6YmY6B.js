/**
 * @remix-run/router v1.20.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function I() {
  return I = Object.assign ? Object.assign.bind() : function(e) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var a in r)
        Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a]);
    }
    return e;
  }, I.apply(this, arguments);
}
var $;
(function(e) {
  e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE";
})($ || ($ = {}));
const Ht = "popstate";
function Wr(e) {
  e === void 0 && (e = {});
  let {
    initialEntries: t = ["/"],
    initialIndex: r,
    v5Compat: a = !1
  } = e, n;
  n = t.map((h, v) => y(h, typeof h == "string" ? null : h.state, v === 0 ? "default" : void 0));
  let s = d(r ?? n.length - 1), o = $.Pop, c = null;
  function d(h) {
    return Math.min(Math.max(h, 0), n.length - 1);
  }
  function m() {
    return n[s];
  }
  function y(h, v, w) {
    v === void 0 && (v = null);
    let L = ye(n ? m().pathname : "/", h, v, w);
    return le(L.pathname.charAt(0) === "/", "relative pathnames are not supported in memory history: " + JSON.stringify(h)), L;
  }
  function g(h) {
    return typeof h == "string" ? h : se(h);
  }
  return {
    get index() {
      return s;
    },
    get action() {
      return o;
    },
    get location() {
      return m();
    },
    createHref: g,
    createURL(h) {
      return new URL(g(h), "http://localhost");
    },
    encodeLocation(h) {
      let v = typeof h == "string" ? ie(h) : h;
      return {
        pathname: v.pathname || "",
        search: v.search || "",
        hash: v.hash || ""
      };
    },
    push(h, v) {
      o = $.Push;
      let w = y(h, v);
      s += 1, n.splice(s, n.length, w), a && c && c({
        action: o,
        location: w,
        delta: 1
      });
    },
    replace(h, v) {
      o = $.Replace;
      let w = y(h, v);
      n[s] = w, a && c && c({
        action: o,
        location: w,
        delta: 0
      });
    },
    go(h) {
      o = $.Pop;
      let v = d(s + h), w = n[v];
      s = v, c && c({
        action: o,
        location: w,
        delta: h
      });
    },
    listen(h) {
      return c = h, () => {
        c = null;
      };
    }
  };
}
function Kr(e) {
  e === void 0 && (e = {});
  function t(a, n) {
    let {
      pathname: s,
      search: o,
      hash: c
    } = a.location;
    return ye(
      "",
      {
        pathname: s,
        search: o,
        hash: c
      },
      // state defaults to `null` because `window.history.state` does
      n.state && n.state.usr || null,
      n.state && n.state.key || "default"
    );
  }
  function r(a, n) {
    return typeof n == "string" ? n : se(n);
  }
  return qt(t, r, null, e);
}
function kr(e) {
  e === void 0 && (e = {});
  function t(n, s) {
    let {
      pathname: o = "/",
      search: c = "",
      hash: d = ""
    } = ie(n.location.hash.substr(1));
    return !o.startsWith("/") && !o.startsWith(".") && (o = "/" + o), ye(
      "",
      {
        pathname: o,
        search: c,
        hash: d
      },
      // state defaults to `null` because `window.history.state` does
      s.state && s.state.usr || null,
      s.state && s.state.key || "default"
    );
  }
  function r(n, s) {
    let o = n.document.querySelector("base"), c = "";
    if (o && o.getAttribute("href")) {
      let d = n.location.href, m = d.indexOf("#");
      c = m === -1 ? d : d.slice(0, m);
    }
    return c + "#" + (typeof s == "string" ? s : se(s));
  }
  function a(n, s) {
    le(n.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(s) + ")");
  }
  return qt(t, r, a, e);
}
function B(e, t) {
  if (e === !1 || e === null || typeof e > "u")
    throw new Error(t);
}
function le(e, t) {
  if (!e) {
    typeof console < "u" && console.warn(t);
    try {
      throw new Error(t);
    } catch {
    }
  }
}
function $r() {
  return Math.random().toString(36).substr(2, 8);
}
function zt(e, t) {
  return {
    usr: e.state,
    key: e.key,
    idx: t
  };
}
function ye(e, t, r, a) {
  return r === void 0 && (r = null), I({
    pathname: typeof e == "string" ? e : e.pathname,
    search: "",
    hash: ""
  }, typeof t == "string" ? ie(t) : t, {
    state: r,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: t && t.key || a || $r()
  });
}
function se(e) {
  let {
    pathname: t = "/",
    search: r = "",
    hash: a = ""
  } = e;
  return r && r !== "?" && (t += r.charAt(0) === "?" ? r : "?" + r), a && a !== "#" && (t += a.charAt(0) === "#" ? a : "#" + a), t;
}
function ie(e) {
  let t = {};
  if (e) {
    let r = e.indexOf("#");
    r >= 0 && (t.hash = e.substr(r), e = e.substr(0, r));
    let a = e.indexOf("?");
    a >= 0 && (t.search = e.substr(a), e = e.substr(0, a)), e && (t.pathname = e);
  }
  return t;
}
function qt(e, t, r, a) {
  a === void 0 && (a = {});
  let {
    window: n = document.defaultView,
    v5Compat: s = !1
  } = a, o = n.history, c = $.Pop, d = null, m = y();
  m == null && (m = 0, o.replaceState(I({}, o.state, {
    idx: m
  }), ""));
  function y() {
    return (o.state || {
      idx: null
    }).idx;
  }
  function g() {
    c = $.Pop;
    let L = y(), U = L == null ? null : L - m;
    m = L, d && d({
      action: c,
      location: w.location,
      delta: U
    });
  }
  function S(L, U) {
    c = $.Push;
    let x = ye(w.location, L, U);
    r && r(x, L), m = y() + 1;
    let F = zt(x, m), b = w.createHref(x);
    try {
      o.pushState(F, "", b);
    } catch (K) {
      if (K instanceof DOMException && K.name === "DataCloneError")
        throw K;
      n.location.assign(b);
    }
    s && d && d({
      action: c,
      location: w.location,
      delta: 1
    });
  }
  function h(L, U) {
    c = $.Replace;
    let x = ye(w.location, L, U);
    r && r(x, L), m = y();
    let F = zt(x, m), b = w.createHref(x);
    o.replaceState(F, "", b), s && d && d({
      action: c,
      location: w.location,
      delta: 0
    });
  }
  function v(L) {
    let U = n.location.origin !== "null" ? n.location.origin : n.location.href, x = typeof L == "string" ? L : se(L);
    return x = x.replace(/ $/, "%20"), B(U, "No window.location.(origin|href) available to create URL for href: " + x), new URL(x, U);
  }
  let w = {
    get action() {
      return c;
    },
    get location() {
      return e(n, o);
    },
    listen(L) {
      if (d)
        throw new Error("A history only accepts one active listener");
      return n.addEventListener(Ht, g), d = L, () => {
        n.removeEventListener(Ht, g), d = null;
      };
    },
    createHref(L) {
      return t(n, L);
    },
    createURL: v,
    encodeLocation(L) {
      let U = v(L);
      return {
        pathname: U.pathname,
        search: U.search,
        hash: U.hash
      };
    },
    push: S,
    replace: h,
    go(L) {
      return o.go(L);
    }
  };
  return w;
}
var H;
(function(e) {
  e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error";
})(H || (H = {}));
const Vr = /* @__PURE__ */ new Set(["lazy", "caseSensitive", "path", "id", "index", "children"]);
function Yr(e) {
  return e.index === !0;
}
function Ne(e, t, r, a) {
  return r === void 0 && (r = []), a === void 0 && (a = {}), e.map((n, s) => {
    let o = [...r, String(s)], c = typeof n.id == "string" ? n.id : o.join("-");
    if (B(n.index !== !0 || !n.children, "Cannot specify children on an index route"), B(!a[c], 'Found a route id collision on id "' + c + `".  Route id's must be globally unique within Data Router usages`), Yr(n)) {
      let d = I({}, n, t(n), {
        id: c
      });
      return a[c] = d, d;
    } else {
      let d = I({}, n, t(n), {
        id: c,
        children: void 0
      });
      return a[c] = d, n.children && (d.children = Ne(n.children, t, o, a)), d;
    }
  });
}
function pe(e, t, r) {
  return r === void 0 && (r = "/"), it(e, t, r, !1);
}
function it(e, t, r, a) {
  let n = typeof t == "string" ? ie(t) : t, s = Ye(n.pathname || "/", r);
  if (s == null)
    return null;
  let o = tr(e);
  Jr(o);
  let c = null;
  for (let d = 0; c == null && d < o.length; ++d) {
    let m = ar(s);
    c = aa(o[d], m, a);
  }
  return c;
}
function er(e, t) {
  let {
    route: r,
    pathname: a,
    params: n
  } = e;
  return {
    id: r.id,
    pathname: a,
    params: n,
    data: t[r.id],
    handle: r.handle
  };
}
function tr(e, t, r, a) {
  t === void 0 && (t = []), r === void 0 && (r = []), a === void 0 && (a = "");
  let n = (s, o, c) => {
    let d = {
      relativePath: c === void 0 ? s.path || "" : c,
      caseSensitive: s.caseSensitive === !0,
      childrenIndex: o,
      route: s
    };
    d.relativePath.startsWith("/") && (B(d.relativePath.startsWith(a), 'Absolute route path "' + d.relativePath + '" nested under path ' + ('"' + a + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), d.relativePath = d.relativePath.slice(a.length));
    let m = Ie([a, d.relativePath]), y = r.concat(d);
    s.children && s.children.length > 0 && (B(
      // Our types know better, but runtime JS may not!
      // @ts-expect-error
      s.index !== !0,
      "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + m + '".')
    ), tr(s.children, t, y, m)), !(s.path == null && !s.index) && t.push({
      path: m,
      score: ta(m, s.index),
      routesMeta: y
    });
  };
  return e.forEach((s, o) => {
    var c;
    if (s.path === "" || !((c = s.path) != null && c.includes("?")))
      n(s, o);
    else
      for (let d of rr(s.path))
        n(s, o, d);
  }), t;
}
function rr(e) {
  let t = e.split("/");
  if (t.length === 0) return [];
  let [r, ...a] = t, n = r.endsWith("?"), s = r.replace(/\?$/, "");
  if (a.length === 0)
    return n ? [s, ""] : [s];
  let o = rr(a.join("/")), c = [];
  return c.push(...o.map((d) => d === "" ? s : [s, d].join("/"))), n && c.push(...o), c.map((d) => e.startsWith("/") && d === "" ? "/" : d);
}
function Jr(e) {
  e.sort((t, r) => t.score !== r.score ? r.score - t.score : ra(t.routesMeta.map((a) => a.childrenIndex), r.routesMeta.map((a) => a.childrenIndex)));
}
const Xr = /^:[\w-]+$/, Gr = 3, Qr = 2, Zr = 1, qr = 10, ea = -2, Bt = (e) => e === "*";
function ta(e, t) {
  let r = e.split("/"), a = r.length;
  return r.some(Bt) && (a += ea), t && (a += Qr), r.filter((n) => !Bt(n)).reduce((n, s) => n + (Xr.test(s) ? Gr : s === "" ? Zr : qr), a);
}
function ra(e, t) {
  return e.length === t.length && e.slice(0, -1).every((a, n) => a === t[n]) ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    e[e.length - 1] - t[t.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function aa(e, t, r) {
  r === void 0 && (r = !1);
  let {
    routesMeta: a
  } = e, n = {}, s = "/", o = [];
  for (let c = 0; c < a.length; ++c) {
    let d = a[c], m = c === a.length - 1, y = s === "/" ? t : t.slice(s.length) || "/", g = mt({
      path: d.relativePath,
      caseSensitive: d.caseSensitive,
      end: m
    }, y), S = d.route;
    if (!g && m && r && !a[a.length - 1].route.index && (g = mt({
      path: d.relativePath,
      caseSensitive: d.caseSensitive,
      end: !1
    }, y)), !g)
      return null;
    Object.assign(n, g.params), o.push({
      // TODO: Can this as be avoided?
      params: n,
      pathname: Ie([s, g.pathname]),
      pathnameBase: sr(Ie([s, g.pathnameBase])),
      route: S
    }), g.pathnameBase !== "/" && (s = Ie([s, g.pathnameBase]));
  }
  return o;
}
function na(e, t) {
  t === void 0 && (t = {});
  let r = e;
  r.endsWith("*") && r !== "*" && !r.endsWith("/*") && (le(!1, 'Route path "' + r + '" will be treated as if it were ' + ('"' + r.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + r.replace(/\*$/, "/*") + '".')), r = r.replace(/\*$/, "/*"));
  const a = r.startsWith("/") ? "/" : "", n = (o) => o == null ? "" : typeof o == "string" ? o : String(o), s = r.split(/\/+/).map((o, c, d) => {
    if (c === d.length - 1 && o === "*")
      return n(t["*"]);
    const y = o.match(/^:([\w-]+)(\??)$/);
    if (y) {
      const [, g, S] = y;
      let h = t[g];
      return B(S === "?" || h != null, 'Missing ":' + g + '" param'), n(h);
    }
    return o.replace(/\?$/g, "");
  }).filter((o) => !!o);
  return a + s.join("/");
}
function mt(e, t) {
  typeof e == "string" && (e = {
    path: e,
    caseSensitive: !1,
    end: !0
  });
  let [r, a] = ia(e.path, e.caseSensitive, e.end), n = t.match(r);
  if (!n) return null;
  let s = n[0], o = s.replace(/(.)\/+$/, "$1"), c = n.slice(1);
  return {
    params: a.reduce((m, y, g) => {
      let {
        paramName: S,
        isOptional: h
      } = y;
      if (S === "*") {
        let w = c[g] || "";
        o = s.slice(0, s.length - w.length).replace(/(.)\/+$/, "$1");
      }
      const v = c[g];
      return h && !v ? m[S] = void 0 : m[S] = (v || "").replace(/%2F/g, "/"), m;
    }, {}),
    pathname: s,
    pathnameBase: o,
    pattern: e
  };
}
function ia(e, t, r) {
  t === void 0 && (t = !1), r === void 0 && (r = !0), le(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".'));
  let a = [], n = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (o, c, d) => (a.push({
    paramName: c,
    isOptional: d != null
  }), d ? "/?([^\\/]+)?" : "/([^\\/]+)"));
  return e.endsWith("*") ? (a.push({
    paramName: "*"
  }), n += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : r ? n += "\\/*$" : e !== "" && e !== "/" && (n += "(?:(?=\\/|$))"), [new RegExp(n, t ? void 0 : "i"), a];
}
function ar(e) {
  try {
    return e.split("/").map((t) => decodeURIComponent(t).replace(/\//g, "%2F")).join("/");
  } catch (t) {
    return le(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")), e;
  }
}
function Ye(e, t) {
  if (t === "/") return e;
  if (!e.toLowerCase().startsWith(t.toLowerCase()))
    return null;
  let r = t.endsWith("/") ? t.length - 1 : t.length, a = e.charAt(r);
  return a && a !== "/" ? null : e.slice(r) || "/";
}
function nr(e, t) {
  t === void 0 && (t = "/");
  let {
    pathname: r,
    search: a = "",
    hash: n = ""
  } = typeof e == "string" ? ie(e) : e;
  return {
    pathname: r ? r.startsWith("/") ? r : oa(r, t) : t,
    search: sa(a),
    hash: da(n)
  };
}
function oa(e, t) {
  let r = t.replace(/\/+$/, "").split("/");
  return e.split("/").forEach((n) => {
    n === ".." ? r.length > 1 && r.pop() : n !== "." && r.push(n);
  }), r.length > 1 ? r.join("/") : "/";
}
function ht(e, t, r, a) {
  return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(a) + "].  Please separate it out to the ") + ("`to." + r + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function ir(e) {
  return e.filter((t, r) => r === 0 || t.route.path && t.route.path.length > 0);
}
function or(e, t) {
  let r = ir(e);
  return t ? r.map((a, n) => n === r.length - 1 ? a.pathname : a.pathnameBase) : r.map((a) => a.pathnameBase);
}
function lr(e, t, r, a) {
  a === void 0 && (a = !1);
  let n;
  typeof e == "string" ? n = ie(e) : (n = I({}, e), B(!n.pathname || !n.pathname.includes("?"), ht("?", "pathname", "search", n)), B(!n.pathname || !n.pathname.includes("#"), ht("#", "pathname", "hash", n)), B(!n.search || !n.search.includes("#"), ht("#", "search", "hash", n)));
  let s = e === "" || n.pathname === "", o = s ? "/" : n.pathname, c;
  if (o == null)
    c = r;
  else {
    let g = t.length - 1;
    if (!a && o.startsWith("..")) {
      let S = o.split("/");
      for (; S[0] === ".."; )
        S.shift(), g -= 1;
      n.pathname = S.join("/");
    }
    c = g >= 0 ? t[g] : "/";
  }
  let d = nr(n, c), m = o && o !== "/" && o.endsWith("/"), y = (s || o === ".") && r.endsWith("/");
  return !d.pathname.endsWith("/") && (m || y) && (d.pathname += "/"), d;
}
function la(e) {
  return e === "" || e.pathname === "" ? "/" : typeof e == "string" ? ie(e).pathname : e.pathname;
}
const Ie = (e) => e.join("/").replace(/\/\/+/g, "/"), sr = (e) => e.replace(/\/+$/, "").replace(/^\/*/, "/"), sa = (e) => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, da = (e) => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e, ua = function(t, r) {
  r === void 0 && (r = {});
  let a = typeof r == "number" ? {
    status: r
  } : r, n = new Headers(a.headers);
  return n.has("Content-Type") || n.set("Content-Type", "application/json; charset=utf-8"), new Response(JSON.stringify(t), I({}, a, {
    headers: n
  }));
};
class fa {
  constructor(t, r) {
    this.type = "DataWithResponseInit", this.data = t, this.init = r || null;
  }
}
function ca(e, t) {
  return new fa(e, typeof t == "number" ? {
    status: t
  } : t);
}
class yt extends Error {
}
class dr {
  constructor(t, r) {
    this.pendingKeysSet = /* @__PURE__ */ new Set(), this.subscribers = /* @__PURE__ */ new Set(), this.deferredKeys = [], B(t && typeof t == "object" && !Array.isArray(t), "defer() only accepts plain objects");
    let a;
    this.abortPromise = new Promise((s, o) => a = o), this.controller = new AbortController();
    let n = () => a(new yt("Deferred data aborted"));
    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener("abort", n), this.controller.signal.addEventListener("abort", n), this.data = Object.entries(t).reduce((s, o) => {
      let [c, d] = o;
      return Object.assign(s, {
        [c]: this.trackPromise(c, d)
      });
    }, {}), this.done && this.unlistenAbortSignal(), this.init = r;
  }
  trackPromise(t, r) {
    if (!(r instanceof Promise))
      return r;
    this.deferredKeys.push(t), this.pendingKeysSet.add(t);
    let a = Promise.race([r, this.abortPromise]).then((n) => this.onSettle(a, t, void 0, n), (n) => this.onSettle(a, t, n));
    return a.catch(() => {
    }), Object.defineProperty(a, "_tracked", {
      get: () => !0
    }), a;
  }
  onSettle(t, r, a, n) {
    if (this.controller.signal.aborted && a instanceof yt)
      return this.unlistenAbortSignal(), Object.defineProperty(t, "_error", {
        get: () => a
      }), Promise.reject(a);
    if (this.pendingKeysSet.delete(r), this.done && this.unlistenAbortSignal(), a === void 0 && n === void 0) {
      let s = new Error('Deferred data for key "' + r + '" resolved/rejected with `undefined`, you must resolve/reject with a value or `null`.');
      return Object.defineProperty(t, "_error", {
        get: () => s
      }), this.emit(!1, r), Promise.reject(s);
    }
    return n === void 0 ? (Object.defineProperty(t, "_error", {
      get: () => a
    }), this.emit(!1, r), Promise.reject(a)) : (Object.defineProperty(t, "_data", {
      get: () => n
    }), this.emit(!1, r), n);
  }
  emit(t, r) {
    this.subscribers.forEach((a) => a(t, r));
  }
  subscribe(t) {
    return this.subscribers.add(t), () => this.subscribers.delete(t);
  }
  cancel() {
    this.controller.abort(), this.pendingKeysSet.forEach((t, r) => this.pendingKeysSet.delete(r)), this.emit(!0);
  }
  async resolveData(t) {
    let r = !1;
    if (!this.done) {
      let a = () => this.cancel();
      t.addEventListener("abort", a), r = await new Promise((n) => {
        this.subscribe((s) => {
          t.removeEventListener("abort", a), (s || this.done) && n(s);
        });
      });
    }
    return r;
  }
  get done() {
    return this.pendingKeysSet.size === 0;
  }
  get unwrappedData() {
    return B(this.data !== null && this.done, "Can only unwrap data on initialized and settled deferreds"), Object.entries(this.data).reduce((t, r) => {
      let [a, n] = r;
      return Object.assign(t, {
        [a]: pa(n)
      });
    }, {});
  }
  get pendingKeys() {
    return Array.from(this.pendingKeysSet);
  }
}
function ha(e) {
  return e instanceof Promise && e._tracked === !0;
}
function pa(e) {
  if (!ha(e))
    return e;
  if (e._error)
    throw e._error;
  return e._data;
}
const ma = function(t, r) {
  r === void 0 && (r = {});
  let a = typeof r == "number" ? {
    status: r
  } : r;
  return new dr(t, a);
}, St = function(t, r) {
  r === void 0 && (r = 302);
  let a = r;
  typeof a == "number" ? a = {
    status: a
  } : typeof a.status > "u" && (a.status = 302);
  let n = new Headers(a.headers);
  return n.set("Location", t), new Response(null, I({}, a, {
    headers: n
  }));
}, ya = (e, t) => {
  let r = St(e, t);
  return r.headers.set("X-Remix-Reload-Document", "true"), r;
}, ga = (e, t) => {
  let r = St(e, t);
  return r.headers.set("X-Remix-Replace", "true"), r;
};
class lt {
  constructor(t, r, a, n) {
    n === void 0 && (n = !1), this.status = t, this.statusText = r || "", this.internal = n, a instanceof Error ? (this.data = a.toString(), this.error = a) : this.data = a;
  }
}
function He(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e;
}
const ur = ["post", "put", "patch", "delete"], va = new Set(ur), wa = ["get", ...ur], ba = new Set(wa), Ra = /* @__PURE__ */ new Set([301, 302, 303, 307, 308]), Da = /* @__PURE__ */ new Set([307, 308]), ot = {
  state: "idle",
  location: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, fr = {
  state: "idle",
  data: void 0,
  formMethod: void 0,
  formAction: void 0,
  formEncType: void 0,
  formData: void 0,
  json: void 0,
  text: void 0
}, Oe = {
  state: "unblocked",
  proceed: void 0,
  reset: void 0,
  location: void 0
}, Et = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, cr = (e) => ({
  hasErrorBoundary: !!e.hasErrorBoundary
}), hr = "remix-router-transitions";
function Sa(e) {
  const t = e.window ? e.window : typeof window < "u" ? window : void 0, r = typeof t < "u" && typeof t.document < "u" && typeof t.document.createElement < "u", a = !r;
  B(e.routes.length > 0, "You must provide a non-empty routes array to createRouter");
  let n;
  if (e.mapRouteProperties)
    n = e.mapRouteProperties;
  else if (e.detectErrorBoundary) {
    let i = e.detectErrorBoundary;
    n = (l) => ({
      hasErrorBoundary: i(l)
    });
  } else
    n = cr;
  let s = {}, o = Ne(e.routes, n, void 0, s), c, d = e.basename || "/", m = e.dataStrategy || gr, y = e.patchRoutesOnNavigation, g = I({
    v7_fetcherPersist: !1,
    v7_normalizeFormMethod: !1,
    v7_partialHydration: !1,
    v7_prependBasename: !1,
    v7_relativeSplatPath: !1,
    v7_skipActionErrorRevalidation: !1
  }, e.future), S = null, h = /* @__PURE__ */ new Set(), v = null, w = null, L = null, U = e.hydrationData != null, x = pe(o, e.history.location, d), F = null;
  if (x == null && !y) {
    let i = Y(404, {
      pathname: e.history.location.pathname
    }), {
      matches: l,
      route: u
    } = st(o);
    x = l, F = {
      [u.id]: i
    };
  }
  x && !e.hydrationData && et(x, o, e.history.location.pathname).active && (x = null);
  let b;
  if (x)
    if (x.some((i) => i.route.lazy))
      b = !1;
    else if (!x.some((i) => i.route.loader))
      b = !0;
    else if (g.v7_partialHydration) {
      let i = e.hydrationData ? e.hydrationData.loaderData : null, l = e.hydrationData ? e.hydrationData.errors : null;
      if (l) {
        let u = x.findIndex((p) => l[p.route.id] !== void 0);
        b = x.slice(0, u + 1).every((p) => !wt(p.route, i, l));
      } else
        b = x.every((u) => !wt(u.route, i, l));
    } else
      b = e.hydrationData != null;
  else if (b = !1, x = [], g.v7_partialHydration) {
    let i = et(null, o, e.history.location.pathname);
    i.active && i.matches && (x = i.matches);
  }
  let K, f = {
    historyAction: e.history.action,
    location: e.history.location,
    matches: x,
    initialized: b,
    navigation: ot,
    // Don't restore on initial updateState() if we were SSR'd
    restoreScrollPosition: e.hydrationData != null ? !1 : null,
    preventScrollReset: !1,
    revalidation: "idle",
    loaderData: e.hydrationData && e.hydrationData.loaderData || {},
    actionData: e.hydrationData && e.hydrationData.actionData || null,
    errors: e.hydrationData && e.hydrationData.errors || F,
    fetchers: /* @__PURE__ */ new Map(),
    blockers: /* @__PURE__ */ new Map()
  }, j = $.Pop, O = !1, A, G = !1, V = /* @__PURE__ */ new Map(), ne = null, re = !1, de = !1, Je = [], Xe = /* @__PURE__ */ new Set(), Z = /* @__PURE__ */ new Map(), Ge = 0, ze = -1, Te = /* @__PURE__ */ new Map(), ue = /* @__PURE__ */ new Set(), je = /* @__PURE__ */ new Map(), Be = /* @__PURE__ */ new Map(), fe = /* @__PURE__ */ new Set(), Se = /* @__PURE__ */ new Map(), Ee = /* @__PURE__ */ new Map(), Qe;
  function Pr() {
    if (S = e.history.listen((i) => {
      let {
        action: l,
        location: u,
        delta: p
      } = i;
      if (Qe) {
        Qe(), Qe = void 0;
        return;
      }
      le(Ee.size === 0 || p != null, "You are trying to use a blocker on a POP navigation to a location that was not created by @remix-run/router. This will fail silently in production. This can happen if you are navigating outside the router via `window.history.pushState`/`window.location.hash` instead of using router navigation APIs.  This can also happen if you are using createHashRouter and the user manually changes the URL.");
      let R = _t({
        currentLocation: f.location,
        nextLocation: u,
        historyAction: l
      });
      if (R && p != null) {
        let M = new Promise((C) => {
          Qe = C;
        });
        e.history.go(p * -1), qe(R, {
          state: "blocked",
          location: u,
          proceed() {
            qe(R, {
              state: "proceeding",
              proceed: void 0,
              reset: void 0,
              location: u
            }), M.then(() => e.history.go(p));
          },
          reset() {
            let C = new Map(f.blockers);
            C.set(R, Oe), te({
              blockers: C
            });
          }
        });
        return;
      }
      return Pe(l, u);
    }), r) {
      Ia(t, V);
      let i = () => Na(t, V);
      t.addEventListener("pagehide", i), ne = () => t.removeEventListener("pagehide", i);
    }
    return f.initialized || Pe($.Pop, f.location, {
      initialHydration: !0
    }), K;
  }
  function xr() {
    S && S(), ne && ne(), h.clear(), A && A.abort(), f.fetchers.forEach((i, l) => Ze(l)), f.blockers.forEach((i, l) => At(l));
  }
  function Lr(i) {
    return h.add(i), () => h.delete(i);
  }
  function te(i, l) {
    l === void 0 && (l = {}), f = I({}, f, i);
    let u = [], p = [];
    g.v7_fetcherPersist && f.fetchers.forEach((R, M) => {
      R.state === "idle" && (fe.has(M) ? p.push(M) : u.push(M));
    }), [...h].forEach((R) => R(f, {
      deletedFetchers: p,
      viewTransitionOpts: l.viewTransitionOpts,
      flushSync: l.flushSync === !0
    })), g.v7_fetcherPersist && (u.forEach((R) => f.fetchers.delete(R)), p.forEach((R) => Ze(R)));
  }
  function Ce(i, l, u) {
    var p, R;
    let {
      flushSync: M
    } = u === void 0 ? {} : u, C = f.actionData != null && f.navigation.formMethod != null && ae(f.navigation.formMethod) && f.navigation.state === "loading" && ((p = i.state) == null ? void 0 : p._isRedirect) !== !0, E;
    l.actionData ? Object.keys(l.actionData).length > 0 ? E = l.actionData : E = null : C ? E = f.actionData : E = null;
    let P = l.loaderData ? Gt(f.loaderData, l.loaderData, l.matches || [], l.errors) : f.loaderData, D = f.blockers;
    D.size > 0 && (D = new Map(D), D.forEach((N, q) => D.set(q, Oe)));
    let T = O === !0 || f.navigation.formMethod != null && ae(f.navigation.formMethod) && ((R = i.state) == null ? void 0 : R._isRedirect) !== !0;
    c && (o = c, c = void 0), re || j === $.Pop || (j === $.Push ? e.history.push(i, i.state) : j === $.Replace && e.history.replace(i, i.state));
    let _;
    if (j === $.Pop) {
      let N = V.get(f.location.pathname);
      N && N.has(i.pathname) ? _ = {
        currentLocation: f.location,
        nextLocation: i
      } : V.has(i.pathname) && (_ = {
        currentLocation: i,
        nextLocation: f.location
      });
    } else if (G) {
      let N = V.get(f.location.pathname);
      N ? N.add(i.pathname) : (N = /* @__PURE__ */ new Set([i.pathname]), V.set(f.location.pathname, N)), _ = {
        currentLocation: f.location,
        nextLocation: i
      };
    }
    te(I({}, l, {
      actionData: E,
      loaderData: P,
      historyAction: j,
      location: i,
      initialized: !0,
      navigation: ot,
      revalidation: "idle",
      restoreScrollPosition: It(i, l.matches || f.matches),
      preventScrollReset: T,
      blockers: D
    }), {
      viewTransitionOpts: _,
      flushSync: M === !0
    }), j = $.Pop, O = !1, G = !1, re = !1, de = !1, Je = [];
  }
  async function Lt(i, l) {
    if (typeof i == "number") {
      e.history.go(i);
      return;
    }
    let u = gt(f.location, f.matches, d, g.v7_prependBasename, i, g.v7_relativeSplatPath, l == null ? void 0 : l.fromRouteId, l == null ? void 0 : l.relative), {
      path: p,
      submission: R,
      error: M
    } = Kt(g.v7_normalizeFormMethod, !1, u, l), C = f.location, E = ye(f.location, p, l && l.state);
    E = I({}, E, e.history.encodeLocation(E));
    let P = l && l.replace != null ? l.replace : void 0, D = $.Push;
    P === !0 ? D = $.Replace : P === !1 || R != null && ae(R.formMethod) && R.formAction === f.location.pathname + f.location.search && (D = $.Replace);
    let T = l && "preventScrollReset" in l ? l.preventScrollReset === !0 : void 0, _ = (l && l.flushSync) === !0, N = _t({
      currentLocation: C,
      nextLocation: E,
      historyAction: D
    });
    if (N) {
      qe(N, {
        state: "blocked",
        location: E,
        proceed() {
          qe(N, {
            state: "proceeding",
            proceed: void 0,
            reset: void 0,
            location: E
          }), Lt(i, l);
        },
        reset() {
          let q = new Map(f.blockers);
          q.set(N, Oe), te({
            blockers: q
          });
        }
      });
      return;
    }
    return await Pe(D, E, {
      submission: R,
      // Send through the formData serialization error if we have one so we can
      // render at the right error boundary after we match routes
      pendingError: M,
      preventScrollReset: T,
      replace: l && l.replace,
      enableViewTransition: l && l.viewTransition,
      flushSync: _
    });
  }
  function Mr() {
    if (dt(), te({
      revalidation: "loading"
    }), f.navigation.state !== "submitting") {
      if (f.navigation.state === "idle") {
        Pe(f.historyAction, f.location, {
          startUninterruptedRevalidation: !0
        });
        return;
      }
      Pe(j || f.historyAction, f.navigation.location, {
        overrideNavigation: f.navigation,
        // Proxy through any rending view transition
        enableViewTransition: G === !0
      });
    }
  }
  async function Pe(i, l, u) {
    A && A.abort(), A = null, j = i, re = (u && u.startUninterruptedRevalidation) === !0, Nr(f.location, f.matches), O = (u && u.preventScrollReset) === !0, G = (u && u.enableViewTransition) === !0;
    let p = c || o, R = u && u.overrideNavigation, M = pe(p, l, d), C = (u && u.flushSync) === !0, E = et(M, p, l.pathname);
    if (E.active && E.matches && (M = E.matches), !M) {
      let {
        error: k,
        notFoundMatches: W,
        route: J
      } = ut(l.pathname);
      Ce(l, {
        matches: W,
        loaderData: {},
        errors: {
          [J.id]: k
        }
      }, {
        flushSync: C
      });
      return;
    }
    if (f.initialized && !de && ja(f.location, l) && !(u && u.submission && ae(u.submission.formMethod))) {
      Ce(l, {
        matches: M
      }, {
        flushSync: C
      });
      return;
    }
    A = new AbortController();
    let P = _e(e.history, l, A.signal, u && u.submission), D;
    if (u && u.pendingError)
      D = [be(M).route.id, {
        type: H.error,
        error: u.pendingError
      }];
    else if (u && u.submission && ae(u.submission.formMethod)) {
      let k = await Tr(P, l, u.submission, M, E.active, {
        replace: u.replace,
        flushSync: C
      });
      if (k.shortCircuited)
        return;
      if (k.pendingActionResult) {
        let [W, J] = k.pendingActionResult;
        if (ee(J) && He(J.error) && J.error.status === 404) {
          A = null, Ce(l, {
            matches: k.matches,
            loaderData: {},
            errors: {
              [W]: J.error
            }
          });
          return;
        }
      }
      M = k.matches || M, D = k.pendingActionResult, R = pt(l, u.submission), C = !1, E.active = !1, P = _e(e.history, P.url, P.signal);
    }
    let {
      shortCircuited: T,
      matches: _,
      loaderData: N,
      errors: q
    } = await jr(P, l, M, E.active, R, u && u.submission, u && u.fetcherSubmission, u && u.replace, u && u.initialHydration === !0, C, D);
    T || (A = null, Ce(l, I({
      matches: _ || M
    }, Qt(D), {
      loaderData: N,
      errors: q
    })));
  }
  async function Tr(i, l, u, p, R, M) {
    M === void 0 && (M = {}), dt();
    let C = _a(l, u);
    if (te({
      navigation: C
    }, {
      flushSync: M.flushSync === !0
    }), R) {
      let D = await tt(p, l.pathname, i.signal);
      if (D.type === "aborted")
        return {
          shortCircuited: !0
        };
      if (D.type === "error") {
        let T = be(D.partialMatches).route.id;
        return {
          matches: D.partialMatches,
          pendingActionResult: [T, {
            type: H.error,
            error: D.error
          }]
        };
      } else if (D.matches)
        p = D.matches;
      else {
        let {
          notFoundMatches: T,
          error: _,
          route: N
        } = ut(l.pathname);
        return {
          matches: T,
          pendingActionResult: [N.id, {
            type: H.error,
            error: _
          }]
        };
      }
    }
    let E, P = Me(p, l);
    if (!P.route.action && !P.route.lazy)
      E = {
        type: H.error,
        error: Y(405, {
          method: i.method,
          pathname: l.pathname,
          routeId: P.route.id
        })
      };
    else if (E = (await We("action", f, i, [P], p, null))[P.route.id], i.signal.aborted)
      return {
        shortCircuited: !0
      };
    if (De(E)) {
      let D;
      return M && M.replace != null ? D = M.replace : D = Yt(E.response.headers.get("Location"), new URL(i.url), d) === f.location.pathname + f.location.search, await xe(i, E, !0, {
        submission: u,
        replace: D
      }), {
        shortCircuited: !0
      };
    }
    if (me(E))
      throw Y(400, {
        type: "defer-action"
      });
    if (ee(E)) {
      let D = be(p, P.route.id);
      return (M && M.replace) !== !0 && (j = $.Push), {
        matches: p,
        pendingActionResult: [D.route.id, E]
      };
    }
    return {
      matches: p,
      pendingActionResult: [P.route.id, E]
    };
  }
  async function jr(i, l, u, p, R, M, C, E, P, D, T) {
    let _ = R || pt(l, M), N = M || C || Zt(_), q = !re && (!g.v7_partialHydration || !P);
    if (p) {
      if (q) {
        let X = Mt(T);
        te(I({
          navigation: _
        }, X !== void 0 ? {
          actionData: X
        } : {}), {
          flushSync: D
        });
      }
      let z = await tt(u, l.pathname, i.signal);
      if (z.type === "aborted")
        return {
          shortCircuited: !0
        };
      if (z.type === "error") {
        let X = be(z.partialMatches).route.id;
        return {
          matches: z.partialMatches,
          loaderData: {},
          errors: {
            [X]: z.error
          }
        };
      } else if (z.matches)
        u = z.matches;
      else {
        let {
          error: X,
          notFoundMatches: Ue,
          route: $e
        } = ut(l.pathname);
        return {
          matches: Ue,
          loaderData: {},
          errors: {
            [$e.id]: X
          }
        };
      }
    }
    let k = c || o, [W, J] = kt(e.history, f, u, N, l, g.v7_partialHydration && P === !0, g.v7_skipActionErrorRevalidation, de, Je, Xe, fe, je, ue, k, d, T);
    if (ft((z) => !(u && u.some((X) => X.route.id === z)) || W && W.some((X) => X.route.id === z)), ze = ++Ge, W.length === 0 && J.length === 0) {
      let z = Ft();
      return Ce(l, I({
        matches: u,
        loaderData: {},
        // Commit pending error if we're short circuiting
        errors: T && ee(T[1]) ? {
          [T[0]]: T[1].error
        } : null
      }, Qt(T), z ? {
        fetchers: new Map(f.fetchers)
      } : {}), {
        flushSync: D
      }), {
        shortCircuited: !0
      };
    }
    if (q) {
      let z = {};
      if (!p) {
        z.navigation = _;
        let X = Mt(T);
        X !== void 0 && (z.actionData = X);
      }
      J.length > 0 && (z.fetchers = Cr(J)), te(z, {
        flushSync: D
      });
    }
    J.forEach((z) => {
      ve(z.key), z.controller && Z.set(z.key, z.controller);
    });
    let Fe = () => J.forEach((z) => ve(z.key));
    A && A.signal.addEventListener("abort", Fe);
    let {
      loaderResults: Ke,
      fetcherResults: he
    } = await Tt(f, u, W, J, i);
    if (i.signal.aborted)
      return {
        shortCircuited: !0
      };
    A && A.signal.removeEventListener("abort", Fe), J.forEach((z) => Z.delete(z.key));
    let oe = nt(Ke);
    if (oe)
      return await xe(i, oe.result, !0, {
        replace: E
      }), {
        shortCircuited: !0
      };
    if (oe = nt(he), oe)
      return ue.add(oe.key), await xe(i, oe.result, !0, {
        replace: E
      }), {
        shortCircuited: !0
      };
    let {
      loaderData: ct,
      errors: ke
    } = Xt(f, u, Ke, T, J, he, Se);
    Se.forEach((z, X) => {
      z.subscribe((Ue) => {
        (Ue || z.done) && Se.delete(X);
      });
    }), g.v7_partialHydration && P && f.errors && (ke = I({}, f.errors, ke));
    let Le = Ft(), rt = Ut(ze), at = Le || rt || J.length > 0;
    return I({
      matches: u,
      loaderData: ct,
      errors: ke
    }, at ? {
      fetchers: new Map(f.fetchers)
    } : {});
  }
  function Mt(i) {
    if (i && !ee(i[1]))
      return {
        [i[0]]: i[1].data
      };
    if (f.actionData)
      return Object.keys(f.actionData).length === 0 ? null : f.actionData;
  }
  function Cr(i) {
    return i.forEach((l) => {
      let u = f.fetchers.get(l.key), p = Ve(void 0, u ? u.data : void 0);
      f.fetchers.set(l.key, p);
    }), new Map(f.fetchers);
  }
  function Fr(i, l, u, p) {
    if (a)
      throw new Error("router.fetch() was called during the server render, but it shouldn't be. You are likely calling a useFetcher() method in the body of your component. Try moving it to a useEffect or a callback.");
    ve(i);
    let R = (p && p.flushSync) === !0, M = c || o, C = gt(f.location, f.matches, d, g.v7_prependBasename, u, g.v7_relativeSplatPath, l, p == null ? void 0 : p.relative), E = pe(M, C, d), P = et(E, M, C);
    if (P.active && P.matches && (E = P.matches), !E) {
      ce(i, l, Y(404, {
        pathname: C
      }), {
        flushSync: R
      });
      return;
    }
    let {
      path: D,
      submission: T,
      error: _
    } = Kt(g.v7_normalizeFormMethod, !0, C, p);
    if (_) {
      ce(i, l, _, {
        flushSync: R
      });
      return;
    }
    let N = Me(E, D), q = (p && p.preventScrollReset) === !0;
    if (T && ae(T.formMethod)) {
      Ur(i, l, D, N, E, P.active, R, q, T);
      return;
    }
    je.set(i, {
      routeId: l,
      path: D
    }), Ar(i, l, D, N, E, P.active, R, q, T);
  }
  async function Ur(i, l, u, p, R, M, C, E, P) {
    dt(), je.delete(i);
    function D(Q) {
      if (!Q.route.action && !Q.route.lazy) {
        let Ae = Y(405, {
          method: P.formMethod,
          pathname: u,
          routeId: l
        });
        return ce(i, l, Ae, {
          flushSync: C
        }), !0;
      }
      return !1;
    }
    if (!M && D(p))
      return;
    let T = f.fetchers.get(i);
    ge(i, Oa(P, T), {
      flushSync: C
    });
    let _ = new AbortController(), N = _e(e.history, u, _.signal, P);
    if (M) {
      let Q = await tt(R, u, N.signal);
      if (Q.type === "aborted")
        return;
      if (Q.type === "error") {
        ce(i, l, Q.error, {
          flushSync: C
        });
        return;
      } else if (Q.matches) {
        if (R = Q.matches, p = Me(R, u), D(p))
          return;
      } else {
        ce(i, l, Y(404, {
          pathname: u
        }), {
          flushSync: C
        });
        return;
      }
    }
    Z.set(i, _);
    let q = Ge, W = (await We("action", f, N, [p], R, i))[p.route.id];
    if (N.signal.aborted) {
      Z.get(i) === _ && Z.delete(i);
      return;
    }
    if (g.v7_fetcherPersist && fe.has(i)) {
      if (De(W) || ee(W)) {
        ge(i, we(void 0));
        return;
      }
    } else {
      if (De(W))
        if (Z.delete(i), ze > q) {
          ge(i, we(void 0));
          return;
        } else
          return ue.add(i), ge(i, Ve(P)), xe(N, W, !1, {
            fetcherSubmission: P,
            preventScrollReset: E
          });
      if (ee(W)) {
        ce(i, l, W.error);
        return;
      }
    }
    if (me(W))
      throw Y(400, {
        type: "defer-action"
      });
    let J = f.navigation.location || f.location, Fe = _e(e.history, J, _.signal), Ke = c || o, he = f.navigation.state !== "idle" ? pe(Ke, f.navigation.location, d) : f.matches;
    B(he, "Didn't find any matches after fetcher action");
    let oe = ++Ge;
    Te.set(i, oe);
    let ct = Ve(P, W.data);
    f.fetchers.set(i, ct);
    let [ke, Le] = kt(e.history, f, he, P, J, !1, g.v7_skipActionErrorRevalidation, de, Je, Xe, fe, je, ue, Ke, d, [p.route.id, W]);
    Le.filter((Q) => Q.key !== i).forEach((Q) => {
      let Ae = Q.key, Nt = f.fetchers.get(Ae), Br = Ve(void 0, Nt ? Nt.data : void 0);
      f.fetchers.set(Ae, Br), ve(Ae), Q.controller && Z.set(Ae, Q.controller);
    }), te({
      fetchers: new Map(f.fetchers)
    });
    let rt = () => Le.forEach((Q) => ve(Q.key));
    _.signal.addEventListener("abort", rt);
    let {
      loaderResults: at,
      fetcherResults: z
    } = await Tt(f, he, ke, Le, Fe);
    if (_.signal.aborted)
      return;
    _.signal.removeEventListener("abort", rt), Te.delete(i), Z.delete(i), Le.forEach((Q) => Z.delete(Q.key));
    let X = nt(at);
    if (X)
      return xe(Fe, X.result, !1, {
        preventScrollReset: E
      });
    if (X = nt(z), X)
      return ue.add(X.key), xe(Fe, X.result, !1, {
        preventScrollReset: E
      });
    let {
      loaderData: Ue,
      errors: $e
    } = Xt(f, he, at, void 0, Le, z, Se);
    if (f.fetchers.has(i)) {
      let Q = we(W.data);
      f.fetchers.set(i, Q);
    }
    Ut(oe), f.navigation.state === "loading" && oe > ze ? (B(j, "Expected pending action"), A && A.abort(), Ce(f.navigation.location, {
      matches: he,
      loaderData: Ue,
      errors: $e,
      fetchers: new Map(f.fetchers)
    })) : (te({
      errors: $e,
      loaderData: Gt(f.loaderData, Ue, he, $e),
      fetchers: new Map(f.fetchers)
    }), de = !1);
  }
  async function Ar(i, l, u, p, R, M, C, E, P) {
    let D = f.fetchers.get(i);
    ge(i, Ve(P, D ? D.data : void 0), {
      flushSync: C
    });
    let T = new AbortController(), _ = _e(e.history, u, T.signal);
    if (M) {
      let W = await tt(R, u, _.signal);
      if (W.type === "aborted")
        return;
      if (W.type === "error") {
        ce(i, l, W.error, {
          flushSync: C
        });
        return;
      } else if (W.matches)
        R = W.matches, p = Me(R, u);
      else {
        ce(i, l, Y(404, {
          pathname: u
        }), {
          flushSync: C
        });
        return;
      }
    }
    Z.set(i, T);
    let N = Ge, k = (await We("loader", f, _, [p], R, i))[p.route.id];
    if (me(k) && (k = await Pt(k, _.signal, !0) || k), Z.get(i) === T && Z.delete(i), !_.signal.aborted) {
      if (fe.has(i)) {
        ge(i, we(void 0));
        return;
      }
      if (De(k))
        if (ze > N) {
          ge(i, we(void 0));
          return;
        } else {
          ue.add(i), await xe(_, k, !1, {
            preventScrollReset: E
          });
          return;
        }
      if (ee(k)) {
        ce(i, l, k.error);
        return;
      }
      B(!me(k), "Unhandled fetcher deferred data"), ge(i, we(k.data));
    }
  }
  async function xe(i, l, u, p) {
    let {
      submission: R,
      fetcherSubmission: M,
      preventScrollReset: C,
      replace: E
    } = p === void 0 ? {} : p;
    l.response.headers.has("X-Remix-Revalidate") && (de = !0);
    let P = l.response.headers.get("Location");
    B(P, "Expected a Location header on the redirect Response"), P = Yt(P, new URL(i.url), d);
    let D = ye(f.location, P, {
      _isRedirect: !0
    });
    if (r) {
      let W = !1;
      if (l.response.headers.has("X-Remix-Reload-Document"))
        W = !0;
      else if (Et.test(P)) {
        const J = e.history.createURL(P);
        W = // Hard reload if it's an absolute URL to a new origin
        J.origin !== t.location.origin || // Hard reload if it's an absolute URL that does not match our basename
        Ye(J.pathname, d) == null;
      }
      if (W) {
        E ? t.location.replace(P) : t.location.assign(P);
        return;
      }
    }
    A = null;
    let T = E === !0 || l.response.headers.has("X-Remix-Replace") ? $.Replace : $.Push, {
      formMethod: _,
      formAction: N,
      formEncType: q
    } = f.navigation;
    !R && !M && _ && N && q && (R = Zt(f.navigation));
    let k = R || M;
    if (Da.has(l.response.status) && k && ae(k.formMethod))
      await Pe(T, D, {
        submission: I({}, k, {
          formAction: P
        }),
        // Preserve these flags across redirects
        preventScrollReset: C || O,
        enableViewTransition: u ? G : void 0
      });
    else {
      let W = pt(D, R);
      await Pe(T, D, {
        overrideNavigation: W,
        // Send fetcher submissions through for shouldRevalidate
        fetcherSubmission: M,
        // Preserve these flags across redirects
        preventScrollReset: C || O,
        enableViewTransition: u ? G : void 0
      });
    }
  }
  async function We(i, l, u, p, R, M) {
    let C, E = {};
    try {
      C = await vr(m, i, l, u, p, R, M, s, n);
    } catch (P) {
      return p.forEach((D) => {
        E[D.route.id] = {
          type: H.error,
          error: P
        };
      }), E;
    }
    for (let [P, D] of Object.entries(C))
      if (Sr(D)) {
        let T = D.result;
        E[P] = {
          type: H.redirect,
          response: br(T, u, P, R, d, g.v7_relativeSplatPath)
        };
      } else
        E[P] = await wr(D);
    return E;
  }
  async function Tt(i, l, u, p, R) {
    let M = i.matches, C = We("loader", i, R, u, l, null), E = Promise.all(p.map(async (T) => {
      if (T.matches && T.match && T.controller) {
        let N = (await We("loader", i, _e(e.history, T.path, T.controller.signal), [T.match], T.matches, T.key))[T.match.route.id];
        return {
          [T.key]: N
        };
      } else
        return Promise.resolve({
          [T.key]: {
            type: H.error,
            error: Y(404, {
              pathname: T.path
            })
          }
        });
    })), P = await C, D = (await E).reduce((T, _) => Object.assign(T, _), {});
    return await Promise.all([Ua(l, P, R.signal, M, i.loaderData), Aa(l, D, p)]), {
      loaderResults: P,
      fetcherResults: D
    };
  }
  function dt() {
    de = !0, Je.push(...ft()), je.forEach((i, l) => {
      Z.has(l) && Xe.add(l), ve(l);
    });
  }
  function ge(i, l, u) {
    u === void 0 && (u = {}), f.fetchers.set(i, l), te({
      fetchers: new Map(f.fetchers)
    }, {
      flushSync: (u && u.flushSync) === !0
    });
  }
  function ce(i, l, u, p) {
    p === void 0 && (p = {});
    let R = be(f.matches, l);
    Ze(i), te({
      errors: {
        [R.route.id]: u
      },
      fetchers: new Map(f.fetchers)
    }, {
      flushSync: (p && p.flushSync) === !0
    });
  }
  function jt(i) {
    return g.v7_fetcherPersist && (Be.set(i, (Be.get(i) || 0) + 1), fe.has(i) && fe.delete(i)), f.fetchers.get(i) || fr;
  }
  function Ze(i) {
    let l = f.fetchers.get(i);
    Z.has(i) && !(l && l.state === "loading" && Te.has(i)) && ve(i), je.delete(i), Te.delete(i), ue.delete(i), fe.delete(i), Xe.delete(i), f.fetchers.delete(i);
  }
  function _r(i) {
    if (g.v7_fetcherPersist) {
      let l = (Be.get(i) || 0) - 1;
      l <= 0 ? (Be.delete(i), fe.add(i)) : Be.set(i, l);
    } else
      Ze(i);
    te({
      fetchers: new Map(f.fetchers)
    });
  }
  function ve(i) {
    let l = Z.get(i);
    l && (l.abort(), Z.delete(i));
  }
  function Ct(i) {
    for (let l of i) {
      let u = jt(l), p = we(u.data);
      f.fetchers.set(l, p);
    }
  }
  function Ft() {
    let i = [], l = !1;
    for (let u of ue) {
      let p = f.fetchers.get(u);
      B(p, "Expected fetcher: " + u), p.state === "loading" && (ue.delete(u), i.push(u), l = !0);
    }
    return Ct(i), l;
  }
  function Ut(i) {
    let l = [];
    for (let [u, p] of Te)
      if (p < i) {
        let R = f.fetchers.get(u);
        B(R, "Expected fetcher: " + u), R.state === "loading" && (ve(u), Te.delete(u), l.push(u));
      }
    return Ct(l), l.length > 0;
  }
  function Or(i, l) {
    let u = f.blockers.get(i) || Oe;
    return Ee.get(i) !== l && Ee.set(i, l), u;
  }
  function At(i) {
    f.blockers.delete(i), Ee.delete(i);
  }
  function qe(i, l) {
    let u = f.blockers.get(i) || Oe;
    B(u.state === "unblocked" && l.state === "blocked" || u.state === "blocked" && l.state === "blocked" || u.state === "blocked" && l.state === "proceeding" || u.state === "blocked" && l.state === "unblocked" || u.state === "proceeding" && l.state === "unblocked", "Invalid blocker state transition: " + u.state + " -> " + l.state);
    let p = new Map(f.blockers);
    p.set(i, l), te({
      blockers: p
    });
  }
  function _t(i) {
    let {
      currentLocation: l,
      nextLocation: u,
      historyAction: p
    } = i;
    if (Ee.size === 0)
      return;
    Ee.size > 1 && le(!1, "A router only supports one blocker at a time");
    let R = Array.from(Ee.entries()), [M, C] = R[R.length - 1], E = f.blockers.get(M);
    if (!(E && E.state === "proceeding") && C({
      currentLocation: l,
      nextLocation: u,
      historyAction: p
    }))
      return M;
  }
  function ut(i) {
    let l = Y(404, {
      pathname: i
    }), u = c || o, {
      matches: p,
      route: R
    } = st(u);
    return ft(), {
      notFoundMatches: p,
      route: R,
      error: l
    };
  }
  function ft(i) {
    let l = [];
    return Se.forEach((u, p) => {
      (!i || i(p)) && (u.cancel(), l.push(p), Se.delete(p));
    }), l;
  }
  function Ir(i, l, u) {
    if (v = i, L = l, w = u || null, !U && f.navigation === ot) {
      U = !0;
      let p = It(f.location, f.matches);
      p != null && te({
        restoreScrollPosition: p
      });
    }
    return () => {
      v = null, L = null, w = null;
    };
  }
  function Ot(i, l) {
    return w && w(i, l.map((p) => er(p, f.loaderData))) || i.key;
  }
  function Nr(i, l) {
    if (v && L) {
      let u = Ot(i, l);
      v[u] = L();
    }
  }
  function It(i, l) {
    if (v) {
      let u = Ot(i, l), p = v[u];
      if (typeof p == "number")
        return p;
    }
    return null;
  }
  function et(i, l, u) {
    if (y)
      if (i) {
        if (Object.keys(i[0].params).length > 0)
          return {
            active: !0,
            matches: it(l, u, d, !0)
          };
      } else
        return {
          active: !0,
          matches: it(l, u, d, !0) || []
        };
    return {
      active: !1,
      matches: null
    };
  }
  async function tt(i, l, u) {
    if (!y)
      return {
        type: "success",
        matches: i
      };
    let p = i;
    for (; ; ) {
      let R = c == null, M = c || o, C = s;
      try {
        await y({
          path: l,
          matches: p,
          patch: (D, T) => {
            u.aborted || Vt(D, T, M, C, n);
          }
        });
      } catch (D) {
        return {
          type: "error",
          error: D,
          partialMatches: p
        };
      } finally {
        R && !u.aborted && (o = [...o]);
      }
      if (u.aborted)
        return {
          type: "aborted"
        };
      let E = pe(M, l, d);
      if (E)
        return {
          type: "success",
          matches: E
        };
      let P = it(M, l, d, !0);
      if (!P || p.length === P.length && p.every((D, T) => D.route.id === P[T].route.id))
        return {
          type: "success",
          matches: null
        };
      p = P;
    }
  }
  function Hr(i) {
    s = {}, c = Ne(i, n, void 0, s);
  }
  function zr(i, l) {
    let u = c == null;
    Vt(i, l, c || o, s, n), u && (o = [...o], te({}));
  }
  return K = {
    get basename() {
      return d;
    },
    get future() {
      return g;
    },
    get state() {
      return f;
    },
    get routes() {
      return o;
    },
    get window() {
      return t;
    },
    initialize: Pr,
    subscribe: Lr,
    enableScrollRestoration: Ir,
    navigate: Lt,
    fetch: Fr,
    revalidate: Mr,
    // Passthrough to history-aware createHref used by useHref so we get proper
    // hash-aware URLs in DOM paths
    createHref: (i) => e.history.createHref(i),
    encodeLocation: (i) => e.history.encodeLocation(i),
    getFetcher: jt,
    deleteFetcher: _r,
    dispose: xr,
    getBlocker: Or,
    deleteBlocker: At,
    patchRoutes: zr,
    _internalFetchControllers: Z,
    _internalActiveDeferreds: Se,
    // TODO: Remove setRoutes, it's temporary to avoid dealing with
    // updating the tree while validating the update algorithm.
    _internalSetRoutes: Hr
  }, K;
}
const pr = Symbol("deferred");
function Ea(e, t) {
  B(e.length > 0, "You must provide a non-empty routes array to createStaticHandler");
  let r = {}, a = (t ? t.basename : null) || "/", n;
  if (t != null && t.mapRouteProperties)
    n = t.mapRouteProperties;
  else if (t != null && t.detectErrorBoundary) {
    let h = t.detectErrorBoundary;
    n = (v) => ({
      hasErrorBoundary: h(v)
    });
  } else
    n = cr;
  let s = I({
    v7_relativeSplatPath: !1,
    v7_throwAbortReason: !1
  }, t ? t.future : null), o = Ne(e, n, void 0, r);
  async function c(h, v) {
    let {
      requestContext: w,
      skipLoaderErrorBubbling: L,
      dataStrategy: U
    } = v === void 0 ? {} : v, x = new URL(h.url), F = h.method, b = ye("", se(x), null, "default"), K = pe(o, b, a);
    if (!Dt(F) && F !== "HEAD") {
      let j = Y(405, {
        method: F
      }), {
        matches: O,
        route: A
      } = st(o);
      return {
        basename: a,
        location: b,
        matches: O,
        loaderData: {},
        actionData: null,
        errors: {
          [A.id]: j
        },
        statusCode: j.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    } else if (!K) {
      let j = Y(404, {
        pathname: b.pathname
      }), {
        matches: O,
        route: A
      } = st(o);
      return {
        basename: a,
        location: b,
        matches: O,
        loaderData: {},
        actionData: null,
        errors: {
          [A.id]: j
        },
        statusCode: j.status,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    let f = await m(h, b, K, w, U || null, L === !0, null);
    return Re(f) ? f : I({
      location: b,
      basename: a
    }, f);
  }
  async function d(h, v) {
    let {
      routeId: w,
      requestContext: L,
      dataStrategy: U
    } = v === void 0 ? {} : v, x = new URL(h.url), F = h.method, b = ye("", se(x), null, "default"), K = pe(o, b, a);
    if (!Dt(F) && F !== "HEAD" && F !== "OPTIONS")
      throw Y(405, {
        method: F
      });
    if (!K)
      throw Y(404, {
        pathname: b.pathname
      });
    let f = w ? K.find((G) => G.route.id === w) : Me(K, b);
    if (w && !f)
      throw Y(403, {
        pathname: b.pathname,
        routeId: w
      });
    if (!f)
      throw Y(404, {
        pathname: b.pathname
      });
    let j = await m(h, b, K, L, U || null, !1, f);
    if (Re(j))
      return j;
    let O = j.errors ? Object.values(j.errors)[0] : void 0;
    if (O !== void 0)
      throw O;
    if (j.actionData)
      return Object.values(j.actionData)[0];
    if (j.loaderData) {
      var A;
      let G = Object.values(j.loaderData)[0];
      return (A = j.activeDeferreds) != null && A[f.route.id] && (G[pr] = j.activeDeferreds[f.route.id]), G;
    }
  }
  async function m(h, v, w, L, U, x, F) {
    B(h.signal, "query()/queryRoute() requests must contain an AbortController signal");
    try {
      if (ae(h.method.toLowerCase()))
        return await y(h, w, F || Me(w, v), L, U, x, F != null);
      let b = await g(h, w, L, U, x, F);
      return Re(b) ? b : I({}, b, {
        actionData: null,
        actionHeaders: {}
      });
    } catch (b) {
      if (Ca(b) && Re(b.result)) {
        if (b.type === H.error)
          throw b.result;
        return b.result;
      }
      if (Fa(b))
        return b;
      throw b;
    }
  }
  async function y(h, v, w, L, U, x, F) {
    let b;
    if (!w.route.action && !w.route.lazy) {
      let j = Y(405, {
        method: h.method,
        pathname: new URL(h.url).pathname,
        routeId: w.route.id
      });
      if (F)
        throw j;
      b = {
        type: H.error,
        error: j
      };
    } else
      b = (await S("action", h, [w], v, F, L, U))[w.route.id], h.signal.aborted && Wt(h, F, s);
    if (De(b))
      throw new Response(null, {
        status: b.response.status,
        headers: {
          Location: b.response.headers.get("Location")
        }
      });
    if (me(b)) {
      let j = Y(400, {
        type: "defer-action"
      });
      if (F)
        throw j;
      b = {
        type: H.error,
        error: j
      };
    }
    if (F) {
      if (ee(b))
        throw b.error;
      return {
        matches: [w],
        loaderData: {},
        actionData: {
          [w.route.id]: b.data
        },
        errors: null,
        // Note: statusCode + headers are unused here since queryRoute will
        // return the raw Response or value
        statusCode: 200,
        loaderHeaders: {},
        actionHeaders: {},
        activeDeferreds: null
      };
    }
    let K = new Request(h.url, {
      headers: h.headers,
      redirect: h.redirect,
      signal: h.signal
    });
    if (ee(b)) {
      let j = x ? w : be(v, w.route.id), O = await g(K, v, L, U, x, null, [j.route.id, b]);
      return I({}, O, {
        statusCode: He(b.error) ? b.error.status : b.statusCode != null ? b.statusCode : 500,
        actionData: null,
        actionHeaders: I({}, b.headers ? {
          [w.route.id]: b.headers
        } : {})
      });
    }
    let f = await g(K, v, L, U, x, null);
    return I({}, f, {
      actionData: {
        [w.route.id]: b.data
      }
    }, b.statusCode ? {
      statusCode: b.statusCode
    } : {}, {
      actionHeaders: b.headers ? {
        [w.route.id]: b.headers
      } : {}
    });
  }
  async function g(h, v, w, L, U, x, F) {
    let b = x != null;
    if (b && !(x != null && x.route.loader) && !(x != null && x.route.lazy))
      throw Y(400, {
        method: h.method,
        pathname: new URL(h.url).pathname,
        routeId: x == null ? void 0 : x.route.id
      });
    let f = (x ? [x] : F && ee(F[1]) ? vt(v, F[0]) : v).filter((V) => V.route.loader || V.route.lazy);
    if (f.length === 0)
      return {
        matches: v,
        // Add a null for all matched routes for proper revalidation on the client
        loaderData: v.reduce((V, ne) => Object.assign(V, {
          [ne.route.id]: null
        }), {}),
        errors: F && ee(F[1]) ? {
          [F[0]]: F[1].error
        } : null,
        statusCode: 200,
        loaderHeaders: {},
        activeDeferreds: null
      };
    let j = await S("loader", h, f, v, b, w, L);
    h.signal.aborted && Wt(h, b, s);
    let O = /* @__PURE__ */ new Map(), A = Rr(v, j, F, O, U), G = new Set(f.map((V) => V.route.id));
    return v.forEach((V) => {
      G.has(V.route.id) || (A.loaderData[V.route.id] = null);
    }), I({}, A, {
      matches: v,
      activeDeferreds: O.size > 0 ? Object.fromEntries(O.entries()) : null
    });
  }
  async function S(h, v, w, L, U, x, F) {
    let b = await vr(F || gr, h, null, v, w, L, null, r, n, x), K = {};
    return await Promise.all(L.map(async (f) => {
      if (!(f.route.id in b))
        return;
      let j = b[f.route.id];
      if (Sr(j)) {
        let O = j.result;
        throw br(O, v, f.route.id, L, a, s.v7_relativeSplatPath);
      }
      if (Re(j.result) && U)
        throw j;
      K[f.route.id] = await wr(j);
    })), K;
  }
  return {
    dataRoutes: o,
    query: c,
    queryRoute: d
  };
}
function Pa(e, t, r) {
  return I({}, t, {
    statusCode: He(r) ? r.status : 500,
    errors: {
      [t._deepestRenderedBoundaryId || e[0].id]: r
    }
  });
}
function Wt(e, t, r) {
  if (r.v7_throwAbortReason && e.signal.reason !== void 0)
    throw e.signal.reason;
  let a = t ? "queryRoute" : "query";
  throw new Error(a + "() call aborted: " + e.method + " " + e.url);
}
function xa(e) {
  return e != null && ("formData" in e && e.formData != null || "body" in e && e.body !== void 0);
}
function gt(e, t, r, a, n, s, o, c) {
  let d, m;
  if (o) {
    d = [];
    for (let g of t)
      if (d.push(g), g.route.id === o) {
        m = g;
        break;
      }
  } else
    d = t, m = t[t.length - 1];
  let y = lr(n || ".", or(d, s), Ye(e.pathname, r) || e.pathname, c === "path");
  if (n == null && (y.search = e.search, y.hash = e.hash), (n == null || n === "" || n === ".") && m) {
    let g = xt(y.search);
    if (m.route.index && !g)
      y.search = y.search ? y.search.replace(/^\?/, "?index&") : "?index";
    else if (!m.route.index && g) {
      let S = new URLSearchParams(y.search), h = S.getAll("index");
      S.delete("index"), h.filter((w) => w).forEach((w) => S.append("index", w));
      let v = S.toString();
      y.search = v ? "?" + v : "";
    }
  }
  return a && r !== "/" && (y.pathname = y.pathname === "/" ? r : Ie([r, y.pathname])), se(y);
}
function Kt(e, t, r, a) {
  if (!a || !xa(a))
    return {
      path: r
    };
  if (a.formMethod && !Dt(a.formMethod))
    return {
      path: r,
      error: Y(405, {
        method: a.formMethod
      })
    };
  let n = () => ({
    path: r,
    error: Y(400, {
      type: "invalid-body"
    })
  }), s = a.formMethod || "get", o = e ? s.toUpperCase() : s.toLowerCase(), c = Dr(r);
  if (a.body !== void 0) {
    if (a.formEncType === "text/plain") {
      if (!ae(o))
        return n();
      let S = typeof a.body == "string" ? a.body : a.body instanceof FormData || a.body instanceof URLSearchParams ? (
        // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data
        Array.from(a.body.entries()).reduce((h, v) => {
          let [w, L] = v;
          return "" + h + w + "=" + L + `
`;
        }, "")
      ) : String(a.body);
      return {
        path: r,
        submission: {
          formMethod: o,
          formAction: c,
          formEncType: a.formEncType,
          formData: void 0,
          json: void 0,
          text: S
        }
      };
    } else if (a.formEncType === "application/json") {
      if (!ae(o))
        return n();
      try {
        let S = typeof a.body == "string" ? JSON.parse(a.body) : a.body;
        return {
          path: r,
          submission: {
            formMethod: o,
            formAction: c,
            formEncType: a.formEncType,
            formData: void 0,
            json: S,
            text: void 0
          }
        };
      } catch {
        return n();
      }
    }
  }
  B(typeof FormData == "function", "FormData is not available in this environment");
  let d, m;
  if (a.formData)
    d = bt(a.formData), m = a.formData;
  else if (a.body instanceof FormData)
    d = bt(a.body), m = a.body;
  else if (a.body instanceof URLSearchParams)
    d = a.body, m = Jt(d);
  else if (a.body == null)
    d = new URLSearchParams(), m = new FormData();
  else
    try {
      d = new URLSearchParams(a.body), m = Jt(d);
    } catch {
      return n();
    }
  let y = {
    formMethod: o,
    formAction: c,
    formEncType: a && a.formEncType || "application/x-www-form-urlencoded",
    formData: m,
    json: void 0,
    text: void 0
  };
  if (ae(y.formMethod))
    return {
      path: r,
      submission: y
    };
  let g = ie(r);
  return t && g.search && xt(g.search) && d.append("index", ""), g.search = "?" + d, {
    path: se(g),
    submission: y
  };
}
function vt(e, t, r) {
  r === void 0 && (r = !1);
  let a = e.findIndex((n) => n.route.id === t);
  return a >= 0 ? e.slice(0, r ? a + 1 : a) : e;
}
function kt(e, t, r, a, n, s, o, c, d, m, y, g, S, h, v, w) {
  let L = w ? ee(w[1]) ? w[1].error : w[1].data : void 0, U = e.createURL(t.location), x = e.createURL(n), F = r;
  s && t.errors ? F = vt(r, Object.keys(t.errors)[0], !0) : w && ee(w[1]) && (F = vt(r, w[0]));
  let b = w ? w[1].statusCode : void 0, K = o && b && b >= 400, f = F.filter((O, A) => {
    let {
      route: G
    } = O;
    if (G.lazy)
      return !0;
    if (G.loader == null)
      return !1;
    if (s)
      return wt(G, t.loaderData, t.errors);
    if (La(t.loaderData, t.matches[A], O) || d.some((re) => re === O.route.id))
      return !0;
    let V = t.matches[A], ne = O;
    return $t(O, I({
      currentUrl: U,
      currentParams: V.params,
      nextUrl: x,
      nextParams: ne.params
    }, a, {
      actionResult: L,
      actionStatus: b,
      defaultShouldRevalidate: K ? !1 : (
        // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate
        c || U.pathname + U.search === x.pathname + x.search || // Search params affect all loaders
        U.search !== x.search || mr(V, ne)
      )
    }));
  }), j = [];
  return g.forEach((O, A) => {
    if (s || !r.some((de) => de.route.id === O.routeId) || y.has(A))
      return;
    let G = pe(h, O.path, v);
    if (!G) {
      j.push({
        key: A,
        routeId: O.routeId,
        path: O.path,
        matches: null,
        match: null,
        controller: null
      });
      return;
    }
    let V = t.fetchers.get(A), ne = Me(G, O.path), re = !1;
    S.has(A) ? re = !1 : m.has(A) ? (m.delete(A), re = !0) : V && V.state !== "idle" && V.data === void 0 ? re = c : re = $t(ne, I({
      currentUrl: U,
      currentParams: t.matches[t.matches.length - 1].params,
      nextUrl: x,
      nextParams: r[r.length - 1].params
    }, a, {
      actionResult: L,
      actionStatus: b,
      defaultShouldRevalidate: K ? !1 : c
    })), re && j.push({
      key: A,
      routeId: O.routeId,
      path: O.path,
      matches: G,
      match: ne,
      controller: new AbortController()
    });
  }), [f, j];
}
function wt(e, t, r) {
  if (e.lazy)
    return !0;
  if (!e.loader)
    return !1;
  let a = t != null && t[e.id] !== void 0, n = r != null && r[e.id] !== void 0;
  return !a && n ? !1 : typeof e.loader == "function" && e.loader.hydrate === !0 ? !0 : !a && !n;
}
function La(e, t, r) {
  let a = (
    // [a] -> [a, b]
    !t || // [a, b] -> [a, c]
    r.route.id !== t.route.id
  ), n = e[r.route.id] === void 0;
  return a || n;
}
function mr(e, t) {
  let r = e.route.path;
  return (
    // param change for this match, /users/123 -> /users/456
    e.pathname !== t.pathname || // splat param changed, which is not present in match.path
    // e.g. /files/images/avatar.jpg -> files/finances.xls
    r != null && r.endsWith("*") && e.params["*"] !== t.params["*"]
  );
}
function $t(e, t) {
  if (e.route.shouldRevalidate) {
    let r = e.route.shouldRevalidate(t);
    if (typeof r == "boolean")
      return r;
  }
  return t.defaultShouldRevalidate;
}
function Vt(e, t, r, a, n) {
  var s;
  let o;
  if (e) {
    let m = a[e];
    B(m, "No route found to patch children into: routeId = " + e), m.children || (m.children = []), o = m.children;
  } else
    o = r;
  let c = t.filter((m) => !o.some((y) => yr(m, y))), d = Ne(c, n, [e || "_", "patch", String(((s = o) == null ? void 0 : s.length) || "0")], a);
  o.push(...d);
}
function yr(e, t) {
  return "id" in e && "id" in t && e.id === t.id ? !0 : e.index === t.index && e.path === t.path && e.caseSensitive === t.caseSensitive ? (!e.children || e.children.length === 0) && (!t.children || t.children.length === 0) ? !0 : e.children.every((r, a) => {
    var n;
    return (n = t.children) == null ? void 0 : n.some((s) => yr(r, s));
  }) : !1;
}
async function Ma(e, t, r) {
  if (!e.lazy)
    return;
  let a = await e.lazy();
  if (!e.lazy)
    return;
  let n = r[e.id];
  B(n, "No route found in manifest");
  let s = {};
  for (let o in a) {
    let d = n[o] !== void 0 && // This property isn't static since it should always be updated based
    // on the route updates
    o !== "hasErrorBoundary";
    le(!d, 'Route "' + n.id + '" has a static property "' + o + '" defined but its lazy function is also returning a value for this property. ' + ('The lazy route property "' + o + '" will be ignored.')), !d && !Vr.has(o) && (s[o] = a[o]);
  }
  Object.assign(n, s), Object.assign(n, I({}, t(n), {
    lazy: void 0
  }));
}
async function gr(e) {
  let {
    matches: t
  } = e, r = t.filter((n) => n.shouldLoad);
  return (await Promise.all(r.map((n) => n.resolve()))).reduce((n, s, o) => Object.assign(n, {
    [r[o].route.id]: s
  }), {});
}
async function vr(e, t, r, a, n, s, o, c, d, m) {
  let y = s.map((h) => h.route.lazy ? Ma(h.route, d, c) : void 0), g = s.map((h, v) => {
    let w = y[v], L = n.some((x) => x.route.id === h.route.id);
    return I({}, h, {
      shouldLoad: L,
      resolve: async (x) => (x && a.method === "GET" && (h.route.lazy || h.route.loader) && (L = !0), L ? Ta(t, a, h, w, x, m) : Promise.resolve({
        type: H.data,
        result: void 0
      }))
    });
  }), S = await e({
    matches: g,
    request: a,
    params: s[0].params,
    fetcherKey: o,
    context: m
  });
  try {
    await Promise.all(y);
  } catch {
  }
  return S;
}
async function Ta(e, t, r, a, n, s) {
  let o, c, d = (m) => {
    let y, g = new Promise((v, w) => y = w);
    c = () => y(), t.signal.addEventListener("abort", c);
    let S = (v) => typeof m != "function" ? Promise.reject(new Error("You cannot call the handler for a route which defines a boolean " + ('"' + e + '" [routeId: ' + r.route.id + "]"))) : m({
      request: t,
      params: r.params,
      context: s
    }, ...v !== void 0 ? [v] : []), h = (async () => {
      try {
        return {
          type: "data",
          result: await (n ? n((w) => S(w)) : S())
        };
      } catch (v) {
        return {
          type: "error",
          result: v
        };
      }
    })();
    return Promise.race([h, g]);
  };
  try {
    let m = r.route[e];
    if (a)
      if (m) {
        let y, [g] = await Promise.all([
          // If the handler throws, don't let it immediately bubble out,
          // since we need to let the lazy() execution finish so we know if this
          // route has a boundary that can handle the error
          d(m).catch((S) => {
            y = S;
          }),
          a
        ]);
        if (y !== void 0)
          throw y;
        o = g;
      } else if (await a, m = r.route[e], m)
        o = await d(m);
      else if (e === "action") {
        let y = new URL(t.url), g = y.pathname + y.search;
        throw Y(405, {
          method: t.method,
          pathname: g,
          routeId: r.route.id
        });
      } else
        return {
          type: H.data,
          result: void 0
        };
    else if (m)
      o = await d(m);
    else {
      let y = new URL(t.url), g = y.pathname + y.search;
      throw Y(404, {
        pathname: g
      });
    }
    B(o.result !== void 0, "You defined " + (e === "action" ? "an action" : "a loader") + " for route " + ('"' + r.route.id + "\" but didn't return anything from your `" + e + "` ") + "function. Please return a value or `null`.");
  } catch (m) {
    return {
      type: H.error,
      result: m
    };
  } finally {
    c && t.signal.removeEventListener("abort", c);
  }
  return o;
}
async function wr(e) {
  let {
    result: t,
    type: r
  } = e;
  if (Re(t)) {
    let m;
    try {
      let y = t.headers.get("Content-Type");
      y && /\bapplication\/json\b/.test(y) ? t.body == null ? m = null : m = await t.json() : m = await t.text();
    } catch (y) {
      return {
        type: H.error,
        error: y
      };
    }
    return r === H.error ? {
      type: H.error,
      error: new lt(t.status, t.statusText, m),
      statusCode: t.status,
      headers: t.headers
    } : {
      type: H.data,
      data: m,
      statusCode: t.status,
      headers: t.headers
    };
  }
  if (r === H.error) {
    if (Rt(t)) {
      var a;
      if (t.data instanceof Error) {
        var n;
        return {
          type: H.error,
          error: t.data,
          statusCode: (n = t.init) == null ? void 0 : n.status
        };
      }
      t = new lt(((a = t.init) == null ? void 0 : a.status) || 500, void 0, t.data);
    }
    return {
      type: H.error,
      error: t,
      statusCode: He(t) ? t.status : void 0
    };
  }
  if (Er(t)) {
    var s, o;
    return {
      type: H.deferred,
      deferredData: t,
      statusCode: (s = t.init) == null ? void 0 : s.status,
      headers: ((o = t.init) == null ? void 0 : o.headers) && new Headers(t.init.headers)
    };
  }
  if (Rt(t)) {
    var c, d;
    return {
      type: H.data,
      data: t.data,
      statusCode: (c = t.init) == null ? void 0 : c.status,
      headers: (d = t.init) != null && d.headers ? new Headers(t.init.headers) : void 0
    };
  }
  return {
    type: H.data,
    data: t
  };
}
function br(e, t, r, a, n, s) {
  let o = e.headers.get("Location");
  if (B(o, "Redirects returned/thrown from loaders/actions must have a Location header"), !Et.test(o)) {
    let c = a.slice(0, a.findIndex((d) => d.route.id === r) + 1);
    o = gt(new URL(t.url), c, n, !0, o, s), e.headers.set("Location", o);
  }
  return e;
}
function Yt(e, t, r) {
  if (Et.test(e)) {
    let a = e, n = a.startsWith("//") ? new URL(t.protocol + a) : new URL(a), s = Ye(n.pathname, r) != null;
    if (n.origin === t.origin && s)
      return n.pathname + n.search + n.hash;
  }
  return e;
}
function _e(e, t, r, a) {
  let n = e.createURL(Dr(t)).toString(), s = {
    signal: r
  };
  if (a && ae(a.formMethod)) {
    let {
      formMethod: o,
      formEncType: c
    } = a;
    s.method = o.toUpperCase(), c === "application/json" ? (s.headers = new Headers({
      "Content-Type": c
    }), s.body = JSON.stringify(a.json)) : c === "text/plain" ? s.body = a.text : c === "application/x-www-form-urlencoded" && a.formData ? s.body = bt(a.formData) : s.body = a.formData;
  }
  return new Request(n, s);
}
function bt(e) {
  let t = new URLSearchParams();
  for (let [r, a] of e.entries())
    t.append(r, typeof a == "string" ? a : a.name);
  return t;
}
function Jt(e) {
  let t = new FormData();
  for (let [r, a] of e.entries())
    t.append(r, a);
  return t;
}
function Rr(e, t, r, a, n) {
  let s = {}, o = null, c, d = !1, m = {}, y = r && ee(r[1]) ? r[1].error : void 0;
  return e.forEach((g) => {
    if (!(g.route.id in t))
      return;
    let S = g.route.id, h = t[S];
    if (B(!De(h), "Cannot handle redirect results in processLoaderData"), ee(h)) {
      let v = h.error;
      if (y !== void 0 && (v = y, y = void 0), o = o || {}, n)
        o[S] = v;
      else {
        let w = be(e, S);
        o[w.route.id] == null && (o[w.route.id] = v);
      }
      s[S] = void 0, d || (d = !0, c = He(h.error) ? h.error.status : 500), h.headers && (m[S] = h.headers);
    } else
      me(h) ? (a.set(S, h.deferredData), s[S] = h.deferredData.data, h.statusCode != null && h.statusCode !== 200 && !d && (c = h.statusCode), h.headers && (m[S] = h.headers)) : (s[S] = h.data, h.statusCode && h.statusCode !== 200 && !d && (c = h.statusCode), h.headers && (m[S] = h.headers));
  }), y !== void 0 && r && (o = {
    [r[0]]: y
  }, s[r[0]] = void 0), {
    loaderData: s,
    errors: o,
    statusCode: c || 200,
    loaderHeaders: m
  };
}
function Xt(e, t, r, a, n, s, o) {
  let {
    loaderData: c,
    errors: d
  } = Rr(
    t,
    r,
    a,
    o,
    !1
    // This method is only called client side so we always want to bubble
  );
  return n.forEach((m) => {
    let {
      key: y,
      match: g,
      controller: S
    } = m, h = s[y];
    if (B(h, "Did not find corresponding fetcher result"), !(S && S.signal.aborted))
      if (ee(h)) {
        let v = be(e.matches, g == null ? void 0 : g.route.id);
        d && d[v.route.id] || (d = I({}, d, {
          [v.route.id]: h.error
        })), e.fetchers.delete(y);
      } else if (De(h))
        B(!1, "Unhandled fetcher revalidation redirect");
      else if (me(h))
        B(!1, "Unhandled fetcher deferred data");
      else {
        let v = we(h.data);
        e.fetchers.set(y, v);
      }
  }), {
    loaderData: c,
    errors: d
  };
}
function Gt(e, t, r, a) {
  let n = I({}, t);
  for (let s of r) {
    let o = s.route.id;
    if (t.hasOwnProperty(o) ? t[o] !== void 0 && (n[o] = t[o]) : e[o] !== void 0 && s.route.loader && (n[o] = e[o]), a && a.hasOwnProperty(o))
      break;
  }
  return n;
}
function Qt(e) {
  return e ? ee(e[1]) ? {
    // Clear out prior actionData on errors
    actionData: {}
  } : {
    actionData: {
      [e[0]]: e[1].data
    }
  } : {};
}
function be(e, t) {
  return (t ? e.slice(0, e.findIndex((a) => a.route.id === t) + 1) : [...e]).reverse().find((a) => a.route.hasErrorBoundary === !0) || e[0];
}
function st(e) {
  let t = e.length === 1 ? e[0] : e.find((r) => r.index || !r.path || r.path === "/") || {
    id: "__shim-error-route__"
  };
  return {
    matches: [{
      params: {},
      pathname: "",
      pathnameBase: "",
      route: t
    }],
    route: t
  };
}
function Y(e, t) {
  let {
    pathname: r,
    routeId: a,
    method: n,
    type: s,
    message: o
  } = t === void 0 ? {} : t, c = "Unknown Server Error", d = "Unknown @remix-run/router error";
  return e === 400 ? (c = "Bad Request", n && r && a ? d = "You made a " + n + ' request to "' + r + '" but ' + ('did not provide a `loader` for route "' + a + '", ') + "so there is no way to handle the request." : s === "defer-action" ? d = "defer() is not supported in actions" : s === "invalid-body" && (d = "Unable to encode submission body")) : e === 403 ? (c = "Forbidden", d = 'Route "' + a + '" does not match URL "' + r + '"') : e === 404 ? (c = "Not Found", d = 'No route matches URL "' + r + '"') : e === 405 && (c = "Method Not Allowed", n && r && a ? d = "You made a " + n.toUpperCase() + ' request to "' + r + '" but ' + ('did not provide an `action` for route "' + a + '", ') + "so there is no way to handle the request." : n && (d = 'Invalid request method "' + n.toUpperCase() + '"')), new lt(e || 500, c, new Error(d), !0);
}
function nt(e) {
  let t = Object.entries(e);
  for (let r = t.length - 1; r >= 0; r--) {
    let [a, n] = t[r];
    if (De(n))
      return {
        key: a,
        result: n
      };
  }
}
function Dr(e) {
  let t = typeof e == "string" ? ie(e) : e;
  return se(I({}, t, {
    hash: ""
  }));
}
function ja(e, t) {
  return e.pathname !== t.pathname || e.search !== t.search ? !1 : e.hash === "" ? t.hash !== "" : e.hash === t.hash ? !0 : t.hash !== "";
}
function Ca(e) {
  return e != null && typeof e == "object" && "type" in e && "result" in e && (e.type === H.data || e.type === H.error);
}
function Sr(e) {
  return Re(e.result) && Ra.has(e.result.status);
}
function me(e) {
  return e.type === H.deferred;
}
function ee(e) {
  return e.type === H.error;
}
function De(e) {
  return (e && e.type) === H.redirect;
}
function Rt(e) {
  return typeof e == "object" && e != null && "type" in e && "data" in e && "init" in e && e.type === "DataWithResponseInit";
}
function Er(e) {
  let t = e;
  return t && typeof t == "object" && typeof t.data == "object" && typeof t.subscribe == "function" && typeof t.cancel == "function" && typeof t.resolveData == "function";
}
function Re(e) {
  return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.headers == "object" && typeof e.body < "u";
}
function Fa(e) {
  if (!Re(e))
    return !1;
  let t = e.status, r = e.headers.get("Location");
  return t >= 300 && t <= 399 && r != null;
}
function Dt(e) {
  return ba.has(e.toLowerCase());
}
function ae(e) {
  return va.has(e.toLowerCase());
}
async function Ua(e, t, r, a, n) {
  let s = Object.entries(t);
  for (let o = 0; o < s.length; o++) {
    let [c, d] = s[o], m = e.find((S) => (S == null ? void 0 : S.route.id) === c);
    if (!m)
      continue;
    let y = a.find((S) => S.route.id === m.route.id), g = y != null && !mr(y, m) && (n && n[m.route.id]) !== void 0;
    me(d) && g && await Pt(d, r, !1).then((S) => {
      S && (t[c] = S);
    });
  }
}
async function Aa(e, t, r) {
  for (let a = 0; a < r.length; a++) {
    let {
      key: n,
      routeId: s,
      controller: o
    } = r[a], c = t[n];
    e.find((m) => (m == null ? void 0 : m.route.id) === s) && me(c) && (B(o, "Expected an AbortController for revalidating fetcher deferred result"), await Pt(c, o.signal, !0).then((m) => {
      m && (t[n] = m);
    }));
  }
}
async function Pt(e, t, r) {
  if (r === void 0 && (r = !1), !await e.deferredData.resolveData(t)) {
    if (r)
      try {
        return {
          type: H.data,
          data: e.deferredData.unwrappedData
        };
      } catch (n) {
        return {
          type: H.error,
          error: n
        };
      }
    return {
      type: H.data,
      data: e.deferredData.data
    };
  }
}
function xt(e) {
  return new URLSearchParams(e).getAll("index").some((t) => t === "");
}
function Me(e, t) {
  let r = typeof t == "string" ? ie(t).search : t.search;
  if (e[e.length - 1].route.index && xt(r || ""))
    return e[e.length - 1];
  let a = ir(e);
  return a[a.length - 1];
}
function Zt(e) {
  let {
    formMethod: t,
    formAction: r,
    formEncType: a,
    text: n,
    formData: s,
    json: o
  } = e;
  if (!(!t || !r || !a)) {
    if (n != null)
      return {
        formMethod: t,
        formAction: r,
        formEncType: a,
        formData: void 0,
        json: void 0,
        text: n
      };
    if (s != null)
      return {
        formMethod: t,
        formAction: r,
        formEncType: a,
        formData: s,
        json: void 0,
        text: void 0
      };
    if (o !== void 0)
      return {
        formMethod: t,
        formAction: r,
        formEncType: a,
        formData: void 0,
        json: o,
        text: void 0
      };
  }
}
function pt(e, t) {
  return t ? {
    state: "loading",
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text
  } : {
    state: "loading",
    location: e,
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0
  };
}
function _a(e, t) {
  return {
    state: "submitting",
    location: e,
    formMethod: t.formMethod,
    formAction: t.formAction,
    formEncType: t.formEncType,
    formData: t.formData,
    json: t.json,
    text: t.text
  };
}
function Ve(e, t) {
  return e ? {
    state: "loading",
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t
  } : {
    state: "loading",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: t
  };
}
function Oa(e, t) {
  return {
    state: "submitting",
    formMethod: e.formMethod,
    formAction: e.formAction,
    formEncType: e.formEncType,
    formData: e.formData,
    json: e.json,
    text: e.text,
    data: t ? t.data : void 0
  };
}
function we(e) {
  return {
    state: "idle",
    formMethod: void 0,
    formAction: void 0,
    formEncType: void 0,
    formData: void 0,
    json: void 0,
    text: void 0,
    data: e
  };
}
function Ia(e, t) {
  try {
    let r = e.sessionStorage.getItem(hr);
    if (r) {
      let a = JSON.parse(r);
      for (let [n, s] of Object.entries(a || {}))
        s && Array.isArray(s) && t.set(n, new Set(s || []));
    }
  } catch {
  }
}
function Na(e, t) {
  if (t.size > 0) {
    let r = {};
    for (let [a, n] of t)
      r[a] = [...n];
    try {
      e.sessionStorage.setItem(hr, JSON.stringify(r));
    } catch (a) {
      le(!1, "Failed to save applied view transitions in sessionStorage (" + a + ").");
    }
  }
}
const Ha = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbortedDeferredError: yt,
  get Action() {
    return $;
  },
  IDLE_BLOCKER: Oe,
  IDLE_FETCHER: fr,
  IDLE_NAVIGATION: ot,
  UNSAFE_DEFERRED_SYMBOL: pr,
  UNSAFE_DeferredData: dr,
  UNSAFE_ErrorResponseImpl: lt,
  UNSAFE_convertRouteMatchToUiMatch: er,
  UNSAFE_convertRoutesToDataRoutes: Ne,
  UNSAFE_decodePath: ar,
  UNSAFE_getResolveToMatches: or,
  UNSAFE_invariant: B,
  UNSAFE_warning: le,
  createBrowserHistory: Kr,
  createHashHistory: kr,
  createMemoryHistory: Wr,
  createPath: se,
  createRouter: Sa,
  createStaticHandler: Ea,
  data: ca,
  defer: ma,
  generatePath: na,
  getStaticContextFromError: Pa,
  getToPathname: la,
  isDataWithResponseInit: Rt,
  isDeferredData: Er,
  isRouteErrorResponse: He,
  joinPaths: Ie,
  json: ua,
  matchPath: mt,
  matchRoutes: pe,
  normalizePathname: sr,
  parsePath: ie,
  redirect: St,
  redirectDocument: ya,
  replace: ga,
  resolvePath: nr,
  resolveTo: lr,
  stripBasename: Ye
}, Symbol.toStringTag, { value: "Module" }));
export {
  $ as A,
  Ha as B,
  lt as E,
  Oe as I,
  lr as a,
  He as b,
  mt as c,
  ar as d,
  er as e,
  Wr as f,
  or as g,
  yt as h,
  B as i,
  Ie as j,
  Sa as k,
  se as l,
  pe as m,
  ma as n,
  na as o,
  ie as p,
  ua as q,
  St as r,
  Ye as s,
  ya as t,
  ga as u,
  nr as v,
  le as w,
  Kr as x,
  kr as y,
  fr as z
};
//# sourceMappingURL=router-Oe6YmY6B.js.map
