import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { matchPath, useRouteError } from "react-router-dom";
import { Client as UrqlClient, cacheExchange, fetchExchange } from "urql";
import { graphql } from "./graphql/index.js";
import { useQuery } from "@tanstack/react-query";
import { CirclePlayIcon, LogInIcon } from "lucide-react";
import { createClient } from "zudoku/openapi-worker";
import { useAuth } from "../../authentication/hook.js";
import { ErrorPage } from "../../components/ErrorPage.js";
import { SyntaxHighlight } from "../../components/SyntaxHighlight.js";
import { Button } from "../../ui/Button.js";
import { joinPath } from "../../util/joinPath.js";
import { PlaygroundDialog } from "./playground/PlaygroundDialog.js";
import { GetServerQuery } from "./Sidecar.js";
const GetCategoriesQuery = graphql(`
  query GetCategories($input: JSON!, $type: SchemaType!) {
    schema(input: $input, type: $type) {
      tags {
        __typename
        name
        operations {
          __typename
          slug
          deprecated
          method
          summary
          operationId
          path
        }
      }
    }
  }
`);
const OpenApiErrorPage = () => {
    const error = useRouteError();
    const message = error instanceof Error ? (_jsx(SyntaxHighlight, { code: error.message })) : ("An unknown error occurred");
    return (_jsx(ErrorPage, { category: "Error", title: "An error occurred", message: message }));
};
const MethodColorMap = {
    get: "green",
    post: "blue",
    put: "yellow",
    delete: "red",
    patch: "purple",
    options: "gray",
    head: "gray",
};
export const openApiPlugin = (config) => {
    const basePath = joinPath(config.navigationId ?? "/reference");
    const client = config.server
        ? new UrqlClient({
            url: config.server,
            exchanges: [cacheExchange, fetchExchange],
        })
        : createClient({ useMemoryClient: config.inMemory ?? false });
    return {
        getHead: () => {
            if (config.type === "url" && !config.skipPreload) {
                return (_jsx("link", { rel: "preload", href: config.input, as: "fetch", crossOrigin: "anonymous" }));
            }
            if (config.server) {
                return _jsx("link", { rel: "preconnect", href: config.server });
            }
        },
        getMdxComponents: () => ({
            OpenPlaygroundButton: ({ requireAuth, server, method, url, ...props }) => {
                const auth = useAuth();
                const serverQuery = useQuery({
                    queryFn: async () => {
                        const result = await client.query(GetServerQuery, {
                            type: config.type,
                            input: config.input,
                        });
                        return result.data;
                    },
                    enabled: !server,
                    queryKey: ["playground-server"],
                });
                if (requireAuth && !auth.isAuthenticated) {
                    return (_jsxs(Button, { className: "gap-2 items-center", variant: "outline", onClick: auth.login, children: ["Login to open in Playground ", _jsx(LogInIcon, { size: 16 })] }));
                }
                return (_jsx(PlaygroundDialog, { url: url ?? "/", method: method ?? "get", server: server ?? serverQuery.data?.schema.url ?? "https://example.com", ...props, children: _jsxs(Button, { className: "gap-2 items-center", variant: "outline", children: ["Open in Playground ", _jsx(CirclePlayIcon, { size: 16 })] }) }));
            },
        }),
        getSidebar: async (path) => {
            if (!matchPath({ path: basePath, end: false }, path)) {
                return [];
            }
            const { data } = await client.query(GetCategoriesQuery, {
                input: config.input,
                type: config.type,
            });
            if (!data)
                return [];
            const categories = data.schema.tags
                .filter((tag) => tag.operations.length > 0)
                .map((tag) => ({
                type: "category",
                label: tag.name || "Other endpoints",
                collapsible: true,
                collapsed: false,
                items: tag.operations.map((operation) => ({
                    type: "link",
                    label: operation.summary ?? operation.path,
                    href: `#${operation.slug}`,
                    badge: {
                        label: operation.method,
                        color: MethodColorMap[operation.method.toLowerCase()],
                    },
                })),
            }));
            categories.unshift({
                type: "link",
                label: "Overview",
                href: "#description",
            });
            return categories;
        },
        getRoutes: () => [
            {
                async lazy() {
                    const { OpenApiRoute } = await import("./Route.js");
                    return {
                        element: _jsx(OpenApiRoute, { client: client, config: config }),
                    };
                },
                errorElement: _jsx(OpenApiErrorPage, {}),
                children: [
                    {
                        path: basePath,
                        children: [
                            {
                                index: true,
                                async lazy() {
                                    const { OperationList } = await import("./OperationList.js");
                                    return { element: _jsx(OperationList, {}) };
                                },
                            },
                        ],
                    },
                ],
            },
        ],
    };
};
//# sourceMappingURL=index.js.map