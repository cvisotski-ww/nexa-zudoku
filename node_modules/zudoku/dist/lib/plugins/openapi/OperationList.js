import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useQuery } from "urql";
import { CategoryHeading } from "../../components/CategoryHeading.js";
import { DeveloperHint } from "../../components/DeveloperHint.js";
import { ErrorPage } from "../../components/ErrorPage.js";
import { Heading } from "../../components/Heading.js";
import { InlineCode } from "../../components/InlineCode.js";
import { Markdown, ProseClasses } from "../../components/Markdown.js";
import { SyntaxHighlight } from "../../components/SyntaxHighlight.js";
import { cn } from "../../util/cn.js";
import { Endpoint } from "./Endpoint.js";
import { OperationListItem } from "./OperationListItem.js";
import StaggeredRender from "./StaggeredRender.js";
import { useOasConfig } from "./context.js";
import { graphql } from "./graphql/index.js";
export const OperationsFragment = graphql(/* GraphQL */ `
  fragment OperationsFragment on OperationItem {
    slug
    summary
    method
    description
    operationId
    contentTypes
    path
    parameters {
      name
      in
      description
      required
      schema
      style
      examples {
        name
        description
        externalValue
        value
        summary
      }
    }
    requestBody {
      content {
        mediaType
        encoding {
          name
        }
        schema
      }
      description
      required
    }
    responses {
      statusCode
      links
      description
      content {
        mediaType
        encoding {
          name
        }
        schema
      }
    }
  }
`);
const AllOperationsQuery = graphql(/* GraphQL */ `
  query AllOperations($input: JSON!, $type: SchemaType!) {
    schema(input: $input, type: $type) {
      description
      title
      url
      version
      tags {
        name
        description
        operations {
          slug
          ...OperationsFragment
        }
      }
    }
  }
`);
const suspenseContext = { suspense: true };
export const OperationList = () => {
    const { type, input } = useOasConfig();
    const [result] = useQuery({
        query: AllOperationsQuery,
        variables: { type, input },
        context: suspenseContext,
    });
    const error = result.error?.graphQLErrors.at(0);
    // Looks like there is no Suspense level error handling (yet)?
    // So we handle the error case in the component directly
    if (error) {
        return (_jsx(ErrorPage, { category: "Error", title: "Schema cannot be displayed", message: _jsxs(_Fragment, { children: [_jsxs(DeveloperHint, { className: "mb-4", children: ["Check your configuration value ", _jsx(InlineCode, { children: "apis.type" }), " ", "and ", _jsx(InlineCode, { children: "apis.input" }), " in the Zudoku config."] }), "An error occurred while trying to fetch the API reference:", _jsx(SyntaxHighlight, { code: error.toString(), language: "plain" })] }) }));
    }
    if (!result.data)
        return null;
    return (_jsxs("div", { className: "pt-[--padding-content-top]", children: [_jsxs("div", { className: cn(ProseClasses, "mb-16 max-w-full prose-img:max-w-prose"), children: [_jsx(CategoryHeading, { children: "Overview" }), _jsx(Heading, { level: 1, id: "description", registerSidebarAnchor: true, children: result.data.schema.title }), _jsx(Markdown, { content: result.data.schema.description ?? "" })] }), _jsx("hr", {}), _jsx("div", { className: "my-4 flex justify-end", children: _jsx(Endpoint, {}) }), result.data.schema.tags
                .filter((tag) => tag.operations.length > 0)
                .map((tag) => (_jsxs("div", { children: [tag.name && _jsx(CategoryHeading, { children: tag.name }), tag.description && (_jsx(Markdown, { className: `${ProseClasses} max-w-full prose-img:max-w-prose w-full mt-2 mb-12`, content: tag.description })), _jsx("div", { className: "operation mb-12", children: _jsx(StaggeredRender, { children: tag.operations.map((fragment) => (_jsx(OperationListItem, { operationFragment: fragment }, fragment.slug))) }) })] }, tag.name)))] }));
};
//# sourceMappingURL=OperationList.js.map