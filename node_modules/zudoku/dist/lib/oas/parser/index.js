import { GraphQLError } from "graphql/error/index.js";
import { OpenAPIV3 } from "openapi-types";
import { dereference } from "./dereference/index.js";
import { upgradeSchema } from "./upgrade/index.js";
export const HttpMethods = Object.values(OpenAPIV3.HttpMethods);
// class ValidationError extends Error {
//   constructor(public errors: OutputUnit[]) {
//     super("Validation error");
//   }
// }
// const getValidator = async (openApiVersion: string) => {
//   if (openApiVersion.startsWith("3.0")) {
//     const schema = (await import("./schemas/v3.0.json")) as any;
//     return new Validator(schema, "4");
//   }
//   if (openApiVersion.startsWith("3.1")) {
//     const schema = (await import("./schemas/v3.1.json")) as any;
//     return new Validator(schema as any, "2020-12");
//   }
//   throw new Error(`Unsupported OpenAPI version: ${openApiVersion}`);
// };
const parseSchemaInput = async (schemaInput) => {
    if (typeof schemaInput === "string") {
        if (schemaInput.trim().startsWith("{")) {
            try {
                return JSON.parse(schemaInput);
            }
            catch (err) {
                throw new GraphQLError("Invalid JSON schema", {
                    originalError: err,
                });
            }
        }
        if (schemaInput.includes("://")) {
            let response;
            try {
                response = await fetch(schemaInput, {
                    cache: "force-cache",
                });
            }
            catch (err) {
                throw new GraphQLError("Failed to fetch schema", {
                    originalError: err,
                });
            }
            if (!response.ok) {
                throw new GraphQLError(`Failed to fetch schema: ${response.statusText}`);
            }
            const schemaText = await response.text();
            try {
                if (schemaText.trim().startsWith("{")) {
                    return JSON.parse(schemaText);
                }
                else {
                    const yaml = await import("yaml");
                    return yaml.parse(schemaText);
                }
            }
            catch (err) {
                throw new GraphQLError("Fetched invalid schema", {
                    originalError: err,
                });
            }
        }
        const yaml = await import("yaml");
        const parsed = yaml.parse(schemaInput);
        if (typeof parsed === "object")
            return parsed;
    }
    if (typeof schemaInput === "object")
        return schemaInput;
    throw new GraphQLError("Unsupported schema input: " + schemaInput);
};
/**
 * Validates, dereferences and upgrades the OpenAPI schema (to v3.1) if necessary.
 */
export const validate = async (schemaInput) => {
    const schema = await parseSchemaInput(schemaInput);
    if (!schema.openapi) {
        throw new GraphQLError("OpenAPI version is not defined");
    }
    // const validator = await getValidator(schema.openapi);
    // const result = validator.validate(schema);
    //
    // if (!result.valid) {
    //   throw new ValidationError(result.errors);
    // }
    const dereferenced = await dereference(schema);
    return upgradeSchema(dereferenced);
};
//# sourceMappingURL=index.js.map