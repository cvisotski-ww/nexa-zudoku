import {
  require_react_dom
} from "./chunk-5QLD5OAE.js";
import {
  $,
  B,
  He,
  Ie,
  Kr,
  Oe,
  Sa,
  St,
  Wr,
  Ye,
  ar,
  er,
  fr,
  ga,
  ie,
  kr,
  le,
  lr,
  lt,
  ma,
  mt,
  na,
  nr,
  or,
  pe,
  se,
  ua,
  ya,
  yt
} from "./chunk-ZOAZAIYS.js";
import {
  dr
} from "./chunk-VJHVP7KM.js";
import {
  Check,
  Copy,
  Info,
  Lightbulb,
  ShieldAlert,
  TriangleAlert
} from "./chunk-7KXO56BK.js";
import {
  require_react
} from "./chunk-DDZAXPWP.js";
import {
  __toESM
} from "./chunk-HXA6O6EE.js";

// node_modules/zudoku/lib/index-DJqnphbT.js
var u = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function f(e2) {
  return e2 && e2.__esModule && Object.prototype.hasOwnProperty.call(e2, "default") ? e2.default : e2;
}
function a(e2) {
  if (e2.__esModule) return e2;
  var o2 = e2.default;
  if (typeof o2 == "function") {
    var t = function r() {
      return this instanceof r ? Reflect.construct(o2, arguments, this.constructor) : o2.apply(this, arguments);
    };
    t.prototype = o2.prototype;
  } else t = {};
  return Object.defineProperty(t, "__esModule", { value: true }), Object.keys(e2).forEach(function(r) {
    var n2 = Object.getOwnPropertyDescriptor(e2, r);
    Object.defineProperty(t, r, n2.get ? n2 : {
      enumerable: true,
      get: function() {
        return e2[r];
      }
    });
  }), t;
}
function c(e2) {
  if (typeof e2 != "string")
    throw new TypeError("Expected a string");
  return e2.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}

// node_modules/zudoku/lib/index-BRCiYFaL.js
var n = __toESM(require_react(), 1);
var Bt = __toESM(require_react_dom(), 1);
function I() {
  return I = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var o2 in r)
        Object.prototype.hasOwnProperty.call(r, o2) && (e2[o2] = r[o2]);
    }
    return e2;
  }, I.apply(this, arguments);
}
var U = n.createContext(null);
U.displayName = "DataRouter";
var B2 = n.createContext(null);
B2.displayName = "DataRouterState";
var Z = n.createContext(null);
Z.displayName = "Await";
var S = n.createContext(null);
S.displayName = "Navigation";
var M = n.createContext(null);
M.displayName = "Location";
var _ = n.createContext({
  outlet: null,
  matches: [],
  isDataRoute: false
});
_.displayName = "Route";
var xe = n.createContext(null);
xe.displayName = "RouteError";
function De(e2, t) {
  let {
    relative: r
  } = t === void 0 ? {} : t;
  V() || (true ? B(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : B(false));
  let {
    basename: o2,
    navigator: a3
  } = n.useContext(S), {
    hash: l,
    pathname: i2,
    search: u2
  } = Y(e2, {
    relative: r
  }), f2 = i2;
  return o2 !== "/" && (f2 = i2 === "/" ? o2 : Ie([o2, i2])), a3.createHref({
    pathname: f2,
    search: u2,
    hash: l
  });
}
function V() {
  return n.useContext(M) != null;
}
function L() {
  return V() || (true ? B(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : B(false)), n.useContext(M).location;
}
function it() {
  return n.useContext(M).navigationType;
}
function lt2(e2) {
  V() || (true ? B(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useMatch() may be used only in the context of a <Router> component."
  ) : B(false));
  let {
    pathname: t
  } = L();
  return n.useMemo(() => mt(e2, ar(t)), [t, e2]);
}
var st = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";
function ut(e2) {
  n.useContext(S).static || n.useLayoutEffect(e2);
}
function te() {
  let {
    isDataRoute: e2
  } = n.useContext(_);
  return e2 ? Xt() : zt();
}
function zt() {
  V() || (true ? B(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : B(false));
  let e2 = n.useContext(U), {
    basename: t,
    future: r,
    navigator: o2
  } = n.useContext(S), {
    matches: a3
  } = n.useContext(_), {
    pathname: l
  } = L(), i2 = JSON.stringify(or(a3, r.v7_relativeSplatPath)), u2 = n.useRef(false);
  return ut(() => {
    u2.current = true;
  }), n.useCallback(function(s2, c3) {
    if (c3 === void 0 && (c3 = {}), le(u2.current, st), !u2.current) return;
    if (typeof s2 == "number") {
      o2.go(s2);
      return;
    }
    let d2 = lr(s2, JSON.parse(i2), l, c3.relative === "path");
    e2 == null && t !== "/" && (d2.pathname = d2.pathname === "/" ? t : Ie([t, d2.pathname])), (c3.replace ? o2.replace : o2.push)(d2, c3.state, c3);
  }, [t, o2, i2, l, e2]);
}
var ct = n.createContext(null);
function dt() {
  return n.useContext(ct);
}
function Oe2(e2) {
  let t = n.useContext(_).outlet;
  return t && n.createElement(ct.Provider, {
    value: e2
  }, t);
}
function ft() {
  let {
    matches: e2
  } = n.useContext(_), t = e2[e2.length - 1];
  return t ? t.params : {};
}
function Y(e2, t) {
  let {
    relative: r
  } = t === void 0 ? {} : t, {
    future: o2
  } = n.useContext(S), {
    matches: a3
  } = n.useContext(_), {
    pathname: l
  } = L(), i2 = JSON.stringify(or(a3, o2.v7_relativeSplatPath));
  return n.useMemo(() => lr(e2, JSON.parse(i2), l, r === "path"), [e2, i2, l, r]);
}
function Pe(e2, t) {
  return pe2(e2, t);
}
function pe2(e2, t, r, o2) {
  V() || (true ? B(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  ) : B(false));
  let {
    navigator: a3
  } = n.useContext(S), {
    matches: l
  } = n.useContext(_), i2 = l[l.length - 1], u2 = i2 ? i2.params : {}, f2 = i2 ? i2.pathname : "/", s2 = i2 ? i2.pathnameBase : "/", c3 = i2 && i2.route;
  if (true) {
    let h = c3 && c3.path || "";
    gt(f2, !c3 || h.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + f2 + '" (under <Route path="' + h + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + h + '"> to <Route ') + ('path="' + (h === "/" ? "*" : h + "/*") + '">.'));
  }
  let d2 = L(), p3;
  if (t) {
    var v;
    let h = typeof t == "string" ? ie(t) : t;
    s2 === "/" || (v = h.pathname) != null && v.startsWith(s2) || (true ? B(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + s2 + '" ') + ('but pathname "' + h.pathname + '" was given in the `location` prop.')) : B(false)), p3 = h;
  } else
    p3 = d2;
  let g2 = p3.pathname || "/", N2 = g2;
  if (s2 !== "/") {
    let h = s2.replace(/^\//, "").split("/");
    N2 = "/" + g2.replace(/^\//, "").split("/").slice(h.length).join("/");
  }
  let y2 = pe(e2, {
    pathname: N2
  });
  le(c3 || y2 != null, 'No routes matched location "' + p3.pathname + p3.search + p3.hash + '" '), le(y2 == null || y2[y2.length - 1].route.element !== void 0 || y2[y2.length - 1].route.Component !== void 0 || y2[y2.length - 1].route.lazy !== void 0, 'Matched leaf route at location "' + p3.pathname + p3.search + p3.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.');
  let w2 = pt(y2 && y2.map((h) => Object.assign({}, h, {
    params: Object.assign({}, u2, h.params),
    pathname: Ie([
      s2,
      // Re-encode pathnames that were decoded inside matchRoutes
      a3.encodeLocation ? a3.encodeLocation(h.pathname).pathname : h.pathname
    ]),
    pathnameBase: h.pathnameBase === "/" ? s2 : Ie([
      s2,
      // Re-encode pathnames that were decoded inside matchRoutes
      a3.encodeLocation ? a3.encodeLocation(h.pathnameBase).pathname : h.pathnameBase
    ])
  })), l, r, o2);
  return t && w2 ? n.createElement(M.Provider, {
    value: {
      location: I({
        pathname: "/",
        search: "",
        hash: "",
        state: null,
        key: "default"
      }, p3),
      navigationType: $.Pop
    }
  }, w2) : w2;
}
function Wt() {
  let e2 = ke(), t = He(e2) ? e2.status + " " + e2.statusText : e2 instanceof Error ? e2.message : JSON.stringify(e2), r = e2 instanceof Error ? e2.stack : null, o2 = "rgba(200,200,200, 0.5)", a3 = {
    padding: "0.5rem",
    backgroundColor: o2
  }, l = {
    padding: "2px 4px",
    backgroundColor: o2
  }, i2 = null;
  return console.error("Error handled by React Router default ErrorBoundary:", e2), i2 = n.createElement(n.Fragment, null, n.createElement("p", null, "💿 Hey developer 👋"), n.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", n.createElement("code", {
    style: l
  }, "ErrorBoundary"), " or", " ", n.createElement("code", {
    style: l
  }, "errorElement"), " prop on your route.")), n.createElement(n.Fragment, null, n.createElement("h2", null, "Unexpected Application Error!"), n.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, t), r ? n.createElement("pre", {
    style: a3
  }, r) : null, i2);
}
var Yt = n.createElement(Wt, null);
var $t = class extends n.Component {
  constructor(t) {
    super(t), this.state = {
      location: t.location,
      revalidation: t.revalidation,
      error: t.error
    };
  }
  static getDerivedStateFromError(t) {
    return {
      error: t
    };
  }
  static getDerivedStateFromProps(t, r) {
    return r.location !== t.location || r.revalidation !== "idle" && t.revalidation === "idle" ? {
      error: t.error,
      location: t.location,
      revalidation: t.revalidation
    } : {
      error: t.error !== void 0 ? t.error : r.error,
      location: r.location,
      revalidation: t.revalidation || r.revalidation
    };
  }
  componentDidCatch(t, r) {
    console.error("React Router caught the following error during render", t, r);
  }
  render() {
    return this.state.error !== void 0 ? n.createElement(_.Provider, {
      value: this.props.routeContext
    }, n.createElement(xe.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
};
function Jt(e2) {
  let {
    routeContext: t,
    match: r,
    children: o2
  } = e2, a3 = n.useContext(U);
  return a3 && a3.static && a3.staticContext && (r.route.errorElement || r.route.ErrorBoundary) && (a3.staticContext._deepestRenderedBoundaryId = r.route.id), n.createElement(_.Provider, {
    value: t
  }, o2);
}
function pt(e2, t, r, o2) {
  var a3;
  if (t === void 0 && (t = []), r === void 0 && (r = null), o2 === void 0 && (o2 = null), e2 == null) {
    var l;
    if (!r)
      return null;
    if (r.errors)
      e2 = r.matches;
    else if ((l = o2) != null && l.v7_partialHydration && t.length === 0 && !r.initialized && r.matches.length > 0)
      e2 = r.matches;
    else
      return null;
  }
  let i2 = e2, u2 = (a3 = r) == null ? void 0 : a3.errors;
  if (u2 != null) {
    let c3 = i2.findIndex((d2) => d2.route.id && (u2 == null ? void 0 : u2[d2.route.id]) !== void 0);
    c3 >= 0 || (true ? B(false, "Could not find a matching route for errors on route IDs: " + Object.keys(u2).join(",")) : B(false)), i2 = i2.slice(0, Math.min(i2.length, c3 + 1));
  }
  let f2 = false, s2 = -1;
  if (r && o2 && o2.v7_partialHydration)
    for (let c3 = 0; c3 < i2.length; c3++) {
      let d2 = i2[c3];
      if ((d2.route.HydrateFallback || d2.route.hydrateFallbackElement) && (s2 = c3), d2.route.id) {
        let {
          loaderData: p3,
          errors: v
        } = r, g2 = d2.route.loader && p3[d2.route.id] === void 0 && (!v || v[d2.route.id] === void 0);
        if (d2.route.lazy || g2) {
          f2 = true, s2 >= 0 ? i2 = i2.slice(0, s2 + 1) : i2 = [i2[0]];
          break;
        }
      }
    }
  return i2.reduceRight((c3, d2, p3) => {
    let v, g2 = false, N2 = null, y2 = null;
    r && (v = u2 && d2.route.id ? u2[d2.route.id] : void 0, N2 = d2.route.errorElement || Yt, f2 && (s2 < 0 && p3 === 0 ? (gt("route-fallback", false, "No `HydrateFallback` element provided to render during initial hydration"), g2 = true, y2 = null) : s2 === p3 && (g2 = true, y2 = d2.route.hydrateFallbackElement || null)));
    let w2 = t.concat(i2.slice(0, p3 + 1)), h = () => {
      let E;
      return v ? E = N2 : g2 ? E = y2 : d2.route.Component ? E = n.createElement(d2.route.Component, null) : d2.route.element ? E = d2.route.element : E = c3, n.createElement(Jt, {
        match: d2,
        routeContext: {
          outlet: c3,
          matches: w2,
          isDataRoute: r != null
        },
        children: E
      });
    };
    return r && (d2.route.ErrorBoundary || d2.route.errorElement || p3 === 0) ? n.createElement($t, {
      location: r.location,
      revalidation: r.revalidation,
      component: N2,
      error: v,
      children: h(),
      routeContext: {
        outlet: null,
        matches: w2,
        isDataRoute: true
      }
    }) : h();
  }, null);
}
var he = function(e2) {
  return e2.UseBlocker = "useBlocker", e2.UseRevalidator = "useRevalidator", e2.UseNavigateStable = "useNavigate", e2;
}(he || {});
var O = function(e2) {
  return e2.UseBlocker = "useBlocker", e2.UseLoaderData = "useLoaderData", e2.UseActionData = "useActionData", e2.UseRouteError = "useRouteError", e2.UseNavigation = "useNavigation", e2.UseRouteLoaderData = "useRouteLoaderData", e2.UseMatches = "useMatches", e2.UseRevalidator = "useRevalidator", e2.UseNavigateStable = "useNavigate", e2.UseRouteId = "useRouteId", e2;
}(O || {});
function Le(e2) {
  return e2 + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function Te(e2) {
  let t = n.useContext(U);
  return t || (true ? B(false, Le(e2)) : B(false)), t;
}
function j(e2) {
  let t = n.useContext(B2);
  return t || (true ? B(false, Le(e2)) : B(false)), t;
}
function qt(e2) {
  let t = n.useContext(_);
  return t || (true ? B(false, Le(e2)) : B(false)), t;
}
function re(e2) {
  let t = qt(e2), r = t.matches[t.matches.length - 1];
  return r.route.id || (true ? B(false, e2 + ' can only be used on routes that contain a unique "id"') : B(false)), r.route.id;
}
function Fe() {
  return re(O.UseRouteId);
}
function Ue() {
  return j(O.UseNavigation).navigation;
}
function ht() {
  let e2 = Te(he.UseRevalidator), t = j(O.UseRevalidator);
  return n.useMemo(() => ({
    revalidate: e2.router.revalidate,
    state: t.revalidation
  }), [e2.router.revalidate, t.revalidation]);
}
function Ve() {
  let {
    matches: e2,
    loaderData: t
  } = j(O.UseMatches);
  return n.useMemo(() => e2.map((r) => er(r, t)), [e2, t]);
}
function mt2() {
  let e2 = j(O.UseLoaderData), t = re(O.UseLoaderData);
  if (e2.errors && e2.errors[t] != null) {
    console.error("You cannot `useLoaderData` in an errorElement (routeId: " + t + ")");
    return;
  }
  return e2.loaderData[t];
}
function vt(e2) {
  return j(O.UseRouteLoaderData).loaderData[e2];
}
function Et() {
  let e2 = j(O.UseActionData), t = re(O.UseLoaderData);
  return e2.actionData ? e2.actionData[t] : void 0;
}
function ke() {
  var e2;
  let t = n.useContext(xe), r = j(O.UseRouteError), o2 = re(O.UseRouteError);
  return t !== void 0 ? t : (e2 = r.errors) == null ? void 0 : e2[o2];
}
function Ie2() {
  let e2 = n.useContext(Z);
  return e2 == null ? void 0 : e2._data;
}
function yt2() {
  let e2 = n.useContext(Z);
  return e2 == null ? void 0 : e2._error;
}
var Gt = 0;
function Ae(e2) {
  let {
    router: t,
    basename: r
  } = Te(he.UseBlocker), o2 = j(O.UseBlocker), [a3, l] = n.useState(""), i2 = n.useCallback((u2) => {
    if (typeof e2 != "function")
      return !!e2;
    if (r === "/")
      return e2(u2);
    let {
      currentLocation: f2,
      nextLocation: s2,
      historyAction: c3
    } = u2;
    return e2({
      currentLocation: I({}, f2, {
        pathname: Ye(f2.pathname, r) || f2.pathname
      }),
      nextLocation: I({}, s2, {
        pathname: Ye(s2.pathname, r) || s2.pathname
      }),
      historyAction: c3
    });
  }, [r, e2]);
  return n.useEffect(() => {
    let u2 = String(++Gt);
    return l(u2), () => t.deleteBlocker(u2);
  }, [t]), n.useEffect(() => {
    a3 !== "" && t.getBlocker(a3, i2);
  }, [t, a3, i2]), a3 && o2.blockers.has(a3) ? o2.blockers.get(a3) : Oe;
}
function Xt() {
  let {
    router: e2
  } = Te(he.UseNavigateStable), t = re(O.UseNavigateStable), r = n.useRef(false);
  return ut(() => {
    r.current = true;
  }), n.useCallback(function(a3, l) {
    l === void 0 && (l = {}), le(r.current, st), r.current && (typeof a3 == "number" ? e2.navigate(a3) : e2.navigate(a3, I({
      fromRouteId: t
    }, l)));
  }, [e2, t]);
}
var We = {};
function gt(e2, t, r) {
  !t && !We[e2] && (We[e2] = true, le(false, r));
}
var Qt = "startTransition";
var ue = n[Qt];
function Zt(e2) {
  let {
    fallbackElement: t,
    router: r,
    future: o2
  } = e2, [a3, l] = n.useState(r.state), {
    v7_startTransition: i2
  } = o2 || {}, u2 = n.useCallback((d2) => {
    i2 && ue ? ue(() => l(d2)) : l(d2);
  }, [l, i2]);
  n.useLayoutEffect(() => r.subscribe(u2), [r, u2]), n.useEffect(() => {
    le(t == null || !r.future.v7_partialHydration, "`<RouterProvider fallbackElement>` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead");
  }, []);
  let f2 = n.useMemo(() => ({
    createHref: r.createHref,
    encodeLocation: r.encodeLocation,
    go: (d2) => r.navigate(d2),
    push: (d2, p3, v) => r.navigate(d2, {
      state: p3,
      preventScrollReset: v == null ? void 0 : v.preventScrollReset
    }),
    replace: (d2, p3, v) => r.navigate(d2, {
      replace: true,
      state: p3,
      preventScrollReset: v == null ? void 0 : v.preventScrollReset
    })
  }), [r]), s2 = r.basename || "/", c3 = n.useMemo(() => ({
    router: r,
    navigator: f2,
    static: false,
    basename: s2
  }), [r, f2, s2]);
  return n.createElement(n.Fragment, null, n.createElement(U.Provider, {
    value: c3
  }, n.createElement(B2.Provider, {
    value: a3
  }, n.createElement(H, {
    basename: s2,
    location: a3.location,
    navigationType: a3.historyAction,
    navigator: f2,
    future: {
      v7_relativeSplatPath: r.future.v7_relativeSplatPath
    }
  }, a3.initialized || r.future.v7_partialHydration ? n.createElement(er2, {
    routes: r.routes,
    future: r.future,
    state: a3
  }) : t))), null);
}
function er2(e2) {
  let {
    routes: t,
    future: r,
    state: o2
  } = e2;
  return pe2(t, void 0, o2, r);
}
function Nt(e2) {
  let {
    basename: t,
    children: r,
    initialEntries: o2,
    initialIndex: a3,
    future: l
  } = e2, i2 = n.useRef();
  i2.current == null && (i2.current = Wr({
    initialEntries: o2,
    initialIndex: a3,
    v5Compat: true
  }));
  let u2 = i2.current, [f2, s2] = n.useState({
    action: u2.action,
    location: u2.location
  }), {
    v7_startTransition: c3
  } = l || {}, d2 = n.useCallback((p3) => {
    c3 && ue ? ue(() => s2(p3)) : s2(p3);
  }, [s2, c3]);
  return n.useLayoutEffect(() => u2.listen(d2), [u2, d2]), n.createElement(H, {
    basename: t,
    children: r,
    location: f2.location,
    navigationType: f2.action,
    navigator: u2,
    future: l
  });
}
function bt(e2) {
  let {
    to: t,
    replace: r,
    state: o2,
    relative: a3
  } = e2;
  V() || (true ? B(
    false,
    // TODO: This error is probably because they somehow have 2 versions of
    // the router loaded. We can help them understand how to avoid that.
    "<Navigate> may be used only in the context of a <Router> component."
  ) : B(false));
  let {
    future: l,
    static: i2
  } = n.useContext(S);
  le(!i2, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");
  let {
    matches: u2
  } = n.useContext(_), {
    pathname: f2
  } = L(), s2 = te(), c3 = lr(t, or(u2, l.v7_relativeSplatPath), f2, a3 === "path"), d2 = JSON.stringify(c3);
  return n.useEffect(() => s2(JSON.parse(d2), {
    replace: r,
    state: o2,
    relative: a3
  }), [s2, d2, a3, r, o2]), null;
}
function Rt(e2) {
  return Oe2(e2.context);
}
function Be(e2) {
  true ? B(false, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : B(false);
}
function H(e2) {
  let {
    basename: t = "/",
    children: r = null,
    location: o2,
    navigationType: a3 = $.Pop,
    navigator: l,
    static: i2 = false,
    future: u2
  } = e2;
  V() && (true ? B(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : B(false));
  let f2 = t.replace(/^\/*/, "/"), s2 = n.useMemo(() => ({
    basename: f2,
    navigator: l,
    static: i2,
    future: I({
      v7_relativeSplatPath: false
    }, u2)
  }), [f2, u2, l, i2]);
  typeof o2 == "string" && (o2 = ie(o2));
  let {
    pathname: c3 = "/",
    search: d2 = "",
    hash: p3 = "",
    state: v = null,
    key: g2 = "default"
  } = o2, N2 = n.useMemo(() => {
    let y2 = Ye(c3, f2);
    return y2 == null ? null : {
      location: {
        pathname: y2,
        search: d2,
        hash: p3,
        state: v,
        key: g2
      },
      navigationType: a3
    };
  }, [f2, c3, d2, p3, v, g2, a3]);
  return le(N2 != null, '<Router basename="' + f2 + '"> is not able to match the URL ' + ('"' + c3 + d2 + p3 + '" because it does not start with the ') + "basename, so the <Router> won't render anything."), N2 == null ? null : n.createElement(S.Provider, {
    value: s2
  }, n.createElement(M.Provider, {
    children: r,
    value: N2
  }));
}
function wt(e2) {
  let {
    children: t,
    location: r
  } = e2;
  return Pe(W(t), r);
}
function Ct(e2) {
  let {
    children: t,
    errorElement: r,
    resolve: o2
  } = e2;
  return n.createElement(rr, {
    resolve: o2,
    errorElement: r
  }, n.createElement(nr2, null, t));
}
var P = function(e2) {
  return e2[e2.pending = 0] = "pending", e2[e2.success = 1] = "success", e2[e2.error = 2] = "error", e2;
}(P || {});
var tr = new Promise(() => {
});
var rr = class extends n.Component {
  constructor(t) {
    super(t), this.state = {
      error: null
    };
  }
  static getDerivedStateFromError(t) {
    return {
      error: t
    };
  }
  componentDidCatch(t, r) {
    console.error("<Await> caught the following error during render", t, r);
  }
  render() {
    let {
      children: t,
      errorElement: r,
      resolve: o2
    } = this.props, a3 = null, l = P.pending;
    if (!(o2 instanceof Promise))
      l = P.success, a3 = Promise.resolve(), Object.defineProperty(a3, "_tracked", {
        get: () => true
      }), Object.defineProperty(a3, "_data", {
        get: () => o2
      });
    else if (this.state.error) {
      l = P.error;
      let i2 = this.state.error;
      a3 = Promise.reject().catch(() => {
      }), Object.defineProperty(a3, "_tracked", {
        get: () => true
      }), Object.defineProperty(a3, "_error", {
        get: () => i2
      });
    } else o2._tracked ? (a3 = o2, l = "_error" in a3 ? P.error : "_data" in a3 ? P.success : P.pending) : (l = P.pending, Object.defineProperty(o2, "_tracked", {
      get: () => true
    }), a3 = o2.then((i2) => Object.defineProperty(o2, "_data", {
      get: () => i2
    }), (i2) => Object.defineProperty(o2, "_error", {
      get: () => i2
    })));
    if (l === P.error && a3._error instanceof yt)
      throw tr;
    if (l === P.error && !r)
      throw a3._error;
    if (l === P.error)
      return n.createElement(Z.Provider, {
        value: a3,
        children: r
      });
    if (l === P.success)
      return n.createElement(Z.Provider, {
        value: a3,
        children: t
      });
    throw a3;
  }
};
function nr2(e2) {
  let {
    children: t
  } = e2, r = Ie2(), o2 = typeof t == "function" ? t(r) : t;
  return n.createElement(n.Fragment, null, o2);
}
function W(e2, t) {
  t === void 0 && (t = []);
  let r = [];
  return n.Children.forEach(e2, (o2, a3) => {
    if (!n.isValidElement(o2))
      return;
    let l = [...t, a3];
    if (o2.type === n.Fragment) {
      r.push.apply(r, W(o2.props.children, l));
      return;
    }
    o2.type !== Be && (true ? B(false, "[" + (typeof o2.type == "string" ? o2.type : o2.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : B(false)), !o2.props.index || !o2.props.children || (true ? B(false, "An index route cannot have child routes.") : B(false));
    let i2 = {
      id: o2.props.id || l.join("-"),
      caseSensitive: o2.props.caseSensitive,
      element: o2.props.element,
      Component: o2.props.Component,
      index: o2.props.index,
      path: o2.props.path,
      loader: o2.props.loader,
      action: o2.props.action,
      errorElement: o2.props.errorElement,
      ErrorBoundary: o2.props.ErrorBoundary,
      hasErrorBoundary: o2.props.ErrorBoundary != null || o2.props.errorElement != null,
      shouldRevalidate: o2.props.shouldRevalidate,
      handle: o2.props.handle,
      lazy: o2.props.lazy
    };
    o2.props.children && (i2.children = W(o2.props.children, l)), r.push(i2);
  }), r;
}
function St2(e2) {
  return pt(e2);
}
function me(e2) {
  let t = {
    // Note: this check also occurs in createRoutesFromChildren so update
    // there if you change this -- please and thank you!
    hasErrorBoundary: e2.ErrorBoundary != null || e2.errorElement != null
  };
  return e2.Component && (e2.element && true && le(false, "You should not include both `Component` and `element` on your route - `Component` will be used."), Object.assign(t, {
    element: n.createElement(e2.Component),
    Component: void 0
  })), e2.HydrateFallback && (e2.hydrateFallbackElement && true && le(false, "You should not include both `HydrateFallback` and `hydrateFallbackElement` on your route - `HydrateFallback` will be used."), Object.assign(t, {
    hydrateFallbackElement: n.createElement(e2.HydrateFallback),
    HydrateFallback: void 0
  })), e2.ErrorBoundary && (e2.errorElement && true && le(false, "You should not include both `ErrorBoundary` and `errorElement` on your route - `ErrorBoundary` will be used."), Object.assign(t, {
    errorElement: n.createElement(e2.ErrorBoundary),
    ErrorBoundary: void 0
  })), t;
}
function _t(e2, t) {
  return Sa({
    basename: t == null ? void 0 : t.basename,
    future: I({}, t == null ? void 0 : t.future, {
      v7_prependBasename: true
    }),
    history: Wr({
      initialEntries: t == null ? void 0 : t.initialEntries,
      initialIndex: t == null ? void 0 : t.initialIndex
    }),
    hydrationData: t == null ? void 0 : t.hydrationData,
    routes: e2,
    mapRouteProperties: me,
    dataStrategy: t == null ? void 0 : t.dataStrategy,
    patchRoutesOnNavigation: t == null ? void 0 : t.patchRoutesOnNavigation
  }).initialize();
}
var jr = Object.freeze(Object.defineProperty({
  __proto__: null,
  AbortedDeferredError: yt,
  Await: Ct,
  MemoryRouter: Nt,
  Navigate: bt,
  get NavigationType() {
    return $;
  },
  Outlet: Rt,
  Route: Be,
  Router: H,
  RouterProvider: Zt,
  Routes: wt,
  UNSAFE_DataRouterContext: U,
  UNSAFE_DataRouterStateContext: B2,
  UNSAFE_LocationContext: M,
  UNSAFE_NavigationContext: S,
  UNSAFE_RouteContext: _,
  UNSAFE_mapRouteProperties: me,
  UNSAFE_useRouteId: Fe,
  UNSAFE_useRoutesImpl: pe2,
  createMemoryRouter: _t,
  createPath: se,
  createRoutesFromChildren: W,
  createRoutesFromElements: W,
  defer: ma,
  generatePath: na,
  isRouteErrorResponse: He,
  json: ua,
  matchPath: mt,
  matchRoutes: pe,
  parsePath: ie,
  redirect: St,
  redirectDocument: ya,
  renderMatches: St2,
  replace: ga,
  resolvePath: nr,
  useActionData: Et,
  useAsyncError: yt2,
  useAsyncValue: Ie2,
  useBlocker: Ae,
  useHref: De,
  useInRouterContext: V,
  useLoaderData: mt2,
  useLocation: L,
  useMatch: lt2,
  useMatches: Ve,
  useNavigate: te,
  useNavigation: Ue,
  useNavigationType: it,
  useOutlet: Oe2,
  useOutletContext: dt,
  useParams: ft,
  useResolvedPath: Y,
  useRevalidator: ht,
  useRouteError: ke,
  useRouteLoaderData: vt,
  useRoutes: Pe
}, Symbol.toStringTag, { value: "Module" }));
function D() {
  return D = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t = 1; t < arguments.length; t++) {
      var r = arguments[t];
      for (var o2 in r)
        Object.prototype.hasOwnProperty.call(r, o2) && (e2[o2] = r[o2]);
    }
    return e2;
  }, D.apply(this, arguments);
}
function Me(e2, t) {
  if (e2 == null) return {};
  var r = {}, o2 = Object.keys(e2), a3, l;
  for (l = 0; l < o2.length; l++)
    a3 = o2[l], !(t.indexOf(a3) >= 0) && (r[a3] = e2[a3]);
  return r;
}
var le2 = "get";
var se2 = "application/x-www-form-urlencoded";
function ve(e2) {
  return e2 != null && typeof e2.tagName == "string";
}
function or2(e2) {
  return ve(e2) && e2.tagName.toLowerCase() === "button";
}
function ar2(e2) {
  return ve(e2) && e2.tagName.toLowerCase() === "form";
}
function ir(e2) {
  return ve(e2) && e2.tagName.toLowerCase() === "input";
}
function lr2(e2) {
  return !!(e2.metaKey || e2.altKey || e2.ctrlKey || e2.shiftKey);
}
function sr(e2, t) {
  return e2.button === 0 && // Ignore everything but left clicks
  (!t || t === "_self") && // Let browser handle "target=_blank" etc.
  !lr2(e2);
}
function ce(e2) {
  return e2 === void 0 && (e2 = ""), new URLSearchParams(typeof e2 == "string" || Array.isArray(e2) || e2 instanceof URLSearchParams ? e2 : Object.keys(e2).reduce((t, r) => {
    let o2 = e2[r];
    return t.concat(Array.isArray(o2) ? o2.map((a3) => [r, a3]) : [[r, o2]]);
  }, []));
}
function ur(e2, t) {
  let r = ce(e2);
  return t && t.forEach((o2, a3) => {
    r.has(a3) || t.getAll(a3).forEach((l) => {
      r.append(a3, l);
    });
  }), r;
}
var ae = null;
function cr() {
  if (ae === null)
    try {
      new FormData(
        document.createElement("form"),
        // @ts-expect-error if FormData supports the submitter parameter, this will throw
        0
      ), ae = false;
    } catch {
      ae = true;
    }
  return ae;
}
var dr2 = /* @__PURE__ */ new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);
function Ne(e2) {
  return e2 != null && !dr2.has(e2) ? (le(false, '"' + e2 + '" is not a valid `encType` for `<Form>`/`<fetcher.Form>` ' + ('and will default to "' + se2 + '"')), null) : e2;
}
function fr2(e2, t) {
  let r, o2, a3, l, i2;
  if (ar2(e2)) {
    let u2 = e2.getAttribute("action");
    o2 = u2 ? Ye(u2, t) : null, r = e2.getAttribute("method") || le2, a3 = Ne(e2.getAttribute("enctype")) || se2, l = new FormData(e2);
  } else if (or2(e2) || ir(e2) && (e2.type === "submit" || e2.type === "image")) {
    let u2 = e2.form;
    if (u2 == null)
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    let f2 = e2.getAttribute("formaction") || u2.getAttribute("action");
    if (o2 = f2 ? Ye(f2, t) : null, r = e2.getAttribute("formmethod") || u2.getAttribute("method") || le2, a3 = Ne(e2.getAttribute("formenctype")) || Ne(u2.getAttribute("enctype")) || se2, l = new FormData(u2, e2), !cr()) {
      let {
        name: s2,
        type: c3,
        value: d2
      } = e2;
      if (c3 === "image") {
        let p3 = s2 ? s2 + "." : "";
        l.append(p3 + "x", "0"), l.append(p3 + "y", "0");
      } else s2 && l.append(s2, d2);
    }
  } else {
    if (ve(e2))
      throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
    r = le2, o2 = null, a3 = se2, i2 = e2;
  }
  return l && a3 === "text/plain" && (i2 = l, l = void 0), {
    action: o2,
    method: r.toLowerCase(),
    encType: a3,
    formData: l,
    body: i2
  };
}
var pr = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"];
var hr = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"];
var mr = ["fetcherKey", "navigate", "reloadDocument", "replace", "state", "method", "action", "onSubmit", "relative", "preventScrollReset", "viewTransition"];
var vr = "6";
try {
  window.__reactRouterVersion = vr;
} catch {
}
function Er(e2, t) {
  return Sa({
    basename: t == null ? void 0 : t.basename,
    future: D({}, t == null ? void 0 : t.future, {
      v7_prependBasename: true
    }),
    history: Kr({
      window: t == null ? void 0 : t.window
    }),
    hydrationData: (t == null ? void 0 : t.hydrationData) || xt(),
    routes: e2,
    mapRouteProperties: me,
    dataStrategy: t == null ? void 0 : t.dataStrategy,
    patchRoutesOnNavigation: t == null ? void 0 : t.patchRoutesOnNavigation,
    window: t == null ? void 0 : t.window
  }).initialize();
}
function yr(e2, t) {
  return Sa({
    basename: t == null ? void 0 : t.basename,
    future: D({}, t == null ? void 0 : t.future, {
      v7_prependBasename: true
    }),
    history: kr({
      window: t == null ? void 0 : t.window
    }),
    hydrationData: (t == null ? void 0 : t.hydrationData) || xt(),
    routes: e2,
    mapRouteProperties: me,
    dataStrategy: t == null ? void 0 : t.dataStrategy,
    patchRoutesOnNavigation: t == null ? void 0 : t.patchRoutesOnNavigation,
    window: t == null ? void 0 : t.window
  }).initialize();
}
function xt() {
  var e2;
  let t = (e2 = window) == null ? void 0 : e2.__staticRouterHydrationData;
  return t && t.errors && (t = D({}, t, {
    errors: gr(t.errors)
  })), t;
}
function gr(e2) {
  if (!e2) return null;
  let t = Object.entries(e2), r = {};
  for (let [o2, a3] of t)
    if (a3 && a3.__type === "RouteErrorResponse")
      r[o2] = new lt(a3.status, a3.statusText, a3.data, a3.internal === true);
    else if (a3 && a3.__type === "Error") {
      if (a3.__subType) {
        let l = window[a3.__subType];
        if (typeof l == "function")
          try {
            let i2 = new l(a3.message);
            i2.stack = "", r[o2] = i2;
          } catch {
          }
      }
      if (r[o2] == null) {
        let l = new Error(a3.message);
        l.stack = "", r[o2] = l;
      }
    } else
      r[o2] = a3;
  return r;
}
var Ee = n.createContext({
  isTransitioning: false
});
Ee.displayName = "ViewTransition";
var ye = n.createContext(/* @__PURE__ */ new Map());
ye.displayName = "Fetchers";
var Nr = "startTransition";
var A = n[Nr];
var br = "flushSync";
var Ye2 = Bt[br];
var Rr = "useId";
var $e = n[Rr];
function wr(e2) {
  A ? A(e2) : e2();
}
function q(e2) {
  Ye2 ? Ye2(e2) : e2();
}
var Cr = class {
  constructor() {
    this.status = "pending", this.promise = new Promise((t, r) => {
      this.resolve = (o2) => {
        this.status === "pending" && (this.status = "resolved", t(o2));
      }, this.reject = (o2) => {
        this.status === "pending" && (this.status = "rejected", r(o2));
      };
    });
  }
};
function Sr(e2) {
  let {
    fallbackElement: t,
    router: r,
    future: o2
  } = e2, [a3, l] = n.useState(r.state), [i2, u2] = n.useState(), [f2, s2] = n.useState({
    isTransitioning: false
  }), [c3, d2] = n.useState(), [p3, v] = n.useState(), [g2, N2] = n.useState(), y2 = n.useRef(/* @__PURE__ */ new Map()), {
    v7_startTransition: w2
  } = o2 || {}, h = n.useCallback((R) => {
    w2 ? wr(R) : R();
  }, [w2]), E = n.useCallback((R, F2) => {
    let {
      deletedFetchers: x2,
      flushSync: oe3,
      viewTransitionOpts: K3
    } = F2;
    x2.forEach((z3) => y2.current.delete(z3)), R.fetchers.forEach((z3, At3) => {
      z3.data !== void 0 && y2.current.set(At3, z3.data);
    });
    let It3 = r.window == null || r.window.document == null || typeof r.window.document.startViewTransition != "function";
    if (!K3 || It3) {
      oe3 ? q(() => l(R)) : h(() => l(R));
      return;
    }
    if (oe3) {
      q(() => {
        p3 && (c3 && c3.resolve(), p3.skipTransition()), s2({
          isTransitioning: true,
          flushSync: true,
          currentLocation: K3.currentLocation,
          nextLocation: K3.nextLocation
        });
      });
      let z3 = r.window.document.startViewTransition(() => {
        q(() => l(R));
      });
      z3.finished.finally(() => {
        q(() => {
          d2(void 0), v(void 0), u2(void 0), s2({
            isTransitioning: false
          });
        });
      }), q(() => v(z3));
      return;
    }
    p3 ? (c3 && c3.resolve(), p3.skipTransition(), N2({
      state: R,
      currentLocation: K3.currentLocation,
      nextLocation: K3.nextLocation
    })) : (u2(R), s2({
      isTransitioning: true,
      flushSync: false,
      currentLocation: K3.currentLocation,
      nextLocation: K3.nextLocation
    }));
  }, [r.window, p3, c3, y2, h]);
  n.useLayoutEffect(() => r.subscribe(E), [r, E]), n.useEffect(() => {
    f2.isTransitioning && !f2.flushSync && d2(new Cr());
  }, [f2]), n.useEffect(() => {
    if (c3 && i2 && r.window) {
      let R = i2, F2 = c3.promise, x2 = r.window.document.startViewTransition(async () => {
        h(() => l(R)), await F2;
      });
      x2.finished.finally(() => {
        d2(void 0), v(void 0), u2(void 0), s2({
          isTransitioning: false
        });
      }), v(x2);
    }
  }, [h, i2, c3, r.window]), n.useEffect(() => {
    c3 && i2 && a3.location.key === i2.location.key && c3.resolve();
  }, [c3, p3, a3.location, i2]), n.useEffect(() => {
    !f2.isTransitioning && g2 && (u2(g2.state), s2({
      isTransitioning: true,
      flushSync: false,
      currentLocation: g2.currentLocation,
      nextLocation: g2.nextLocation
    }), N2(void 0));
  }, [f2.isTransitioning, g2]), n.useEffect(() => {
    le(t == null || !r.future.v7_partialHydration, "`<RouterProvider fallbackElement>` is deprecated when using `v7_partialHydration`, use a `HydrateFallback` component instead");
  }, []);
  let b2 = n.useMemo(() => ({
    createHref: r.createHref,
    encodeLocation: r.encodeLocation,
    go: (R) => r.navigate(R),
    push: (R, F2, x2) => r.navigate(R, {
      state: F2,
      preventScrollReset: x2 == null ? void 0 : x2.preventScrollReset
    }),
    replace: (R, F2, x2) => r.navigate(R, {
      replace: true,
      state: F2,
      preventScrollReset: x2 == null ? void 0 : x2.preventScrollReset
    })
  }), [r]), k3 = r.basename || "/", J3 = n.useMemo(() => ({
    router: r,
    navigator: b2,
    static: false,
    basename: k3
  }), [r, b2, k3]), ne2 = n.useMemo(() => ({
    v7_relativeSplatPath: r.future.v7_relativeSplatPath
  }), [r.future.v7_relativeSplatPath]);
  return n.createElement(n.Fragment, null, n.createElement(U.Provider, {
    value: J3
  }, n.createElement(B2.Provider, {
    value: a3
  }, n.createElement(ye.Provider, {
    value: y2.current
  }, n.createElement(Ee.Provider, {
    value: f2
  }, n.createElement(H, {
    basename: k3,
    location: a3.location,
    navigationType: a3.historyAction,
    navigator: b2,
    future: ne2
  }, a3.initialized || r.future.v7_partialHydration ? n.createElement(_r, {
    routes: r.routes,
    future: r.future,
    state: a3
  }) : t))))), null);
}
var _r = n.memo(xr);
function xr(e2) {
  let {
    routes: t,
    future: r,
    state: o2
  } = e2;
  return pe2(t, void 0, o2, r);
}
function Dr(e2) {
  let {
    basename: t,
    children: r,
    future: o2,
    window: a3
  } = e2, l = n.useRef();
  l.current == null && (l.current = Kr({
    window: a3,
    v5Compat: true
  }));
  let i2 = l.current, [u2, f2] = n.useState({
    action: i2.action,
    location: i2.location
  }), {
    v7_startTransition: s2
  } = o2 || {}, c3 = n.useCallback((d2) => {
    s2 && A ? A(() => f2(d2)) : f2(d2);
  }, [f2, s2]);
  return n.useLayoutEffect(() => i2.listen(c3), [i2, c3]), n.createElement(H, {
    basename: t,
    children: r,
    location: u2.location,
    navigationType: u2.action,
    navigator: i2,
    future: o2
  });
}
function Or(e2) {
  let {
    basename: t,
    children: r,
    future: o2,
    window: a3
  } = e2, l = n.useRef();
  l.current == null && (l.current = kr({
    window: a3,
    v5Compat: true
  }));
  let i2 = l.current, [u2, f2] = n.useState({
    action: i2.action,
    location: i2.location
  }), {
    v7_startTransition: s2
  } = o2 || {}, c3 = n.useCallback((d2) => {
    s2 && A ? A(() => f2(d2)) : f2(d2);
  }, [f2, s2]);
  return n.useLayoutEffect(() => i2.listen(c3), [i2, c3]), n.createElement(H, {
    basename: t,
    children: r,
    location: u2.location,
    navigationType: u2.action,
    navigator: i2,
    future: o2
  });
}
function Dt(e2) {
  let {
    basename: t,
    children: r,
    future: o2,
    history: a3
  } = e2, [l, i2] = n.useState({
    action: a3.action,
    location: a3.location
  }), {
    v7_startTransition: u2
  } = o2 || {}, f2 = n.useCallback((s2) => {
    u2 && A ? A(() => i2(s2)) : i2(s2);
  }, [i2, u2]);
  return n.useLayoutEffect(() => a3.listen(f2), [a3, f2]), n.createElement(H, {
    basename: t,
    children: r,
    location: l.location,
    navigationType: l.action,
    navigator: a3,
    future: o2
  });
}
Dt.displayName = "unstable_HistoryRouter";
var Pr = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
var Lr = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var je = n.forwardRef(function(t, r) {
  let {
    onClick: o2,
    relative: a3,
    reloadDocument: l,
    replace: i2,
    state: u2,
    target: f2,
    to: s2,
    preventScrollReset: c3,
    viewTransition: d2
  } = t, p3 = Me(t, pr), {
    basename: v
  } = n.useContext(S), g2, N2 = false;
  if (typeof s2 == "string" && Lr.test(s2) && (g2 = s2, Pr))
    try {
      let E = new URL(window.location.href), b2 = s2.startsWith("//") ? new URL(E.protocol + s2) : new URL(s2), k3 = Ye(b2.pathname, v);
      b2.origin === E.origin && k3 != null ? s2 = k3 + b2.search + b2.hash : N2 = true;
    } catch {
      le(false, '<Link to="' + s2 + '"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.');
    }
  let y2 = De(s2, {
    relative: a3
  }), w2 = Tt(s2, {
    replace: i2,
    state: u2,
    target: f2,
    preventScrollReset: c3,
    relative: a3,
    viewTransition: d2
  });
  function h(E) {
    o2 && o2(E), E.defaultPrevented || w2(E);
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    n.createElement("a", D({}, p3, {
      href: g2 || y2,
      onClick: N2 || l ? o2 : h,
      ref: r,
      target: f2
    }))
  );
});
je.displayName = "Link";
var Ot = n.forwardRef(function(t, r) {
  let {
    "aria-current": o2 = "page",
    caseSensitive: a3 = false,
    className: l = "",
    end: i2 = false,
    style: u2,
    to: f2,
    viewTransition: s2,
    children: c3
  } = t, d2 = Me(t, hr), p3 = Y(f2, {
    relative: d2.relative
  }), v = L(), g2 = n.useContext(B2), {
    navigator: N2,
    basename: y2
  } = n.useContext(S), w2 = g2 != null && // Conditional usage is OK here because the usage of a data router is static
  // eslint-disable-next-line react-hooks/rules-of-hooks
  kt(p3) && s2 === true, h = N2.encodeLocation ? N2.encodeLocation(p3).pathname : p3.pathname, E = v.pathname, b2 = g2 && g2.navigation && g2.navigation.location ? g2.navigation.location.pathname : null;
  a3 || (E = E.toLowerCase(), b2 = b2 ? b2.toLowerCase() : null, h = h.toLowerCase()), b2 && y2 && (b2 = Ye(b2, y2) || b2);
  const k3 = h !== "/" && h.endsWith("/") ? h.length - 1 : h.length;
  let J3 = E === h || !i2 && E.startsWith(h) && E.charAt(k3) === "/", ne2 = b2 != null && (b2 === h || !i2 && b2.startsWith(h) && b2.charAt(h.length) === "/"), R = {
    isActive: J3,
    isPending: ne2,
    isTransitioning: w2
  }, F2 = J3 ? o2 : void 0, x2;
  typeof l == "function" ? x2 = l(R) : x2 = [l, J3 ? "active" : null, ne2 ? "pending" : null, w2 ? "transitioning" : null].filter(Boolean).join(" ");
  let oe3 = typeof u2 == "function" ? u2(R) : u2;
  return n.createElement(je, D({}, d2, {
    "aria-current": F2,
    className: x2,
    ref: r,
    style: oe3,
    to: f2,
    viewTransition: s2
  }), typeof c3 == "function" ? c3(R) : c3);
});
Ot.displayName = "NavLink";
var He2 = n.forwardRef((e2, t) => {
  let {
    fetcherKey: r,
    navigate: o2,
    reloadDocument: a3,
    replace: l,
    state: i2,
    method: u2 = le2,
    action: f2,
    onSubmit: s2,
    relative: c3,
    preventScrollReset: d2,
    viewTransition: p3
  } = e2, v = Me(e2, mr), g2 = ze(), N2 = Ut(f2, {
    relative: c3
  }), y2 = u2.toLowerCase() === "get" ? "get" : "post", w2 = (h) => {
    if (s2 && s2(h), h.defaultPrevented) return;
    h.preventDefault();
    let E = h.nativeEvent.submitter, b2 = (E == null ? void 0 : E.getAttribute("formmethod")) || u2;
    g2(E || h.currentTarget, {
      fetcherKey: r,
      method: b2,
      navigate: o2,
      replace: l,
      state: i2,
      relative: c3,
      preventScrollReset: d2,
      viewTransition: p3
    });
  };
  return n.createElement("form", D({
    ref: t,
    method: y2,
    action: N2,
    onSubmit: a3 ? s2 : w2
  }, v));
});
He2.displayName = "Form";
function Pt(e2) {
  let {
    getKey: t,
    storageKey: r
  } = e2;
  return Vt({
    getKey: t,
    storageKey: r
  }), null;
}
Pt.displayName = "ScrollRestoration";
var $2;
(function(e2) {
  e2.UseScrollRestoration = "useScrollRestoration", e2.UseSubmit = "useSubmit", e2.UseSubmitFetcher = "useSubmitFetcher", e2.UseFetcher = "useFetcher", e2.useViewTransitionState = "useViewTransitionState";
})($2 || ($2 = {}));
var ee;
(function(e2) {
  e2.UseFetcher = "useFetcher", e2.UseFetchers = "useFetchers", e2.UseScrollRestoration = "useScrollRestoration";
})(ee || (ee = {}));
function Lt(e2) {
  return e2 + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function ge(e2) {
  let t = n.useContext(U);
  return t || (true ? B(false, Lt(e2)) : B(false)), t;
}
function Ke(e2) {
  let t = n.useContext(B2);
  return t || (true ? B(false, Lt(e2)) : B(false)), t;
}
function Tt(e2, t) {
  let {
    target: r,
    replace: o2,
    state: a3,
    preventScrollReset: l,
    relative: i2,
    viewTransition: u2
  } = t === void 0 ? {} : t, f2 = te(), s2 = L(), c3 = Y(e2, {
    relative: i2
  });
  return n.useCallback((d2) => {
    if (sr(d2, r)) {
      d2.preventDefault();
      let p3 = o2 !== void 0 ? o2 : se(s2) === se(c3);
      f2(e2, {
        replace: p3,
        state: a3,
        preventScrollReset: l,
        relative: i2,
        viewTransition: u2
      });
    }
  }, [s2, f2, c3, o2, a3, r, e2, l, i2, u2]);
}
function Tr(e2) {
  le(typeof URLSearchParams < "u", "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params.");
  let t = n.useRef(ce(e2)), r = n.useRef(false), o2 = L(), a3 = n.useMemo(() => (
    // Only merge in the defaults if we haven't yet called setSearchParams.
    // Once we call that we want those to take precedence, otherwise you can't
    // remove a param with setSearchParams({}) if it has an initial value
    ur(o2.search, r.current ? null : t.current)
  ), [o2.search]), l = te(), i2 = n.useCallback((u2, f2) => {
    const s2 = ce(typeof u2 == "function" ? u2(a3) : u2);
    r.current = true, l("?" + s2, f2);
  }, [l, a3]);
  return [a3, i2];
}
function Fr() {
  if (typeof document > "u")
    throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
}
var Ur = 0;
var Ft = () => "__" + String(++Ur) + "__";
function ze() {
  let {
    router: e2
  } = ge($2.UseSubmit), {
    basename: t
  } = n.useContext(S), r = Fe();
  return n.useCallback(function(o2, a3) {
    a3 === void 0 && (a3 = {}), Fr();
    let {
      action: l,
      method: i2,
      encType: u2,
      formData: f2,
      body: s2
    } = fr2(o2, t);
    if (a3.navigate === false) {
      let c3 = a3.fetcherKey || Ft();
      e2.fetch(c3, r, a3.action || l, {
        preventScrollReset: a3.preventScrollReset,
        formData: f2,
        body: s2,
        formMethod: a3.method || i2,
        formEncType: a3.encType || u2,
        flushSync: a3.flushSync
      });
    } else
      e2.navigate(a3.action || l, {
        preventScrollReset: a3.preventScrollReset,
        formData: f2,
        body: s2,
        formMethod: a3.method || i2,
        formEncType: a3.encType || u2,
        replace: a3.replace,
        state: a3.state,
        fromRouteId: r,
        flushSync: a3.flushSync,
        viewTransition: a3.viewTransition
      });
  }, [e2, t, r]);
}
function Ut(e2, t) {
  let {
    relative: r
  } = t === void 0 ? {} : t, {
    basename: o2
  } = n.useContext(S), a3 = n.useContext(_);
  a3 || (true ? B(false, "useFormAction must be used inside a RouteContext") : B(false));
  let [l] = a3.matches.slice(-1), i2 = D({}, Y(e2 || ".", {
    relative: r
  })), u2 = L();
  if (e2 == null) {
    i2.search = u2.search;
    let f2 = new URLSearchParams(i2.search), s2 = f2.getAll("index");
    if (s2.some((d2) => d2 === "")) {
      f2.delete("index"), s2.filter((p3) => p3).forEach((p3) => f2.append("index", p3));
      let d2 = f2.toString();
      i2.search = d2 ? "?" + d2 : "";
    }
  }
  return (!e2 || e2 === ".") && l.route.index && (i2.search = i2.search ? i2.search.replace(/^\?/, "?index&") : "?index"), o2 !== "/" && (i2.pathname = i2.pathname === "/" ? o2 : Ie([o2, i2.pathname])), se(i2);
}
function Vr(e2) {
  var t;
  let {
    key: r
  } = e2 === void 0 ? {} : e2, {
    router: o2
  } = ge($2.UseFetcher), a3 = Ke(ee.UseFetcher), l = n.useContext(ye), i2 = n.useContext(_), u2 = (t = i2.matches[i2.matches.length - 1]) == null ? void 0 : t.route.id;
  l || (true ? B(false, "useFetcher must be used inside a FetchersContext") : B(false)), i2 || (true ? B(false, "useFetcher must be used inside a RouteContext") : B(false)), u2 == null && (true ? B(false, 'useFetcher can only be used on routes that contain a unique "id"') : B(false));
  let f2 = $e ? $e() : "", [s2, c3] = n.useState(r || f2);
  r && r !== s2 ? c3(r) : s2 || c3(Ft()), n.useEffect(() => (o2.getFetcher(s2), () => {
    o2.deleteFetcher(s2);
  }), [o2, s2]);
  let d2 = n.useCallback((h, E) => {
    u2 || (true ? B(false, "No routeId available for fetcher.load()") : B(false)), o2.fetch(s2, u2, h, E);
  }, [s2, u2, o2]), p3 = ze(), v = n.useCallback((h, E) => {
    p3(h, D({}, E, {
      navigate: false,
      fetcherKey: s2
    }));
  }, [s2, p3]), g2 = n.useMemo(() => {
    let h = n.forwardRef((E, b2) => n.createElement(He2, D({}, E, {
      navigate: false,
      fetcherKey: s2,
      ref: b2
    })));
    return h.displayName = "fetcher.Form", h;
  }, [s2]), N2 = a3.fetchers.get(s2) || fr, y2 = l.get(s2);
  return n.useMemo(() => D({
    Form: g2,
    submit: v,
    load: d2
  }, N2, {
    data: y2
  }), [g2, v, d2, N2, y2]);
}
function kr2() {
  let e2 = Ke(ee.UseFetchers);
  return Array.from(e2.fetchers.entries()).map((t) => {
    let [r, o2] = t;
    return D({}, o2, {
      key: r
    });
  });
}
var Je = "react-router-scroll-positions";
var ie2 = {};
function Vt(e2) {
  let {
    getKey: t,
    storageKey: r
  } = e2 === void 0 ? {} : e2, {
    router: o2
  } = ge($2.UseScrollRestoration), {
    restoreScrollPosition: a3,
    preventScrollReset: l
  } = Ke(ee.UseScrollRestoration), {
    basename: i2
  } = n.useContext(S), u2 = L(), f2 = Ve(), s2 = Ue();
  n.useEffect(() => (window.history.scrollRestoration = "manual", () => {
    window.history.scrollRestoration = "auto";
  }), []), Ar(n.useCallback(() => {
    if (s2.state === "idle") {
      let c3 = (t ? t(u2, f2) : null) || u2.key;
      ie2[c3] = window.scrollY;
    }
    try {
      sessionStorage.setItem(r || Je, JSON.stringify(ie2));
    } catch (c3) {
      le(false, "Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (" + c3 + ").");
    }
    window.history.scrollRestoration = "auto";
  }, [r, t, s2.state, u2, f2])), typeof document < "u" && (n.useLayoutEffect(() => {
    try {
      let c3 = sessionStorage.getItem(r || Je);
      c3 && (ie2 = JSON.parse(c3));
    } catch {
    }
  }, [r]), n.useLayoutEffect(() => {
    let c3 = t && i2 !== "/" ? (p3, v) => t(
      // Strip the basename to match useLocation()
      D({}, p3, {
        pathname: Ye(p3.pathname, i2) || p3.pathname
      }),
      v
    ) : t, d2 = o2 == null ? void 0 : o2.enableScrollRestoration(ie2, () => window.scrollY, c3);
    return () => d2 && d2();
  }, [o2, i2, t]), n.useLayoutEffect(() => {
    if (a3 !== false) {
      if (typeof a3 == "number") {
        window.scrollTo(0, a3);
        return;
      }
      if (u2.hash) {
        let c3 = document.getElementById(decodeURIComponent(u2.hash.slice(1)));
        if (c3) {
          c3.scrollIntoView();
          return;
        }
      }
      l !== true && window.scrollTo(0, 0);
    }
  }, [u2, a3, l]));
}
function Ir(e2, t) {
  let {
    capture: r
  } = t || {};
  n.useEffect(() => {
    let o2 = r != null ? {
      capture: r
    } : void 0;
    return window.addEventListener("beforeunload", e2, o2), () => {
      window.removeEventListener("beforeunload", e2, o2);
    };
  }, [e2, r]);
}
function Ar(e2, t) {
  let {
    capture: r
  } = {};
  n.useEffect(() => {
    let o2 = r != null ? {
      capture: r
    } : void 0;
    return window.addEventListener("pagehide", e2, o2), () => {
      window.removeEventListener("pagehide", e2, o2);
    };
  }, [e2, r]);
}
function Br(e2) {
  let {
    when: t,
    message: r
  } = e2, o2 = Ae(t);
  n.useEffect(() => {
    o2.state === "blocked" && (window.confirm(r) ? setTimeout(o2.proceed, 0) : o2.reset());
  }, [o2, r]), n.useEffect(() => {
    o2.state === "blocked" && !t && o2.reset();
  }, [o2, t]);
}
function kt(e2, t) {
  t === void 0 && (t = {});
  let r = n.useContext(Ee);
  r == null && (true ? B(false, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?") : B(false));
  let {
    basename: o2
  } = ge($2.useViewTransitionState), a3 = Y(e2, {
    relative: t.relative
  });
  if (!r.isTransitioning)
    return false;
  let l = Ye(r.currentLocation.pathname, o2) || r.currentLocation.pathname, i2 = Ye(r.nextLocation.pathname, o2) || r.nextLocation.pathname;
  return mt(a3.pathname, i2) != null || mt(a3.pathname, l) != null;
}
var Hr = Object.freeze(Object.defineProperty({
  __proto__: null,
  AbortedDeferredError: yt,
  Await: Ct,
  BrowserRouter: Dr,
  Form: He2,
  HashRouter: Or,
  Link: je,
  MemoryRouter: Nt,
  NavLink: Ot,
  Navigate: bt,
  get NavigationType() {
    return $;
  },
  Outlet: Rt,
  Route: Be,
  Router: H,
  RouterProvider: Sr,
  Routes: wt,
  ScrollRestoration: Pt,
  UNSAFE_DataRouterContext: U,
  UNSAFE_DataRouterStateContext: B2,
  UNSAFE_ErrorResponseImpl: lt,
  UNSAFE_FetchersContext: ye,
  UNSAFE_LocationContext: M,
  UNSAFE_NavigationContext: S,
  UNSAFE_RouteContext: _,
  UNSAFE_ViewTransitionContext: Ee,
  UNSAFE_useRouteId: Fe,
  UNSAFE_useScrollRestoration: Vt,
  createBrowserRouter: Er,
  createHashRouter: yr,
  createMemoryRouter: _t,
  createPath: se,
  createRoutesFromChildren: W,
  createRoutesFromElements: W,
  createSearchParams: ce,
  defer: ma,
  generatePath: na,
  isRouteErrorResponse: He,
  json: ua,
  matchPath: mt,
  matchRoutes: pe,
  parsePath: ie,
  redirect: St,
  redirectDocument: ya,
  renderMatches: St2,
  replace: ga,
  resolvePath: nr,
  unstable_HistoryRouter: Dt,
  unstable_usePrompt: Br,
  useActionData: Et,
  useAsyncError: yt2,
  useAsyncValue: Ie2,
  useBeforeUnload: Ir,
  useBlocker: Ae,
  useFetcher: Vr,
  useFetchers: kr2,
  useFormAction: Ut,
  useHref: De,
  useInRouterContext: V,
  useLinkClickHandler: Tt,
  useLoaderData: mt2,
  useLocation: L,
  useMatch: lt2,
  useMatches: Ve,
  useNavigate: te,
  useNavigation: Ue,
  useNavigationType: it,
  useOutlet: Oe2,
  useOutletContext: dt,
  useParams: ft,
  useResolvedPath: Y,
  useRevalidator: ht,
  useRouteError: ke,
  useRouteLoaderData: vt,
  useRoutes: Pe,
  useSearchParams: Tr,
  useSubmit: ze,
  useViewTransitionState: kt
}, Symbol.toStringTag, { value: "Module" }));

// node_modules/zudoku/lib/joinPath-B7kNnUX4.js
var o = (...n2) => {
  const a3 = n2.filter((e2) => !!e2).map((e2) => e2.replace(/(^\/+|\/+$)/g, "")).join("/").replace(/(^\/+|\/+$)/g, "");
  return a3 ? `/${a3}` : "/";
};

// node_modules/zudoku/lib/ZudokuContext-BEmsYQoq.js
var P2 = __toESM(require_react(), 1);
var import_react = __toESM(require_react(), 1);
var Le2 = (t) => {
  throw TypeError(t);
};
var pe3 = (t, e2, s2) => e2.has(t) || Le2("Cannot " + s2);
var i = (t, e2, s2) => (pe3(t, e2, "read from private field"), s2 ? s2.call(t) : e2.get(t));
var y = (t, e2, s2) => e2.has(t) ? Le2("Cannot add the same private member more than once") : e2 instanceof WeakSet ? e2.add(t) : e2.set(t, s2);
var c2 = (t, e2, s2, r) => (pe3(t, e2, "write to private field"), r ? r.call(t, s2) : e2.set(t, s2), s2);
var b = (t, e2, s2) => (pe3(t, e2, "access private method"), s2);
var xe2 = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set(), this.subscribe = this.subscribe.bind(this);
  }
  subscribe(t) {
    return this.listeners.add(t), this.onSubscribe(), () => {
      this.listeners.delete(t), this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};
var V2 = typeof window > "u" || "Deno" in globalThis;
function be() {
}
function Gt2(t, e2) {
  return typeof t == "function" ? t(e2) : t;
}
function me2(t) {
  return typeof t == "number" && t >= 0 && t !== 1 / 0;
}
function Ze(t, e2) {
  return Math.max(t + (e2 || 0) - Date.now(), 0);
}
function de(t, e2) {
  return typeof t == "function" ? t(e2) : t;
}
function I2(t, e2) {
  return typeof t == "function" ? t(e2) : t;
}
function zt2(t, e2) {
  const {
    type: s2 = "all",
    exact: r,
    fetchStatus: n2,
    predicate: o2,
    queryKey: a3,
    stale: h
  } = t;
  if (a3) {
    if (r) {
      if (e2.queryHash !== lt3(a3, e2.options))
        return false;
    } else if (!Qe(e2.queryKey, a3))
      return false;
  }
  if (s2 !== "all") {
    const l = e2.isActive();
    if (s2 === "active" && !l || s2 === "inactive" && l)
      return false;
  }
  return !(typeof h == "boolean" && e2.isStale() !== h || n2 && n2 !== e2.state.fetchStatus || o2 && !o2(e2));
}
function Vt2(t, e2) {
  const { exact: s2, status: r, predicate: n2, mutationKey: o2 } = t;
  if (o2) {
    if (!e2.options.mutationKey)
      return false;
    if (s2) {
      if (ge2(e2.options.mutationKey) !== ge2(o2))
        return false;
    } else if (!Qe(e2.options.mutationKey, o2))
      return false;
  }
  return !(r && e2.state.status !== r || n2 && !n2(e2));
}
function lt3(t, e2) {
  return ((e2 == null ? void 0 : e2.queryKeyHashFn) || ge2)(t);
}
function ge2(t) {
  return JSON.stringify(
    t,
    (e2, s2) => Ce(s2) ? Object.keys(s2).sort().reduce((r, n2) => (r[n2] = s2[n2], r), {}) : s2
  );
}
function Qe(t, e2) {
  return t === e2 ? true : typeof t != typeof e2 ? false : t && e2 && typeof t == "object" && typeof e2 == "object" ? !Object.keys(e2).some((s2) => !Qe(t[s2], e2[s2])) : false;
}
function Re(t, e2) {
  if (t === e2)
    return t;
  const s2 = Ne2(t) && Ne2(e2);
  if (s2 || Ce(t) && Ce(e2)) {
    const r = s2 ? t : Object.keys(t), n2 = r.length, o2 = s2 ? e2 : Object.keys(e2), a3 = o2.length, h = s2 ? [] : {};
    let l = 0;
    for (let R = 0; R < a3; R++) {
      const v = s2 ? R : o2[R];
      (!s2 && r.includes(v) || s2) && t[v] === void 0 && e2[v] === void 0 ? (h[v] = void 0, l++) : (h[v] = Re(t[v], e2[v]), h[v] === t[v] && t[v] !== void 0 && l++);
    }
    return n2 === a3 && l === n2 ? t : h;
  }
  return e2;
}
function Se(t, e2) {
  if (!e2 || Object.keys(t).length !== Object.keys(e2).length)
    return false;
  for (const s2 in t)
    if (t[s2] !== e2[s2])
      return false;
  return true;
}
function Ne2(t) {
  return Array.isArray(t) && t.length === Object.keys(t).length;
}
function Ce(t) {
  if (!Ke2(t))
    return false;
  const e2 = t.constructor;
  if (e2 === void 0)
    return true;
  const s2 = e2.prototype;
  return !(!Ke2(s2) || !s2.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype);
}
function Ke2(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function dt2(t) {
  return new Promise((e2) => {
    setTimeout(e2, t);
  });
}
function we(t, e2, s2) {
  if (typeof s2.structuralSharing == "function")
    return s2.structuralSharing(t, e2);
  if (s2.structuralSharing !== false) {
    if (true)
      try {
        return Re(t, e2);
      } catch (r) {
        console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${s2.queryHash}]: ${r}`
        );
      }
    return Re(t, e2);
  }
  return e2;
}
function $t2(t, e2, s2 = 0) {
  const r = [...t, e2];
  return s2 && r.length > s2 ? r.slice(1) : r;
}
function Wt2(t, e2, s2 = 0) {
  const r = [e2, ...t];
  return s2 && r.length > s2 ? r.slice(0, -1) : r;
}
var fe = Symbol();
function ft2(t, e2) {
  return t.queryFn === fe && console.error(
    `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${t.queryHash}'`
  ), !t.queryFn && (e2 != null && e2.initialPromise) ? () => e2.initialPromise : !t.queryFn || t.queryFn === fe ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn;
}
var K;
var A2;
var J;
var Ge;
var yt3 = (Ge = class extends xe2 {
  constructor() {
    super();
    y(this, K);
    y(this, A2);
    y(this, J);
    c2(this, J, (e2) => {
      if (!V2 && window.addEventListener) {
        const s2 = () => e2();
        return window.addEventListener("visibilitychange", s2, false), () => {
          window.removeEventListener("visibilitychange", s2);
        };
      }
    });
  }
  onSubscribe() {
    i(this, A2) || this.setEventListener(i(this, J));
  }
  onUnsubscribe() {
    var e2;
    this.hasListeners() || ((e2 = i(this, A2)) == null || e2.call(this), c2(this, A2, void 0));
  }
  setEventListener(e2) {
    var s2;
    c2(this, J, e2), (s2 = i(this, A2)) == null || s2.call(this), c2(this, A2, e2((r) => {
      typeof r == "boolean" ? this.setFocused(r) : this.onFocus();
    }));
  }
  setFocused(e2) {
    i(this, K) !== e2 && (c2(this, K, e2), this.onFocus());
  }
  onFocus() {
    const e2 = this.isFocused();
    this.listeners.forEach((s2) => {
      s2(e2);
    });
  }
  isFocused() {
    var e2;
    return typeof i(this, K) == "boolean" ? i(this, K) : ((e2 = globalThis.document) == null ? void 0 : e2.visibilityState) !== "hidden";
  }
}, K = /* @__PURE__ */ new WeakMap(), A2 = /* @__PURE__ */ new WeakMap(), J = /* @__PURE__ */ new WeakMap(), Ge);
var Xe = new yt3();
var Z2;
var k;
var X;
var ze2;
var pt2 = (ze2 = class extends xe2 {
  constructor() {
    super();
    y(this, Z2, true);
    y(this, k);
    y(this, X);
    c2(this, X, (e2) => {
      if (!V2 && window.addEventListener) {
        const s2 = () => e2(true), r = () => e2(false);
        return window.addEventListener("online", s2, false), window.addEventListener("offline", r, false), () => {
          window.removeEventListener("online", s2), window.removeEventListener("offline", r);
        };
      }
    });
  }
  onSubscribe() {
    i(this, k) || this.setEventListener(i(this, X));
  }
  onUnsubscribe() {
    var e2;
    this.hasListeners() || ((e2 = i(this, k)) == null || e2.call(this), c2(this, k, void 0));
  }
  setEventListener(e2) {
    var s2;
    c2(this, X, e2), (s2 = i(this, k)) == null || s2.call(this), c2(this, k, e2(this.setOnline.bind(this)));
  }
  setOnline(e2) {
    i(this, Z2) !== e2 && (c2(this, Z2, e2), this.listeners.forEach((r) => {
      r(e2);
    }));
  }
  isOnline() {
    return i(this, Z2);
  }
}, Z2 = /* @__PURE__ */ new WeakMap(), k = /* @__PURE__ */ new WeakMap(), X = /* @__PURE__ */ new WeakMap(), ze2);
var Ye3 = new pt2();
function Ee2() {
  let t, e2;
  const s2 = new Promise((n2, o2) => {
    t = n2, e2 = o2;
  });
  s2.status = "pending", s2.catch(() => {
  });
  function r(n2) {
    Object.assign(s2, n2), delete s2.resolve, delete s2.reject;
  }
  return s2.resolve = (n2) => {
    r({
      status: "fulfilled",
      value: n2
    }), t(n2);
  }, s2.reject = (n2) => {
    r({
      status: "rejected",
      reason: n2
    }), e2(n2);
  }, s2;
}
function vt2(t) {
  return Math.min(1e3 * 2 ** t, 3e4);
}
function et(t) {
  return (t ?? "online") === "online" ? Ye3.isOnline() : true;
}
var tt = class extends Error {
  constructor(t) {
    super("CancelledError"), this.revert = t == null ? void 0 : t.revert, this.silent = t == null ? void 0 : t.silent;
  }
};
function ve2(t) {
  return t instanceof tt;
}
function bt2(t) {
  let e2 = false, s2 = 0, r = false, n2;
  const o2 = Ee2(), a3 = (f2) => {
    var g2;
    r || (m(new tt(f2)), (g2 = t.abort) == null || g2.call(t));
  }, h = () => {
    e2 = true;
  }, l = () => {
    e2 = false;
  }, R = () => Xe.isFocused() && (t.networkMode === "always" || Ye3.isOnline()) && t.canRun(), v = () => et(t.networkMode) && t.canRun(), u2 = (f2) => {
    var g2;
    r || (r = true, (g2 = t.onSuccess) == null || g2.call(t, f2), n2 == null || n2(), o2.resolve(f2));
  }, m = (f2) => {
    var g2;
    r || (r = true, (g2 = t.onError) == null || g2.call(t, f2), n2 == null || n2(), o2.reject(f2));
  }, S2 = () => new Promise((f2) => {
    var g2;
    n2 = (T2) => {
      (r || R()) && f2(T2);
    }, (g2 = t.onPause) == null || g2.call(t);
  }).then(() => {
    var f2;
    n2 = void 0, r || (f2 = t.onContinue) == null || f2.call(t);
  }), w2 = () => {
    if (r)
      return;
    let f2;
    const g2 = s2 === 0 ? t.initialPromise : void 0;
    try {
      f2 = g2 ?? t.fn();
    } catch (T2) {
      f2 = Promise.reject(T2);
    }
    Promise.resolve(f2).then(u2).catch((T2) => {
      var ye3;
      if (r)
        return;
      const Q = t.retry ?? (V2 ? 0 : 3), N2 = t.retryDelay ?? vt2, he3 = typeof N2 == "function" ? N2(s2, T2) : N2, ce2 = Q === true || typeof Q == "number" && s2 < Q || typeof Q == "function" && Q(s2, T2);
      if (e2 || !ce2) {
        m(T2);
        return;
      }
      s2++, (ye3 = t.onFail) == null || ye3.call(t, s2, T2), dt2(he3).then(() => R() ? void 0 : S2()).then(() => {
        e2 ? m(T2) : w2();
      });
    });
  };
  return {
    promise: o2,
    cancel: a3,
    continue: () => (n2 == null || n2(), o2),
    cancelRetry: h,
    continueRetry: l,
    canStart: v,
    start: () => (v() ? w2() : S2().then(w2), o2)
  };
}
function mt3() {
  let t = [], e2 = 0, s2 = (h) => {
    h();
  }, r = (h) => {
    h();
  }, n2 = (h) => setTimeout(h, 0);
  const o2 = (h) => {
    e2 ? t.push(h) : n2(() => {
      s2(h);
    });
  }, a3 = () => {
    const h = t;
    t = [], h.length && n2(() => {
      r(() => {
        h.forEach((l) => {
          s2(l);
        });
      });
    });
  };
  return {
    batch: (h) => {
      let l;
      e2++;
      try {
        l = h();
      } finally {
        e2--, e2 || a3();
      }
      return l;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (h) => (...l) => {
      o2(() => {
        h(...l);
      });
    },
    schedule: o2,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (h) => {
      s2 = h;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (h) => {
      r = h;
    },
    setScheduler: (h) => {
      n2 = h;
    }
  };
}
var je2 = mt3();
var _2;
var Ve2;
var gt2 = (Ve2 = class {
  constructor() {
    y(this, _2);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout(), me2(this.gcTime) && c2(this, _2, setTimeout(() => {
      this.optionalRemove();
    }, this.gcTime));
  }
  updateGcTime(t) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      t ?? (V2 ? 1 / 0 : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    i(this, _2) && (clearTimeout(i(this, _2)), c2(this, _2, void 0));
  }
}, _2 = /* @__PURE__ */ new WeakMap(), Ve2);
var Y2;
var ee2;
var D2;
var C;
var ae2;
var H2;
var q2;
var j2;
var $e2;
var Jt2 = ($e2 = class extends gt2 {
  constructor(e2) {
    super();
    y(this, q2);
    y(this, Y2);
    y(this, ee2);
    y(this, D2);
    y(this, C);
    y(this, ae2);
    y(this, H2);
    c2(this, H2, false), c2(this, ae2, e2.defaultOptions), this.setOptions(e2.options), this.observers = [], c2(this, D2, e2.cache), this.queryKey = e2.queryKey, this.queryHash = e2.queryHash, c2(this, Y2, Rt2(this.options)), this.state = e2.state ?? i(this, Y2), this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var e2;
    return (e2 = i(this, C)) == null ? void 0 : e2.promise;
  }
  setOptions(e2) {
    this.options = { ...i(this, ae2), ...e2 }, this.updateGcTime(this.options.gcTime);
  }
  optionalRemove() {
    !this.observers.length && this.state.fetchStatus === "idle" && i(this, D2).remove(this);
  }
  setData(e2, s2) {
    const r = we(this.state.data, e2, this.options);
    return b(this, q2, j2).call(this, {
      data: r,
      type: "success",
      dataUpdatedAt: s2 == null ? void 0 : s2.updatedAt,
      manual: s2 == null ? void 0 : s2.manual
    }), r;
  }
  setState(e2, s2) {
    b(this, q2, j2).call(this, { type: "setState", state: e2, setStateOptions: s2 });
  }
  cancel(e2) {
    var r, n2;
    const s2 = (r = i(this, C)) == null ? void 0 : r.promise;
    return (n2 = i(this, C)) == null || n2.cancel(e2), s2 ? s2.then(be).catch(be) : Promise.resolve();
  }
  destroy() {
    super.destroy(), this.cancel({ silent: true });
  }
  reset() {
    this.destroy(), this.setState(i(this, Y2));
  }
  isActive() {
    return this.observers.some(
      (e2) => I2(e2.options.enabled, this) !== false
    );
  }
  isDisabled() {
    return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === fe || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStale() {
    return this.state.isInvalidated ? true : this.getObserversCount() > 0 ? this.observers.some(
      (e2) => e2.getCurrentResult().isStale
    ) : this.state.data === void 0;
  }
  isStaleByTime(e2 = 0) {
    return this.state.isInvalidated || this.state.data === void 0 || !Ze(this.state.dataUpdatedAt, e2);
  }
  onFocus() {
    var s2;
    const e2 = this.observers.find((r) => r.shouldFetchOnWindowFocus());
    e2 == null || e2.refetch({ cancelRefetch: false }), (s2 = i(this, C)) == null || s2.continue();
  }
  onOnline() {
    var s2;
    const e2 = this.observers.find((r) => r.shouldFetchOnReconnect());
    e2 == null || e2.refetch({ cancelRefetch: false }), (s2 = i(this, C)) == null || s2.continue();
  }
  addObserver(e2) {
    this.observers.includes(e2) || (this.observers.push(e2), this.clearGcTimeout(), i(this, D2).notify({ type: "observerAdded", query: this, observer: e2 }));
  }
  removeObserver(e2) {
    this.observers.includes(e2) && (this.observers = this.observers.filter((s2) => s2 !== e2), this.observers.length || (i(this, C) && (i(this, H2) ? i(this, C).cancel({ revert: true }) : i(this, C).cancelRetry()), this.scheduleGc()), i(this, D2).notify({ type: "observerRemoved", query: this, observer: e2 }));
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    this.state.isInvalidated || b(this, q2, j2).call(this, { type: "invalidate" });
  }
  fetch(e2, s2) {
    var l, R, v;
    if (this.state.fetchStatus !== "idle") {
      if (this.state.data !== void 0 && (s2 != null && s2.cancelRefetch))
        this.cancel({ silent: true });
      else if (i(this, C))
        return i(this, C).continueRetry(), i(this, C).promise;
    }
    if (e2 && this.setOptions(e2), !this.options.queryFn) {
      const u2 = this.observers.find((m) => m.options.queryFn);
      u2 && this.setOptions(u2.options);
    }
    Array.isArray(this.options.queryKey) || console.error(
      "As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']"
    );
    const r = new AbortController(), n2 = (u2) => {
      Object.defineProperty(u2, "signal", {
        enumerable: true,
        get: () => (c2(this, H2, true), r.signal)
      });
    }, o2 = () => {
      const u2 = ft2(this.options, s2), m = {
        queryKey: this.queryKey,
        meta: this.meta
      };
      return n2(m), c2(this, H2, false), this.options.persister ? this.options.persister(
        u2,
        m,
        this
      ) : u2(m);
    }, a3 = {
      fetchOptions: s2,
      options: this.options,
      queryKey: this.queryKey,
      state: this.state,
      fetchFn: o2
    };
    n2(a3), (l = this.options.behavior) == null || l.onFetch(
      a3,
      this
    ), c2(this, ee2, this.state), (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((R = a3.fetchOptions) == null ? void 0 : R.meta)) && b(this, q2, j2).call(this, { type: "fetch", meta: (v = a3.fetchOptions) == null ? void 0 : v.meta });
    const h = (u2) => {
      var m, S2, w2, f2;
      ve2(u2) && u2.silent || b(this, q2, j2).call(this, {
        type: "error",
        error: u2
      }), ve2(u2) || ((S2 = (m = i(this, D2).config).onError) == null || S2.call(
        m,
        u2,
        this
      ), (f2 = (w2 = i(this, D2).config).onSettled) == null || f2.call(
        w2,
        this.state.data,
        u2,
        this
      )), this.scheduleGc();
    };
    return c2(this, C, bt2({
      initialPromise: s2 == null ? void 0 : s2.initialPromise,
      fn: a3.fetchFn,
      abort: r.abort.bind(r),
      onSuccess: (u2) => {
        var m, S2, w2, f2;
        if (u2 === void 0) {
          console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          ), h(new Error(`${this.queryHash} data is undefined`));
          return;
        }
        try {
          this.setData(u2);
        } catch (g2) {
          h(g2);
          return;
        }
        (S2 = (m = i(this, D2).config).onSuccess) == null || S2.call(m, u2, this), (f2 = (w2 = i(this, D2).config).onSettled) == null || f2.call(
          w2,
          u2,
          this.state.error,
          this
        ), this.scheduleGc();
      },
      onError: h,
      onFail: (u2, m) => {
        b(this, q2, j2).call(this, { type: "failed", failureCount: u2, error: m });
      },
      onPause: () => {
        b(this, q2, j2).call(this, { type: "pause" });
      },
      onContinue: () => {
        b(this, q2, j2).call(this, { type: "continue" });
      },
      retry: a3.options.retry,
      retryDelay: a3.options.retryDelay,
      networkMode: a3.options.networkMode,
      canRun: () => true
    })), i(this, C).start();
  }
}, Y2 = /* @__PURE__ */ new WeakMap(), ee2 = /* @__PURE__ */ new WeakMap(), D2 = /* @__PURE__ */ new WeakMap(), C = /* @__PURE__ */ new WeakMap(), ae2 = /* @__PURE__ */ new WeakMap(), H2 = /* @__PURE__ */ new WeakMap(), q2 = /* @__PURE__ */ new WeakSet(), j2 = function(e2) {
  const s2 = (r) => {
    switch (e2.type) {
      case "failed":
        return {
          ...r,
          fetchFailureCount: e2.failureCount,
          fetchFailureReason: e2.error
        };
      case "pause":
        return {
          ...r,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...r,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...r,
          ...st2(r.data, this.options),
          fetchMeta: e2.meta ?? null
        };
      case "success":
        return {
          ...r,
          data: e2.data,
          dataUpdateCount: r.dataUpdateCount + 1,
          dataUpdatedAt: e2.dataUpdatedAt ?? Date.now(),
          error: null,
          isInvalidated: false,
          status: "success",
          ...!e2.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
      case "error":
        const n2 = e2.error;
        return ve2(n2) && n2.revert && i(this, ee2) ? { ...i(this, ee2), fetchStatus: "idle" } : {
          ...r,
          error: n2,
          errorUpdateCount: r.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: r.fetchFailureCount + 1,
          fetchFailureReason: n2,
          fetchStatus: "idle",
          status: "error"
        };
      case "invalidate":
        return {
          ...r,
          isInvalidated: true
        };
      case "setState":
        return {
          ...r,
          ...e2.state
        };
    }
  };
  this.state = s2(this.state), je2.batch(() => {
    this.observers.forEach((r) => {
      r.onQueryUpdate();
    }), i(this, D2).notify({ query: this, type: "updated", action: e2 });
  });
}, $e2);
function st2(t, e2) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: et(e2.networkMode) ? "fetching" : "paused",
    ...t === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function Rt2(t) {
  const e2 = typeof t.initialData == "function" ? t.initialData() : t.initialData, s2 = e2 !== void 0, r = s2 ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
  return {
    data: e2,
    dataUpdateCount: 0,
    dataUpdatedAt: s2 ? r ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: s2 ? "success" : "pending",
    fetchStatus: "idle"
  };
}
var O2;
var d;
var oe;
var F;
var B3;
var te2;
var M2;
var x;
var ue2;
var se3;
var re2;
var G;
var z;
var L2;
var ie3;
var p;
var ne;
var Fe2;
var Oe3;
var Te2;
var De2;
var Pe2;
var qe;
var Ie3;
var it2;
var We2;
var rt = (We2 = class extends xe2 {
  constructor(e2, s2) {
    super();
    y(this, p);
    y(this, O2);
    y(this, d);
    y(this, oe);
    y(this, F);
    y(this, B3);
    y(this, te2);
    y(this, M2);
    y(this, x);
    y(this, ue2);
    y(this, se3);
    y(this, re2);
    y(this, G);
    y(this, z);
    y(this, L2);
    y(this, ie3, /* @__PURE__ */ new Set());
    this.options = s2, c2(this, O2, e2), c2(this, x, null), c2(this, M2, Ee2()), this.options.experimental_prefetchInRender || i(this, M2).reject(
      new Error("experimental_prefetchInRender feature flag is not enabled")
    ), this.bindMethods(), this.setOptions(s2);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    this.listeners.size === 1 && (i(this, d).addObserver(this), _e(i(this, d), this.options) ? b(this, p, ne).call(this) : this.updateResult(), b(this, p, De2).call(this));
  }
  onUnsubscribe() {
    this.hasListeners() || this.destroy();
  }
  shouldFetchOnReconnect() {
    return Ue2(
      i(this, d),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return Ue2(
      i(this, d),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set(), b(this, p, Pe2).call(this), b(this, p, qe).call(this), i(this, d).removeObserver(this);
  }
  setOptions(e2, s2) {
    const r = this.options, n2 = i(this, d);
    if (this.options = i(this, O2).defaultQueryOptions(e2), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof I2(this.options.enabled, i(this, d)) != "boolean")
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    b(this, p, Ie3).call(this), i(this, d).setOptions(this.options), r._defaulted && !Se(this.options, r) && i(this, O2).getQueryCache().notify({
      type: "observerOptionsUpdated",
      query: i(this, d),
      observer: this
    });
    const o2 = this.hasListeners();
    o2 && He3(
      i(this, d),
      n2,
      this.options,
      r
    ) && b(this, p, ne).call(this), this.updateResult(s2), o2 && (i(this, d) !== n2 || I2(this.options.enabled, i(this, d)) !== I2(r.enabled, i(this, d)) || de(this.options.staleTime, i(this, d)) !== de(r.staleTime, i(this, d))) && b(this, p, Fe2).call(this);
    const a3 = b(this, p, Oe3).call(this);
    o2 && (i(this, d) !== n2 || I2(this.options.enabled, i(this, d)) !== I2(r.enabled, i(this, d)) || a3 !== i(this, L2)) && b(this, p, Te2).call(this, a3);
  }
  getOptimisticResult(e2) {
    const s2 = i(this, O2).getQueryCache().build(i(this, O2), e2), r = this.createResult(s2, e2);
    return Ct2(this, r) && (c2(this, F, r), c2(this, te2, this.options), c2(this, B3, i(this, d).state)), r;
  }
  getCurrentResult() {
    return i(this, F);
  }
  trackResult(e2, s2) {
    const r = {};
    return Object.keys(e2).forEach((n2) => {
      Object.defineProperty(r, n2, {
        configurable: false,
        enumerable: true,
        get: () => (this.trackProp(n2), s2 == null || s2(n2), e2[n2])
      });
    }), r;
  }
  trackProp(e2) {
    i(this, ie3).add(e2);
  }
  getCurrentQuery() {
    return i(this, d);
  }
  refetch({ ...e2 } = {}) {
    return this.fetch({
      ...e2
    });
  }
  fetchOptimistic(e2) {
    const s2 = i(this, O2).defaultQueryOptions(e2), r = i(this, O2).getQueryCache().build(i(this, O2), s2);
    return r.fetch().then(() => this.createResult(r, s2));
  }
  fetch(e2) {
    return b(this, p, ne).call(this, {
      ...e2,
      cancelRefetch: e2.cancelRefetch ?? true
    }).then(() => (this.updateResult(), i(this, F)));
  }
  createResult(e2, s2) {
    var Me2;
    const r = i(this, d), n2 = this.options, o2 = i(this, F), a3 = i(this, B3), h = i(this, te2), R = e2 !== r ? e2.state : i(this, oe), { state: v } = e2;
    let u2 = { ...v }, m = false, S2;
    if (s2._optimisticResults) {
      const E = this.hasListeners(), $3 = !E && _e(e2, s2), W3 = E && He3(e2, r, s2, n2);
      ($3 || W3) && (u2 = {
        ...u2,
        ...st2(v.data, e2.options)
      }), s2._optimisticResults === "isRestoring" && (u2.fetchStatus = "idle");
    }
    let { error: w2, errorUpdatedAt: f2, status: g2 } = u2;
    if (s2.select && u2.data !== void 0)
      if (o2 && u2.data === (a3 == null ? void 0 : a3.data) && s2.select === i(this, ue2))
        S2 = i(this, se3);
      else
        try {
          c2(this, ue2, s2.select), S2 = s2.select(u2.data), S2 = we(o2 == null ? void 0 : o2.data, S2, s2), c2(this, se3, S2), c2(this, x, null);
        } catch (E) {
          c2(this, x, E);
        }
    else
      S2 = u2.data;
    if (s2.placeholderData !== void 0 && S2 === void 0 && g2 === "pending") {
      let E;
      if (o2 != null && o2.isPlaceholderData && s2.placeholderData === (h == null ? void 0 : h.placeholderData))
        E = o2.data;
      else if (E = typeof s2.placeholderData == "function" ? s2.placeholderData(
        (Me2 = i(this, re2)) == null ? void 0 : Me2.state.data,
        i(this, re2)
      ) : s2.placeholderData, s2.select && E !== void 0)
        try {
          E = s2.select(E), c2(this, x, null);
        } catch ($3) {
          c2(this, x, $3);
        }
      E !== void 0 && (g2 = "success", S2 = we(
        o2 == null ? void 0 : o2.data,
        E,
        s2
      ), m = true);
    }
    i(this, x) && (w2 = i(this, x), S2 = i(this, se3), f2 = Date.now(), g2 = "error");
    const T2 = u2.fetchStatus === "fetching", Q = g2 === "pending", N2 = g2 === "error", he3 = Q && T2, ce2 = S2 !== void 0, U2 = {
      status: g2,
      fetchStatus: u2.fetchStatus,
      isPending: Q,
      isSuccess: g2 === "success",
      isError: N2,
      isInitialLoading: he3,
      isLoading: he3,
      data: S2,
      dataUpdatedAt: u2.dataUpdatedAt,
      error: w2,
      errorUpdatedAt: f2,
      failureCount: u2.fetchFailureCount,
      failureReason: u2.fetchFailureReason,
      errorUpdateCount: u2.errorUpdateCount,
      isFetched: u2.dataUpdateCount > 0 || u2.errorUpdateCount > 0,
      isFetchedAfterMount: u2.dataUpdateCount > R.dataUpdateCount || u2.errorUpdateCount > R.errorUpdateCount,
      isFetching: T2,
      isRefetching: T2 && !Q,
      isLoadingError: N2 && !ce2,
      isPaused: u2.fetchStatus === "paused",
      isPlaceholderData: m,
      isRefetchError: N2 && ce2,
      isStale: Ae2(e2, s2),
      refetch: this.refetch,
      promise: i(this, M2)
    };
    if (this.options.experimental_prefetchInRender) {
      const E = (le4) => {
        U2.status === "error" ? le4.reject(U2.error) : U2.data !== void 0 && le4.resolve(U2.data);
      }, $3 = () => {
        const le4 = c2(this, M2, U2.promise = Ee2());
        E(le4);
      }, W3 = i(this, M2);
      switch (W3.status) {
        case "pending":
          e2.queryHash === r.queryHash && E(W3);
          break;
        case "fulfilled":
          (U2.status === "error" || U2.data !== W3.value) && $3();
          break;
        case "rejected":
          (U2.status !== "error" || U2.error !== W3.reason) && $3();
          break;
      }
    }
    return U2;
  }
  updateResult(e2) {
    const s2 = i(this, F), r = this.createResult(i(this, d), this.options);
    if (c2(this, B3, i(this, d).state), c2(this, te2, this.options), i(this, B3).data !== void 0 && c2(this, re2, i(this, d)), Se(r, s2))
      return;
    c2(this, F, r);
    const n2 = {}, o2 = () => {
      if (!s2)
        return true;
      const { notifyOnChangeProps: a3 } = this.options, h = typeof a3 == "function" ? a3() : a3;
      if (h === "all" || !h && !i(this, ie3).size)
        return true;
      const l = new Set(
        h ?? i(this, ie3)
      );
      return this.options.throwOnError && l.add("error"), Object.keys(i(this, F)).some((R) => {
        const v = R;
        return i(this, F)[v] !== s2[v] && l.has(v);
      });
    };
    (e2 == null ? void 0 : e2.listeners) !== false && o2() && (n2.listeners = true), b(this, p, it2).call(this, { ...n2, ...e2 });
  }
  onQueryUpdate() {
    this.updateResult(), this.hasListeners() && b(this, p, De2).call(this);
  }
}, O2 = /* @__PURE__ */ new WeakMap(), d = /* @__PURE__ */ new WeakMap(), oe = /* @__PURE__ */ new WeakMap(), F = /* @__PURE__ */ new WeakMap(), B3 = /* @__PURE__ */ new WeakMap(), te2 = /* @__PURE__ */ new WeakMap(), M2 = /* @__PURE__ */ new WeakMap(), x = /* @__PURE__ */ new WeakMap(), ue2 = /* @__PURE__ */ new WeakMap(), se3 = /* @__PURE__ */ new WeakMap(), re2 = /* @__PURE__ */ new WeakMap(), G = /* @__PURE__ */ new WeakMap(), z = /* @__PURE__ */ new WeakMap(), L2 = /* @__PURE__ */ new WeakMap(), ie3 = /* @__PURE__ */ new WeakMap(), p = /* @__PURE__ */ new WeakSet(), ne = function(e2) {
  b(this, p, Ie3).call(this);
  let s2 = i(this, d).fetch(
    this.options,
    e2
  );
  return e2 != null && e2.throwOnError || (s2 = s2.catch(be)), s2;
}, Fe2 = function() {
  b(this, p, Pe2).call(this);
  const e2 = de(
    this.options.staleTime,
    i(this, d)
  );
  if (V2 || i(this, F).isStale || !me2(e2))
    return;
  const r = Ze(i(this, F).dataUpdatedAt, e2) + 1;
  c2(this, G, setTimeout(() => {
    i(this, F).isStale || this.updateResult();
  }, r));
}, Oe3 = function() {
  return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(i(this, d)) : this.options.refetchInterval) ?? false;
}, Te2 = function(e2) {
  b(this, p, qe).call(this), c2(this, L2, e2), !(V2 || I2(this.options.enabled, i(this, d)) === false || !me2(i(this, L2)) || i(this, L2) === 0) && c2(this, z, setInterval(() => {
    (this.options.refetchIntervalInBackground || Xe.isFocused()) && b(this, p, ne).call(this);
  }, i(this, L2)));
}, De2 = function() {
  b(this, p, Fe2).call(this), b(this, p, Te2).call(this, b(this, p, Oe3).call(this));
}, Pe2 = function() {
  i(this, G) && (clearTimeout(i(this, G)), c2(this, G, void 0));
}, qe = function() {
  i(this, z) && (clearInterval(i(this, z)), c2(this, z, void 0));
}, Ie3 = function() {
  const e2 = i(this, O2).getQueryCache().build(i(this, O2), this.options);
  if (e2 === i(this, d))
    return;
  const s2 = i(this, d);
  c2(this, d, e2), c2(this, oe, e2.state), this.hasListeners() && (s2 == null || s2.removeObserver(this), e2.addObserver(this));
}, it2 = function(e2) {
  je2.batch(() => {
    e2.listeners && this.listeners.forEach((s2) => {
      s2(i(this, F));
    }), i(this, O2).getQueryCache().notify({
      query: i(this, d),
      type: "observerResultsUpdated"
    });
  });
}, We2);
function St3(t, e2) {
  return I2(e2.enabled, t) !== false && t.state.data === void 0 && !(t.state.status === "error" && e2.retryOnMount === false);
}
function _e(t, e2) {
  return St3(t, e2) || t.state.data !== void 0 && Ue2(t, e2, e2.refetchOnMount);
}
function Ue2(t, e2, s2) {
  if (I2(e2.enabled, t) !== false) {
    const r = typeof s2 == "function" ? s2(t) : s2;
    return r === "always" || r !== false && Ae2(t, e2);
  }
  return false;
}
function He3(t, e2, s2, r) {
  return (t !== e2 || I2(r.enabled, t) === false) && (!s2.suspense || t.state.status !== "error") && Ae2(t, s2);
}
function Ae2(t, e2) {
  return I2(e2.enabled, t) !== false && t.isStaleByTime(de(e2.staleTime, t));
}
function Ct2(t, e2) {
  return !Se(t.getCurrentResult(), e2);
}
var nt = P2.createContext(
  void 0
);
var wt2 = (t) => {
  const e2 = P2.useContext(nt);
  if (!e2)
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  return e2;
};
var Zt2 = ({
  client: t,
  children: e2
}) => (P2.useEffect(() => (t.mount(), () => {
  t.unmount();
}), [t]), dr.jsx(nt.Provider, { value: t, children: e2 }));
var at = P2.createContext(false);
var Et2 = () => P2.useContext(at);
at.Provider;
function Ft2() {
  let t = false;
  return {
    clearReset: () => {
      t = false;
    },
    reset: () => {
      t = true;
    },
    isReset: () => t
  };
}
var Ot2 = P2.createContext(Ft2());
var Tt2 = () => P2.useContext(Ot2);
function Dt2(t, e2) {
  return typeof t == "function" ? t(...e2) : !!t;
}
function Pt2() {
}
var qt2 = (t, e2) => {
  (t.suspense || t.throwOnError) && (e2.isReset() || (t.retryOnMount = false));
};
var It = (t) => {
  P2.useEffect(() => {
    t.clearReset();
  }, [t]);
};
var Ut2 = ({
  result: t,
  errorResetBoundary: e2,
  throwOnError: s2,
  query: r
}) => t.isError && !e2.isReset() && !t.isFetching && r && Dt2(s2, [t.error, r]);
var xt2 = (t, e2) => e2.state.data === void 0;
var Qt2 = (t) => {
  t.suspense && (typeof t.staleTime != "number" && (t.staleTime = 1e3), typeof t.gcTime == "number" && (t.gcTime = Math.max(t.gcTime, 1e3)));
};
var jt = (t, e2) => t.isLoading && t.isFetching && !e2;
var At = (t, e2) => (t == null ? void 0 : t.suspense) && e2.isPending;
var Be2 = (t, e2, s2) => e2.fetchOptimistic(t).catch(() => {
  s2.clearReset();
});
function ot(t, e2, s2) {
  var v, u2, m, S2, w2;
  if (typeof t != "object" || Array.isArray(t))
    throw new Error(
      'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
    );
  const r = wt2(), n2 = Et2(), o2 = Tt2(), a3 = r.defaultQueryOptions(t);
  (u2 = (v = r.getDefaultOptions().queries) == null ? void 0 : v._experimental_beforeQuery) == null || u2.call(
    v,
    a3
  ), a3._optimisticResults = n2 ? "isRestoring" : "optimistic", Qt2(a3), qt2(a3, o2), It(o2);
  const h = !r.getQueryCache().get(a3.queryHash), [l] = P2.useState(
    () => new e2(
      r,
      a3
    )
  ), R = l.getOptimisticResult(a3);
  if (P2.useSyncExternalStore(
    P2.useCallback(
      (f2) => {
        const g2 = n2 ? () => {
        } : l.subscribe(je2.batchCalls(f2));
        return l.updateResult(), g2;
      },
      [l, n2]
    ),
    () => l.getCurrentResult(),
    () => l.getCurrentResult()
  ), P2.useEffect(() => {
    l.setOptions(a3, { listeners: false });
  }, [a3, l]), At(a3, R))
    throw Be2(a3, l, o2);
  if (Ut2({
    result: R,
    errorResetBoundary: o2,
    throwOnError: a3.throwOnError,
    query: r.getQueryCache().get(a3.queryHash)
  }))
    throw R.error;
  if ((S2 = (m = r.getDefaultOptions().queries) == null ? void 0 : m._experimental_afterQuery) == null || S2.call(
    m,
    a3,
    R
  ), a3.experimental_prefetchInRender && !V2 && jt(R, n2)) {
    const f2 = h ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      Be2(a3, l, o2)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      (w2 = r.getQueryCache().get(a3.queryHash)) == null ? void 0 : w2.promise
    );
    f2 == null || f2.catch(Pt2).finally(() => {
      l.hasListeners() || l.updateResult();
    });
  }
  return a3.notifyOnChangeProps ? R : l.trackResult(R);
}
function kt2(t, e2) {
  return ot(t, rt);
}
function Mt(t, e2) {
  return t.queryFn === fe && console.error("skipToken is not allowed for useSuspenseQuery"), ot(
    {
      ...t,
      enabled: true,
      suspense: true,
      throwOnError: xt2,
      placeholderData: void 0
    },
    rt
  );
}
var Lt2 = (0, import_react.createContext)(
  void 0
);
var ke2 = () => {
  const t = (0, import_react.useContext)(Lt2);
  if (!t)
    throw new Error("useDevPortal must be used within a DevPortalProvider.");
  return t;
};
var Xt2 = () => {
  const { getApiIdentities: t } = ke2();
  return kt2({
    queryFn: t,
    queryKey: ["api-identities"]
  });
};
var Nt2 = () => {
  const { topNavigation: t } = ke2(), s2 = L().pathname.split("/").at(1);
  if (s2)
    return t.find((r) => r.id === s2);
};
var Yt2 = () => {
  const { getPluginSidebar: t, sidebars: e2 } = ke2(), s2 = Nt2(), r = s2 == null ? void 0 : s2.id, n2 = r ? e2[r] ?? [] : [], o2 = L();
  return Mt({
    queryFn: async () => {
      const a3 = r ? await t(r) : await t(o2.pathname);
      return {
        items: [...n2, ...a3],
        currentTopNavItem: s2
      };
    },
    queryKey: ["navigation", r]
  });
};

// node_modules/zudoku/lib/Markdown-CWI6lU11.js
var import_react2 = __toESM(require_react(), 1);
function Ai(e2) {
  var t, n2, r = "";
  if (typeof e2 == "string" || typeof e2 == "number") r += e2;
  else if (typeof e2 == "object") if (Array.isArray(e2)) for (t = 0; t < e2.length; t++) e2[t] && (n2 = Ai(e2[t])) && (r && (r += " "), r += n2);
  else for (t in e2) e2[t] && (r && (r += " "), r += t);
  return r;
}
function Gs() {
  for (var e2, t, n2 = 0, r = ""; n2 < arguments.length; ) (e2 = arguments[n2++]) && (t = Ai(e2)) && (r && (r += " "), r += t);
  return r;
}
var Kr2 = (e2) => typeof e2 == "boolean" ? "".concat(e2) : e2 === 0 ? "0" : e2;
var Zr = Gs;
var qs = (e2, t) => (n2) => {
  var r;
  if ((t == null ? void 0 : t.variants) == null) return Zr(e2, n2 == null ? void 0 : n2.class, n2 == null ? void 0 : n2.className);
  const { variants: a3, defaultVariants: u2 } = t, i2 = Object.keys(a3).map((c3) => {
    const f2 = n2 == null ? void 0 : n2[c3], d2 = u2 == null ? void 0 : u2[c3];
    if (f2 === null) return null;
    const b2 = Kr2(f2) || Kr2(d2);
    return a3[c3][b2];
  }), o2 = n2 && Object.entries(n2).reduce((c3, f2) => {
    let [d2, b2] = f2;
    return b2 === void 0 || (c3[d2] = b2), c3;
  }, {}), l = t == null || (r = t.compoundVariants) === null || r === void 0 ? void 0 : r.reduce((c3, f2) => {
    let { class: d2, className: b2, ...m } = f2;
    return Object.entries(m).every((h) => {
      let [E, y2] = h;
      return Array.isArray(y2) ? y2.includes({
        ...u2,
        ...o2
      }[E]) : {
        ...u2,
        ...o2
      }[E] === y2;
    }) ? [
      ...c3,
      d2,
      b2
    ] : c3;
  }, []);
  return Zr(e2, i2, l, n2 == null ? void 0 : n2.class, n2 == null ? void 0 : n2.className);
};
function _i(e2) {
  var t, n2, r = "";
  if (typeof e2 == "string" || typeof e2 == "number") r += e2;
  else if (typeof e2 == "object") if (Array.isArray(e2)) {
    var a3 = e2.length;
    for (t = 0; t < a3; t++) e2[t] && (n2 = _i(e2[t])) && (r && (r += " "), r += n2);
  } else for (n2 in e2) e2[n2] && (r && (r += " "), r += n2);
  return r;
}
function yr2() {
  for (var e2, t, n2 = 0, r = "", a3 = arguments.length; n2 < a3; n2++) (e2 = arguments[n2]) && (t = _i(e2)) && (r && (r += " "), r += t);
  return r;
}
var Ar2 = "-";
var $s = (e2) => {
  const t = Vs(e2), {
    conflictingClassGroups: n2,
    conflictingClassGroupModifiers: r
  } = e2;
  return {
    getClassGroupId: (i2) => {
      const o2 = i2.split(Ar2);
      return o2[0] === "" && o2.length !== 1 && o2.shift(), Ci(o2, t) || Ws(i2);
    },
    getConflictingClassGroupIds: (i2, o2) => {
      const l = n2[i2] || [];
      return o2 && r[i2] ? [...l, ...r[i2]] : l;
    }
  };
};
var Ci = (e2, t) => {
  var i2;
  if (e2.length === 0)
    return t.classGroupId;
  const n2 = e2[0], r = t.nextPart.get(n2), a3 = r ? Ci(e2.slice(1), r) : void 0;
  if (a3)
    return a3;
  if (t.validators.length === 0)
    return;
  const u2 = e2.join(Ar2);
  return (i2 = t.validators.find(({
    validator: o2
  }) => o2(u2))) == null ? void 0 : i2.classGroupId;
};
var Jr = /^\[(.+)\]$/;
var Ws = (e2) => {
  if (Jr.test(e2)) {
    const t = Jr.exec(e2)[1], n2 = t == null ? void 0 : t.substring(0, t.indexOf(":"));
    if (n2)
      return "arbitrary.." + n2;
  }
};
var Vs = (e2) => {
  const {
    theme: t,
    prefix: n2
  } = e2, r = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return Xs(Object.entries(e2.classGroups), n2).forEach(([u2, i2]) => {
    nr3(i2, r, u2, t);
  }), r;
};
var nr3 = (e2, t, n2, r) => {
  e2.forEach((a3) => {
    if (typeof a3 == "string") {
      const u2 = a3 === "" ? t : ea(t, a3);
      u2.classGroupId = n2;
      return;
    }
    if (typeof a3 == "function") {
      if (Qs(a3)) {
        nr3(a3(r), t, n2, r);
        return;
      }
      t.validators.push({
        validator: a3,
        classGroupId: n2
      });
      return;
    }
    Object.entries(a3).forEach(([u2, i2]) => {
      nr3(i2, ea(t, u2), n2, r);
    });
  });
};
var ea = (e2, t) => {
  let n2 = e2;
  return t.split(Ar2).forEach((r) => {
    n2.nextPart.has(r) || n2.nextPart.set(r, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), n2 = n2.nextPart.get(r);
  }), n2;
};
var Qs = (e2) => e2.isThemeGetter;
var Xs = (e2, t) => t ? e2.map(([n2, r]) => {
  const a3 = r.map((u2) => typeof u2 == "string" ? t + u2 : typeof u2 == "object" ? Object.fromEntries(Object.entries(u2).map(([i2, o2]) => [t + i2, o2])) : u2);
  return [n2, a3];
}) : e2;
var Ks = (e2) => {
  if (e2 < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t = 0, n2 = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
  const a3 = (u2, i2) => {
    n2.set(u2, i2), t++, t > e2 && (t = 0, r = n2, n2 = /* @__PURE__ */ new Map());
  };
  return {
    get(u2) {
      let i2 = n2.get(u2);
      if (i2 !== void 0)
        return i2;
      if ((i2 = r.get(u2)) !== void 0)
        return a3(u2, i2), i2;
    },
    set(u2, i2) {
      n2.has(u2) ? n2.set(u2, i2) : a3(u2, i2);
    }
  };
};
var xi = "!";
var Zs = (e2) => {
  const {
    separator: t,
    experimentalParseClassName: n2
  } = e2, r = t.length === 1, a3 = t[0], u2 = t.length, i2 = (o2) => {
    const l = [];
    let c3 = 0, f2 = 0, d2;
    for (let y2 = 0; y2 < o2.length; y2++) {
      let _3 = o2[y2];
      if (c3 === 0) {
        if (_3 === a3 && (r || o2.slice(y2, y2 + u2) === t)) {
          l.push(o2.slice(f2, y2)), f2 = y2 + u2;
          continue;
        }
        if (_3 === "/") {
          d2 = y2;
          continue;
        }
      }
      _3 === "[" ? c3++ : _3 === "]" && c3--;
    }
    const b2 = l.length === 0 ? o2 : o2.substring(f2), m = b2.startsWith(xi), h = m ? b2.substring(1) : b2, E = d2 && d2 > f2 ? d2 - f2 : void 0;
    return {
      modifiers: l,
      hasImportantModifier: m,
      baseClassName: h,
      maybePostfixModifierPosition: E
    };
  };
  return n2 ? (o2) => n2({
    className: o2,
    parseClassName: i2
  }) : i2;
};
var Js = (e2) => {
  if (e2.length <= 1)
    return e2;
  const t = [];
  let n2 = [];
  return e2.forEach((r) => {
    r[0] === "[" ? (t.push(...n2.sort(), r), n2 = []) : n2.push(r);
  }), t.push(...n2.sort()), t;
};
var eo = (e2) => ({
  cache: Ks(e2.cacheSize),
  parseClassName: Zs(e2),
  ...$s(e2)
});
var to = /\s+/;
var no = (e2, t) => {
  const {
    parseClassName: n2,
    getClassGroupId: r,
    getConflictingClassGroupIds: a3
  } = t, u2 = [], i2 = e2.trim().split(to);
  let o2 = "";
  for (let l = i2.length - 1; l >= 0; l -= 1) {
    const c3 = i2[l], {
      modifiers: f2,
      hasImportantModifier: d2,
      baseClassName: b2,
      maybePostfixModifierPosition: m
    } = n2(c3);
    let h = !!m, E = r(h ? b2.substring(0, m) : b2);
    if (!E) {
      if (!h) {
        o2 = c3 + (o2.length > 0 ? " " + o2 : o2);
        continue;
      }
      if (E = r(b2), !E) {
        o2 = c3 + (o2.length > 0 ? " " + o2 : o2);
        continue;
      }
      h = false;
    }
    const y2 = Js(f2).join(":"), _3 = d2 ? y2 + xi : y2, x2 = _3 + E;
    if (u2.includes(x2))
      continue;
    u2.push(x2);
    const I3 = a3(E, h);
    for (let M3 = 0; M3 < I3.length; ++M3) {
      const B4 = I3[M3];
      u2.push(_3 + B4);
    }
    o2 = c3 + (o2.length > 0 ? " " + o2 : o2);
  }
  return o2;
};
function ro() {
  let e2 = 0, t, n2, r = "";
  for (; e2 < arguments.length; )
    (t = arguments[e2++]) && (n2 = ki(t)) && (r && (r += " "), r += n2);
  return r;
}
var ki = (e2) => {
  if (typeof e2 == "string")
    return e2;
  let t, n2 = "";
  for (let r = 0; r < e2.length; r++)
    e2[r] && (t = ki(e2[r])) && (n2 && (n2 += " "), n2 += t);
  return n2;
};
function ao(e2, ...t) {
  let n2, r, a3, u2 = i2;
  function i2(l) {
    const c3 = t.reduce((f2, d2) => d2(f2), e2());
    return n2 = eo(c3), r = n2.cache.get, a3 = n2.cache.set, u2 = o2, o2(l);
  }
  function o2(l) {
    const c3 = r(l);
    if (c3)
      return c3;
    const f2 = no(l, n2);
    return a3(l, f2), f2;
  }
  return function() {
    return u2(ro.apply(null, arguments));
  };
}
var oe2 = (e2) => {
  const t = (n2) => n2[e2] || [];
  return t.isThemeGetter = true, t;
};
var Ii = /^\[(?:([a-z-]+):)?(.+)\]$/i;
var io = /^\d+\/\d+$/;
var uo = /* @__PURE__ */ new Set(["px", "full", "screen"]);
var so = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var oo = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var lo = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
var co = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var fo = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
var $e3 = (e2) => Tt3(e2) || uo.has(e2) || io.test(e2);
var Ve3 = (e2) => xt3(e2, "length", yo);
var Tt3 = (e2) => !!e2 && !Number.isNaN(Number(e2));
var Fn = (e2) => xt3(e2, "number", Tt3);
var wt3 = (e2) => !!e2 && Number.isInteger(Number(e2));
var ho = (e2) => e2.endsWith("%") && Tt3(e2.slice(0, -1));
var V3 = (e2) => Ii.test(e2);
var Qe2 = (e2) => so.test(e2);
var po = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
var mo = (e2) => xt3(e2, po, Si);
var go = (e2) => xt3(e2, "position", Si);
var bo = /* @__PURE__ */ new Set(["image", "url"]);
var Eo = (e2) => xt3(e2, bo, _o);
var To = (e2) => xt3(e2, "", Ao);
var Dt3 = () => true;
var xt3 = (e2, t, n2) => {
  const r = Ii.exec(e2);
  return r ? r[1] ? typeof t == "string" ? r[1] === t : t.has(r[1]) : n2(r[2]) : false;
};
var yo = (e2) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  oo.test(e2) && !lo.test(e2)
);
var Si = () => false;
var Ao = (e2) => co.test(e2);
var _o = (e2) => fo.test(e2);
var Co = () => {
  const e2 = oe2("colors"), t = oe2("spacing"), n2 = oe2("blur"), r = oe2("brightness"), a3 = oe2("borderColor"), u2 = oe2("borderRadius"), i2 = oe2("borderSpacing"), o2 = oe2("borderWidth"), l = oe2("contrast"), c3 = oe2("grayscale"), f2 = oe2("hueRotate"), d2 = oe2("invert"), b2 = oe2("gap"), m = oe2("gradientColorStops"), h = oe2("gradientColorStopPositions"), E = oe2("inset"), y2 = oe2("margin"), _3 = oe2("opacity"), x2 = oe2("padding"), I3 = oe2("saturate"), M3 = oe2("scale"), B4 = oe2("sepia"), R = oe2("skew"), U2 = oe2("space"), q3 = oe2("translate"), Y3 = () => ["auto", "contain", "none"], S2 = () => ["auto", "hidden", "clip", "visible", "scroll"], H3 = () => ["auto", V3, t], F2 = () => [V3, t], ee3 = () => ["", $e3, Ve3], G2 = () => ["auto", Tt3, V3], j3 = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], te3 = () => ["solid", "dashed", "dotted", "double", "none"], se4 = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], re3 = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], me3 = () => ["", "0", V3], A3 = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], ae3 = () => [Tt3, V3];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [Dt3],
      spacing: [$e3, Ve3],
      blur: ["none", "", Qe2, V3],
      brightness: ae3(),
      borderColor: [e2],
      borderRadius: ["none", "", "full", Qe2, V3],
      borderSpacing: F2(),
      borderWidth: ee3(),
      contrast: ae3(),
      grayscale: me3(),
      hueRotate: ae3(),
      invert: me3(),
      gap: F2(),
      gradientColorStops: [e2],
      gradientColorStopPositions: [ho, Ve3],
      inset: H3(),
      margin: H3(),
      opacity: ae3(),
      padding: F2(),
      saturate: ae3(),
      scale: ae3(),
      sepia: me3(),
      skew: ae3(),
      space: F2(),
      translate: F2()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", V3]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Qe2]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": A3()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": A3()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...j3(), V3]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: S2()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": S2()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": S2()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: Y3()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": Y3()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": Y3()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [E]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [E]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [E]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [E]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [E]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [E]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [E]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [E]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [E]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", wt3, V3]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: H3()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", V3]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: me3()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: me3()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", wt3, V3]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [Dt3]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", wt3, V3]
        }, V3]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": G2()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": G2()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [Dt3]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [wt3, V3]
        }, V3]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": G2()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": G2()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", V3]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", V3]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [b2]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [b2]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [b2]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...re3()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...re3(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...re3(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [x2]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [x2]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [x2]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [x2]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [x2]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [x2]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [x2]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [x2]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [x2]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [y2]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [y2]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [y2]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [y2]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [y2]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [y2]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [y2]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [y2]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [y2]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [U2]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [U2]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", V3, t]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [V3, t, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [V3, t, "none", "full", "min", "max", "fit", "prose", {
          screen: [Qe2]
        }, Qe2]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [V3, t, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [V3, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [V3, t, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [V3, t, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", Qe2, Ve3]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Fn]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [Dt3]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", V3]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Tt3, Fn]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", $e3, V3]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", V3]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", V3]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e2]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [_3]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e2]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [_3]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...te3(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", $e3, Ve3]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", $e3, V3]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e2]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: F2()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", V3]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", V3]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [_3]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...j3(), go]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", mo]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, Eo]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e2]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [h]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [h]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [h]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [m]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [m]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [m]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [u2]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [u2]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [u2]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [u2]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [u2]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [u2]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [u2]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [u2]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [u2]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [u2]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [u2]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [u2]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [u2]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [u2]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [u2]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [o2]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [o2]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [o2]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [o2]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [o2]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [o2]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [o2]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [o2]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [o2]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [_3]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...te3(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [o2]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [o2]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [_3]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: te3()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [a3]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [a3]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [a3]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [a3]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [a3]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [a3]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [a3]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [a3]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [a3]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [a3]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...te3()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [$e3, V3]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [$e3, Ve3]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e2]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: ee3()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e2]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [_3]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [$e3, Ve3]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e2]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", Qe2, To]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [Dt3]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [_3]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...se4(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": se4()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [n2]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [r]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [l]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", Qe2, V3]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [c3]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [f2]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [d2]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [I3]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [B4]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [n2]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [r]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [l]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [c3]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [f2]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [d2]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [_3]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [I3]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [B4]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [i2]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [i2]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [i2]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", V3]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: ae3()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", V3]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: ae3()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", V3]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [M3]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [M3]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [M3]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [wt3, V3]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [q3]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [q3]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [R]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [R]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", V3]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e2]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", V3]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e2]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": F2()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": F2()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": F2()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": F2()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": F2()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": F2()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": F2()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": F2()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": F2()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": F2()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": F2()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": F2()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": F2()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": F2()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": F2()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": F2()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": F2()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": F2()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", V3]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e2, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [$e3, Ve3, Fn]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e2, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
};
var xo = ao(Co);
function bt3(...e2) {
  return xo(yr2(e2));
}
var ko = {
  note: {
    border: "border-gray-300 dark:border-zinc-800",
    bg: "bg-gray-100 dark:bg-zinc-800/50",
    iconColor: "text-gray-600 dark:text-zinc-300",
    titleColor: "text-gray-600 dark:text-zinc-300",
    textColor: "text-gray-600 dark:text-zinc-300",
    Icon: Info
  },
  tip: {
    border: "border-green-500 dark:border-green-800",
    bg: "bg-green-200/25 dark:bg-green-950/70",
    iconColor: "text-green-600 dark:text-green-200",
    titleColor: "text-green-700 dark:text-green-200",
    textColor: "text-green-600 dark:text-green-50",
    Icon: Lightbulb
  },
  info: {
    border: "border-blue-400 dark:border-blue-900/60",
    bg: "bg-blue-50 dark:bg-blue-950/40",
    iconColor: "text-blue-400 dark:text-blue-200",
    titleColor: "text-blue-700 dark:text-blue-200",
    textColor: "text-blue-600 dark:text-blue-100",
    Icon: Info
  },
  caution: {
    border: "border-yellow-400 dark:border-yellow-400/25",
    bg: "bg-yellow-100/60 dark:bg-yellow-400/10",
    iconColor: "text-yellow-500 dark:text-yellow-300",
    titleColor: "text-yellow-600 dark:text-yellow-300",
    textColor: "text-yellow-700 dark:text-yellow-200",
    Icon: TriangleAlert
  },
  danger: {
    border: "border-rose-400 dark:border-rose-800",
    bg: "bg-rose-50 dark:bg-rose-950/40",
    iconColor: "text-rose-400 dark:text-rose-300",
    titleColor: "text-rose-800 dark:text-rose-300",
    textColor: "text-rose-700 dark:text-rose-100",
    Icon: ShieldAlert
  }
};
var at2 = ({ type: e2, children: t, title: n2, className: r }) => {
  const { border: a3, bg: u2, iconColor: i2, titleColor: o2, textColor: l, Icon: c3 } = ko[e2];
  return dr.jsxs(
    "div",
    {
      className: bt3(
        "not-prose grid grid-cols-[min-content_1fr] grid-rows-[fit-content_1fr] gap-x-4 gap-y-2 text-md rounded-md border p-4",
        "[&_a]:underline [&_a]:decoration-current [&_a]:decoration-from-font [&_a]:underline-offset-4 hover:[&_a]:decoration-1",
        "[&_code]:!bg-gray-50 [&_code]:dark:!bg-gray-800 [&_code]:!border-none my-2",
        n2 && "items-center",
        a3,
        u2,
        r
      ),
      children: [
        dr.jsx(
          c3,
          {
            className: bt3(!n2 && "translate-y-px", i2),
            size: 20,
            "aria-hidden": "true"
          }
        ),
        n2 && dr.jsx("h3", { className: bt3("font-medium", o2), children: n2 }),
        dr.jsx("div", { className: bt3("col-start-2", !n2 && "row-start-1", l), children: t })
      ]
    }
  );
};
var Ni = (0, import_react2.createContext)(
  void 0
);
var Io = () => {
  const e2 = (0, import_react2.useContext)(Ni);
  if (!e2)
    throw new Error(
      "useViewportAnchor must be used within a CurrentAnchorProvider"
    );
  return e2;
};
var So = () => {
  const e2 = (0, import_react2.useRef)(null), { observe: t, unobserve: n2 } = Io();
  return (0, import_react2.useEffect)(() => {
    const a3 = e2.current;
    if (a3)
      return t(a3), () => n2(a3);
  }, [t, n2]), { ref: (0, import_react2.useCallback)((a3) => {
    a3 && (e2.current = a3);
  }, []) };
};
var Db = ({
  children: e2
}) => {
  const [t, n2] = (0, import_react2.useState)(""), r = (0, import_react2.useRef)(null), a3 = (0, import_react2.useRef)(/* @__PURE__ */ new Set());
  (0, import_react2.useEffect)(() => (r.current = new IntersectionObserver(
    (o2) => {
      for (const l of o2)
        l.isIntersecting && l.target.id && n2(l.target.id);
    },
    {
      // 115px is the height of the sticky header
      // see --header-height in `main.css`
      rootMargin: "115px 0px -80% 0px",
      threshold: 0.75
    }
  ), () => {
    var o2;
    return (o2 = r.current) == null ? void 0 : o2.disconnect();
  }), []), (0, import_react2.useEffect)(() => {
    const o2 = a3.current, l = () => {
      const c3 = window.scrollY === 0, f2 = window.innerHeight + window.scrollY >= document.body.scrollHeight;
      c3 ? n2("") : f2 && requestIdleCallback(() => {
        const d2 = Array.from(o2).pop();
        n2((d2 == null ? void 0 : d2.id) ?? "");
      });
    };
    return document.addEventListener("scroll", l), () => {
      o2.clear(), document.removeEventListener("scroll", l);
    };
  }, []);
  const u2 = (0, import_react2.useMemo)(() => ({
    observe: (o2) => {
      !o2 || !r.current || (a3.current.add(o2), r.current.observe(o2));
    },
    unobserve: (o2) => {
      !o2 || !r.current || (a3.current.delete(o2), r.current.unobserve(o2));
    }
  }), []), i2 = (0, import_react2.useMemo)(
    () => ({ activeAnchor: t, setActiveAnchor: n2, ...u2 }),
    [t, n2, u2]
  );
  return dr.jsx(Ni.Provider, { value: i2, children: e2 });
};
var No = qs("group relative", {
  variants: {
    level: {
      6: "text-md",
      5: "text-lg",
      4: "text-xl",
      3: "text-xl font-semibold",
      2: "text-2xl font-bold",
      1: "text-4xl font-extrabold"
    }
  },
  defaultVariants: {
    level: 1
  }
});
var Ro = (e2) => {
  switch (e2) {
    case 1:
      return "h1";
    case 2:
      return "h2";
    case 3:
      return "h3";
    case 4:
      return "h4";
    case 5:
      return "h5";
    case 6:
      return "h6";
    default:
      return "h1";
  }
};
var ht3 = ({
  level: e2,
  children: t,
  id: n2,
  className: r,
  registerSidebarAnchor: a3
}) => {
  const u2 = Ro(e2 ?? 1), { ref: i2 } = So();
  return dr.jsxs(
    u2,
    {
      className: No({ className: r, level: e2 }),
      ref: a3 ? i2 : void 0,
      id: n2,
      children: [
        n2 && dr.jsx(
          "a",
          {
            href: `#${n2}`,
            className: "no-underline absolute text-primary -left-[0.8em] pr-2.5 opacity-0 group-hover:opacity-50 hover:!opacity-100 transition-opacity duration-200",
            "aria-label": `Link to ${n2}`,
            children: "#"
          }
        ),
        t
      ]
    }
  );
};
function ta(e2) {
  const t = [], n2 = String(e2 || "");
  let r = n2.indexOf(","), a3 = 0, u2 = false;
  for (; !u2; ) {
    r === -1 && (r = n2.length, u2 = true);
    const i2 = n2.slice(a3, r).trim();
    (i2 || !u2) && t.push(i2), a3 = r + 1, r = n2.indexOf(",", a3);
  }
  return t;
}
function Ri(e2, t) {
  const n2 = {};
  return (e2[e2.length - 1] === "" ? [...e2, ""] : e2).join(
    (n2.padRight ? " " : "") + "," + (n2.padLeft === false ? "" : " ")
  ).trim();
}
var Lo = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
var Oo = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u;
var wo = {};
function na2(e2, t) {
  return (wo.jsx ? Oo : Lo).test(e2);
}
var Do = /[ \t\n\f\r]/g;
function Po(e2) {
  return typeof e2 == "object" ? e2.type === "text" ? ra(e2.value) : false : ra(e2);
}
function ra(e2) {
  return e2.replace(Do, "") === "";
}
var Qt3 = class {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(t, n2, r) {
    this.property = t, this.normal = n2, r && (this.space = r);
  }
};
Qt3.prototype.property = {};
Qt3.prototype.normal = {};
Qt3.prototype.space = null;
function Li(e2, t) {
  const n2 = {}, r = {};
  let a3 = -1;
  for (; ++a3 < e2.length; )
    Object.assign(n2, e2[a3].property), Object.assign(r, e2[a3].normal);
  return new Qt3(n2, r, t);
}
function $t3(e2) {
  return e2.toLowerCase();
}
var Le3 = class {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(t, n2) {
    this.property = t, this.attribute = n2;
  }
};
Le3.prototype.space = null;
Le3.prototype.boolean = false;
Le3.prototype.booleanish = false;
Le3.prototype.overloadedBoolean = false;
Le3.prototype.number = false;
Le3.prototype.commaSeparated = false;
Le3.prototype.spaceSeparated = false;
Le3.prototype.commaOrSpaceSeparated = false;
Le3.prototype.mustUseProperty = false;
Le3.prototype.defined = false;
var Mo = 0;
var W2 = ct2();
var fe2 = ct2();
var Oi = ct2();
var P3 = ct2();
var ue3 = ct2();
var yt4 = ct2();
var Ie4 = ct2();
function ct2() {
  return 2 ** ++Mo;
}
var rr2 = Object.freeze(Object.defineProperty({
  __proto__: null,
  boolean: W2,
  booleanish: fe2,
  commaOrSpaceSeparated: Ie4,
  commaSeparated: yt4,
  number: P3,
  overloadedBoolean: Oi,
  spaceSeparated: ue3
}, Symbol.toStringTag, { value: "Module" }));
var Bn = Object.keys(rr2);
var _r2 = class extends Le3 {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(t, n2, r, a3) {
    let u2 = -1;
    if (super(t, n2), aa(this, "space", a3), typeof r == "number")
      for (; ++u2 < Bn.length; ) {
        const i2 = Bn[u2];
        aa(this, Bn[u2], (r & rr2[i2]) === rr2[i2]);
      }
  }
};
_r2.prototype.defined = true;
function aa(e2, t, n2) {
  n2 && (e2[t] = n2);
}
var Fo = {}.hasOwnProperty;
function kt3(e2) {
  const t = {}, n2 = {};
  let r;
  for (r in e2.properties)
    if (Fo.call(e2.properties, r)) {
      const a3 = e2.properties[r], u2 = new _r2(
        r,
        e2.transform(e2.attributes || {}, r),
        a3,
        e2.space
      );
      e2.mustUseProperty && e2.mustUseProperty.includes(r) && (u2.mustUseProperty = true), t[r] = u2, n2[$t3(r)] = r, n2[$t3(u2.attribute)] = r;
    }
  return new Qt3(t, n2, e2.space);
}
var wi = kt3({
  space: "xlink",
  transform(e2, t) {
    return "xlink:" + t.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
var Di = kt3({
  space: "xml",
  transform(e2, t) {
    return "xml:" + t.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function Pi(e2, t) {
  return t in e2 ? e2[t] : t;
}
function Mi(e2, t) {
  return Pi(e2, t.toLowerCase());
}
var Fi = kt3({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: Mi,
  properties: { xmlns: null, xmlnsXLink: null }
});
var Bi = kt3({
  transform(e2, t) {
    return t === "role" ? t : "aria-" + t.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: fe2,
    ariaAutoComplete: null,
    ariaBusy: fe2,
    ariaChecked: fe2,
    ariaColCount: P3,
    ariaColIndex: P3,
    ariaColSpan: P3,
    ariaControls: ue3,
    ariaCurrent: null,
    ariaDescribedBy: ue3,
    ariaDetails: null,
    ariaDisabled: fe2,
    ariaDropEffect: ue3,
    ariaErrorMessage: null,
    ariaExpanded: fe2,
    ariaFlowTo: ue3,
    ariaGrabbed: fe2,
    ariaHasPopup: null,
    ariaHidden: fe2,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: ue3,
    ariaLevel: P3,
    ariaLive: null,
    ariaModal: fe2,
    ariaMultiLine: fe2,
    ariaMultiSelectable: fe2,
    ariaOrientation: null,
    ariaOwns: ue3,
    ariaPlaceholder: null,
    ariaPosInSet: P3,
    ariaPressed: fe2,
    ariaReadOnly: fe2,
    ariaRelevant: null,
    ariaRequired: fe2,
    ariaRoleDescription: ue3,
    ariaRowCount: P3,
    ariaRowIndex: P3,
    ariaRowSpan: P3,
    ariaSelected: fe2,
    ariaSetSize: P3,
    ariaSort: null,
    ariaValueMax: P3,
    ariaValueMin: P3,
    ariaValueNow: P3,
    ariaValueText: null,
    role: null
  }
});
var Bo = kt3({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: Mi,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: yt4,
    acceptCharset: ue3,
    accessKey: ue3,
    action: null,
    allow: null,
    allowFullScreen: W2,
    allowPaymentRequest: W2,
    allowUserMedia: W2,
    alt: null,
    as: null,
    async: W2,
    autoCapitalize: null,
    autoComplete: ue3,
    autoFocus: W2,
    autoPlay: W2,
    blocking: ue3,
    capture: null,
    charSet: null,
    checked: W2,
    cite: null,
    className: ue3,
    cols: P3,
    colSpan: null,
    content: null,
    contentEditable: fe2,
    controls: W2,
    controlsList: ue3,
    coords: P3 | yt4,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: W2,
    defer: W2,
    dir: null,
    dirName: null,
    disabled: W2,
    download: Oi,
    draggable: fe2,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: W2,
    formTarget: null,
    headers: ue3,
    height: P3,
    hidden: W2,
    high: P3,
    href: null,
    hrefLang: null,
    htmlFor: ue3,
    httpEquiv: ue3,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: W2,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: W2,
    itemId: null,
    itemProp: ue3,
    itemRef: ue3,
    itemScope: W2,
    itemType: ue3,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: W2,
    low: P3,
    manifest: null,
    max: null,
    maxLength: P3,
    media: null,
    method: null,
    min: null,
    minLength: P3,
    multiple: W2,
    muted: W2,
    name: null,
    nonce: null,
    noModule: W2,
    noValidate: W2,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: W2,
    optimum: P3,
    pattern: null,
    ping: ue3,
    placeholder: null,
    playsInline: W2,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: W2,
    referrerPolicy: null,
    rel: ue3,
    required: W2,
    reversed: W2,
    rows: P3,
    rowSpan: P3,
    sandbox: ue3,
    scope: null,
    scoped: W2,
    seamless: W2,
    selected: W2,
    shadowRootClonable: W2,
    shadowRootDelegatesFocus: W2,
    shadowRootMode: null,
    shape: null,
    size: P3,
    sizes: null,
    slot: null,
    span: P3,
    spellCheck: fe2,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: P3,
    step: null,
    style: null,
    tabIndex: P3,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: W2,
    useMap: null,
    value: fe2,
    width: P3,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: ue3,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: P3,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: P3,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: W2,
    // Lists. Use CSS to reduce space between items instead
    declare: W2,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: P3,
    // `<img>` and `<object>`
    leftMargin: P3,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: P3,
    // `<body>`
    marginWidth: P3,
    // `<body>`
    noResize: W2,
    // `<frame>`
    noHref: W2,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: W2,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: W2,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: P3,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: fe2,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: P3,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: P3,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: W2,
    disableRemotePlayback: W2,
    prefix: null,
    property: null,
    results: P3,
    security: null,
    unselectable: null
  }
});
var vo = kt3({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: Pi,
  properties: {
    about: Ie4,
    accentHeight: P3,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: P3,
    amplitude: P3,
    arabicForm: null,
    ascent: P3,
    attributeName: null,
    attributeType: null,
    azimuth: P3,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: P3,
    by: null,
    calcMode: null,
    capHeight: P3,
    className: ue3,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: P3,
    diffuseConstant: P3,
    direction: null,
    display: null,
    dur: null,
    divisor: P3,
    dominantBaseline: null,
    download: W2,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: P3,
    enableBackground: null,
    end: null,
    event: null,
    exponent: P3,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: P3,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: yt4,
    g2: yt4,
    glyphName: yt4,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: P3,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: P3,
    horizOriginX: P3,
    horizOriginY: P3,
    id: null,
    ideographic: P3,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: P3,
    k: P3,
    k1: P3,
    k2: P3,
    k3: P3,
    k4: P3,
    kernelMatrix: Ie4,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: P3,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: P3,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: P3,
    overlineThickness: P3,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: P3,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: ue3,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: P3,
    pointsAtY: P3,
    pointsAtZ: P3,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: Ie4,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: Ie4,
    rev: Ie4,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: Ie4,
    requiredFeatures: Ie4,
    requiredFonts: Ie4,
    requiredFormats: Ie4,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: P3,
    specularExponent: P3,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: P3,
    strikethroughThickness: P3,
    string: null,
    stroke: null,
    strokeDashArray: Ie4,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: P3,
    strokeOpacity: P3,
    strokeWidth: null,
    style: null,
    surfaceScale: P3,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: Ie4,
    tabIndex: P3,
    tableValues: null,
    target: null,
    targetX: P3,
    targetY: P3,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: Ie4,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: P3,
    underlineThickness: P3,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: P3,
    values: null,
    vAlphabetic: P3,
    vMathematical: P3,
    vectorEffect: null,
    vHanging: P3,
    vIdeographic: P3,
    version: null,
    vertAdvY: P3,
    vertOriginX: P3,
    vertOriginY: P3,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: P3,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
});
var Ho = /^data[-\w.:]+$/i;
var ia = /-[a-z]/g;
var Uo = /[A-Z]/g;
function _n(e2, t) {
  const n2 = $t3(t);
  let r = t, a3 = Le3;
  if (n2 in e2.normal)
    return e2.property[e2.normal[n2]];
  if (n2.length > 4 && n2.slice(0, 4) === "data" && Ho.test(t)) {
    if (t.charAt(4) === "-") {
      const u2 = t.slice(5).replace(ia, Yo);
      r = "data" + u2.charAt(0).toUpperCase() + u2.slice(1);
    } else {
      const u2 = t.slice(4);
      if (!ia.test(u2)) {
        let i2 = u2.replace(Uo, zo);
        i2.charAt(0) !== "-" && (i2 = "-" + i2), t = "data" + i2;
      }
    }
    a3 = _r2;
  }
  return new a3(r, t);
}
function zo(e2) {
  return "-" + e2.toLowerCase();
}
function Yo(e2) {
  return e2.charAt(1).toUpperCase();
}
var jo = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
};
var Xt3 = Li([Di, wi, Fi, Bi, Bo], "html");
var et2 = Li([Di, wi, Fi, Bi, vo], "svg");
function ua2(e2) {
  const t = String(e2 || "").trim();
  return t ? t.split(/[ \t\n\r\f]+/g) : [];
}
function vi(e2) {
  return e2.join(" ").trim();
}
var Hi = {};
var sa = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;
var Go = /\n/g;
var qo = /^\s*/;
var $o = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/;
var Wo = /^:\s*/;
var Vo = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/;
var Qo = /^[;\s]*/;
var Xo = /^\s+|\s+$/g;
var Ko = `
`;
var oa = "/";
var la = "*";
var ut3 = "";
var Zo = "comment";
var Jo = "declaration";
var el = function(e2, t) {
  if (typeof e2 != "string")
    throw new TypeError("First argument must be a string");
  if (!e2) return [];
  t = t || {};
  var n2 = 1, r = 1;
  function a3(h) {
    var E = h.match(Go);
    E && (n2 += E.length);
    var y2 = h.lastIndexOf(Ko);
    r = ~y2 ? h.length - y2 : r + h.length;
  }
  function u2() {
    var h = { line: n2, column: r };
    return function(E) {
      return E.position = new i2(h), c3(), E;
    };
  }
  function i2(h) {
    this.start = h, this.end = { line: n2, column: r }, this.source = t.source;
  }
  i2.prototype.content = e2;
  function o2(h) {
    var E = new Error(
      t.source + ":" + n2 + ":" + r + ": " + h
    );
    if (E.reason = h, E.filename = t.source, E.line = n2, E.column = r, E.source = e2, !t.silent) throw E;
  }
  function l(h) {
    var E = h.exec(e2);
    if (E) {
      var y2 = E[0];
      return a3(y2), e2 = e2.slice(y2.length), E;
    }
  }
  function c3() {
    l(qo);
  }
  function f2(h) {
    var E;
    for (h = h || []; E = d2(); )
      E !== false && h.push(E);
    return h;
  }
  function d2() {
    var h = u2();
    if (!(oa != e2.charAt(0) || la != e2.charAt(1))) {
      for (var E = 2; ut3 != e2.charAt(E) && (la != e2.charAt(E) || oa != e2.charAt(E + 1)); )
        ++E;
      if (E += 2, ut3 === e2.charAt(E - 1))
        return o2("End of comment missing");
      var y2 = e2.slice(2, E - 2);
      return r += 2, a3(y2), e2 = e2.slice(E), r += 2, h({
        type: Zo,
        comment: y2
      });
    }
  }
  function b2() {
    var h = u2(), E = l($o);
    if (E) {
      if (d2(), !l(Wo)) return o2("property missing ':'");
      var y2 = l(Vo), _3 = h({
        type: Jo,
        property: ca(E[0].replace(sa, ut3)),
        value: y2 ? ca(y2[0].replace(sa, ut3)) : ut3
      });
      return l(Qo), _3;
    }
  }
  function m() {
    var h = [];
    f2(h);
    for (var E; E = b2(); )
      E !== false && (h.push(E), f2(h));
    return h;
  }
  return c3(), m();
};
function ca(e2) {
  return e2 ? e2.replace(Xo, ut3) : ut3;
}
var tl = u && u.__importDefault || function(e2) {
  return e2 && e2.__esModule ? e2 : { default: e2 };
};
Object.defineProperty(Hi, "__esModule", { value: true });
var nl = tl(el);
function rl(e2, t) {
  var n2 = null;
  if (!e2 || typeof e2 != "string")
    return n2;
  var r = (0, nl.default)(e2), a3 = typeof t == "function";
  return r.forEach(function(u2) {
    if (u2.type === "declaration") {
      var i2 = u2.property, o2 = u2.value;
      a3 ? t(i2, o2, u2) : o2 && (n2 = n2 || {}, n2[i2] = o2);
    }
  }), n2;
}
var da = Hi.default = rl;
var al = da.default || da;
var Cn = Ui("end");
var Ye4 = Ui("start");
function Ui(e2) {
  return t;
  function t(n2) {
    const r = n2 && n2.position && n2.position[e2] || {};
    if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0)
      return {
        line: r.line,
        column: r.column,
        offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0
      };
  }
}
function il(e2) {
  const t = Ye4(e2), n2 = Cn(e2);
  if (t && n2)
    return { start: t, end: n2 };
}
function vt3(e2) {
  return !e2 || typeof e2 != "object" ? "" : "position" in e2 || "type" in e2 ? fa(e2.position) : "start" in e2 || "end" in e2 ? fa(e2) : "line" in e2 || "column" in e2 ? ar3(e2) : "";
}
function ar3(e2) {
  return ha(e2 && e2.line) + ":" + ha(e2 && e2.column);
}
function fa(e2) {
  return ar3(e2 && e2.start) + "-" + ar3(e2 && e2.end);
}
function ha(e2) {
  return e2 && typeof e2 == "number" ? e2 : 1;
}
var be2 = class extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(t, n2, r) {
    super(), typeof n2 == "string" && (r = n2, n2 = void 0);
    let a3 = "", u2 = {}, i2 = false;
    if (n2 && ("line" in n2 && "column" in n2 ? u2 = { place: n2 } : "start" in n2 && "end" in n2 ? u2 = { place: n2 } : "type" in n2 ? u2 = {
      ancestors: [n2],
      place: n2.position
    } : u2 = { ...n2 }), typeof t == "string" ? a3 = t : !u2.cause && t && (i2 = true, a3 = t.message, u2.cause = t), !u2.ruleId && !u2.source && typeof r == "string") {
      const l = r.indexOf(":");
      l === -1 ? u2.ruleId = r : (u2.source = r.slice(0, l), u2.ruleId = r.slice(l + 1));
    }
    if (!u2.place && u2.ancestors && u2.ancestors) {
      const l = u2.ancestors[u2.ancestors.length - 1];
      l && (u2.place = l.position);
    }
    const o2 = u2.place && "start" in u2.place ? u2.place.start : u2.place;
    this.ancestors = u2.ancestors || void 0, this.cause = u2.cause || void 0, this.column = o2 ? o2.column : void 0, this.fatal = void 0, this.file, this.message = a3, this.line = o2 ? o2.line : void 0, this.name = vt3(u2.place) || "1:1", this.place = u2.place || void 0, this.reason = this.message, this.ruleId = u2.ruleId || void 0, this.source = u2.source || void 0, this.stack = i2 && u2.cause && typeof u2.cause.stack == "string" ? u2.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
};
be2.prototype.file = "";
be2.prototype.name = "";
be2.prototype.reason = "";
be2.prototype.message = "";
be2.prototype.stack = "";
be2.prototype.column = void 0;
be2.prototype.line = void 0;
be2.prototype.ancestors = void 0;
be2.prototype.cause = void 0;
be2.prototype.fatal = void 0;
be2.prototype.place = void 0;
be2.prototype.ruleId = void 0;
be2.prototype.source = void 0;
var Cr2 = {}.hasOwnProperty;
var ul = /* @__PURE__ */ new Map();
var sl = /[A-Z]/g;
var ol = /-([a-z])/g;
var ll = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
var cl = /* @__PURE__ */ new Set(["td", "th"]);
var zi = "https://github.com/syntax-tree/hast-util-to-jsx-runtime";
function dl(e2, t) {
  if (!t || t.Fragment === void 0)
    throw new TypeError("Expected `Fragment` in options");
  const n2 = t.filePath || void 0;
  let r;
  if (t.development) {
    if (typeof t.jsxDEV != "function")
      throw new TypeError(
        "Expected `jsxDEV` in options when `development: true`"
      );
    r = Tl(n2, t.jsxDEV);
  } else {
    if (typeof t.jsx != "function")
      throw new TypeError("Expected `jsx` in production options");
    if (typeof t.jsxs != "function")
      throw new TypeError("Expected `jsxs` in production options");
    r = El(n2, t.jsx, t.jsxs);
  }
  const a3 = {
    Fragment: t.Fragment,
    ancestors: [],
    components: t.components || {},
    create: r,
    elementAttributeNameCase: t.elementAttributeNameCase || "react",
    evaluater: t.createEvaluater ? t.createEvaluater() : void 0,
    filePath: n2,
    ignoreInvalidStyle: t.ignoreInvalidStyle || false,
    passKeys: t.passKeys !== false,
    passNode: t.passNode || false,
    schema: t.space === "svg" ? et2 : Xt3,
    stylePropertyNameCase: t.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: t.tableCellAlignToStyle !== false
  }, u2 = Yi(a3, e2, void 0);
  return u2 && typeof u2 != "string" ? u2 : a3.create(
    e2,
    a3.Fragment,
    { children: u2 || void 0 },
    void 0
  );
}
function Yi(e2, t, n2) {
  if (t.type === "element")
    return fl(e2, t, n2);
  if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression")
    return hl(e2, t);
  if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement")
    return ml(e2, t, n2);
  if (t.type === "mdxjsEsm")
    return pl(e2, t);
  if (t.type === "root")
    return gl(e2, t, n2);
  if (t.type === "text")
    return bl(e2, t);
}
function fl(e2, t, n2) {
  const r = e2.schema;
  let a3 = r;
  t.tagName.toLowerCase() === "svg" && r.space === "html" && (a3 = et2, e2.schema = a3), e2.ancestors.push(t);
  const u2 = Gi(e2, t.tagName, false), i2 = yl(e2, t);
  let o2 = kr3(e2, t);
  return ll.has(t.tagName) && (o2 = o2.filter(function(l) {
    return typeof l == "string" ? !Po(l) : true;
  })), ji(e2, i2, u2, t), xr2(i2, o2), e2.ancestors.pop(), e2.schema = r, e2.create(t, u2, i2, n2);
}
function hl(e2, t) {
  if (t.data && t.data.estree && e2.evaluater) {
    const r = t.data.estree.body[0];
    return r.type, /** @type {Child | undefined} */
    e2.evaluater.evaluateExpression(r.expression);
  }
  Wt3(e2, t.position);
}
function pl(e2, t) {
  if (t.data && t.data.estree && e2.evaluater)
    return (
      /** @type {Child | undefined} */
      e2.evaluater.evaluateProgram(t.data.estree)
    );
  Wt3(e2, t.position);
}
function ml(e2, t, n2) {
  const r = e2.schema;
  let a3 = r;
  t.name === "svg" && r.space === "html" && (a3 = et2, e2.schema = a3), e2.ancestors.push(t);
  const u2 = t.name === null ? e2.Fragment : Gi(e2, t.name, true), i2 = Al(e2, t), o2 = kr3(e2, t);
  return ji(e2, i2, u2, t), xr2(i2, o2), e2.ancestors.pop(), e2.schema = r, e2.create(t, u2, i2, n2);
}
function gl(e2, t, n2) {
  const r = {};
  return xr2(r, kr3(e2, t)), e2.create(t, e2.Fragment, r, n2);
}
function bl(e2, t) {
  return t.value;
}
function ji(e2, t, n2, r) {
  typeof n2 != "string" && n2 !== e2.Fragment && e2.passNode && (t.node = r);
}
function xr2(e2, t) {
  if (t.length > 0) {
    const n2 = t.length > 1 ? t : t[0];
    n2 && (e2.children = n2);
  }
}
function El(e2, t, n2) {
  return r;
  function r(a3, u2, i2, o2) {
    const c3 = Array.isArray(i2.children) ? n2 : t;
    return o2 ? c3(u2, i2, o2) : c3(u2, i2);
  }
}
function Tl(e2, t) {
  return n2;
  function n2(r, a3, u2, i2) {
    const o2 = Array.isArray(u2.children), l = Ye4(r);
    return t(
      a3,
      u2,
      i2,
      o2,
      {
        columnNumber: l ? l.column - 1 : void 0,
        fileName: e2,
        lineNumber: l ? l.line : void 0
      },
      void 0
    );
  }
}
function yl(e2, t) {
  const n2 = {};
  let r, a3;
  for (a3 in t.properties)
    if (a3 !== "children" && Cr2.call(t.properties, a3)) {
      const u2 = _l(e2, a3, t.properties[a3]);
      if (u2) {
        const [i2, o2] = u2;
        e2.tableCellAlignToStyle && i2 === "align" && typeof o2 == "string" && cl.has(t.tagName) ? r = o2 : n2[i2] = o2;
      }
    }
  if (r) {
    const u2 = (
      /** @type {Style} */
      n2.style || (n2.style = {})
    );
    u2[e2.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r;
  }
  return n2;
}
function Al(e2, t) {
  const n2 = {};
  for (const r of t.attributes)
    if (r.type === "mdxJsxExpressionAttribute")
      if (r.data && r.data.estree && e2.evaluater) {
        const u2 = r.data.estree.body[0];
        u2.type;
        const i2 = u2.expression;
        i2.type;
        const o2 = i2.properties[0];
        o2.type, Object.assign(
          n2,
          e2.evaluater.evaluateExpression(o2.argument)
        );
      } else
        Wt3(e2, t.position);
    else {
      const a3 = r.name;
      let u2;
      if (r.value && typeof r.value == "object")
        if (r.value.data && r.value.data.estree && e2.evaluater) {
          const o2 = r.value.data.estree.body[0];
          o2.type, u2 = e2.evaluater.evaluateExpression(o2.expression);
        } else
          Wt3(e2, t.position);
      else
        u2 = r.value === null ? true : r.value;
      n2[a3] = /** @type {Props[keyof Props]} */
      u2;
    }
  return n2;
}
function kr3(e2, t) {
  const n2 = [];
  let r = -1;
  const a3 = e2.passKeys ? /* @__PURE__ */ new Map() : ul;
  for (; ++r < t.children.length; ) {
    const u2 = t.children[r];
    let i2;
    if (e2.passKeys) {
      const l = u2.type === "element" ? u2.tagName : u2.type === "mdxJsxFlowElement" || u2.type === "mdxJsxTextElement" ? u2.name : void 0;
      if (l) {
        const c3 = a3.get(l) || 0;
        i2 = l + "-" + c3, a3.set(l, c3 + 1);
      }
    }
    const o2 = Yi(e2, u2, i2);
    o2 !== void 0 && n2.push(o2);
  }
  return n2;
}
function _l(e2, t, n2) {
  const r = _n(e2.schema, t);
  if (!(n2 == null || typeof n2 == "number" && Number.isNaN(n2))) {
    if (Array.isArray(n2) && (n2 = r.commaSeparated ? Ri(n2) : vi(n2)), r.property === "style") {
      let a3 = typeof n2 == "object" ? n2 : Cl(e2, String(n2));
      return e2.stylePropertyNameCase === "css" && (a3 = xl(a3)), ["style", a3];
    }
    return [
      e2.elementAttributeNameCase === "react" && r.space ? jo[r.property] || r.property : r.attribute,
      n2
    ];
  }
}
function Cl(e2, t) {
  const n2 = {};
  try {
    al(t, r);
  } catch (a3) {
    if (!e2.ignoreInvalidStyle) {
      const u2 = (
        /** @type {Error} */
        a3
      ), i2 = new be2("Cannot parse `style` attribute", {
        ancestors: e2.ancestors,
        cause: u2,
        ruleId: "style",
        source: "hast-util-to-jsx-runtime"
      });
      throw i2.file = e2.filePath || void 0, i2.url = zi + "#cannot-parse-style-attribute", i2;
    }
  }
  return n2;
  function r(a3, u2) {
    let i2 = a3;
    i2.slice(0, 2) !== "--" && (i2.slice(0, 4) === "-ms-" && (i2 = "ms-" + i2.slice(4)), i2 = i2.replace(ol, Il)), n2[i2] = u2;
  }
}
function Gi(e2, t, n2) {
  let r;
  if (!n2)
    r = { type: "Literal", value: t };
  else if (t.includes(".")) {
    const a3 = t.split(".");
    let u2 = -1, i2;
    for (; ++u2 < a3.length; ) {
      const o2 = na2(a3[u2]) ? { type: "Identifier", name: a3[u2] } : { type: "Literal", value: a3[u2] };
      i2 = i2 ? {
        type: "MemberExpression",
        object: i2,
        property: o2,
        computed: !!(u2 && o2.type === "Literal"),
        optional: false
      } : o2;
    }
    r = i2;
  } else
    r = na2(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t };
  if (r.type === "Literal") {
    const a3 = (
      /** @type {keyof JSX.IntrinsicElements} */
      r.value
    );
    return Cr2.call(e2.components, a3) ? e2.components[a3] : a3;
  }
  if (e2.evaluater)
    return e2.evaluater.evaluateExpression(r);
  Wt3(e2);
}
function Wt3(e2, t) {
  const n2 = new be2(
    "Cannot handle MDX estrees without `createEvaluater`",
    {
      ancestors: e2.ancestors,
      place: t,
      ruleId: "mdx-estree",
      source: "hast-util-to-jsx-runtime"
    }
  );
  throw n2.file = e2.filePath || void 0, n2.url = zi + "#cannot-handle-mdx-estrees-without-createevaluater", n2;
}
function xl(e2) {
  const t = {};
  let n2;
  for (n2 in e2)
    Cr2.call(e2, n2) && (t[kl(n2)] = e2[n2]);
  return t;
}
function kl(e2) {
  let t = e2.replace(sl, Sl);
  return t.slice(0, 3) === "ms-" && (t = "-" + t), t;
}
function Il(e2, t) {
  return t.toUpperCase();
}
function Sl(e2) {
  return "-" + e2.toLowerCase();
}
var vn = {
  action: ["form"],
  cite: ["blockquote", "del", "ins", "q"],
  data: ["object"],
  formAction: ["button", "input"],
  href: ["a", "area", "base", "link"],
  icon: ["menuitem"],
  itemId: null,
  manifest: ["html"],
  ping: ["a", "area"],
  poster: ["video"],
  src: [
    "audio",
    "embed",
    "iframe",
    "img",
    "input",
    "script",
    "source",
    "track",
    "video"
  ]
};
var Nl = {};
function Ir2(e2, t) {
  const n2 = Nl, r = typeof n2.includeImageAlt == "boolean" ? n2.includeImageAlt : true, a3 = typeof n2.includeHtml == "boolean" ? n2.includeHtml : true;
  return qi(e2, r, a3);
}
function qi(e2, t, n2) {
  if (Rl(e2)) {
    if ("value" in e2)
      return e2.type === "html" && !n2 ? "" : e2.value;
    if (t && "alt" in e2 && e2.alt)
      return e2.alt;
    if ("children" in e2)
      return pa(e2.children, t, n2);
  }
  return Array.isArray(e2) ? pa(e2, t, n2) : "";
}
function pa(e2, t, n2) {
  const r = [];
  let a3 = -1;
  for (; ++a3 < e2.length; )
    r[a3] = qi(e2[a3], t, n2);
  return r.join("");
}
function Rl(e2) {
  return !!(e2 && typeof e2 == "object");
}
var ma2 = typeof document < "u" && document.createElement("i");
function Sr2(e2) {
  const t = "&" + e2 + ";";
  ma2.innerHTML = t;
  const n2 = ma2.textContent;
  return n2.charCodeAt(n2.length - 1) === 59 && e2 !== "semi" || n2 === t ? false : n2;
}
function Ne3(e2, t, n2, r) {
  const a3 = e2.length;
  let u2 = 0, i2;
  if (t < 0 ? t = -t > a3 ? 0 : a3 + t : t = t > a3 ? a3 : t, n2 = n2 > 0 ? n2 : 0, r.length < 1e4)
    i2 = Array.from(r), i2.unshift(t, n2), e2.splice(...i2);
  else
    for (n2 && e2.splice(t, n2); u2 < r.length; )
      i2 = r.slice(u2, u2 + 1e4), i2.unshift(t, 0), e2.splice(...i2), u2 += 1e4, t += 1e4;
}
function Re2(e2, t) {
  return e2.length > 0 ? (Ne3(e2, e2.length, 0, t), e2) : t;
}
var ga2 = {}.hasOwnProperty;
function $i(e2) {
  const t = {};
  let n2 = -1;
  for (; ++n2 < e2.length; )
    Ll(t, e2[n2]);
  return t;
}
function Ll(e2, t) {
  let n2;
  for (n2 in t) {
    const a3 = (ga2.call(e2, n2) ? e2[n2] : void 0) || (e2[n2] = {}), u2 = t[n2];
    let i2;
    if (u2)
      for (i2 in u2) {
        ga2.call(a3, i2) || (a3[i2] = []);
        const o2 = u2[i2];
        Ol(
          // @ts-expect-error Looks like a list.
          a3[i2],
          Array.isArray(o2) ? o2 : o2 ? [o2] : []
        );
      }
  }
}
function Ol(e2, t) {
  let n2 = -1;
  const r = [];
  for (; ++n2 < t.length; )
    (t[n2].add === "after" ? e2 : r).push(t[n2]);
  Ne3(e2, 0, 0, r);
}
function Wi(e2, t) {
  const n2 = Number.parseInt(e2, t);
  return (
    // C0 except for HT, LF, FF, CR, space.
    n2 < 9 || n2 === 11 || n2 > 13 && n2 < 32 || // Control character (DEL) of C0, and C1 controls.
    n2 > 126 && n2 < 160 || // Lone high surrogates and low surrogates.
    n2 > 55295 && n2 < 57344 || // Noncharacters.
    n2 > 64975 && n2 < 65008 || /* eslint-disable no-bitwise */
    (n2 & 65535) === 65535 || (n2 & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    n2 > 1114111 ? "�" : String.fromCodePoint(n2)
  );
}
function De3(e2) {
  return e2.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
var ye2 = tt2(/[A-Za-z]/);
var ge3 = tt2(/[\dA-Za-z]/);
var wl = tt2(/[#-'*+\--9=?A-Z^-~]/);
function mn(e2) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    e2 !== null && (e2 < 32 || e2 === 127)
  );
}
var ir2 = tt2(/\d/);
var Dl = tt2(/[\dA-Fa-f]/);
var Pl = tt2(/[!-/:-@[-`{-~]/);
function z2(e2) {
  return e2 !== null && e2 < -2;
}
function ie4(e2) {
  return e2 !== null && (e2 < 0 || e2 === 32);
}
function K2(e2) {
  return e2 === -2 || e2 === -1 || e2 === 32;
}
var xn = tt2(new RegExp("\\p{P}|\\p{S}", "u"));
var lt4 = tt2(/\s/);
function tt2(e2) {
  return t;
  function t(n2) {
    return n2 !== null && n2 > -1 && e2.test(String.fromCharCode(n2));
  }
}
function It2(e2) {
  const t = [];
  let n2 = -1, r = 0, a3 = 0;
  for (; ++n2 < e2.length; ) {
    const u2 = e2.charCodeAt(n2);
    let i2 = "";
    if (u2 === 37 && ge3(e2.charCodeAt(n2 + 1)) && ge3(e2.charCodeAt(n2 + 2)))
      a3 = 2;
    else if (u2 < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(u2)) || (i2 = String.fromCharCode(u2));
    else if (u2 > 55295 && u2 < 57344) {
      const o2 = e2.charCodeAt(n2 + 1);
      u2 < 56320 && o2 > 56319 && o2 < 57344 ? (i2 = String.fromCharCode(u2, o2), a3 = 1) : i2 = "�";
    } else
      i2 = String.fromCharCode(u2);
    i2 && (t.push(e2.slice(r, n2), encodeURIComponent(i2)), r = n2 + a3 + 1, i2 = ""), a3 && (n2 += a3, a3 = 0);
  }
  return t.join("") + e2.slice(r);
}
function J2(e2, t, n2, r) {
  const a3 = r ? r - 1 : Number.POSITIVE_INFINITY;
  let u2 = 0;
  return i2;
  function i2(l) {
    return K2(l) ? (e2.enter(n2), o2(l)) : t(l);
  }
  function o2(l) {
    return K2(l) && u2++ < a3 ? (e2.consume(l), o2) : (e2.exit(n2), t(l));
  }
}
var Ml = {
  tokenize: Fl
};
function Fl(e2) {
  const t = e2.attempt(
    this.parser.constructs.contentInitial,
    r,
    a3
  );
  let n2;
  return t;
  function r(o2) {
    if (o2 === null) {
      e2.consume(o2);
      return;
    }
    return e2.enter("lineEnding"), e2.consume(o2), e2.exit("lineEnding"), J2(e2, t, "linePrefix");
  }
  function a3(o2) {
    return e2.enter("paragraph"), u2(o2);
  }
  function u2(o2) {
    const l = e2.enter("chunkText", {
      contentType: "text",
      previous: n2
    });
    return n2 && (n2.next = l), n2 = l, i2(o2);
  }
  function i2(o2) {
    if (o2 === null) {
      e2.exit("chunkText"), e2.exit("paragraph"), e2.consume(o2);
      return;
    }
    return z2(o2) ? (e2.consume(o2), e2.exit("chunkText"), u2) : (e2.consume(o2), i2);
  }
}
var Bl = {
  tokenize: vl
};
var ba = {
  tokenize: Hl
};
function vl(e2) {
  const t = this, n2 = [];
  let r = 0, a3, u2, i2;
  return o2;
  function o2(I3) {
    if (r < n2.length) {
      const M3 = n2[r];
      return t.containerState = M3[1], e2.attempt(
        M3[0].continuation,
        l,
        c3
      )(I3);
    }
    return c3(I3);
  }
  function l(I3) {
    if (r++, t.containerState._closeFlow) {
      t.containerState._closeFlow = void 0, a3 && x2();
      const M3 = t.events.length;
      let B4 = M3, R;
      for (; B4--; )
        if (t.events[B4][0] === "exit" && t.events[B4][1].type === "chunkFlow") {
          R = t.events[B4][1].end;
          break;
        }
      _3(r);
      let U2 = M3;
      for (; U2 < t.events.length; )
        t.events[U2][1].end = Object.assign({}, R), U2++;
      return Ne3(
        t.events,
        B4 + 1,
        0,
        t.events.slice(M3)
      ), t.events.length = U2, c3(I3);
    }
    return o2(I3);
  }
  function c3(I3) {
    if (r === n2.length) {
      if (!a3)
        return b2(I3);
      if (a3.currentConstruct && a3.currentConstruct.concrete)
        return h(I3);
      t.interrupt = !!(a3.currentConstruct && !a3._gfmTableDynamicInterruptHack);
    }
    return t.containerState = {}, e2.check(
      ba,
      f2,
      d2
    )(I3);
  }
  function f2(I3) {
    return a3 && x2(), _3(r), b2(I3);
  }
  function d2(I3) {
    return t.parser.lazy[t.now().line] = r !== n2.length, i2 = t.now().offset, h(I3);
  }
  function b2(I3) {
    return t.containerState = {}, e2.attempt(
      ba,
      m,
      h
    )(I3);
  }
  function m(I3) {
    return r++, n2.push([t.currentConstruct, t.containerState]), b2(I3);
  }
  function h(I3) {
    if (I3 === null) {
      a3 && x2(), _3(0), e2.consume(I3);
      return;
    }
    return a3 = a3 || t.parser.flow(t.now()), e2.enter("chunkFlow", {
      contentType: "flow",
      previous: u2,
      _tokenizer: a3
    }), E(I3);
  }
  function E(I3) {
    if (I3 === null) {
      y2(e2.exit("chunkFlow"), true), _3(0), e2.consume(I3);
      return;
    }
    return z2(I3) ? (e2.consume(I3), y2(e2.exit("chunkFlow")), r = 0, t.interrupt = void 0, o2) : (e2.consume(I3), E);
  }
  function y2(I3, M3) {
    const B4 = t.sliceStream(I3);
    if (M3 && B4.push(null), I3.previous = u2, u2 && (u2.next = I3), u2 = I3, a3.defineSkip(I3.start), a3.write(B4), t.parser.lazy[I3.start.line]) {
      let R = a3.events.length;
      for (; R--; )
        if (
          // The token starts before the line ending…
          a3.events[R][1].start.offset < i2 && // …and either is not ended yet…
          (!a3.events[R][1].end || // …or ends after it.
          a3.events[R][1].end.offset > i2)
        )
          return;
      const U2 = t.events.length;
      let q3 = U2, Y3, S2;
      for (; q3--; )
        if (t.events[q3][0] === "exit" && t.events[q3][1].type === "chunkFlow") {
          if (Y3) {
            S2 = t.events[q3][1].end;
            break;
          }
          Y3 = true;
        }
      for (_3(r), R = U2; R < t.events.length; )
        t.events[R][1].end = Object.assign({}, S2), R++;
      Ne3(
        t.events,
        q3 + 1,
        0,
        t.events.slice(U2)
      ), t.events.length = R;
    }
  }
  function _3(I3) {
    let M3 = n2.length;
    for (; M3-- > I3; ) {
      const B4 = n2[M3];
      t.containerState = B4[1], B4[0].exit.call(t, e2);
    }
    n2.length = I3;
  }
  function x2() {
    a3.write([null]), u2 = void 0, a3 = void 0, t.containerState._closeFlow = void 0;
  }
}
function Hl(e2, t, n2) {
  return J2(
    e2,
    e2.attempt(this.parser.constructs.document, t, n2),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
function gn(e2) {
  if (e2 === null || ie4(e2) || lt4(e2))
    return 1;
  if (xn(e2))
    return 2;
}
function kn(e2, t, n2) {
  const r = [];
  let a3 = -1;
  for (; ++a3 < e2.length; ) {
    const u2 = e2[a3].resolveAll;
    u2 && !r.includes(u2) && (t = u2(t, n2), r.push(u2));
  }
  return t;
}
var ur2 = {
  name: "attention",
  tokenize: zl,
  resolveAll: Ul
};
function Ul(e2, t) {
  let n2 = -1, r, a3, u2, i2, o2, l, c3, f2;
  for (; ++n2 < e2.length; )
    if (e2[n2][0] === "enter" && e2[n2][1].type === "attentionSequence" && e2[n2][1]._close) {
      for (r = n2; r--; )
        if (e2[r][0] === "exit" && e2[r][1].type === "attentionSequence" && e2[r][1]._open && // If the markers are the same:
        t.sliceSerialize(e2[r][1]).charCodeAt(0) === t.sliceSerialize(e2[n2][1]).charCodeAt(0)) {
          if ((e2[r][1]._close || e2[n2][1]._open) && (e2[n2][1].end.offset - e2[n2][1].start.offset) % 3 && !((e2[r][1].end.offset - e2[r][1].start.offset + e2[n2][1].end.offset - e2[n2][1].start.offset) % 3))
            continue;
          l = e2[r][1].end.offset - e2[r][1].start.offset > 1 && e2[n2][1].end.offset - e2[n2][1].start.offset > 1 ? 2 : 1;
          const d2 = Object.assign({}, e2[r][1].end), b2 = Object.assign({}, e2[n2][1].start);
          Ea(d2, -l), Ea(b2, l), i2 = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: d2,
            end: Object.assign({}, e2[r][1].end)
          }, o2 = {
            type: l > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, e2[n2][1].start),
            end: b2
          }, u2 = {
            type: l > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, e2[r][1].end),
            end: Object.assign({}, e2[n2][1].start)
          }, a3 = {
            type: l > 1 ? "strong" : "emphasis",
            start: Object.assign({}, i2.start),
            end: Object.assign({}, o2.end)
          }, e2[r][1].end = Object.assign({}, i2.start), e2[n2][1].start = Object.assign({}, o2.end), c3 = [], e2[r][1].end.offset - e2[r][1].start.offset && (c3 = Re2(c3, [
            ["enter", e2[r][1], t],
            ["exit", e2[r][1], t]
          ])), c3 = Re2(c3, [
            ["enter", a3, t],
            ["enter", i2, t],
            ["exit", i2, t],
            ["enter", u2, t]
          ]), c3 = Re2(
            c3,
            kn(
              t.parser.constructs.insideSpan.null,
              e2.slice(r + 1, n2),
              t
            )
          ), c3 = Re2(c3, [
            ["exit", u2, t],
            ["enter", o2, t],
            ["exit", o2, t],
            ["exit", a3, t]
          ]), e2[n2][1].end.offset - e2[n2][1].start.offset ? (f2 = 2, c3 = Re2(c3, [
            ["enter", e2[n2][1], t],
            ["exit", e2[n2][1], t]
          ])) : f2 = 0, Ne3(e2, r - 1, n2 - r + 3, c3), n2 = r + c3.length - f2 - 2;
          break;
        }
    }
  for (n2 = -1; ++n2 < e2.length; )
    e2[n2][1].type === "attentionSequence" && (e2[n2][1].type = "data");
  return e2;
}
function zl(e2, t) {
  const n2 = this.parser.constructs.attentionMarkers.null, r = this.previous, a3 = gn(r);
  let u2;
  return i2;
  function i2(l) {
    return u2 = l, e2.enter("attentionSequence"), o2(l);
  }
  function o2(l) {
    if (l === u2)
      return e2.consume(l), o2;
    const c3 = e2.exit("attentionSequence"), f2 = gn(l), d2 = !f2 || f2 === 2 && a3 || n2.includes(l), b2 = !a3 || a3 === 2 && f2 || n2.includes(r);
    return c3._open = !!(u2 === 42 ? d2 : d2 && (a3 || !b2)), c3._close = !!(u2 === 42 ? b2 : b2 && (f2 || !d2)), t(l);
  }
}
function Ea(e2, t) {
  e2.column += t, e2.offset += t, e2._bufferIndex += t;
}
var Yl = {
  name: "autolink",
  tokenize: jl
};
function jl(e2, t, n2) {
  let r = 0;
  return a3;
  function a3(m) {
    return e2.enter("autolink"), e2.enter("autolinkMarker"), e2.consume(m), e2.exit("autolinkMarker"), e2.enter("autolinkProtocol"), u2;
  }
  function u2(m) {
    return ye2(m) ? (e2.consume(m), i2) : c3(m);
  }
  function i2(m) {
    return m === 43 || m === 45 || m === 46 || ge3(m) ? (r = 1, o2(m)) : c3(m);
  }
  function o2(m) {
    return m === 58 ? (e2.consume(m), r = 0, l) : (m === 43 || m === 45 || m === 46 || ge3(m)) && r++ < 32 ? (e2.consume(m), o2) : (r = 0, c3(m));
  }
  function l(m) {
    return m === 62 ? (e2.exit("autolinkProtocol"), e2.enter("autolinkMarker"), e2.consume(m), e2.exit("autolinkMarker"), e2.exit("autolink"), t) : m === null || m === 32 || m === 60 || mn(m) ? n2(m) : (e2.consume(m), l);
  }
  function c3(m) {
    return m === 64 ? (e2.consume(m), f2) : wl(m) ? (e2.consume(m), c3) : n2(m);
  }
  function f2(m) {
    return ge3(m) ? d2(m) : n2(m);
  }
  function d2(m) {
    return m === 46 ? (e2.consume(m), r = 0, f2) : m === 62 ? (e2.exit("autolinkProtocol").type = "autolinkEmail", e2.enter("autolinkMarker"), e2.consume(m), e2.exit("autolinkMarker"), e2.exit("autolink"), t) : b2(m);
  }
  function b2(m) {
    if ((m === 45 || ge3(m)) && r++ < 63) {
      const h = m === 45 ? b2 : d2;
      return e2.consume(m), h;
    }
    return n2(m);
  }
}
var Kt = {
  tokenize: Gl,
  partial: true
};
function Gl(e2, t, n2) {
  return r;
  function r(u2) {
    return K2(u2) ? J2(e2, a3, "linePrefix")(u2) : a3(u2);
  }
  function a3(u2) {
    return u2 === null || z2(u2) ? t(u2) : n2(u2);
  }
}
var Vi = {
  name: "blockQuote",
  tokenize: ql,
  continuation: {
    tokenize: $l
  },
  exit: Wl
};
function ql(e2, t, n2) {
  const r = this;
  return a3;
  function a3(i2) {
    if (i2 === 62) {
      const o2 = r.containerState;
      return o2.open || (e2.enter("blockQuote", {
        _container: true
      }), o2.open = true), e2.enter("blockQuotePrefix"), e2.enter("blockQuoteMarker"), e2.consume(i2), e2.exit("blockQuoteMarker"), u2;
    }
    return n2(i2);
  }
  function u2(i2) {
    return K2(i2) ? (e2.enter("blockQuotePrefixWhitespace"), e2.consume(i2), e2.exit("blockQuotePrefixWhitespace"), e2.exit("blockQuotePrefix"), t) : (e2.exit("blockQuotePrefix"), t(i2));
  }
}
function $l(e2, t, n2) {
  const r = this;
  return a3;
  function a3(i2) {
    return K2(i2) ? J2(
      e2,
      u2,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(i2) : u2(i2);
  }
  function u2(i2) {
    return e2.attempt(Vi, t, n2)(i2);
  }
}
function Wl(e2) {
  e2.exit("blockQuote");
}
var Qi = {
  name: "characterEscape",
  tokenize: Vl
};
function Vl(e2, t, n2) {
  return r;
  function r(u2) {
    return e2.enter("characterEscape"), e2.enter("escapeMarker"), e2.consume(u2), e2.exit("escapeMarker"), a3;
  }
  function a3(u2) {
    return Pl(u2) ? (e2.enter("characterEscapeValue"), e2.consume(u2), e2.exit("characterEscapeValue"), e2.exit("characterEscape"), t) : n2(u2);
  }
}
var Xi = {
  name: "characterReference",
  tokenize: Ql
};
function Ql(e2, t, n2) {
  const r = this;
  let a3 = 0, u2, i2;
  return o2;
  function o2(d2) {
    return e2.enter("characterReference"), e2.enter("characterReferenceMarker"), e2.consume(d2), e2.exit("characterReferenceMarker"), l;
  }
  function l(d2) {
    return d2 === 35 ? (e2.enter("characterReferenceMarkerNumeric"), e2.consume(d2), e2.exit("characterReferenceMarkerNumeric"), c3) : (e2.enter("characterReferenceValue"), u2 = 31, i2 = ge3, f2(d2));
  }
  function c3(d2) {
    return d2 === 88 || d2 === 120 ? (e2.enter("characterReferenceMarkerHexadecimal"), e2.consume(d2), e2.exit("characterReferenceMarkerHexadecimal"), e2.enter("characterReferenceValue"), u2 = 6, i2 = Dl, f2) : (e2.enter("characterReferenceValue"), u2 = 7, i2 = ir2, f2(d2));
  }
  function f2(d2) {
    if (d2 === 59 && a3) {
      const b2 = e2.exit("characterReferenceValue");
      return i2 === ge3 && !Sr2(r.sliceSerialize(b2)) ? n2(d2) : (e2.enter("characterReferenceMarker"), e2.consume(d2), e2.exit("characterReferenceMarker"), e2.exit("characterReference"), t);
    }
    return i2(d2) && a3++ < u2 ? (e2.consume(d2), f2) : n2(d2);
  }
}
var Ta = {
  tokenize: Kl,
  partial: true
};
var ya2 = {
  name: "codeFenced",
  tokenize: Xl,
  concrete: true
};
function Xl(e2, t, n2) {
  const r = this, a3 = {
    tokenize: B4,
    partial: true
  };
  let u2 = 0, i2 = 0, o2;
  return l;
  function l(R) {
    return c3(R);
  }
  function c3(R) {
    const U2 = r.events[r.events.length - 1];
    return u2 = U2 && U2[1].type === "linePrefix" ? U2[2].sliceSerialize(U2[1], true).length : 0, o2 = R, e2.enter("codeFenced"), e2.enter("codeFencedFence"), e2.enter("codeFencedFenceSequence"), f2(R);
  }
  function f2(R) {
    return R === o2 ? (i2++, e2.consume(R), f2) : i2 < 3 ? n2(R) : (e2.exit("codeFencedFenceSequence"), K2(R) ? J2(e2, d2, "whitespace")(R) : d2(R));
  }
  function d2(R) {
    return R === null || z2(R) ? (e2.exit("codeFencedFence"), r.interrupt ? t(R) : e2.check(Ta, E, M3)(R)) : (e2.enter("codeFencedFenceInfo"), e2.enter("chunkString", {
      contentType: "string"
    }), b2(R));
  }
  function b2(R) {
    return R === null || z2(R) ? (e2.exit("chunkString"), e2.exit("codeFencedFenceInfo"), d2(R)) : K2(R) ? (e2.exit("chunkString"), e2.exit("codeFencedFenceInfo"), J2(e2, m, "whitespace")(R)) : R === 96 && R === o2 ? n2(R) : (e2.consume(R), b2);
  }
  function m(R) {
    return R === null || z2(R) ? d2(R) : (e2.enter("codeFencedFenceMeta"), e2.enter("chunkString", {
      contentType: "string"
    }), h(R));
  }
  function h(R) {
    return R === null || z2(R) ? (e2.exit("chunkString"), e2.exit("codeFencedFenceMeta"), d2(R)) : R === 96 && R === o2 ? n2(R) : (e2.consume(R), h);
  }
  function E(R) {
    return e2.attempt(a3, M3, y2)(R);
  }
  function y2(R) {
    return e2.enter("lineEnding"), e2.consume(R), e2.exit("lineEnding"), _3;
  }
  function _3(R) {
    return u2 > 0 && K2(R) ? J2(
      e2,
      x2,
      "linePrefix",
      u2 + 1
    )(R) : x2(R);
  }
  function x2(R) {
    return R === null || z2(R) ? e2.check(Ta, E, M3)(R) : (e2.enter("codeFlowValue"), I3(R));
  }
  function I3(R) {
    return R === null || z2(R) ? (e2.exit("codeFlowValue"), x2(R)) : (e2.consume(R), I3);
  }
  function M3(R) {
    return e2.exit("codeFenced"), t(R);
  }
  function B4(R, U2, q3) {
    let Y3 = 0;
    return S2;
    function S2(j3) {
      return R.enter("lineEnding"), R.consume(j3), R.exit("lineEnding"), H3;
    }
    function H3(j3) {
      return R.enter("codeFencedFence"), K2(j3) ? J2(
        R,
        F2,
        "linePrefix",
        r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
      )(j3) : F2(j3);
    }
    function F2(j3) {
      return j3 === o2 ? (R.enter("codeFencedFenceSequence"), ee3(j3)) : q3(j3);
    }
    function ee3(j3) {
      return j3 === o2 ? (Y3++, R.consume(j3), ee3) : Y3 >= i2 ? (R.exit("codeFencedFenceSequence"), K2(j3) ? J2(R, G2, "whitespace")(j3) : G2(j3)) : q3(j3);
    }
    function G2(j3) {
      return j3 === null || z2(j3) ? (R.exit("codeFencedFence"), U2(j3)) : q3(j3);
    }
  }
}
function Kl(e2, t, n2) {
  const r = this;
  return a3;
  function a3(i2) {
    return i2 === null ? n2(i2) : (e2.enter("lineEnding"), e2.consume(i2), e2.exit("lineEnding"), u2);
  }
  function u2(i2) {
    return r.parser.lazy[r.now().line] ? n2(i2) : t(i2);
  }
}
var Hn = {
  name: "codeIndented",
  tokenize: Jl
};
var Zl = {
  tokenize: ec,
  partial: true
};
function Jl(e2, t, n2) {
  const r = this;
  return a3;
  function a3(c3) {
    return e2.enter("codeIndented"), J2(e2, u2, "linePrefix", 5)(c3);
  }
  function u2(c3) {
    const f2 = r.events[r.events.length - 1];
    return f2 && f2[1].type === "linePrefix" && f2[2].sliceSerialize(f2[1], true).length >= 4 ? i2(c3) : n2(c3);
  }
  function i2(c3) {
    return c3 === null ? l(c3) : z2(c3) ? e2.attempt(Zl, i2, l)(c3) : (e2.enter("codeFlowValue"), o2(c3));
  }
  function o2(c3) {
    return c3 === null || z2(c3) ? (e2.exit("codeFlowValue"), i2(c3)) : (e2.consume(c3), o2);
  }
  function l(c3) {
    return e2.exit("codeIndented"), t(c3);
  }
}
function ec(e2, t, n2) {
  const r = this;
  return a3;
  function a3(i2) {
    return r.parser.lazy[r.now().line] ? n2(i2) : z2(i2) ? (e2.enter("lineEnding"), e2.consume(i2), e2.exit("lineEnding"), a3) : J2(e2, u2, "linePrefix", 5)(i2);
  }
  function u2(i2) {
    const o2 = r.events[r.events.length - 1];
    return o2 && o2[1].type === "linePrefix" && o2[2].sliceSerialize(o2[1], true).length >= 4 ? t(i2) : z2(i2) ? a3(i2) : n2(i2);
  }
}
var tc = {
  name: "codeText",
  tokenize: ac,
  resolve: nc,
  previous: rc
};
function nc(e2) {
  let t = e2.length - 4, n2 = 3, r, a3;
  if ((e2[n2][1].type === "lineEnding" || e2[n2][1].type === "space") && (e2[t][1].type === "lineEnding" || e2[t][1].type === "space")) {
    for (r = n2; ++r < t; )
      if (e2[r][1].type === "codeTextData") {
        e2[n2][1].type = "codeTextPadding", e2[t][1].type = "codeTextPadding", n2 += 2, t -= 2;
        break;
      }
  }
  for (r = n2 - 1, t++; ++r <= t; )
    a3 === void 0 ? r !== t && e2[r][1].type !== "lineEnding" && (a3 = r) : (r === t || e2[r][1].type === "lineEnding") && (e2[a3][1].type = "codeTextData", r !== a3 + 2 && (e2[a3][1].end = e2[r - 1][1].end, e2.splice(a3 + 2, r - a3 - 2), t -= r - a3 - 2, r = a3 + 2), a3 = void 0);
  return e2;
}
function rc(e2) {
  return e2 !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function ac(e2, t, n2) {
  let r = 0, a3, u2;
  return i2;
  function i2(d2) {
    return e2.enter("codeText"), e2.enter("codeTextSequence"), o2(d2);
  }
  function o2(d2) {
    return d2 === 96 ? (e2.consume(d2), r++, o2) : (e2.exit("codeTextSequence"), l(d2));
  }
  function l(d2) {
    return d2 === null ? n2(d2) : d2 === 32 ? (e2.enter("space"), e2.consume(d2), e2.exit("space"), l) : d2 === 96 ? (u2 = e2.enter("codeTextSequence"), a3 = 0, f2(d2)) : z2(d2) ? (e2.enter("lineEnding"), e2.consume(d2), e2.exit("lineEnding"), l) : (e2.enter("codeTextData"), c3(d2));
  }
  function c3(d2) {
    return d2 === null || d2 === 32 || d2 === 96 || z2(d2) ? (e2.exit("codeTextData"), l(d2)) : (e2.consume(d2), c3);
  }
  function f2(d2) {
    return d2 === 96 ? (e2.consume(d2), a3++, f2) : a3 === r ? (e2.exit("codeTextSequence"), e2.exit("codeText"), t(d2)) : (u2.type = "codeTextData", c3(d2));
  }
}
function Ki(e2) {
  const t = {};
  let n2 = -1, r, a3, u2, i2, o2, l, c3;
  for (; ++n2 < e2.length; ) {
    for (; n2 in t; )
      n2 = t[n2];
    if (r = e2[n2], n2 && r[1].type === "chunkFlow" && e2[n2 - 1][1].type === "listItemPrefix" && (l = r[1]._tokenizer.events, u2 = 0, u2 < l.length && l[u2][1].type === "lineEndingBlank" && (u2 += 2), u2 < l.length && l[u2][1].type === "content"))
      for (; ++u2 < l.length && l[u2][1].type !== "content"; )
        l[u2][1].type === "chunkText" && (l[u2][1]._isInFirstContentOfListItem = true, u2++);
    if (r[0] === "enter")
      r[1].contentType && (Object.assign(t, ic(e2, n2)), n2 = t[n2], c3 = true);
    else if (r[1]._container) {
      for (u2 = n2, a3 = void 0; u2-- && (i2 = e2[u2], i2[1].type === "lineEnding" || i2[1].type === "lineEndingBlank"); )
        i2[0] === "enter" && (a3 && (e2[a3][1].type = "lineEndingBlank"), i2[1].type = "lineEnding", a3 = u2);
      a3 && (r[1].end = Object.assign({}, e2[a3][1].start), o2 = e2.slice(a3, n2), o2.unshift(r), Ne3(e2, a3, n2 - a3 + 1, o2));
    }
  }
  return !c3;
}
function ic(e2, t) {
  const n2 = e2[t][1], r = e2[t][2];
  let a3 = t - 1;
  const u2 = [], i2 = n2._tokenizer || r.parser[n2.contentType](n2.start), o2 = i2.events, l = [], c3 = {};
  let f2, d2, b2 = -1, m = n2, h = 0, E = 0;
  const y2 = [E];
  for (; m; ) {
    for (; e2[++a3][1] !== m; )
      ;
    u2.push(a3), m._tokenizer || (f2 = r.sliceStream(m), m.next || f2.push(null), d2 && i2.defineSkip(m.start), m._isInFirstContentOfListItem && (i2._gfmTasklistFirstContentOfListItem = true), i2.write(f2), m._isInFirstContentOfListItem && (i2._gfmTasklistFirstContentOfListItem = void 0)), d2 = m, m = m.next;
  }
  for (m = n2; ++b2 < o2.length; )
    o2[b2][0] === "exit" && o2[b2 - 1][0] === "enter" && o2[b2][1].type === o2[b2 - 1][1].type && o2[b2][1].start.line !== o2[b2][1].end.line && (E = b2 + 1, y2.push(E), m._tokenizer = void 0, m.previous = void 0, m = m.next);
  for (i2.events = [], m ? (m._tokenizer = void 0, m.previous = void 0) : y2.pop(), b2 = y2.length; b2--; ) {
    const _3 = o2.slice(y2[b2], y2[b2 + 1]), x2 = u2.pop();
    l.unshift([x2, x2 + _3.length - 1]), Ne3(e2, x2, 2, _3);
  }
  for (b2 = -1; ++b2 < l.length; )
    c3[h + l[b2][0]] = h + l[b2][1], h += l[b2][1] - l[b2][0] - 1;
  return c3;
}
var uc = {
  tokenize: lc,
  resolve: oc
};
var sc = {
  tokenize: cc,
  partial: true
};
function oc(e2) {
  return Ki(e2), e2;
}
function lc(e2, t) {
  let n2;
  return r;
  function r(o2) {
    return e2.enter("content"), n2 = e2.enter("chunkContent", {
      contentType: "content"
    }), a3(o2);
  }
  function a3(o2) {
    return o2 === null ? u2(o2) : z2(o2) ? e2.check(
      sc,
      i2,
      u2
    )(o2) : (e2.consume(o2), a3);
  }
  function u2(o2) {
    return e2.exit("chunkContent"), e2.exit("content"), t(o2);
  }
  function i2(o2) {
    return e2.consume(o2), e2.exit("chunkContent"), n2.next = e2.enter("chunkContent", {
      contentType: "content",
      previous: n2
    }), n2 = n2.next, a3;
  }
}
function cc(e2, t, n2) {
  const r = this;
  return a3;
  function a3(i2) {
    return e2.exit("chunkContent"), e2.enter("lineEnding"), e2.consume(i2), e2.exit("lineEnding"), J2(e2, u2, "linePrefix");
  }
  function u2(i2) {
    if (i2 === null || z2(i2))
      return n2(i2);
    const o2 = r.events[r.events.length - 1];
    return !r.parser.constructs.disable.null.includes("codeIndented") && o2 && o2[1].type === "linePrefix" && o2[2].sliceSerialize(o2[1], true).length >= 4 ? t(i2) : e2.interrupt(r.parser.constructs.flow, n2, t)(i2);
  }
}
function Zi(e2, t, n2, r, a3, u2, i2, o2, l) {
  const c3 = l || Number.POSITIVE_INFINITY;
  let f2 = 0;
  return d2;
  function d2(_3) {
    return _3 === 60 ? (e2.enter(r), e2.enter(a3), e2.enter(u2), e2.consume(_3), e2.exit(u2), b2) : _3 === null || _3 === 32 || _3 === 41 || mn(_3) ? n2(_3) : (e2.enter(r), e2.enter(i2), e2.enter(o2), e2.enter("chunkString", {
      contentType: "string"
    }), E(_3));
  }
  function b2(_3) {
    return _3 === 62 ? (e2.enter(u2), e2.consume(_3), e2.exit(u2), e2.exit(a3), e2.exit(r), t) : (e2.enter(o2), e2.enter("chunkString", {
      contentType: "string"
    }), m(_3));
  }
  function m(_3) {
    return _3 === 62 ? (e2.exit("chunkString"), e2.exit(o2), b2(_3)) : _3 === null || _3 === 60 || z2(_3) ? n2(_3) : (e2.consume(_3), _3 === 92 ? h : m);
  }
  function h(_3) {
    return _3 === 60 || _3 === 62 || _3 === 92 ? (e2.consume(_3), m) : m(_3);
  }
  function E(_3) {
    return !f2 && (_3 === null || _3 === 41 || ie4(_3)) ? (e2.exit("chunkString"), e2.exit(o2), e2.exit(i2), e2.exit(r), t(_3)) : f2 < c3 && _3 === 40 ? (e2.consume(_3), f2++, E) : _3 === 41 ? (e2.consume(_3), f2--, E) : _3 === null || _3 === 32 || _3 === 40 || mn(_3) ? n2(_3) : (e2.consume(_3), _3 === 92 ? y2 : E);
  }
  function y2(_3) {
    return _3 === 40 || _3 === 41 || _3 === 92 ? (e2.consume(_3), E) : E(_3);
  }
}
function Ji(e2, t, n2, r, a3, u2) {
  const i2 = this;
  let o2 = 0, l;
  return c3;
  function c3(m) {
    return e2.enter(r), e2.enter(a3), e2.consume(m), e2.exit(a3), e2.enter(u2), f2;
  }
  function f2(m) {
    return o2 > 999 || m === null || m === 91 || m === 93 && !l || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    m === 94 && !o2 && "_hiddenFootnoteSupport" in i2.parser.constructs ? n2(m) : m === 93 ? (e2.exit(u2), e2.enter(a3), e2.consume(m), e2.exit(a3), e2.exit(r), t) : z2(m) ? (e2.enter("lineEnding"), e2.consume(m), e2.exit("lineEnding"), f2) : (e2.enter("chunkString", {
      contentType: "string"
    }), d2(m));
  }
  function d2(m) {
    return m === null || m === 91 || m === 93 || z2(m) || o2++ > 999 ? (e2.exit("chunkString"), f2(m)) : (e2.consume(m), l || (l = !K2(m)), m === 92 ? b2 : d2);
  }
  function b2(m) {
    return m === 91 || m === 92 || m === 93 ? (e2.consume(m), o2++, d2) : d2(m);
  }
}
function eu(e2, t, n2, r, a3, u2) {
  let i2;
  return o2;
  function o2(b2) {
    return b2 === 34 || b2 === 39 || b2 === 40 ? (e2.enter(r), e2.enter(a3), e2.consume(b2), e2.exit(a3), i2 = b2 === 40 ? 41 : b2, l) : n2(b2);
  }
  function l(b2) {
    return b2 === i2 ? (e2.enter(a3), e2.consume(b2), e2.exit(a3), e2.exit(r), t) : (e2.enter(u2), c3(b2));
  }
  function c3(b2) {
    return b2 === i2 ? (e2.exit(u2), l(i2)) : b2 === null ? n2(b2) : z2(b2) ? (e2.enter("lineEnding"), e2.consume(b2), e2.exit("lineEnding"), J2(e2, c3, "linePrefix")) : (e2.enter("chunkString", {
      contentType: "string"
    }), f2(b2));
  }
  function f2(b2) {
    return b2 === i2 || b2 === null || z2(b2) ? (e2.exit("chunkString"), c3(b2)) : (e2.consume(b2), b2 === 92 ? d2 : f2);
  }
  function d2(b2) {
    return b2 === i2 || b2 === 92 ? (e2.consume(b2), f2) : f2(b2);
  }
}
function Ht(e2, t) {
  let n2;
  return r;
  function r(a3) {
    return z2(a3) ? (e2.enter("lineEnding"), e2.consume(a3), e2.exit("lineEnding"), n2 = true, r) : K2(a3) ? J2(
      e2,
      r,
      n2 ? "linePrefix" : "lineSuffix"
    )(a3) : t(a3);
  }
}
var dc = {
  name: "definition",
  tokenize: hc
};
var fc = {
  tokenize: pc,
  partial: true
};
function hc(e2, t, n2) {
  const r = this;
  let a3;
  return u2;
  function u2(m) {
    return e2.enter("definition"), i2(m);
  }
  function i2(m) {
    return Ji.call(
      r,
      e2,
      o2,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n2,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(m);
  }
  function o2(m) {
    return a3 = De3(
      r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
    ), m === 58 ? (e2.enter("definitionMarker"), e2.consume(m), e2.exit("definitionMarker"), l) : n2(m);
  }
  function l(m) {
    return ie4(m) ? Ht(e2, c3)(m) : c3(m);
  }
  function c3(m) {
    return Zi(
      e2,
      f2,
      // Note: we don’t need to reset the way `markdown-rs` does.
      n2,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(m);
  }
  function f2(m) {
    return e2.attempt(fc, d2, d2)(m);
  }
  function d2(m) {
    return K2(m) ? J2(e2, b2, "whitespace")(m) : b2(m);
  }
  function b2(m) {
    return m === null || z2(m) ? (e2.exit("definition"), r.parser.defined.push(a3), t(m)) : n2(m);
  }
}
function pc(e2, t, n2) {
  return r;
  function r(o2) {
    return ie4(o2) ? Ht(e2, a3)(o2) : n2(o2);
  }
  function a3(o2) {
    return eu(
      e2,
      u2,
      n2,
      "definitionTitle",
      "definitionTitleMarker",
      "definitionTitleString"
    )(o2);
  }
  function u2(o2) {
    return K2(o2) ? J2(e2, i2, "whitespace")(o2) : i2(o2);
  }
  function i2(o2) {
    return o2 === null || z2(o2) ? t(o2) : n2(o2);
  }
}
var mc = {
  name: "hardBreakEscape",
  tokenize: gc
};
function gc(e2, t, n2) {
  return r;
  function r(u2) {
    return e2.enter("hardBreakEscape"), e2.consume(u2), a3;
  }
  function a3(u2) {
    return z2(u2) ? (e2.exit("hardBreakEscape"), t(u2)) : n2(u2);
  }
}
var bc = {
  name: "headingAtx",
  tokenize: Tc,
  resolve: Ec
};
function Ec(e2, t) {
  let n2 = e2.length - 2, r = 3, a3, u2;
  return e2[r][1].type === "whitespace" && (r += 2), n2 - 2 > r && e2[n2][1].type === "whitespace" && (n2 -= 2), e2[n2][1].type === "atxHeadingSequence" && (r === n2 - 1 || n2 - 4 > r && e2[n2 - 2][1].type === "whitespace") && (n2 -= r + 1 === n2 ? 2 : 4), n2 > r && (a3 = {
    type: "atxHeadingText",
    start: e2[r][1].start,
    end: e2[n2][1].end
  }, u2 = {
    type: "chunkText",
    start: e2[r][1].start,
    end: e2[n2][1].end,
    contentType: "text"
  }, Ne3(e2, r, n2 - r + 1, [
    ["enter", a3, t],
    ["enter", u2, t],
    ["exit", u2, t],
    ["exit", a3, t]
  ])), e2;
}
function Tc(e2, t, n2) {
  let r = 0;
  return a3;
  function a3(f2) {
    return e2.enter("atxHeading"), u2(f2);
  }
  function u2(f2) {
    return e2.enter("atxHeadingSequence"), i2(f2);
  }
  function i2(f2) {
    return f2 === 35 && r++ < 6 ? (e2.consume(f2), i2) : f2 === null || ie4(f2) ? (e2.exit("atxHeadingSequence"), o2(f2)) : n2(f2);
  }
  function o2(f2) {
    return f2 === 35 ? (e2.enter("atxHeadingSequence"), l(f2)) : f2 === null || z2(f2) ? (e2.exit("atxHeading"), t(f2)) : K2(f2) ? J2(e2, o2, "whitespace")(f2) : (e2.enter("atxHeadingText"), c3(f2));
  }
  function l(f2) {
    return f2 === 35 ? (e2.consume(f2), l) : (e2.exit("atxHeadingSequence"), o2(f2));
  }
  function c3(f2) {
    return f2 === null || f2 === 35 || ie4(f2) ? (e2.exit("atxHeadingText"), o2(f2)) : (e2.consume(f2), c3);
  }
}
var yc = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var Aa = ["pre", "script", "style", "textarea"];
var Ac = {
  name: "htmlFlow",
  tokenize: kc,
  resolveTo: xc,
  concrete: true
};
var _c = {
  tokenize: Sc,
  partial: true
};
var Cc = {
  tokenize: Ic,
  partial: true
};
function xc(e2) {
  let t = e2.length;
  for (; t-- && !(e2[t][0] === "enter" && e2[t][1].type === "htmlFlow"); )
    ;
  return t > 1 && e2[t - 2][1].type === "linePrefix" && (e2[t][1].start = e2[t - 2][1].start, e2[t + 1][1].start = e2[t - 2][1].start, e2.splice(t - 2, 2)), e2;
}
function kc(e2, t, n2) {
  const r = this;
  let a3, u2, i2, o2, l;
  return c3;
  function c3(C2) {
    return f2(C2);
  }
  function f2(C2) {
    return e2.enter("htmlFlow"), e2.enter("htmlFlowData"), e2.consume(C2), d2;
  }
  function d2(C2) {
    return C2 === 33 ? (e2.consume(C2), b2) : C2 === 47 ? (e2.consume(C2), u2 = true, E) : C2 === 63 ? (e2.consume(C2), a3 = 3, r.interrupt ? t : A3) : ye2(C2) ? (e2.consume(C2), i2 = String.fromCharCode(C2), y2) : n2(C2);
  }
  function b2(C2) {
    return C2 === 45 ? (e2.consume(C2), a3 = 2, m) : C2 === 91 ? (e2.consume(C2), a3 = 5, o2 = 0, h) : ye2(C2) ? (e2.consume(C2), a3 = 4, r.interrupt ? t : A3) : n2(C2);
  }
  function m(C2) {
    return C2 === 45 ? (e2.consume(C2), r.interrupt ? t : A3) : n2(C2);
  }
  function h(C2) {
    const Te3 = "CDATA[";
    return C2 === Te3.charCodeAt(o2++) ? (e2.consume(C2), o2 === Te3.length ? r.interrupt ? t : F2 : h) : n2(C2);
  }
  function E(C2) {
    return ye2(C2) ? (e2.consume(C2), i2 = String.fromCharCode(C2), y2) : n2(C2);
  }
  function y2(C2) {
    if (C2 === null || C2 === 47 || C2 === 62 || ie4(C2)) {
      const Te3 = C2 === 47, Me2 = i2.toLowerCase();
      return !Te3 && !u2 && Aa.includes(Me2) ? (a3 = 1, r.interrupt ? t(C2) : F2(C2)) : yc.includes(i2.toLowerCase()) ? (a3 = 6, Te3 ? (e2.consume(C2), _3) : r.interrupt ? t(C2) : F2(C2)) : (a3 = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n2(C2) : u2 ? x2(C2) : I3(C2));
    }
    return C2 === 45 || ge3(C2) ? (e2.consume(C2), i2 += String.fromCharCode(C2), y2) : n2(C2);
  }
  function _3(C2) {
    return C2 === 62 ? (e2.consume(C2), r.interrupt ? t : F2) : n2(C2);
  }
  function x2(C2) {
    return K2(C2) ? (e2.consume(C2), x2) : S2(C2);
  }
  function I3(C2) {
    return C2 === 47 ? (e2.consume(C2), S2) : C2 === 58 || C2 === 95 || ye2(C2) ? (e2.consume(C2), M3) : K2(C2) ? (e2.consume(C2), I3) : S2(C2);
  }
  function M3(C2) {
    return C2 === 45 || C2 === 46 || C2 === 58 || C2 === 95 || ge3(C2) ? (e2.consume(C2), M3) : B4(C2);
  }
  function B4(C2) {
    return C2 === 61 ? (e2.consume(C2), R) : K2(C2) ? (e2.consume(C2), B4) : I3(C2);
  }
  function R(C2) {
    return C2 === null || C2 === 60 || C2 === 61 || C2 === 62 || C2 === 96 ? n2(C2) : C2 === 34 || C2 === 39 ? (e2.consume(C2), l = C2, U2) : K2(C2) ? (e2.consume(C2), R) : q3(C2);
  }
  function U2(C2) {
    return C2 === l ? (e2.consume(C2), l = null, Y3) : C2 === null || z2(C2) ? n2(C2) : (e2.consume(C2), U2);
  }
  function q3(C2) {
    return C2 === null || C2 === 34 || C2 === 39 || C2 === 47 || C2 === 60 || C2 === 61 || C2 === 62 || C2 === 96 || ie4(C2) ? B4(C2) : (e2.consume(C2), q3);
  }
  function Y3(C2) {
    return C2 === 47 || C2 === 62 || K2(C2) ? I3(C2) : n2(C2);
  }
  function S2(C2) {
    return C2 === 62 ? (e2.consume(C2), H3) : n2(C2);
  }
  function H3(C2) {
    return C2 === null || z2(C2) ? F2(C2) : K2(C2) ? (e2.consume(C2), H3) : n2(C2);
  }
  function F2(C2) {
    return C2 === 45 && a3 === 2 ? (e2.consume(C2), te3) : C2 === 60 && a3 === 1 ? (e2.consume(C2), se4) : C2 === 62 && a3 === 4 ? (e2.consume(C2), ae3) : C2 === 63 && a3 === 3 ? (e2.consume(C2), A3) : C2 === 93 && a3 === 5 ? (e2.consume(C2), me3) : z2(C2) && (a3 === 6 || a3 === 7) ? (e2.exit("htmlFlowData"), e2.check(
      _c,
      Ae3,
      ee3
    )(C2)) : C2 === null || z2(C2) ? (e2.exit("htmlFlowData"), ee3(C2)) : (e2.consume(C2), F2);
  }
  function ee3(C2) {
    return e2.check(
      Cc,
      G2,
      Ae3
    )(C2);
  }
  function G2(C2) {
    return e2.enter("lineEnding"), e2.consume(C2), e2.exit("lineEnding"), j3;
  }
  function j3(C2) {
    return C2 === null || z2(C2) ? ee3(C2) : (e2.enter("htmlFlowData"), F2(C2));
  }
  function te3(C2) {
    return C2 === 45 ? (e2.consume(C2), A3) : F2(C2);
  }
  function se4(C2) {
    return C2 === 47 ? (e2.consume(C2), i2 = "", re3) : F2(C2);
  }
  function re3(C2) {
    if (C2 === 62) {
      const Te3 = i2.toLowerCase();
      return Aa.includes(Te3) ? (e2.consume(C2), ae3) : F2(C2);
    }
    return ye2(C2) && i2.length < 8 ? (e2.consume(C2), i2 += String.fromCharCode(C2), re3) : F2(C2);
  }
  function me3(C2) {
    return C2 === 93 ? (e2.consume(C2), A3) : F2(C2);
  }
  function A3(C2) {
    return C2 === 62 ? (e2.consume(C2), ae3) : C2 === 45 && a3 === 2 ? (e2.consume(C2), A3) : F2(C2);
  }
  function ae3(C2) {
    return C2 === null || z2(C2) ? (e2.exit("htmlFlowData"), Ae3(C2)) : (e2.consume(C2), ae3);
  }
  function Ae3(C2) {
    return e2.exit("htmlFlow"), t(C2);
  }
}
function Ic(e2, t, n2) {
  const r = this;
  return a3;
  function a3(i2) {
    return z2(i2) ? (e2.enter("lineEnding"), e2.consume(i2), e2.exit("lineEnding"), u2) : n2(i2);
  }
  function u2(i2) {
    return r.parser.lazy[r.now().line] ? n2(i2) : t(i2);
  }
}
function Sc(e2, t, n2) {
  return r;
  function r(a3) {
    return e2.enter("lineEnding"), e2.consume(a3), e2.exit("lineEnding"), e2.attempt(Kt, t, n2);
  }
}
var Nc = {
  name: "htmlText",
  tokenize: Rc
};
function Rc(e2, t, n2) {
  const r = this;
  let a3, u2, i2;
  return o2;
  function o2(A3) {
    return e2.enter("htmlText"), e2.enter("htmlTextData"), e2.consume(A3), l;
  }
  function l(A3) {
    return A3 === 33 ? (e2.consume(A3), c3) : A3 === 47 ? (e2.consume(A3), B4) : A3 === 63 ? (e2.consume(A3), I3) : ye2(A3) ? (e2.consume(A3), q3) : n2(A3);
  }
  function c3(A3) {
    return A3 === 45 ? (e2.consume(A3), f2) : A3 === 91 ? (e2.consume(A3), u2 = 0, h) : ye2(A3) ? (e2.consume(A3), x2) : n2(A3);
  }
  function f2(A3) {
    return A3 === 45 ? (e2.consume(A3), m) : n2(A3);
  }
  function d2(A3) {
    return A3 === null ? n2(A3) : A3 === 45 ? (e2.consume(A3), b2) : z2(A3) ? (i2 = d2, se4(A3)) : (e2.consume(A3), d2);
  }
  function b2(A3) {
    return A3 === 45 ? (e2.consume(A3), m) : d2(A3);
  }
  function m(A3) {
    return A3 === 62 ? te3(A3) : A3 === 45 ? b2(A3) : d2(A3);
  }
  function h(A3) {
    const ae3 = "CDATA[";
    return A3 === ae3.charCodeAt(u2++) ? (e2.consume(A3), u2 === ae3.length ? E : h) : n2(A3);
  }
  function E(A3) {
    return A3 === null ? n2(A3) : A3 === 93 ? (e2.consume(A3), y2) : z2(A3) ? (i2 = E, se4(A3)) : (e2.consume(A3), E);
  }
  function y2(A3) {
    return A3 === 93 ? (e2.consume(A3), _3) : E(A3);
  }
  function _3(A3) {
    return A3 === 62 ? te3(A3) : A3 === 93 ? (e2.consume(A3), _3) : E(A3);
  }
  function x2(A3) {
    return A3 === null || A3 === 62 ? te3(A3) : z2(A3) ? (i2 = x2, se4(A3)) : (e2.consume(A3), x2);
  }
  function I3(A3) {
    return A3 === null ? n2(A3) : A3 === 63 ? (e2.consume(A3), M3) : z2(A3) ? (i2 = I3, se4(A3)) : (e2.consume(A3), I3);
  }
  function M3(A3) {
    return A3 === 62 ? te3(A3) : I3(A3);
  }
  function B4(A3) {
    return ye2(A3) ? (e2.consume(A3), R) : n2(A3);
  }
  function R(A3) {
    return A3 === 45 || ge3(A3) ? (e2.consume(A3), R) : U2(A3);
  }
  function U2(A3) {
    return z2(A3) ? (i2 = U2, se4(A3)) : K2(A3) ? (e2.consume(A3), U2) : te3(A3);
  }
  function q3(A3) {
    return A3 === 45 || ge3(A3) ? (e2.consume(A3), q3) : A3 === 47 || A3 === 62 || ie4(A3) ? Y3(A3) : n2(A3);
  }
  function Y3(A3) {
    return A3 === 47 ? (e2.consume(A3), te3) : A3 === 58 || A3 === 95 || ye2(A3) ? (e2.consume(A3), S2) : z2(A3) ? (i2 = Y3, se4(A3)) : K2(A3) ? (e2.consume(A3), Y3) : te3(A3);
  }
  function S2(A3) {
    return A3 === 45 || A3 === 46 || A3 === 58 || A3 === 95 || ge3(A3) ? (e2.consume(A3), S2) : H3(A3);
  }
  function H3(A3) {
    return A3 === 61 ? (e2.consume(A3), F2) : z2(A3) ? (i2 = H3, se4(A3)) : K2(A3) ? (e2.consume(A3), H3) : Y3(A3);
  }
  function F2(A3) {
    return A3 === null || A3 === 60 || A3 === 61 || A3 === 62 || A3 === 96 ? n2(A3) : A3 === 34 || A3 === 39 ? (e2.consume(A3), a3 = A3, ee3) : z2(A3) ? (i2 = F2, se4(A3)) : K2(A3) ? (e2.consume(A3), F2) : (e2.consume(A3), G2);
  }
  function ee3(A3) {
    return A3 === a3 ? (e2.consume(A3), a3 = void 0, j3) : A3 === null ? n2(A3) : z2(A3) ? (i2 = ee3, se4(A3)) : (e2.consume(A3), ee3);
  }
  function G2(A3) {
    return A3 === null || A3 === 34 || A3 === 39 || A3 === 60 || A3 === 61 || A3 === 96 ? n2(A3) : A3 === 47 || A3 === 62 || ie4(A3) ? Y3(A3) : (e2.consume(A3), G2);
  }
  function j3(A3) {
    return A3 === 47 || A3 === 62 || ie4(A3) ? Y3(A3) : n2(A3);
  }
  function te3(A3) {
    return A3 === 62 ? (e2.consume(A3), e2.exit("htmlTextData"), e2.exit("htmlText"), t) : n2(A3);
  }
  function se4(A3) {
    return e2.exit("htmlTextData"), e2.enter("lineEnding"), e2.consume(A3), e2.exit("lineEnding"), re3;
  }
  function re3(A3) {
    return K2(A3) ? J2(
      e2,
      me3,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(A3) : me3(A3);
  }
  function me3(A3) {
    return e2.enter("htmlTextData"), i2(A3);
  }
}
var Nr2 = {
  name: "labelEnd",
  tokenize: Mc,
  resolveTo: Pc,
  resolveAll: Dc
};
var Lc = {
  tokenize: Fc
};
var Oc = {
  tokenize: Bc
};
var wc = {
  tokenize: vc
};
function Dc(e2) {
  let t = -1;
  for (; ++t < e2.length; ) {
    const n2 = e2[t][1];
    (n2.type === "labelImage" || n2.type === "labelLink" || n2.type === "labelEnd") && (e2.splice(t + 1, n2.type === "labelImage" ? 4 : 2), n2.type = "data", t++);
  }
  return e2;
}
function Pc(e2, t) {
  let n2 = e2.length, r = 0, a3, u2, i2, o2;
  for (; n2--; )
    if (a3 = e2[n2][1], u2) {
      if (a3.type === "link" || a3.type === "labelLink" && a3._inactive)
        break;
      e2[n2][0] === "enter" && a3.type === "labelLink" && (a3._inactive = true);
    } else if (i2) {
      if (e2[n2][0] === "enter" && (a3.type === "labelImage" || a3.type === "labelLink") && !a3._balanced && (u2 = n2, a3.type !== "labelLink")) {
        r = 2;
        break;
      }
    } else a3.type === "labelEnd" && (i2 = n2);
  const l = {
    type: e2[u2][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, e2[u2][1].start),
    end: Object.assign({}, e2[e2.length - 1][1].end)
  }, c3 = {
    type: "label",
    start: Object.assign({}, e2[u2][1].start),
    end: Object.assign({}, e2[i2][1].end)
  }, f2 = {
    type: "labelText",
    start: Object.assign({}, e2[u2 + r + 2][1].end),
    end: Object.assign({}, e2[i2 - 2][1].start)
  };
  return o2 = [
    ["enter", l, t],
    ["enter", c3, t]
  ], o2 = Re2(o2, e2.slice(u2 + 1, u2 + r + 3)), o2 = Re2(o2, [["enter", f2, t]]), o2 = Re2(
    o2,
    kn(
      t.parser.constructs.insideSpan.null,
      e2.slice(u2 + r + 4, i2 - 3),
      t
    )
  ), o2 = Re2(o2, [
    ["exit", f2, t],
    e2[i2 - 2],
    e2[i2 - 1],
    ["exit", c3, t]
  ]), o2 = Re2(o2, e2.slice(i2 + 1)), o2 = Re2(o2, [["exit", l, t]]), Ne3(e2, u2, e2.length, o2), e2;
}
function Mc(e2, t, n2) {
  const r = this;
  let a3 = r.events.length, u2, i2;
  for (; a3--; )
    if ((r.events[a3][1].type === "labelImage" || r.events[a3][1].type === "labelLink") && !r.events[a3][1]._balanced) {
      u2 = r.events[a3][1];
      break;
    }
  return o2;
  function o2(b2) {
    return u2 ? u2._inactive ? d2(b2) : (i2 = r.parser.defined.includes(
      De3(
        r.sliceSerialize({
          start: u2.end,
          end: r.now()
        })
      )
    ), e2.enter("labelEnd"), e2.enter("labelMarker"), e2.consume(b2), e2.exit("labelMarker"), e2.exit("labelEnd"), l) : n2(b2);
  }
  function l(b2) {
    return b2 === 40 ? e2.attempt(
      Lc,
      f2,
      i2 ? f2 : d2
    )(b2) : b2 === 91 ? e2.attempt(
      Oc,
      f2,
      i2 ? c3 : d2
    )(b2) : i2 ? f2(b2) : d2(b2);
  }
  function c3(b2) {
    return e2.attempt(
      wc,
      f2,
      d2
    )(b2);
  }
  function f2(b2) {
    return t(b2);
  }
  function d2(b2) {
    return u2._balanced = true, n2(b2);
  }
}
function Fc(e2, t, n2) {
  return r;
  function r(d2) {
    return e2.enter("resource"), e2.enter("resourceMarker"), e2.consume(d2), e2.exit("resourceMarker"), a3;
  }
  function a3(d2) {
    return ie4(d2) ? Ht(e2, u2)(d2) : u2(d2);
  }
  function u2(d2) {
    return d2 === 41 ? f2(d2) : Zi(
      e2,
      i2,
      o2,
      "resourceDestination",
      "resourceDestinationLiteral",
      "resourceDestinationLiteralMarker",
      "resourceDestinationRaw",
      "resourceDestinationString",
      32
    )(d2);
  }
  function i2(d2) {
    return ie4(d2) ? Ht(e2, l)(d2) : f2(d2);
  }
  function o2(d2) {
    return n2(d2);
  }
  function l(d2) {
    return d2 === 34 || d2 === 39 || d2 === 40 ? eu(
      e2,
      c3,
      n2,
      "resourceTitle",
      "resourceTitleMarker",
      "resourceTitleString"
    )(d2) : f2(d2);
  }
  function c3(d2) {
    return ie4(d2) ? Ht(e2, f2)(d2) : f2(d2);
  }
  function f2(d2) {
    return d2 === 41 ? (e2.enter("resourceMarker"), e2.consume(d2), e2.exit("resourceMarker"), e2.exit("resource"), t) : n2(d2);
  }
}
function Bc(e2, t, n2) {
  const r = this;
  return a3;
  function a3(o2) {
    return Ji.call(
      r,
      e2,
      u2,
      i2,
      "reference",
      "referenceMarker",
      "referenceString"
    )(o2);
  }
  function u2(o2) {
    return r.parser.defined.includes(
      De3(
        r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)
      )
    ) ? t(o2) : n2(o2);
  }
  function i2(o2) {
    return n2(o2);
  }
}
function vc(e2, t, n2) {
  return r;
  function r(u2) {
    return e2.enter("reference"), e2.enter("referenceMarker"), e2.consume(u2), e2.exit("referenceMarker"), a3;
  }
  function a3(u2) {
    return u2 === 93 ? (e2.enter("referenceMarker"), e2.consume(u2), e2.exit("referenceMarker"), e2.exit("reference"), t) : n2(u2);
  }
}
var Hc = {
  name: "labelStartImage",
  tokenize: Uc,
  resolveAll: Nr2.resolveAll
};
function Uc(e2, t, n2) {
  const r = this;
  return a3;
  function a3(o2) {
    return e2.enter("labelImage"), e2.enter("labelImageMarker"), e2.consume(o2), e2.exit("labelImageMarker"), u2;
  }
  function u2(o2) {
    return o2 === 91 ? (e2.enter("labelMarker"), e2.consume(o2), e2.exit("labelMarker"), e2.exit("labelImage"), i2) : n2(o2);
  }
  function i2(o2) {
    return o2 === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n2(o2) : t(o2);
  }
}
var zc = {
  name: "labelStartLink",
  tokenize: Yc,
  resolveAll: Nr2.resolveAll
};
function Yc(e2, t, n2) {
  const r = this;
  return a3;
  function a3(i2) {
    return e2.enter("labelLink"), e2.enter("labelMarker"), e2.consume(i2), e2.exit("labelMarker"), e2.exit("labelLink"), u2;
  }
  function u2(i2) {
    return i2 === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n2(i2) : t(i2);
  }
}
var Un = {
  name: "lineEnding",
  tokenize: jc
};
function jc(e2, t) {
  return n2;
  function n2(r) {
    return e2.enter("lineEnding"), e2.consume(r), e2.exit("lineEnding"), J2(e2, t, "linePrefix");
  }
}
var ln = {
  name: "thematicBreak",
  tokenize: Gc
};
function Gc(e2, t, n2) {
  let r = 0, a3;
  return u2;
  function u2(c3) {
    return e2.enter("thematicBreak"), i2(c3);
  }
  function i2(c3) {
    return a3 = c3, o2(c3);
  }
  function o2(c3) {
    return c3 === a3 ? (e2.enter("thematicBreakSequence"), l(c3)) : r >= 3 && (c3 === null || z2(c3)) ? (e2.exit("thematicBreak"), t(c3)) : n2(c3);
  }
  function l(c3) {
    return c3 === a3 ? (e2.consume(c3), r++, l) : (e2.exit("thematicBreakSequence"), K2(c3) ? J2(e2, o2, "whitespace")(c3) : o2(c3));
  }
}
var Ce2 = {
  name: "list",
  tokenize: Wc,
  continuation: {
    tokenize: Vc
  },
  exit: Xc
};
var qc = {
  tokenize: Kc,
  partial: true
};
var $c = {
  tokenize: Qc,
  partial: true
};
function Wc(e2, t, n2) {
  const r = this, a3 = r.events[r.events.length - 1];
  let u2 = a3 && a3[1].type === "linePrefix" ? a3[2].sliceSerialize(a3[1], true).length : 0, i2 = 0;
  return o2;
  function o2(m) {
    const h = r.containerState.type || (m === 42 || m === 43 || m === 45 ? "listUnordered" : "listOrdered");
    if (h === "listUnordered" ? !r.containerState.marker || m === r.containerState.marker : ir2(m)) {
      if (r.containerState.type || (r.containerState.type = h, e2.enter(h, {
        _container: true
      })), h === "listUnordered")
        return e2.enter("listItemPrefix"), m === 42 || m === 45 ? e2.check(ln, n2, c3)(m) : c3(m);
      if (!r.interrupt || m === 49)
        return e2.enter("listItemPrefix"), e2.enter("listItemValue"), l(m);
    }
    return n2(m);
  }
  function l(m) {
    return ir2(m) && ++i2 < 10 ? (e2.consume(m), l) : (!r.interrupt || i2 < 2) && (r.containerState.marker ? m === r.containerState.marker : m === 41 || m === 46) ? (e2.exit("listItemValue"), c3(m)) : n2(m);
  }
  function c3(m) {
    return e2.enter("listItemMarker"), e2.consume(m), e2.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || m, e2.check(
      Kt,
      // Can’t be empty when interrupting.
      r.interrupt ? n2 : f2,
      e2.attempt(
        qc,
        b2,
        d2
      )
    );
  }
  function f2(m) {
    return r.containerState.initialBlankLine = true, u2++, b2(m);
  }
  function d2(m) {
    return K2(m) ? (e2.enter("listItemPrefixWhitespace"), e2.consume(m), e2.exit("listItemPrefixWhitespace"), b2) : n2(m);
  }
  function b2(m) {
    return r.containerState.size = u2 + r.sliceSerialize(e2.exit("listItemPrefix"), true).length, t(m);
  }
}
function Vc(e2, t, n2) {
  const r = this;
  return r.containerState._closeFlow = void 0, e2.check(Kt, a3, u2);
  function a3(o2) {
    return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, J2(
      e2,
      t,
      "listItemIndent",
      r.containerState.size + 1
    )(o2);
  }
  function u2(o2) {
    return r.containerState.furtherBlankLines || !K2(o2) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, i2(o2)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e2.attempt($c, t, i2)(o2));
  }
  function i2(o2) {
    return r.containerState._closeFlow = true, r.interrupt = void 0, J2(
      e2,
      e2.attempt(Ce2, t, n2),
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(o2);
  }
}
function Qc(e2, t, n2) {
  const r = this;
  return J2(
    e2,
    a3,
    "listItemIndent",
    r.containerState.size + 1
  );
  function a3(u2) {
    const i2 = r.events[r.events.length - 1];
    return i2 && i2[1].type === "listItemIndent" && i2[2].sliceSerialize(i2[1], true).length === r.containerState.size ? t(u2) : n2(u2);
  }
}
function Xc(e2) {
  e2.exit(this.containerState.type);
}
function Kc(e2, t, n2) {
  const r = this;
  return J2(
    e2,
    a3,
    "listItemPrefixWhitespace",
    r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5
  );
  function a3(u2) {
    const i2 = r.events[r.events.length - 1];
    return !K2(u2) && i2 && i2[1].type === "listItemPrefixWhitespace" ? t(u2) : n2(u2);
  }
}
var _a = {
  name: "setextUnderline",
  tokenize: Jc,
  resolveTo: Zc
};
function Zc(e2, t) {
  let n2 = e2.length, r, a3, u2;
  for (; n2--; )
    if (e2[n2][0] === "enter") {
      if (e2[n2][1].type === "content") {
        r = n2;
        break;
      }
      e2[n2][1].type === "paragraph" && (a3 = n2);
    } else
      e2[n2][1].type === "content" && e2.splice(n2, 1), !u2 && e2[n2][1].type === "definition" && (u2 = n2);
  const i2 = {
    type: "setextHeading",
    start: Object.assign({}, e2[a3][1].start),
    end: Object.assign({}, e2[e2.length - 1][1].end)
  };
  return e2[a3][1].type = "setextHeadingText", u2 ? (e2.splice(a3, 0, ["enter", i2, t]), e2.splice(u2 + 1, 0, ["exit", e2[r][1], t]), e2[r][1].end = Object.assign({}, e2[u2][1].end)) : e2[r][1] = i2, e2.push(["exit", i2, t]), e2;
}
function Jc(e2, t, n2) {
  const r = this;
  let a3;
  return u2;
  function u2(c3) {
    let f2 = r.events.length, d2;
    for (; f2--; )
      if (r.events[f2][1].type !== "lineEnding" && r.events[f2][1].type !== "linePrefix" && r.events[f2][1].type !== "content") {
        d2 = r.events[f2][1].type === "paragraph";
        break;
      }
    return !r.parser.lazy[r.now().line] && (r.interrupt || d2) ? (e2.enter("setextHeadingLine"), a3 = c3, i2(c3)) : n2(c3);
  }
  function i2(c3) {
    return e2.enter("setextHeadingLineSequence"), o2(c3);
  }
  function o2(c3) {
    return c3 === a3 ? (e2.consume(c3), o2) : (e2.exit("setextHeadingLineSequence"), K2(c3) ? J2(e2, l, "lineSuffix")(c3) : l(c3));
  }
  function l(c3) {
    return c3 === null || z2(c3) ? (e2.exit("setextHeadingLine"), t(c3)) : n2(c3);
  }
}
var ed = {
  tokenize: td
};
function td(e2) {
  const t = this, n2 = e2.attempt(
    // Try to parse a blank line.
    Kt,
    r,
    // Try to parse initial flow (essentially, only code).
    e2.attempt(
      this.parser.constructs.flowInitial,
      a3,
      J2(
        e2,
        e2.attempt(
          this.parser.constructs.flow,
          a3,
          e2.attempt(uc, a3)
        ),
        "linePrefix"
      )
    )
  );
  return n2;
  function r(u2) {
    if (u2 === null) {
      e2.consume(u2);
      return;
    }
    return e2.enter("lineEndingBlank"), e2.consume(u2), e2.exit("lineEndingBlank"), t.currentConstruct = void 0, n2;
  }
  function a3(u2) {
    if (u2 === null) {
      e2.consume(u2);
      return;
    }
    return e2.enter("lineEnding"), e2.consume(u2), e2.exit("lineEnding"), t.currentConstruct = void 0, n2;
  }
}
var nd = {
  resolveAll: nu()
};
var rd = tu("string");
var ad = tu("text");
function tu(e2) {
  return {
    tokenize: t,
    resolveAll: nu(
      e2 === "text" ? id : void 0
    )
  };
  function t(n2) {
    const r = this, a3 = this.parser.constructs[e2], u2 = n2.attempt(a3, i2, o2);
    return i2;
    function i2(f2) {
      return c3(f2) ? u2(f2) : o2(f2);
    }
    function o2(f2) {
      if (f2 === null) {
        n2.consume(f2);
        return;
      }
      return n2.enter("data"), n2.consume(f2), l;
    }
    function l(f2) {
      return c3(f2) ? (n2.exit("data"), u2(f2)) : (n2.consume(f2), l);
    }
    function c3(f2) {
      if (f2 === null)
        return true;
      const d2 = a3[f2];
      let b2 = -1;
      if (d2)
        for (; ++b2 < d2.length; ) {
          const m = d2[b2];
          if (!m.previous || m.previous.call(r, r.previous))
            return true;
        }
      return false;
    }
  }
}
function nu(e2) {
  return t;
  function t(n2, r) {
    let a3 = -1, u2;
    for (; ++a3 <= n2.length; )
      u2 === void 0 ? n2[a3] && n2[a3][1].type === "data" && (u2 = a3, a3++) : (!n2[a3] || n2[a3][1].type !== "data") && (a3 !== u2 + 2 && (n2[u2][1].end = n2[a3 - 1][1].end, n2.splice(u2 + 2, a3 - u2 - 2), a3 = u2 + 2), u2 = void 0);
    return e2 ? e2(n2, r) : n2;
  }
}
function id(e2, t) {
  let n2 = 0;
  for (; ++n2 <= e2.length; )
    if ((n2 === e2.length || e2[n2][1].type === "lineEnding") && e2[n2 - 1][1].type === "data") {
      const r = e2[n2 - 1][1], a3 = t.sliceStream(r);
      let u2 = a3.length, i2 = -1, o2 = 0, l;
      for (; u2--; ) {
        const c3 = a3[u2];
        if (typeof c3 == "string") {
          for (i2 = c3.length; c3.charCodeAt(i2 - 1) === 32; )
            o2++, i2--;
          if (i2) break;
          i2 = -1;
        } else if (c3 === -2)
          l = true, o2++;
        else if (c3 !== -1) {
          u2++;
          break;
        }
      }
      if (o2) {
        const c3 = {
          type: n2 === e2.length || l || o2 < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: r.end.line,
            column: r.end.column - o2,
            offset: r.end.offset - o2,
            _index: r.start._index + u2,
            _bufferIndex: u2 ? i2 : r.start._bufferIndex + i2
          },
          end: Object.assign({}, r.end)
        };
        r.end = Object.assign({}, c3.start), r.start.offset === r.end.offset ? Object.assign(r, c3) : (e2.splice(
          n2,
          0,
          ["enter", c3, t],
          ["exit", c3, t]
        ), n2 += 2);
      }
      n2++;
    }
  return e2;
}
function ud(e2, t, n2) {
  let r = Object.assign(
    n2 ? Object.assign({}, n2) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const a3 = {}, u2 = [];
  let i2 = [], o2 = [];
  const l = {
    consume: x2,
    enter: I3,
    exit: M3,
    attempt: U2(B4),
    check: U2(R),
    interrupt: U2(R, {
      interrupt: true
    })
  }, c3 = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: e2,
    sliceStream: m,
    sliceSerialize: b2,
    now: h,
    defineSkip: E,
    write: d2
  };
  let f2 = t.tokenize.call(c3, l);
  return t.resolveAll && u2.push(t), c3;
  function d2(H3) {
    return i2 = Re2(i2, H3), y2(), i2[i2.length - 1] !== null ? [] : (q3(t, 0), c3.events = kn(u2, c3.events, c3), c3.events);
  }
  function b2(H3, F2) {
    return od(m(H3), F2);
  }
  function m(H3) {
    return sd(i2, H3);
  }
  function h() {
    const { line: H3, column: F2, offset: ee3, _index: G2, _bufferIndex: j3 } = r;
    return {
      line: H3,
      column: F2,
      offset: ee3,
      _index: G2,
      _bufferIndex: j3
    };
  }
  function E(H3) {
    a3[H3.line] = H3.column, S2();
  }
  function y2() {
    let H3;
    for (; r._index < i2.length; ) {
      const F2 = i2[r._index];
      if (typeof F2 == "string")
        for (H3 = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === H3 && r._bufferIndex < F2.length; )
          _3(F2.charCodeAt(r._bufferIndex));
      else
        _3(F2);
    }
  }
  function _3(H3) {
    f2 = f2(H3);
  }
  function x2(H3) {
    z2(H3) ? (r.line++, r.column = 1, r.offset += H3 === -3 ? 2 : 1, S2()) : H3 !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === i2[r._index].length && (r._bufferIndex = -1, r._index++)), c3.previous = H3;
  }
  function I3(H3, F2) {
    const ee3 = F2 || {};
    return ee3.type = H3, ee3.start = h(), c3.events.push(["enter", ee3, c3]), o2.push(ee3), ee3;
  }
  function M3(H3) {
    const F2 = o2.pop();
    return F2.end = h(), c3.events.push(["exit", F2, c3]), F2;
  }
  function B4(H3, F2) {
    q3(H3, F2.from);
  }
  function R(H3, F2) {
    F2.restore();
  }
  function U2(H3, F2) {
    return ee3;
    function ee3(G2, j3, te3) {
      let se4, re3, me3, A3;
      return Array.isArray(G2) ? Ae3(G2) : "tokenize" in G2 ? (
        // @ts-expect-error Looks like a construct.
        Ae3([G2])
      ) : ae3(G2);
      function ae3(ce2) {
        return Fe3;
        function Fe3(Be3) {
          const ve3 = Be3 !== null && ce2[Be3], nt2 = Be3 !== null && ce2.null, Mn = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(ve3) ? ve3 : ve3 ? [ve3] : [],
            ...Array.isArray(nt2) ? nt2 : nt2 ? [nt2] : []
          ];
          return Ae3(Mn)(Be3);
        }
      }
      function Ae3(ce2) {
        return se4 = ce2, re3 = 0, ce2.length === 0 ? te3 : C2(ce2[re3]);
      }
      function C2(ce2) {
        return Fe3;
        function Fe3(Be3) {
          return A3 = Y3(), me3 = ce2, ce2.partial || (c3.currentConstruct = ce2), ce2.name && c3.parser.constructs.disable.null.includes(ce2.name) ? Me2() : ce2.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            F2 ? Object.assign(Object.create(c3), F2) : c3,
            l,
            Te3,
            Me2
          )(Be3);
        }
      }
      function Te3(ce2) {
        return H3(me3, A3), j3;
      }
      function Me2(ce2) {
        return A3.restore(), ++re3 < se4.length ? C2(se4[re3]) : te3;
      }
    }
  }
  function q3(H3, F2) {
    H3.resolveAll && !u2.includes(H3) && u2.push(H3), H3.resolve && Ne3(
      c3.events,
      F2,
      c3.events.length - F2,
      H3.resolve(c3.events.slice(F2), c3)
    ), H3.resolveTo && (c3.events = H3.resolveTo(c3.events, c3));
  }
  function Y3() {
    const H3 = h(), F2 = c3.previous, ee3 = c3.currentConstruct, G2 = c3.events.length, j3 = Array.from(o2);
    return {
      restore: te3,
      from: G2
    };
    function te3() {
      r = H3, c3.previous = F2, c3.currentConstruct = ee3, c3.events.length = G2, o2 = j3, S2();
    }
  }
  function S2() {
    r.line in a3 && r.column < 2 && (r.column = a3[r.line], r.offset += a3[r.line] - 1);
  }
}
function sd(e2, t) {
  const n2 = t.start._index, r = t.start._bufferIndex, a3 = t.end._index, u2 = t.end._bufferIndex;
  let i2;
  if (n2 === a3)
    i2 = [e2[n2].slice(r, u2)];
  else {
    if (i2 = e2.slice(n2, a3), r > -1) {
      const o2 = i2[0];
      typeof o2 == "string" ? i2[0] = o2.slice(r) : i2.shift();
    }
    u2 > 0 && i2.push(e2[a3].slice(0, u2));
  }
  return i2;
}
function od(e2, t) {
  let n2 = -1;
  const r = [];
  let a3;
  for (; ++n2 < e2.length; ) {
    const u2 = e2[n2];
    let i2;
    if (typeof u2 == "string")
      i2 = u2;
    else
      switch (u2) {
        case -5: {
          i2 = "\r";
          break;
        }
        case -4: {
          i2 = `
`;
          break;
        }
        case -3: {
          i2 = `\r
`;
          break;
        }
        case -2: {
          i2 = t ? " " : "	";
          break;
        }
        case -1: {
          if (!t && a3) continue;
          i2 = " ";
          break;
        }
        default:
          i2 = String.fromCharCode(u2);
      }
    a3 = u2 === -2, r.push(i2);
  }
  return r.join("");
}
var ld = {
  42: Ce2,
  43: Ce2,
  45: Ce2,
  48: Ce2,
  49: Ce2,
  50: Ce2,
  51: Ce2,
  52: Ce2,
  53: Ce2,
  54: Ce2,
  55: Ce2,
  56: Ce2,
  57: Ce2,
  62: Vi
};
var cd = {
  91: dc
};
var dd = {
  [-2]: Hn,
  [-1]: Hn,
  32: Hn
};
var fd = {
  35: bc,
  42: ln,
  45: [_a, ln],
  60: Ac,
  61: _a,
  95: ln,
  96: ya2,
  126: ya2
};
var hd = {
  38: Xi,
  92: Qi
};
var pd = {
  [-5]: Un,
  [-4]: Un,
  [-3]: Un,
  33: Hc,
  38: Xi,
  42: ur2,
  60: [Yl, Nc],
  91: zc,
  92: [mc, Qi],
  93: Nr2,
  95: ur2,
  96: tc
};
var md = {
  null: [ur2, nd]
};
var gd = {
  null: [42, 95]
};
var bd = {
  null: []
};
var Ed = Object.freeze(Object.defineProperty({
  __proto__: null,
  attentionMarkers: gd,
  contentInitial: cd,
  disable: bd,
  document: ld,
  flow: fd,
  flowInitial: dd,
  insideSpan: md,
  string: hd,
  text: pd
}, Symbol.toStringTag, { value: "Module" }));
function Td(e2) {
  const n2 = (
    /** @type {FullNormalizedExtension} */
    $i([Ed, ...(e2 || {}).extensions || []])
  ), r = {
    defined: [],
    lazy: {},
    constructs: n2,
    content: a3(Ml),
    document: a3(Bl),
    flow: a3(ed),
    string: a3(rd),
    text: a3(ad)
  };
  return r;
  function a3(u2) {
    return i2;
    function i2(o2) {
      return ud(r, u2, o2);
    }
  }
}
function yd(e2) {
  for (; !Ki(e2); )
    ;
  return e2;
}
var Ca = /[\0\t\n\r]/g;
function Ad() {
  let e2 = 1, t = "", n2 = true, r;
  return a3;
  function a3(u2, i2, o2) {
    const l = [];
    let c3, f2, d2, b2, m;
    for (u2 = t + (typeof u2 == "string" ? u2.toString() : new TextDecoder(i2 || void 0).decode(u2)), d2 = 0, t = "", n2 && (u2.charCodeAt(0) === 65279 && d2++, n2 = void 0); d2 < u2.length; ) {
      if (Ca.lastIndex = d2, c3 = Ca.exec(u2), b2 = c3 && c3.index !== void 0 ? c3.index : u2.length, m = u2.charCodeAt(b2), !c3) {
        t = u2.slice(d2);
        break;
      }
      if (m === 10 && d2 === b2 && r)
        l.push(-3), r = void 0;
      else
        switch (r && (l.push(-5), r = void 0), d2 < b2 && (l.push(u2.slice(d2, b2)), e2 += b2 - d2), m) {
          case 0: {
            l.push(65533), e2++;
            break;
          }
          case 9: {
            for (f2 = Math.ceil(e2 / 4) * 4, l.push(-2); e2++ < f2; ) l.push(-1);
            break;
          }
          case 10: {
            l.push(-4), e2 = 1;
            break;
          }
          default:
            r = true, e2 = 1;
        }
      d2 = b2 + 1;
    }
    return o2 && (r && l.push(-5), t && l.push(t), l.push(null)), l;
  }
}
var _d = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function Cd(e2) {
  return e2.replace(_d, xd);
}
function xd(e2, t, n2) {
  if (t)
    return t;
  if (n2.charCodeAt(0) === 35) {
    const a3 = n2.charCodeAt(1), u2 = a3 === 120 || a3 === 88;
    return Wi(n2.slice(u2 ? 2 : 1), u2 ? 16 : 10);
  }
  return Sr2(n2) || e2;
}
var ru = {}.hasOwnProperty;
function kd(e2, t, n2) {
  return typeof t != "string" && (n2 = t, t = void 0), Id(n2)(
    yd(
      Td(n2).document().write(Ad()(e2, t, true))
    )
  );
}
function Id(e2) {
  const t = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: u2(Wr2),
      autolinkProtocol: Y3,
      autolinkEmail: Y3,
      atxHeading: u2(Gr),
      blockQuote: u2(ve3),
      characterEscape: Y3,
      characterReference: Y3,
      codeFenced: u2(nt2),
      codeFencedFenceInfo: i2,
      codeFencedFenceMeta: i2,
      codeIndented: u2(nt2, i2),
      codeText: u2(Mn, i2),
      codeTextData: Y3,
      data: Y3,
      codeFlowValue: Y3,
      definition: u2(Ss),
      definitionDestinationString: i2,
      definitionLabelString: i2,
      definitionTitleString: i2,
      emphasis: u2(Ns),
      hardBreakEscape: u2(qr),
      hardBreakTrailing: u2(qr),
      htmlFlow: u2($r, i2),
      htmlFlowData: Y3,
      htmlText: u2($r, i2),
      htmlTextData: Y3,
      image: u2(Rs),
      label: i2,
      link: u2(Wr2),
      listItem: u2(Ls),
      listItemValue: b2,
      listOrdered: u2(Vr2, d2),
      listUnordered: u2(Vr2),
      paragraph: u2(Os),
      reference: C2,
      referenceString: i2,
      resourceDestinationString: i2,
      resourceTitleString: i2,
      setextHeading: u2(Gr),
      strong: u2(ws),
      thematicBreak: u2(Ps)
    },
    exit: {
      atxHeading: l(),
      atxHeadingSequence: B4,
      autolink: l(),
      autolinkEmail: Be3,
      autolinkProtocol: Fe3,
      blockQuote: l(),
      characterEscapeValue: S2,
      characterReferenceMarkerHexadecimal: Me2,
      characterReferenceMarkerNumeric: Me2,
      characterReferenceValue: ce2,
      codeFenced: l(y2),
      codeFencedFence: E,
      codeFencedFenceInfo: m,
      codeFencedFenceMeta: h,
      codeFlowValue: S2,
      codeIndented: l(_3),
      codeText: l(j3),
      codeTextData: S2,
      data: S2,
      definition: l(),
      definitionDestinationString: M3,
      definitionLabelString: x2,
      definitionTitleString: I3,
      emphasis: l(),
      hardBreakEscape: l(F2),
      hardBreakTrailing: l(F2),
      htmlFlow: l(ee3),
      htmlFlowData: S2,
      htmlText: l(G2),
      htmlTextData: S2,
      image: l(se4),
      label: me3,
      labelText: re3,
      lineEnding: H3,
      link: l(te3),
      listItem: l(),
      listOrdered: l(),
      listUnordered: l(),
      paragraph: l(),
      referenceString: Te3,
      resourceDestinationString: A3,
      resourceTitleString: ae3,
      resource: Ae3,
      setextHeading: l(q3),
      setextHeadingLineSequence: U2,
      setextHeadingText: R,
      strong: l(),
      thematicBreak: l()
    }
  };
  au(t, (e2 || {}).mdastExtensions || []);
  const n2 = {};
  return r;
  function r(O3) {
    let v = {
      type: "root",
      children: []
    };
    const $3 = {
      stack: [v],
      tokenStack: [],
      config: t,
      enter: o2,
      exit: c3,
      buffer: i2,
      resume: f2,
      data: n2
    }, Z3 = [];
    let ne2 = -1;
    for (; ++ne2 < O3.length; )
      if (O3[ne2][1].type === "listOrdered" || O3[ne2][1].type === "listUnordered")
        if (O3[ne2][0] === "enter")
          Z3.push(ne2);
        else {
          const Oe4 = Z3.pop();
          ne2 = a3(O3, Oe4, ne2);
        }
    for (ne2 = -1; ++ne2 < O3.length; ) {
      const Oe4 = t[O3[ne2][0]];
      ru.call(Oe4, O3[ne2][1].type) && Oe4[O3[ne2][1].type].call(
        Object.assign(
          {
            sliceSerialize: O3[ne2][2].sliceSerialize
          },
          $3
        ),
        O3[ne2][1]
      );
    }
    if ($3.tokenStack.length > 0) {
      const Oe4 = $3.tokenStack[$3.tokenStack.length - 1];
      (Oe4[1] || xa).call($3, void 0, Oe4[0]);
    }
    for (v.position = {
      start: Xe2(
        O3.length > 0 ? O3[0][1].start : {
          line: 1,
          column: 1,
          offset: 0
        }
      ),
      end: Xe2(
        O3.length > 0 ? O3[O3.length - 2][1].end : {
          line: 1,
          column: 1,
          offset: 0
        }
      )
    }, ne2 = -1; ++ne2 < t.transforms.length; )
      v = t.transforms[ne2](v) || v;
    return v;
  }
  function a3(O3, v, $3) {
    let Z3 = v - 1, ne2 = -1, Oe4 = false, rt2, Ge2, Lt3, Ot3;
    for (; ++Z3 <= $3; ) {
      const xe3 = O3[Z3];
      switch (xe3[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          xe3[0] === "enter" ? ne2++ : ne2--, Ot3 = void 0;
          break;
        }
        case "lineEndingBlank": {
          xe3[0] === "enter" && (rt2 && !Ot3 && !ne2 && !Lt3 && (Lt3 = Z3), Ot3 = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Ot3 = void 0;
      }
      if (!ne2 && xe3[0] === "enter" && xe3[1].type === "listItemPrefix" || ne2 === -1 && xe3[0] === "exit" && (xe3[1].type === "listUnordered" || xe3[1].type === "listOrdered")) {
        if (rt2) {
          let ft3 = Z3;
          for (Ge2 = void 0; ft3--; ) {
            const qe2 = O3[ft3];
            if (qe2[1].type === "lineEnding" || qe2[1].type === "lineEndingBlank") {
              if (qe2[0] === "exit") continue;
              Ge2 && (O3[Ge2][1].type = "lineEndingBlank", Oe4 = true), qe2[1].type = "lineEnding", Ge2 = ft3;
            } else if (!(qe2[1].type === "linePrefix" || qe2[1].type === "blockQuotePrefix" || qe2[1].type === "blockQuotePrefixWhitespace" || qe2[1].type === "blockQuoteMarker" || qe2[1].type === "listItemIndent")) break;
          }
          Lt3 && (!Ge2 || Lt3 < Ge2) && (rt2._spread = true), rt2.end = Object.assign(
            {},
            Ge2 ? O3[Ge2][1].start : xe3[1].end
          ), O3.splice(Ge2 || Z3, 0, ["exit", rt2, xe3[2]]), Z3++, $3++;
        }
        if (xe3[1].type === "listItemPrefix") {
          const ft3 = {
            type: "listItem",
            _spread: false,
            start: Object.assign({}, xe3[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          rt2 = ft3, O3.splice(Z3, 0, ["enter", ft3, xe3[2]]), Z3++, $3++, Lt3 = void 0, Ot3 = true;
        }
      }
    }
    return O3[v][1]._spread = Oe4, $3;
  }
  function u2(O3, v) {
    return $3;
    function $3(Z3) {
      o2.call(this, O3(Z3), Z3), v && v.call(this, Z3);
    }
  }
  function i2() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function o2(O3, v, $3) {
    this.stack[this.stack.length - 1].children.push(O3), this.stack.push(O3), this.tokenStack.push([v, $3]), O3.position = {
      start: Xe2(v.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function l(O3) {
    return v;
    function v($3) {
      O3 && O3.call(this, $3), c3.call(this, $3);
    }
  }
  function c3(O3, v) {
    const $3 = this.stack.pop(), Z3 = this.tokenStack.pop();
    if (Z3)
      Z3[0].type !== O3.type && (v ? v.call(this, O3, Z3[0]) : (Z3[1] || xa).call(this, O3, Z3[0]));
    else throw new Error(
      "Cannot close `" + O3.type + "` (" + vt3({
        start: O3.start,
        end: O3.end
      }) + "): it’s not open"
    );
    $3.position.end = Xe2(O3.end);
  }
  function f2() {
    return Ir2(this.stack.pop());
  }
  function d2() {
    this.data.expectingFirstListItemValue = true;
  }
  function b2(O3) {
    if (this.data.expectingFirstListItemValue) {
      const v = this.stack[this.stack.length - 2];
      v.start = Number.parseInt(this.sliceSerialize(O3), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function m() {
    const O3 = this.resume(), v = this.stack[this.stack.length - 1];
    v.lang = O3;
  }
  function h() {
    const O3 = this.resume(), v = this.stack[this.stack.length - 1];
    v.meta = O3;
  }
  function E() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = true);
  }
  function y2() {
    const O3 = this.resume(), v = this.stack[this.stack.length - 1];
    v.value = O3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function _3() {
    const O3 = this.resume(), v = this.stack[this.stack.length - 1];
    v.value = O3.replace(/(\r?\n|\r)$/g, "");
  }
  function x2(O3) {
    const v = this.resume(), $3 = this.stack[this.stack.length - 1];
    $3.label = v, $3.identifier = De3(
      this.sliceSerialize(O3)
    ).toLowerCase();
  }
  function I3() {
    const O3 = this.resume(), v = this.stack[this.stack.length - 1];
    v.title = O3;
  }
  function M3() {
    const O3 = this.resume(), v = this.stack[this.stack.length - 1];
    v.url = O3;
  }
  function B4(O3) {
    const v = this.stack[this.stack.length - 1];
    if (!v.depth) {
      const $3 = this.sliceSerialize(O3).length;
      v.depth = $3;
    }
  }
  function R() {
    this.data.setextHeadingSlurpLineEnding = true;
  }
  function U2(O3) {
    const v = this.stack[this.stack.length - 1];
    v.depth = this.sliceSerialize(O3).codePointAt(0) === 61 ? 1 : 2;
  }
  function q3() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function Y3(O3) {
    const $3 = this.stack[this.stack.length - 1].children;
    let Z3 = $3[$3.length - 1];
    (!Z3 || Z3.type !== "text") && (Z3 = Ds(), Z3.position = {
      start: Xe2(O3.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, $3.push(Z3)), this.stack.push(Z3);
  }
  function S2(O3) {
    const v = this.stack.pop();
    v.value += this.sliceSerialize(O3), v.position.end = Xe2(O3.end);
  }
  function H3(O3) {
    const v = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const $3 = v.children[v.children.length - 1];
      $3.position.end = Xe2(O3.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(v.type) && (Y3.call(this, O3), S2.call(this, O3));
  }
  function F2() {
    this.data.atHardBreak = true;
  }
  function ee3() {
    const O3 = this.resume(), v = this.stack[this.stack.length - 1];
    v.value = O3;
  }
  function G2() {
    const O3 = this.resume(), v = this.stack[this.stack.length - 1];
    v.value = O3;
  }
  function j3() {
    const O3 = this.resume(), v = this.stack[this.stack.length - 1];
    v.value = O3;
  }
  function te3() {
    const O3 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const v = this.data.referenceType || "shortcut";
      O3.type += "Reference", O3.referenceType = v, delete O3.url, delete O3.title;
    } else
      delete O3.identifier, delete O3.label;
    this.data.referenceType = void 0;
  }
  function se4() {
    const O3 = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const v = this.data.referenceType || "shortcut";
      O3.type += "Reference", O3.referenceType = v, delete O3.url, delete O3.title;
    } else
      delete O3.identifier, delete O3.label;
    this.data.referenceType = void 0;
  }
  function re3(O3) {
    const v = this.sliceSerialize(O3), $3 = this.stack[this.stack.length - 2];
    $3.label = Cd(v), $3.identifier = De3(v).toLowerCase();
  }
  function me3() {
    const O3 = this.stack[this.stack.length - 1], v = this.resume(), $3 = this.stack[this.stack.length - 1];
    if (this.data.inReference = true, $3.type === "link") {
      const Z3 = O3.children;
      $3.children = Z3;
    } else
      $3.alt = v;
  }
  function A3() {
    const O3 = this.resume(), v = this.stack[this.stack.length - 1];
    v.url = O3;
  }
  function ae3() {
    const O3 = this.resume(), v = this.stack[this.stack.length - 1];
    v.title = O3;
  }
  function Ae3() {
    this.data.inReference = void 0;
  }
  function C2() {
    this.data.referenceType = "collapsed";
  }
  function Te3(O3) {
    const v = this.resume(), $3 = this.stack[this.stack.length - 1];
    $3.label = v, $3.identifier = De3(
      this.sliceSerialize(O3)
    ).toLowerCase(), this.data.referenceType = "full";
  }
  function Me2(O3) {
    this.data.characterReferenceType = O3.type;
  }
  function ce2(O3) {
    const v = this.sliceSerialize(O3), $3 = this.data.characterReferenceType;
    let Z3;
    $3 ? (Z3 = Wi(
      v,
      $3 === "characterReferenceMarkerNumeric" ? 10 : 16
    ), this.data.characterReferenceType = void 0) : Z3 = Sr2(v);
    const ne2 = this.stack.pop();
    ne2.value += Z3, ne2.position.end = Xe2(O3.end);
  }
  function Fe3(O3) {
    S2.call(this, O3);
    const v = this.stack[this.stack.length - 1];
    v.url = this.sliceSerialize(O3);
  }
  function Be3(O3) {
    S2.call(this, O3);
    const v = this.stack[this.stack.length - 1];
    v.url = "mailto:" + this.sliceSerialize(O3);
  }
  function ve3() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function nt2() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function Mn() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function Ss() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function Ns() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Gr() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function qr() {
    return {
      type: "break"
    };
  }
  function $r() {
    return {
      type: "html",
      value: ""
    };
  }
  function Rs() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Wr2() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Vr2(O3) {
    return {
      type: "list",
      ordered: O3.type === "listOrdered",
      start: null,
      spread: O3._spread,
      children: []
    };
  }
  function Ls(O3) {
    return {
      type: "listItem",
      spread: O3._spread,
      checked: null,
      children: []
    };
  }
  function Os() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function ws() {
    return {
      type: "strong",
      children: []
    };
  }
  function Ds() {
    return {
      type: "text",
      value: ""
    };
  }
  function Ps() {
    return {
      type: "thematicBreak"
    };
  }
}
function Xe2(e2) {
  return {
    line: e2.line,
    column: e2.column,
    offset: e2.offset
  };
}
function au(e2, t) {
  let n2 = -1;
  for (; ++n2 < t.length; ) {
    const r = t[n2];
    Array.isArray(r) ? au(e2, r) : Sd(e2, r);
  }
}
function Sd(e2, t) {
  let n2;
  for (n2 in t)
    if (ru.call(t, n2))
      switch (n2) {
        case "canContainEols": {
          const r = t[n2];
          r && e2[n2].push(...r);
          break;
        }
        case "transforms": {
          const r = t[n2];
          r && e2[n2].push(...r);
          break;
        }
        case "enter":
        case "exit": {
          const r = t[n2];
          r && Object.assign(e2[n2], r);
          break;
        }
      }
}
function xa(e2, t) {
  throw e2 ? new Error(
    "Cannot close `" + e2.type + "` (" + vt3({
      start: e2.start,
      end: e2.end
    }) + "): a different token (`" + t.type + "`, " + vt3({
      start: t.start,
      end: t.end
    }) + ") is open"
  ) : new Error(
    "Cannot close document, a token (`" + t.type + "`, " + vt3({
      start: t.start,
      end: t.end
    }) + ") is still open"
  );
}
function Nd(e2) {
  const t = this;
  t.parser = n2;
  function n2(r) {
    return kd(r, {
      ...t.data("settings"),
      ...e2,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: t.data("micromarkExtensions") || [],
      mdastExtensions: t.data("fromMarkdownExtensions") || []
    });
  }
}
function Rd(e2, t) {
  const n2 = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: e2.wrap(e2.all(t), true)
  };
  return e2.patch(t, n2), e2.applyData(t, n2);
}
function Ld(e2, t) {
  const n2 = { type: "element", tagName: "br", properties: {}, children: [] };
  return e2.patch(t, n2), [e2.applyData(t, n2), { type: "text", value: `
` }];
}
function Od(e2, t) {
  const n2 = t.value ? t.value + `
` : "", r = {};
  t.lang && (r.className = ["language-" + t.lang]);
  let a3 = {
    type: "element",
    tagName: "code",
    properties: r,
    children: [{ type: "text", value: n2 }]
  };
  return t.meta && (a3.data = { meta: t.meta }), e2.patch(t, a3), a3 = e2.applyData(t, a3), a3 = { type: "element", tagName: "pre", properties: {}, children: [a3] }, e2.patch(t, a3), a3;
}
function wd(e2, t) {
  const n2 = {
    type: "element",
    tagName: "del",
    properties: {},
    children: e2.all(t)
  };
  return e2.patch(t, n2), e2.applyData(t, n2);
}
function Dd(e2, t) {
  const n2 = {
    type: "element",
    tagName: "em",
    properties: {},
    children: e2.all(t)
  };
  return e2.patch(t, n2), e2.applyData(t, n2);
}
function Pd(e2, t) {
  const n2 = typeof e2.options.clobberPrefix == "string" ? e2.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), a3 = It2(r.toLowerCase()), u2 = e2.footnoteOrder.indexOf(r);
  let i2, o2 = e2.footnoteCounts.get(r);
  o2 === void 0 ? (o2 = 0, e2.footnoteOrder.push(r), i2 = e2.footnoteOrder.length) : i2 = u2 + 1, o2 += 1, e2.footnoteCounts.set(r, o2);
  const l = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + n2 + "fn-" + a3,
      id: n2 + "fnref-" + a3 + (o2 > 1 ? "-" + o2 : ""),
      dataFootnoteRef: true,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(i2) }]
  };
  e2.patch(t, l);
  const c3 = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [l]
  };
  return e2.patch(t, c3), e2.applyData(t, c3);
}
function Md(e2, t) {
  const n2 = {
    type: "element",
    tagName: "h" + t.depth,
    properties: {},
    children: e2.all(t)
  };
  return e2.patch(t, n2), e2.applyData(t, n2);
}
function Fd(e2, t) {
  if (e2.options.allowDangerousHtml) {
    const n2 = { type: "raw", value: t.value };
    return e2.patch(t, n2), e2.applyData(t, n2);
  }
}
function iu(e2, t) {
  const n2 = t.referenceType;
  let r = "]";
  if (n2 === "collapsed" ? r += "[]" : n2 === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference")
    return [{ type: "text", value: "![" + t.alt + r }];
  const a3 = e2.all(t), u2 = a3[0];
  u2 && u2.type === "text" ? u2.value = "[" + u2.value : a3.unshift({ type: "text", value: "[" });
  const i2 = a3[a3.length - 1];
  return i2 && i2.type === "text" ? i2.value += r : a3.push({ type: "text", value: r }), a3;
}
function Bd(e2, t) {
  const n2 = String(t.identifier).toUpperCase(), r = e2.definitionById.get(n2);
  if (!r)
    return iu(e2, t);
  const a3 = { src: It2(r.url || ""), alt: t.alt };
  r.title !== null && r.title !== void 0 && (a3.title = r.title);
  const u2 = { type: "element", tagName: "img", properties: a3, children: [] };
  return e2.patch(t, u2), e2.applyData(t, u2);
}
function vd(e2, t) {
  const n2 = { src: It2(t.url) };
  t.alt !== null && t.alt !== void 0 && (n2.alt = t.alt), t.title !== null && t.title !== void 0 && (n2.title = t.title);
  const r = { type: "element", tagName: "img", properties: n2, children: [] };
  return e2.patch(t, r), e2.applyData(t, r);
}
function Hd(e2, t) {
  const n2 = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") };
  e2.patch(t, n2);
  const r = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [n2]
  };
  return e2.patch(t, r), e2.applyData(t, r);
}
function Ud(e2, t) {
  const n2 = String(t.identifier).toUpperCase(), r = e2.definitionById.get(n2);
  if (!r)
    return iu(e2, t);
  const a3 = { href: It2(r.url || "") };
  r.title !== null && r.title !== void 0 && (a3.title = r.title);
  const u2 = {
    type: "element",
    tagName: "a",
    properties: a3,
    children: e2.all(t)
  };
  return e2.patch(t, u2), e2.applyData(t, u2);
}
function zd(e2, t) {
  const n2 = { href: It2(t.url) };
  t.title !== null && t.title !== void 0 && (n2.title = t.title);
  const r = {
    type: "element",
    tagName: "a",
    properties: n2,
    children: e2.all(t)
  };
  return e2.patch(t, r), e2.applyData(t, r);
}
function Yd(e2, t, n2) {
  const r = e2.all(t), a3 = n2 ? jd(n2) : uu(t), u2 = {}, i2 = [];
  if (typeof t.checked == "boolean") {
    const f2 = r[0];
    let d2;
    f2 && f2.type === "element" && f2.tagName === "p" ? d2 = f2 : (d2 = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(d2)), d2.children.length > 0 && d2.children.unshift({ type: "text", value: " " }), d2.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: t.checked, disabled: true },
      children: []
    }), u2.className = ["task-list-item"];
  }
  let o2 = -1;
  for (; ++o2 < r.length; ) {
    const f2 = r[o2];
    (a3 || o2 !== 0 || f2.type !== "element" || f2.tagName !== "p") && i2.push({ type: "text", value: `
` }), f2.type === "element" && f2.tagName === "p" && !a3 ? i2.push(...f2.children) : i2.push(f2);
  }
  const l = r[r.length - 1];
  l && (a3 || l.type !== "element" || l.tagName !== "p") && i2.push({ type: "text", value: `
` });
  const c3 = { type: "element", tagName: "li", properties: u2, children: i2 };
  return e2.patch(t, c3), e2.applyData(t, c3);
}
function jd(e2) {
  let t = false;
  if (e2.type === "list") {
    t = e2.spread || false;
    const n2 = e2.children;
    let r = -1;
    for (; !t && ++r < n2.length; )
      t = uu(n2[r]);
  }
  return t;
}
function uu(e2) {
  const t = e2.spread;
  return t ?? e2.children.length > 1;
}
function Gd(e2, t) {
  const n2 = {}, r = e2.all(t);
  let a3 = -1;
  for (typeof t.start == "number" && t.start !== 1 && (n2.start = t.start); ++a3 < r.length; ) {
    const i2 = r[a3];
    if (i2.type === "element" && i2.tagName === "li" && i2.properties && Array.isArray(i2.properties.className) && i2.properties.className.includes("task-list-item")) {
      n2.className = ["contains-task-list"];
      break;
    }
  }
  const u2 = {
    type: "element",
    tagName: t.ordered ? "ol" : "ul",
    properties: n2,
    children: e2.wrap(r, true)
  };
  return e2.patch(t, u2), e2.applyData(t, u2);
}
function qd(e2, t) {
  const n2 = {
    type: "element",
    tagName: "p",
    properties: {},
    children: e2.all(t)
  };
  return e2.patch(t, n2), e2.applyData(t, n2);
}
function $d(e2, t) {
  const n2 = { type: "root", children: e2.wrap(e2.all(t)) };
  return e2.patch(t, n2), e2.applyData(t, n2);
}
function Wd(e2, t) {
  const n2 = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: e2.all(t)
  };
  return e2.patch(t, n2), e2.applyData(t, n2);
}
function Vd(e2, t) {
  const n2 = e2.all(t), r = n2.shift(), a3 = [];
  if (r) {
    const i2 = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: e2.wrap([r], true)
    };
    e2.patch(t.children[0], i2), a3.push(i2);
  }
  if (n2.length > 0) {
    const i2 = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: e2.wrap(n2, true)
    }, o2 = Ye4(t.children[1]), l = Cn(t.children[t.children.length - 1]);
    o2 && l && (i2.position = { start: o2, end: l }), a3.push(i2);
  }
  const u2 = {
    type: "element",
    tagName: "table",
    properties: {},
    children: e2.wrap(a3, true)
  };
  return e2.patch(t, u2), e2.applyData(t, u2);
}
function Qd(e2, t, n2) {
  const r = n2 ? n2.children : void 0, u2 = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", i2 = n2 && n2.type === "table" ? n2.align : void 0, o2 = i2 ? i2.length : t.children.length;
  let l = -1;
  const c3 = [];
  for (; ++l < o2; ) {
    const d2 = t.children[l], b2 = {}, m = i2 ? i2[l] : void 0;
    m && (b2.align = m);
    let h = { type: "element", tagName: u2, properties: b2, children: [] };
    d2 && (h.children = e2.all(d2), e2.patch(d2, h), h = e2.applyData(d2, h)), c3.push(h);
  }
  const f2 = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: e2.wrap(c3, true)
  };
  return e2.patch(t, f2), e2.applyData(t, f2);
}
function Xd(e2, t) {
  const n2 = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: e2.all(t)
  };
  return e2.patch(t, n2), e2.applyData(t, n2);
}
var ka = 9;
var Ia = 32;
function Kd(e2) {
  const t = String(e2), n2 = /\r?\n|\r/g;
  let r = n2.exec(t), a3 = 0;
  const u2 = [];
  for (; r; )
    u2.push(
      Sa2(t.slice(a3, r.index), a3 > 0, true),
      r[0]
    ), a3 = r.index + r[0].length, r = n2.exec(t);
  return u2.push(Sa2(t.slice(a3), a3 > 0, false)), u2.join("");
}
function Sa2(e2, t, n2) {
  let r = 0, a3 = e2.length;
  if (t) {
    let u2 = e2.codePointAt(r);
    for (; u2 === ka || u2 === Ia; )
      r++, u2 = e2.codePointAt(r);
  }
  if (n2) {
    let u2 = e2.codePointAt(a3 - 1);
    for (; u2 === ka || u2 === Ia; )
      a3--, u2 = e2.codePointAt(a3 - 1);
  }
  return a3 > r ? e2.slice(r, a3) : "";
}
function Zd(e2, t) {
  const n2 = { type: "text", value: Kd(String(t.value)) };
  return e2.patch(t, n2), e2.applyData(t, n2);
}
function Jd(e2, t) {
  const n2 = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return e2.patch(t, n2), e2.applyData(t, n2);
}
var e0 = {
  blockquote: Rd,
  break: Ld,
  code: Od,
  delete: wd,
  emphasis: Dd,
  footnoteReference: Pd,
  heading: Md,
  html: Fd,
  imageReference: Bd,
  image: vd,
  inlineCode: Hd,
  linkReference: Ud,
  link: zd,
  listItem: Yd,
  list: Gd,
  paragraph: qd,
  // @ts-expect-error: root is different, but hard to type.
  root: $d,
  strong: Wd,
  table: Vd,
  tableCell: Xd,
  tableRow: Qd,
  text: Zd,
  thematicBreak: Jd,
  toml: nn,
  yaml: nn,
  definition: nn,
  footnoteDefinition: nn
};
function nn() {
}
var su = -1;
var In = 0;
var bn = 1;
var En = 2;
var Rr2 = 3;
var Lr2 = 4;
var Or2 = 5;
var wr2 = 6;
var ou = 7;
var lu = 8;
var Na = typeof self == "object" ? self : globalThis;
var t0 = (e2, t) => {
  const n2 = (a3, u2) => (e2.set(u2, a3), a3), r = (a3) => {
    if (e2.has(a3))
      return e2.get(a3);
    const [u2, i2] = t[a3];
    switch (u2) {
      case In:
      case su:
        return n2(i2, a3);
      case bn: {
        const o2 = n2([], a3);
        for (const l of i2)
          o2.push(r(l));
        return o2;
      }
      case En: {
        const o2 = n2({}, a3);
        for (const [l, c3] of i2)
          o2[r(l)] = r(c3);
        return o2;
      }
      case Rr2:
        return n2(new Date(i2), a3);
      case Lr2: {
        const { source: o2, flags: l } = i2;
        return n2(new RegExp(o2, l), a3);
      }
      case Or2: {
        const o2 = n2(/* @__PURE__ */ new Map(), a3);
        for (const [l, c3] of i2)
          o2.set(r(l), r(c3));
        return o2;
      }
      case wr2: {
        const o2 = n2(/* @__PURE__ */ new Set(), a3);
        for (const l of i2)
          o2.add(r(l));
        return o2;
      }
      case ou: {
        const { name: o2, message: l } = i2;
        return n2(new Na[o2](l), a3);
      }
      case lu:
        return n2(BigInt(i2), a3);
      case "BigInt":
        return n2(Object(BigInt(i2)), a3);
    }
    return n2(new Na[u2](i2), a3);
  };
  return r;
};
var Ra = (e2) => t0(/* @__PURE__ */ new Map(), e2)(0);
var pt3 = "";
var { toString: n0 } = {};
var { keys: r0 } = Object;
var Pt3 = (e2) => {
  const t = typeof e2;
  if (t !== "object" || !e2)
    return [In, t];
  const n2 = n0.call(e2).slice(8, -1);
  switch (n2) {
    case "Array":
      return [bn, pt3];
    case "Object":
      return [En, pt3];
    case "Date":
      return [Rr2, pt3];
    case "RegExp":
      return [Lr2, pt3];
    case "Map":
      return [Or2, pt3];
    case "Set":
      return [wr2, pt3];
  }
  return n2.includes("Array") ? [bn, n2] : n2.includes("Error") ? [ou, n2] : [En, n2];
};
var rn = ([e2, t]) => e2 === In && (t === "function" || t === "symbol");
var a0 = (e2, t, n2, r) => {
  const a3 = (i2, o2) => {
    const l = r.push(i2) - 1;
    return n2.set(o2, l), l;
  }, u2 = (i2) => {
    if (n2.has(i2))
      return n2.get(i2);
    let [o2, l] = Pt3(i2);
    switch (o2) {
      case In: {
        let f2 = i2;
        switch (l) {
          case "bigint":
            o2 = lu, f2 = i2.toString();
            break;
          case "function":
          case "symbol":
            if (e2)
              throw new TypeError("unable to serialize " + l);
            f2 = null;
            break;
          case "undefined":
            return a3([su], i2);
        }
        return a3([o2, f2], i2);
      }
      case bn: {
        if (l)
          return a3([l, [...i2]], i2);
        const f2 = [], d2 = a3([o2, f2], i2);
        for (const b2 of i2)
          f2.push(u2(b2));
        return d2;
      }
      case En: {
        if (l)
          switch (l) {
            case "BigInt":
              return a3([l, i2.toString()], i2);
            case "Boolean":
            case "Number":
            case "String":
              return a3([l, i2.valueOf()], i2);
          }
        if (t && "toJSON" in i2)
          return u2(i2.toJSON());
        const f2 = [], d2 = a3([o2, f2], i2);
        for (const b2 of r0(i2))
          (e2 || !rn(Pt3(i2[b2]))) && f2.push([u2(b2), u2(i2[b2])]);
        return d2;
      }
      case Rr2:
        return a3([o2, i2.toISOString()], i2);
      case Lr2: {
        const { source: f2, flags: d2 } = i2;
        return a3([o2, { source: f2, flags: d2 }], i2);
      }
      case Or2: {
        const f2 = [], d2 = a3([o2, f2], i2);
        for (const [b2, m] of i2)
          (e2 || !(rn(Pt3(b2)) || rn(Pt3(m)))) && f2.push([u2(b2), u2(m)]);
        return d2;
      }
      case wr2: {
        const f2 = [], d2 = a3([o2, f2], i2);
        for (const b2 of i2)
          (e2 || !rn(Pt3(b2))) && f2.push(u2(b2));
        return d2;
      }
    }
    const { message: c3 } = i2;
    return a3([o2, { name: l, message: c3 }], i2);
  };
  return u2;
};
var La = (e2, { json: t, lossy: n2 } = {}) => {
  const r = [];
  return a0(!(t || n2), !!t, /* @__PURE__ */ new Map(), r)(e2), r;
};
var _t2 = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (e2, t) => t && ("json" in t || "lossy" in t) ? Ra(La(e2, t)) : structuredClone(e2)
) : (e2, t) => Ra(La(e2, t));
function i0(e2, t) {
  const n2 = [{ type: "text", value: "↩" }];
  return t > 1 && n2.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(t) }]
  }), n2;
}
function u0(e2, t) {
  return "Back to reference " + (e2 + 1) + (t > 1 ? "-" + t : "");
}
function s0(e2) {
  const t = typeof e2.options.clobberPrefix == "string" ? e2.options.clobberPrefix : "user-content-", n2 = e2.options.footnoteBackContent || i0, r = e2.options.footnoteBackLabel || u0, a3 = e2.options.footnoteLabel || "Footnotes", u2 = e2.options.footnoteLabelTagName || "h2", i2 = e2.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, o2 = [];
  let l = -1;
  for (; ++l < e2.footnoteOrder.length; ) {
    const c3 = e2.footnoteById.get(e2.footnoteOrder[l]);
    if (!c3)
      continue;
    const f2 = e2.all(c3), d2 = String(c3.identifier).toUpperCase(), b2 = It2(d2.toLowerCase());
    let m = 0;
    const h = [], E = e2.footnoteCounts.get(d2);
    for (; E !== void 0 && ++m <= E; ) {
      h.length > 0 && h.push({ type: "text", value: " " });
      let x2 = typeof n2 == "string" ? n2 : n2(l, m);
      typeof x2 == "string" && (x2 = { type: "text", value: x2 }), h.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + t + "fnref-" + b2 + (m > 1 ? "-" + m : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof r == "string" ? r : r(l, m),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(x2) ? x2 : [x2]
      });
    }
    const y2 = f2[f2.length - 1];
    if (y2 && y2.type === "element" && y2.tagName === "p") {
      const x2 = y2.children[y2.children.length - 1];
      x2 && x2.type === "text" ? x2.value += " " : y2.children.push({ type: "text", value: " " }), y2.children.push(...h);
    } else
      f2.push(...h);
    const _3 = {
      type: "element",
      tagName: "li",
      properties: { id: t + "fn-" + b2 },
      children: e2.wrap(f2, true)
    };
    e2.patch(c3, _3), o2.push(_3);
  }
  if (o2.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: true, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: u2,
          properties: {
            ..._t2(i2),
            id: "footnote-label"
          },
          children: [{ type: "text", value: a3 }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: e2.wrap(o2, true)
        },
        { type: "text", value: `
` }
      ]
    };
}
var Sn = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(e2) {
    if (e2 == null)
      return d0;
    if (typeof e2 == "function")
      return Nn(e2);
    if (typeof e2 == "object")
      return Array.isArray(e2) ? o0(e2) : l0(e2);
    if (typeof e2 == "string")
      return c0(e2);
    throw new Error("Expected function, string, or object as test");
  }
);
function o0(e2) {
  const t = [];
  let n2 = -1;
  for (; ++n2 < e2.length; )
    t[n2] = Sn(e2[n2]);
  return Nn(r);
  function r(...a3) {
    let u2 = -1;
    for (; ++u2 < t.length; )
      if (t[u2].apply(this, a3)) return true;
    return false;
  }
}
function l0(e2) {
  const t = (
    /** @type {Record<string, unknown>} */
    e2
  );
  return Nn(n2);
  function n2(r) {
    const a3 = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      r
    );
    let u2;
    for (u2 in e2)
      if (a3[u2] !== t[u2]) return false;
    return true;
  }
}
function c0(e2) {
  return Nn(t);
  function t(n2) {
    return n2 && n2.type === e2;
  }
}
function Nn(e2) {
  return t;
  function t(n2, r, a3) {
    return !!(f0(n2) && e2.call(
      this,
      n2,
      typeof r == "number" ? r : void 0,
      a3 || void 0
    ));
  }
}
function d0() {
  return true;
}
function f0(e2) {
  return e2 !== null && typeof e2 == "object" && "type" in e2;
}
var cu = [];
var h0 = true;
var sr2 = false;
var p0 = "skip";
function du(e2, t, n2, r) {
  let a3;
  typeof t == "function" && typeof n2 != "function" ? (r = n2, n2 = t) : a3 = t;
  const u2 = Sn(a3), i2 = r ? -1 : 1;
  o2(e2, void 0, [])();
  function o2(l, c3, f2) {
    const d2 = (
      /** @type {Record<string, unknown>} */
      l && typeof l == "object" ? l : {}
    );
    if (typeof d2.type == "string") {
      const m = (
        // `hast`
        typeof d2.tagName == "string" ? d2.tagName : (
          // `xast`
          typeof d2.name == "string" ? d2.name : void 0
        )
      );
      Object.defineProperty(b2, "name", {
        value: "node (" + (l.type + (m ? "<" + m + ">" : "")) + ")"
      });
    }
    return b2;
    function b2() {
      let m = cu, h, E, y2;
      if ((!t || u2(l, c3, f2[f2.length - 1] || void 0)) && (m = m0(n2(l, f2)), m[0] === sr2))
        return m;
      if ("children" in l && l.children) {
        const _3 = (
          /** @type {UnistParent} */
          l
        );
        if (_3.children && m[0] !== p0)
          for (E = (r ? _3.children.length : -1) + i2, y2 = f2.concat(_3); E > -1 && E < _3.children.length; ) {
            const x2 = _3.children[E];
            if (h = o2(x2, E, y2)(), h[0] === sr2)
              return h;
            E = typeof h[1] == "number" ? h[1] : E + i2;
          }
      }
      return m;
    }
  }
}
function m0(e2) {
  return Array.isArray(e2) ? e2 : typeof e2 == "number" ? [h0, e2] : e2 == null ? cu : [e2];
}
function Zt3(e2, t, n2, r) {
  let a3, u2, i2;
  typeof t == "function" && typeof n2 != "function" ? (u2 = void 0, i2 = t, a3 = n2) : (u2 = t, i2 = n2, a3 = r), du(e2, u2, o2, a3);
  function o2(l, c3) {
    const f2 = c3[c3.length - 1], d2 = f2 ? f2.children.indexOf(l) : void 0;
    return i2(l, d2, f2);
  }
}
var or3 = {}.hasOwnProperty;
var g0 = {};
function b0(e2, t) {
  const n2 = t || g0, r = /* @__PURE__ */ new Map(), a3 = /* @__PURE__ */ new Map(), u2 = /* @__PURE__ */ new Map(), i2 = { ...e0, ...n2.handlers }, o2 = {
    all: c3,
    applyData: T0,
    definitionById: r,
    footnoteById: a3,
    footnoteCounts: u2,
    footnoteOrder: [],
    handlers: i2,
    one: l,
    options: n2,
    patch: E0,
    wrap: A0
  };
  return Zt3(e2, function(f2) {
    if (f2.type === "definition" || f2.type === "footnoteDefinition") {
      const d2 = f2.type === "definition" ? r : a3, b2 = String(f2.identifier).toUpperCase();
      d2.has(b2) || d2.set(b2, f2);
    }
  }), o2;
  function l(f2, d2) {
    const b2 = f2.type, m = o2.handlers[b2];
    if (or3.call(o2.handlers, b2) && m)
      return m(o2, f2, d2);
    if (o2.options.passThrough && o2.options.passThrough.includes(b2)) {
      if ("children" in f2) {
        const { children: E, ...y2 } = f2, _3 = _t2(y2);
        return _3.children = o2.all(f2), _3;
      }
      return _t2(f2);
    }
    return (o2.options.unknownHandler || y0)(o2, f2, d2);
  }
  function c3(f2) {
    const d2 = [];
    if ("children" in f2) {
      const b2 = f2.children;
      let m = -1;
      for (; ++m < b2.length; ) {
        const h = o2.one(b2[m], f2);
        if (h) {
          if (m && b2[m - 1].type === "break" && (!Array.isArray(h) && h.type === "text" && (h.value = Oa(h.value)), !Array.isArray(h) && h.type === "element")) {
            const E = h.children[0];
            E && E.type === "text" && (E.value = Oa(E.value));
          }
          Array.isArray(h) ? d2.push(...h) : d2.push(h);
        }
      }
    }
    return d2;
  }
}
function E0(e2, t) {
  e2.position && (t.position = il(e2));
}
function T0(e2, t) {
  let n2 = t;
  if (e2 && e2.data) {
    const r = e2.data.hName, a3 = e2.data.hChildren, u2 = e2.data.hProperties;
    if (typeof r == "string")
      if (n2.type === "element")
        n2.tagName = r;
      else {
        const i2 = "children" in n2 ? n2.children : [n2];
        n2 = { type: "element", tagName: r, properties: {}, children: i2 };
      }
    n2.type === "element" && u2 && Object.assign(n2.properties, _t2(u2)), "children" in n2 && n2.children && a3 !== null && a3 !== void 0 && (n2.children = a3);
  }
  return n2;
}
function y0(e2, t) {
  const n2 = t.data || {}, r = "value" in t && !(or3.call(n2, "hProperties") || or3.call(n2, "hChildren")) ? { type: "text", value: t.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: e2.all(t)
  };
  return e2.patch(t, r), e2.applyData(t, r);
}
function A0(e2, t) {
  const n2 = [];
  let r = -1;
  for (t && n2.push({ type: "text", value: `
` }); ++r < e2.length; )
    r && n2.push({ type: "text", value: `
` }), n2.push(e2[r]);
  return t && e2.length > 0 && n2.push({ type: "text", value: `
` }), n2;
}
function Oa(e2) {
  let t = 0, n2 = e2.charCodeAt(t);
  for (; n2 === 9 || n2 === 32; )
    t++, n2 = e2.charCodeAt(t);
  return e2.slice(t);
}
function wa(e2, t) {
  const n2 = b0(e2, t), r = n2.one(e2, void 0), a3 = s0(n2), u2 = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] };
  return a3 && u2.children.push({ type: "text", value: `
` }, a3), u2;
}
function _0(e2, t) {
  return e2 && "run" in e2 ? async function(n2, r) {
    const a3 = (
      /** @type {HastRoot} */
      wa(n2, { file: r, ...t })
    );
    await e2.run(a3, r);
  } : function(n2, r) {
    return (
      /** @type {HastRoot} */
      wa(n2, { file: r, ...t || e2 })
    );
  };
}
function Da(e2) {
  if (e2)
    throw e2;
}
var cn = Object.prototype.hasOwnProperty;
var fu = Object.prototype.toString;
var Pa = Object.defineProperty;
var Ma = Object.getOwnPropertyDescriptor;
var Fa = function(t) {
  return typeof Array.isArray == "function" ? Array.isArray(t) : fu.call(t) === "[object Array]";
};
var Ba = function(t) {
  if (!t || fu.call(t) !== "[object Object]")
    return false;
  var n2 = cn.call(t, "constructor"), r = t.constructor && t.constructor.prototype && cn.call(t.constructor.prototype, "isPrototypeOf");
  if (t.constructor && !n2 && !r)
    return false;
  var a3;
  for (a3 in t)
    ;
  return typeof a3 > "u" || cn.call(t, a3);
};
var va = function(t, n2) {
  Pa && n2.name === "__proto__" ? Pa(t, n2.name, {
    enumerable: true,
    configurable: true,
    value: n2.newValue,
    writable: true
  }) : t[n2.name] = n2.newValue;
};
var Ha = function(t, n2) {
  if (n2 === "__proto__")
    if (cn.call(t, n2)) {
      if (Ma)
        return Ma(t, n2).value;
    } else return;
  return t[n2];
};
var C0 = function e() {
  var t, n2, r, a3, u2, i2, o2 = arguments[0], l = 1, c3 = arguments.length, f2 = false;
  for (typeof o2 == "boolean" && (f2 = o2, o2 = arguments[1] || {}, l = 2), (o2 == null || typeof o2 != "object" && typeof o2 != "function") && (o2 = {}); l < c3; ++l)
    if (t = arguments[l], t != null)
      for (n2 in t)
        r = Ha(o2, n2), a3 = Ha(t, n2), o2 !== a3 && (f2 && a3 && (Ba(a3) || (u2 = Fa(a3))) ? (u2 ? (u2 = false, i2 = r && Fa(r) ? r : []) : i2 = r && Ba(r) ? r : {}, va(o2, { name: n2, newValue: e(f2, i2, a3) })) : typeof a3 < "u" && va(o2, { name: n2, newValue: a3 }));
  return o2;
};
var zn = f(C0);
function lr3(e2) {
  if (typeof e2 != "object" || e2 === null)
    return false;
  const t = Object.getPrototypeOf(e2);
  return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e2) && !(Symbol.iterator in e2);
}
function x0() {
  const e2 = [], t = { run: n2, use: r };
  return t;
  function n2(...a3) {
    let u2 = -1;
    const i2 = a3.pop();
    if (typeof i2 != "function")
      throw new TypeError("Expected function as last argument, not " + i2);
    o2(null, ...a3);
    function o2(l, ...c3) {
      const f2 = e2[++u2];
      let d2 = -1;
      if (l) {
        i2(l);
        return;
      }
      for (; ++d2 < a3.length; )
        (c3[d2] === null || c3[d2] === void 0) && (c3[d2] = a3[d2]);
      a3 = c3, f2 ? k0(f2, o2)(...c3) : i2(null, ...c3);
    }
  }
  function r(a3) {
    if (typeof a3 != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + a3
      );
    return e2.push(a3), t;
  }
}
function k0(e2, t) {
  let n2;
  return r;
  function r(...i2) {
    const o2 = e2.length > i2.length;
    let l;
    o2 && i2.push(a3);
    try {
      l = e2.apply(this, i2);
    } catch (c3) {
      const f2 = (
        /** @type {Error} */
        c3
      );
      if (o2 && n2)
        throw f2;
      return a3(f2);
    }
    o2 || (l && l.then && typeof l.then == "function" ? l.then(u2, a3) : l instanceof Error ? a3(l) : u2(l));
  }
  function a3(i2, ...o2) {
    n2 || (n2 = true, t(i2, ...o2));
  }
  function u2(i2) {
    a3(null, i2);
  }
}
var He4 = { basename: I0, dirname: S0, extname: N0, join: R0, sep: "/" };
function I0(e2, t) {
  if (t !== void 0 && typeof t != "string")
    throw new TypeError('"ext" argument must be a string');
  Jt3(e2);
  let n2 = 0, r = -1, a3 = e2.length, u2;
  if (t === void 0 || t.length === 0 || t.length > e2.length) {
    for (; a3--; )
      if (e2.codePointAt(a3) === 47) {
        if (u2) {
          n2 = a3 + 1;
          break;
        }
      } else r < 0 && (u2 = true, r = a3 + 1);
    return r < 0 ? "" : e2.slice(n2, r);
  }
  if (t === e2)
    return "";
  let i2 = -1, o2 = t.length - 1;
  for (; a3--; )
    if (e2.codePointAt(a3) === 47) {
      if (u2) {
        n2 = a3 + 1;
        break;
      }
    } else
      i2 < 0 && (u2 = true, i2 = a3 + 1), o2 > -1 && (e2.codePointAt(a3) === t.codePointAt(o2--) ? o2 < 0 && (r = a3) : (o2 = -1, r = i2));
  return n2 === r ? r = i2 : r < 0 && (r = e2.length), e2.slice(n2, r);
}
function S0(e2) {
  if (Jt3(e2), e2.length === 0)
    return ".";
  let t = -1, n2 = e2.length, r;
  for (; --n2; )
    if (e2.codePointAt(n2) === 47) {
      if (r) {
        t = n2;
        break;
      }
    } else r || (r = true);
  return t < 0 ? e2.codePointAt(0) === 47 ? "/" : "." : t === 1 && e2.codePointAt(0) === 47 ? "//" : e2.slice(0, t);
}
function N0(e2) {
  Jt3(e2);
  let t = e2.length, n2 = -1, r = 0, a3 = -1, u2 = 0, i2;
  for (; t--; ) {
    const o2 = e2.codePointAt(t);
    if (o2 === 47) {
      if (i2) {
        r = t + 1;
        break;
      }
      continue;
    }
    n2 < 0 && (i2 = true, n2 = t + 1), o2 === 46 ? a3 < 0 ? a3 = t : u2 !== 1 && (u2 = 1) : a3 > -1 && (u2 = -1);
  }
  return a3 < 0 || n2 < 0 || // We saw a non-dot character immediately before the dot.
  u2 === 0 || // The (right-most) trimmed path component is exactly `..`.
  u2 === 1 && a3 === n2 - 1 && a3 === r + 1 ? "" : e2.slice(a3, n2);
}
function R0(...e2) {
  let t = -1, n2;
  for (; ++t < e2.length; )
    Jt3(e2[t]), e2[t] && (n2 = n2 === void 0 ? e2[t] : n2 + "/" + e2[t]);
  return n2 === void 0 ? "." : L0(n2);
}
function L0(e2) {
  Jt3(e2);
  const t = e2.codePointAt(0) === 47;
  let n2 = O0(e2, !t);
  return n2.length === 0 && !t && (n2 = "."), n2.length > 0 && e2.codePointAt(e2.length - 1) === 47 && (n2 += "/"), t ? "/" + n2 : n2;
}
function O0(e2, t) {
  let n2 = "", r = 0, a3 = -1, u2 = 0, i2 = -1, o2, l;
  for (; ++i2 <= e2.length; ) {
    if (i2 < e2.length)
      o2 = e2.codePointAt(i2);
    else {
      if (o2 === 47)
        break;
      o2 = 47;
    }
    if (o2 === 47) {
      if (!(a3 === i2 - 1 || u2 === 1)) if (a3 !== i2 - 1 && u2 === 2) {
        if (n2.length < 2 || r !== 2 || n2.codePointAt(n2.length - 1) !== 46 || n2.codePointAt(n2.length - 2) !== 46) {
          if (n2.length > 2) {
            if (l = n2.lastIndexOf("/"), l !== n2.length - 1) {
              l < 0 ? (n2 = "", r = 0) : (n2 = n2.slice(0, l), r = n2.length - 1 - n2.lastIndexOf("/")), a3 = i2, u2 = 0;
              continue;
            }
          } else if (n2.length > 0) {
            n2 = "", r = 0, a3 = i2, u2 = 0;
            continue;
          }
        }
        t && (n2 = n2.length > 0 ? n2 + "/.." : "..", r = 2);
      } else
        n2.length > 0 ? n2 += "/" + e2.slice(a3 + 1, i2) : n2 = e2.slice(a3 + 1, i2), r = i2 - a3 - 1;
      a3 = i2, u2 = 0;
    } else o2 === 46 && u2 > -1 ? u2++ : u2 = -1;
  }
  return n2;
}
function Jt3(e2) {
  if (typeof e2 != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(e2)
    );
}
var w0 = { cwd: D0 };
function D0() {
  return "/";
}
function cr2(e2) {
  return !!(e2 !== null && typeof e2 == "object" && "href" in e2 && e2.href && "protocol" in e2 && e2.protocol && // @ts-expect-error: indexing is fine.
  e2.auth === void 0);
}
function P0(e2) {
  if (typeof e2 == "string")
    e2 = new URL(e2);
  else if (!cr2(e2)) {
    const t = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + e2 + "`"
    );
    throw t.code = "ERR_INVALID_ARG_TYPE", t;
  }
  if (e2.protocol !== "file:") {
    const t = new TypeError("The URL must be of scheme file");
    throw t.code = "ERR_INVALID_URL_SCHEME", t;
  }
  return M0(e2);
}
function M0(e2) {
  if (e2.hostname !== "") {
    const r = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw r.code = "ERR_INVALID_FILE_URL_HOST", r;
  }
  const t = e2.pathname;
  let n2 = -1;
  for (; ++n2 < t.length; )
    if (t.codePointAt(n2) === 37 && t.codePointAt(n2 + 1) === 50) {
      const r = t.codePointAt(n2 + 2);
      if (r === 70 || r === 102) {
        const a3 = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw a3.code = "ERR_INVALID_FILE_URL_PATH", a3;
      }
    }
  return decodeURIComponent(t);
}
var Yn = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
var hu = class {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(t) {
    let n2;
    t ? cr2(t) ? n2 = { path: t } : typeof t == "string" || F0(t) ? n2 = { value: t } : n2 = t : n2 = {}, this.cwd = w0.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let r = -1;
    for (; ++r < Yn.length; ) {
      const u2 = Yn[r];
      u2 in n2 && n2[u2] !== void 0 && n2[u2] !== null && (this[u2] = u2 === "history" ? [...n2[u2]] : n2[u2]);
    }
    let a3;
    for (a3 in n2)
      Yn.includes(a3) || (this[a3] = n2[a3]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? He4.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(t) {
    Gn(t, "basename"), jn(t, "basename"), this.path = He4.join(this.dirname || "", t);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? He4.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(t) {
    Ua(this.basename, "dirname"), this.path = He4.join(t || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? He4.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(t) {
    if (jn(t, "extname"), Ua(this.dirname, "extname"), t) {
      if (t.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (t.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = He4.join(this.dirname, this.stem + (t || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(t) {
    cr2(t) && (t = P0(t)), Gn(t, "path"), this.path !== t && this.history.push(t);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? He4.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(t) {
    Gn(t, "stem"), jn(t, "stem"), this.path = He4.join(this.dirname || "", t + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(t, n2, r) {
    const a3 = this.message(t, n2, r);
    throw a3.fatal = true, a3;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(t, n2, r) {
    const a3 = this.message(t, n2, r);
    return a3.fatal = void 0, a3;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(t, n2, r) {
    const a3 = new be2(
      // @ts-expect-error: the overloads are fine.
      t,
      n2,
      r
    );
    return this.path && (a3.name = this.path + ":" + a3.name, a3.file = this.path), a3.fatal = false, this.messages.push(a3), a3;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(t) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value);
  }
};
function jn(e2, t) {
  if (e2 && e2.includes(He4.sep))
    throw new Error(
      "`" + t + "` cannot be a path: did not expect `" + He4.sep + "`"
    );
}
function Gn(e2, t) {
  if (!e2)
    throw new Error("`" + t + "` cannot be empty");
}
function Ua(e2, t) {
  if (!e2)
    throw new Error("Setting `" + t + "` requires `path` to be set too");
}
function F0(e2) {
  return !!(e2 && typeof e2 == "object" && "byteLength" in e2 && "byteOffset" in e2);
}
var B0 = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(e2) {
    const r = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), a3 = r[e2], u2 = function() {
      return a3.apply(u2, arguments);
    };
    Object.setPrototypeOf(u2, r);
    const i2 = Object.getOwnPropertyNames(a3);
    for (const o2 of i2) {
      const l = Object.getOwnPropertyDescriptor(a3, o2);
      l && Object.defineProperty(u2, o2, l);
    }
    return u2;
  }
);
var v0 = {}.hasOwnProperty;
var Dr2 = class _Dr extends B0 {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = x0();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@link Processor `Processor`}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const t = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new _Dr()
    );
    let n2 = -1;
    for (; ++n2 < this.attachers.length; ) {
      const r = this.attachers[n2];
      t.use(...r);
    }
    return t.data(zn(true, {}, this.namespace)), t;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > 👉 **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > 👉 **Note**: to register custom data in TypeScript, augment the
   * > {@link Data `Data`} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(t, n2) {
    return typeof t == "string" ? arguments.length === 2 ? (Wn("data", this.frozen), this.namespace[t] = n2, this) : v0.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (Wn("data", this.frozen), this.namespace = t, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const t = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [n2, ...r] = this.attachers[this.freezeIndex];
      if (r[0] === false)
        continue;
      r[0] === true && (r[0] = void 0);
      const a3 = n2.call(t, ...r);
      typeof a3 == "function" && this.transformers.use(a3);
    }
    return this.frozen = true, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > 👉 **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(t) {
    this.freeze();
    const n2 = an(t), r = this.parser || this.Parser;
    return qn("parse", r), r(String(n2), n2);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > 👉 **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > 👉 **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(t, n2) {
    const r = this;
    return this.freeze(), qn("process", this.parser || this.Parser), $n("process", this.compiler || this.Compiler), n2 ? a3(void 0, n2) : new Promise(a3);
    function a3(u2, i2) {
      const o2 = an(t), l = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        r.parse(o2)
      );
      r.run(l, o2, function(f2, d2, b2) {
        if (f2 || !d2 || !b2)
          return c3(f2);
        const m = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          d2
        ), h = r.stringify(m, b2);
        z0(h) ? b2.value = h : b2.result = h, c3(
          f2,
          /** @type {VFileWithOutput<CompileResult>} */
          b2
        );
      });
      function c3(f2, d2) {
        f2 || !d2 ? i2(f2) : u2 ? u2(d2) : n2(void 0, d2);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > 👉 **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > 👉 **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(t) {
    let n2 = false, r;
    return this.freeze(), qn("processSync", this.parser || this.Parser), $n("processSync", this.compiler || this.Compiler), this.process(t, a3), Ya("processSync", "process", n2), r;
    function a3(u2, i2) {
      n2 = true, Da(u2), r = i2;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > 👉 **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(t, n2, r) {
    za(t), this.freeze();
    const a3 = this.transformers;
    return !r && typeof n2 == "function" && (r = n2, n2 = void 0), r ? u2(void 0, r) : new Promise(u2);
    function u2(i2, o2) {
      const l = an(n2);
      a3.run(t, l, c3);
      function c3(f2, d2, b2) {
        const m = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          d2 || t
        );
        f2 ? o2(f2) : i2 ? i2(m) : r(void 0, m, b2);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > 👉 **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(t, n2) {
    let r = false, a3;
    return this.run(t, n2, u2), Ya("runSync", "run", r), a3;
    function u2(i2, o2) {
      Da(i2), a3 = o2, r = true;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > 👉 **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > 👉 **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > 👉 **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@link CompileResultMap `CompileResultMap`}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(t, n2) {
    this.freeze();
    const r = an(n2), a3 = this.compiler || this.Compiler;
    return $n("stringify", a3), za(t), a3(t, r);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > 👉 **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(t, ...n2) {
    const r = this.attachers, a3 = this.namespace;
    if (Wn("use", this.frozen), t != null) if (typeof t == "function")
      l(t, n2);
    else if (typeof t == "object")
      Array.isArray(t) ? o2(t) : i2(t);
    else
      throw new TypeError("Expected usable value, not `" + t + "`");
    return this;
    function u2(c3) {
      if (typeof c3 == "function")
        l(c3, []);
      else if (typeof c3 == "object")
        if (Array.isArray(c3)) {
          const [f2, ...d2] = (
            /** @type {PluginTuple<Array<unknown>>} */
            c3
          );
          l(f2, d2);
        } else
          i2(c3);
      else
        throw new TypeError("Expected usable value, not `" + c3 + "`");
    }
    function i2(c3) {
      if (!("plugins" in c3) && !("settings" in c3))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      o2(c3.plugins), c3.settings && (a3.settings = zn(true, a3.settings, c3.settings));
    }
    function o2(c3) {
      let f2 = -1;
      if (c3 != null) if (Array.isArray(c3))
        for (; ++f2 < c3.length; ) {
          const d2 = c3[f2];
          u2(d2);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + c3 + "`");
    }
    function l(c3, f2) {
      let d2 = -1, b2 = -1;
      for (; ++d2 < r.length; )
        if (r[d2][0] === c3) {
          b2 = d2;
          break;
        }
      if (b2 === -1)
        r.push([c3, ...f2]);
      else if (f2.length > 0) {
        let [m, ...h] = f2;
        const E = r[b2][1];
        lr3(E) && lr3(m) && (m = zn(true, E, m)), r[b2] = [c3, m, ...h];
      }
    }
  }
};
var H0 = new Dr2().freeze();
function qn(e2, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e2 + "` without `parser`");
}
function $n(e2, t) {
  if (typeof t != "function")
    throw new TypeError("Cannot `" + e2 + "` without `compiler`");
}
function Wn(e2, t) {
  if (t)
    throw new Error(
      "Cannot call `" + e2 + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function za(e2) {
  if (!lr3(e2) || typeof e2.type != "string")
    throw new TypeError("Expected node, got `" + e2 + "`");
}
function Ya(e2, t, n2) {
  if (!n2)
    throw new Error(
      "`" + e2 + "` finished async. Use `" + t + "` instead"
    );
}
function an(e2) {
  return U0(e2) ? e2 : new hu(e2);
}
function U0(e2) {
  return !!(e2 && typeof e2 == "object" && "message" in e2 && "messages" in e2);
}
function z0(e2) {
  return typeof e2 == "string" || Y0(e2);
}
function Y0(e2) {
  return !!(e2 && typeof e2 == "object" && "byteLength" in e2 && "byteOffset" in e2);
}
var j0 = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md";
var ja = [];
var Ga = { allowDangerousHtml: true };
var G0 = /^(https?|ircs?|mailto|xmpp)$/i;
var q0 = [
  { from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" },
  { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" },
  {
    from: "allowNode",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowElement"
  },
  {
    from: "allowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "allowedElements"
  },
  {
    from: "disallowedTypes",
    id: "replace-allownode-allowedtypes-and-disallowedtypes",
    to: "disallowedElements"
  },
  { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" },
  { from: "includeElementIndex", id: "#remove-includeelementindex" },
  {
    from: "includeNodeIndex",
    id: "change-includenodeindex-to-includeelementindex"
  },
  { from: "linkTarget", id: "remove-linktarget" },
  { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" },
  { from: "rawSourcePos", id: "#remove-rawsourcepos" },
  { from: "renderers", id: "change-renderers-to-components", to: "components" },
  { from: "source", id: "change-source-to-children", to: "children" },
  { from: "sourcePos", id: "#remove-sourcepos" },
  { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" },
  { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }
];
function $0(e2) {
  const t = e2.allowedElements, n2 = e2.allowElement, r = e2.children || "", a3 = e2.className, u2 = e2.components, i2 = e2.disallowedElements, o2 = e2.rehypePlugins || ja, l = e2.remarkPlugins || ja, c3 = e2.remarkRehypeOptions ? { ...e2.remarkRehypeOptions, ...Ga } : Ga, f2 = e2.skipHtml, d2 = e2.unwrapDisallowed, b2 = e2.urlTransform || W0, m = H0().use(Nd).use(l).use(_0, c3).use(o2), h = new hu();
  typeof r == "string" && (h.value = r);
  for (const x2 of q0)
    Object.hasOwn(e2, x2.from) && ("" + x2.from + (x2.to ? "use `" + x2.to + "` instead" : "remove it") + j0 + x2.id, void 0);
  const E = m.parse(h);
  let y2 = m.runSync(E, h);
  return a3 && (y2 = {
    type: "element",
    tagName: "div",
    properties: { className: a3 },
    // Assume no doctypes.
    children: (
      /** @type {Array<ElementContent>} */
      y2.type === "root" ? y2.children : [y2]
    )
  }), Zt3(y2, _3), dl(y2, {
    Fragment: dr.Fragment,
    components: u2,
    ignoreInvalidStyle: true,
    jsx: dr.jsx,
    jsxs: dr.jsxs,
    passKeys: true,
    passNode: true
  });
  function _3(x2, I3, M3) {
    if (x2.type === "raw" && M3 && typeof I3 == "number")
      return f2 ? M3.children.splice(I3, 1) : M3.children[I3] = { type: "text", value: x2.value }, I3;
    if (x2.type === "element") {
      let B4;
      for (B4 in vn)
        if (Object.hasOwn(vn, B4) && Object.hasOwn(x2.properties, B4)) {
          const R = x2.properties[B4], U2 = vn[B4];
          (U2 === null || U2.includes(x2.tagName)) && (x2.properties[B4] = b2(String(R || ""), B4, x2));
        }
    }
    if (x2.type === "element") {
      let B4 = t ? !t.includes(x2.tagName) : i2 ? i2.includes(x2.tagName) : false;
      if (!B4 && n2 && typeof I3 == "number" && (B4 = !n2(x2, I3, M3)), B4 && M3 && typeof I3 == "number")
        return d2 && x2.children ? M3.children.splice(I3, 1, ...x2.children) : M3.children.splice(I3, 1), I3;
    }
  }
}
function W0(e2) {
  const t = e2.indexOf(":"), n2 = e2.indexOf("?"), r = e2.indexOf("#"), a3 = e2.indexOf("/");
  return (
    // If there is no protocol, it’s relative.
    t < 0 || // If the first colon is after a `?`, `#`, or `/`, it’s not a protocol.
    a3 > -1 && t > a3 || n2 > -1 && t > n2 || r > -1 && t > r || // It is a protocol, it should be allowed.
    G0.test(e2.slice(0, t)) ? e2 : ""
  );
}
var qa = /[#.]/g;
function V0(e2, t) {
  const n2 = e2 || "", r = {};
  let a3 = 0, u2, i2;
  for (; a3 < n2.length; ) {
    qa.lastIndex = a3;
    const o2 = qa.exec(n2), l = n2.slice(a3, o2 ? o2.index : n2.length);
    l && (u2 ? u2 === "#" ? r.id = l : Array.isArray(r.className) ? r.className.push(l) : r.className = [l] : i2 = l, a3 += l.length), o2 && (u2 = o2[0], a3++);
  }
  return {
    type: "element",
    // @ts-expect-error: tag name is parsed.
    tagName: i2 || t || "div",
    properties: r,
    children: []
  };
}
var Q0 = /* @__PURE__ */ new Set(["button", "menu", "reset", "submit"]);
var dr3 = {}.hasOwnProperty;
function pu(e2, t, n2) {
  const r = n2 && J0(n2);
  function a3(u2, i2, ...o2) {
    let l = -1, c3;
    if (u2 == null) {
      c3 = { type: "root", children: [] };
      const f2 = (
        /** @type {Child} */
        i2
      );
      o2.unshift(f2);
    } else if (c3 = V0(u2, t), c3.tagName = c3.tagName.toLowerCase(), r && dr3.call(r, c3.tagName) && (c3.tagName = r[c3.tagName]), X0(i2, c3.tagName)) {
      let f2;
      for (f2 in i2)
        dr3.call(i2, f2) && K0(e2, c3.properties, f2, i2[f2]);
    } else
      o2.unshift(i2);
    for (; ++l < o2.length; )
      fr3(c3.children, o2[l]);
    return c3.type === "element" && c3.tagName === "template" && (c3.content = { type: "root", children: c3.children }, c3.children = []), c3;
  }
  return a3;
}
function X0(e2, t) {
  return e2 == null || typeof e2 != "object" || Array.isArray(e2) ? false : t === "input" || !e2.type || typeof e2.type != "string" ? true : "children" in e2 && Array.isArray(e2.children) ? false : t === "button" ? Q0.has(e2.type.toLowerCase()) : !("value" in e2);
}
function K0(e2, t, n2, r) {
  const a3 = _n(e2, n2);
  let u2 = -1, i2;
  if (r != null) {
    if (typeof r == "number") {
      if (Number.isNaN(r)) return;
      i2 = r;
    } else typeof r == "boolean" ? i2 = r : typeof r == "string" ? a3.spaceSeparated ? i2 = ua2(r) : a3.commaSeparated ? i2 = ta(r) : a3.commaOrSpaceSeparated ? i2 = ua2(ta(r).join(" ")) : i2 = $a(a3, a3.property, r) : Array.isArray(r) ? i2 = r.concat() : i2 = a3.property === "style" ? Z0(r) : String(r);
    if (Array.isArray(i2)) {
      const o2 = [];
      for (; ++u2 < i2.length; ) {
        const l = (
          /** @type {number | string} */
          $a(a3, a3.property, i2[u2])
        );
        o2[u2] = l;
      }
      i2 = o2;
    }
    if (a3.property === "className" && Array.isArray(t.className)) {
      const o2 = (
        /** @type {number | string} */
        i2
      );
      i2 = t.className.concat(o2);
    }
    t[a3.property] = i2;
  }
}
function fr3(e2, t) {
  let n2 = -1;
  if (t != null) if (typeof t == "string" || typeof t == "number")
    e2.push({ type: "text", value: String(t) });
  else if (Array.isArray(t))
    for (; ++n2 < t.length; )
      fr3(e2, t[n2]);
  else if (typeof t == "object" && "type" in t)
    t.type === "root" ? fr3(e2, t.children) : e2.push(t);
  else
    throw new Error("Expected node, nodes, or string, got `" + t + "`");
}
function $a(e2, t, n2) {
  if (typeof n2 == "string") {
    if (e2.number && n2 && !Number.isNaN(Number(n2)))
      return Number(n2);
    if ((e2.boolean || e2.overloadedBoolean) && (n2 === "" || $t3(n2) === $t3(t)))
      return true;
  }
  return n2;
}
function Z0(e2) {
  const t = [];
  let n2;
  for (n2 in e2)
    dr3.call(e2, n2) && t.push([n2, e2[n2]].join(": "));
  return t.join("; ");
}
function J0(e2) {
  const t = {};
  let n2 = -1;
  for (; ++n2 < e2.length; )
    t[e2[n2].toLowerCase()] = e2[n2];
  return t;
}
var ef = [
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feDropShadow",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "solidColor",
  "textArea",
  "textPath"
];
var tf = pu(Xt3, "div");
var nf = pu(et2, "g", ef);
function rf(e2) {
  const t = String(e2), n2 = [];
  return { toOffset: a3, toPoint: r };
  function r(u2) {
    if (typeof u2 == "number" && u2 > -1 && u2 <= t.length) {
      let i2 = 0;
      for (; ; ) {
        let o2 = n2[i2];
        if (o2 === void 0) {
          const l = Wa(t, n2[i2 - 1]);
          o2 = l === -1 ? t.length + 1 : l + 1, n2[i2] = o2;
        }
        if (o2 > u2)
          return {
            line: i2 + 1,
            column: u2 - (i2 > 0 ? n2[i2 - 1] : 0) + 1,
            offset: u2
          };
        i2++;
      }
    }
  }
  function a3(u2) {
    if (u2 && typeof u2.line == "number" && typeof u2.column == "number" && !Number.isNaN(u2.line) && !Number.isNaN(u2.column)) {
      for (; n2.length < u2.line; ) {
        const o2 = n2[n2.length - 1], l = Wa(t, o2), c3 = l === -1 ? t.length + 1 : l + 1;
        if (o2 === c3) break;
        n2.push(c3);
      }
      const i2 = (u2.line > 1 ? n2[u2.line - 2] : 0) + u2.column - 1;
      if (i2 < n2[u2.line - 1]) return i2;
    }
  }
}
function Wa(e2, t) {
  const n2 = e2.indexOf("\r", t), r = e2.indexOf(`
`, t);
  return r === -1 ? n2 : n2 === -1 || n2 + 1 === r ? r : n2 < r ? n2 : r;
}
var ot2 = {
  html: "http://www.w3.org/1999/xhtml",
  mathml: "http://www.w3.org/1998/Math/MathML",
  svg: "http://www.w3.org/2000/svg",
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
var mu = {}.hasOwnProperty;
var af = Object.prototype;
function uf(e2, t) {
  const n2 = t || {};
  return Pr2(
    {
      file: n2.file || void 0,
      location: false,
      schema: n2.space === "svg" ? et2 : Xt3,
      verbose: n2.verbose || false
    },
    e2
  );
}
function Pr2(e2, t) {
  let n2;
  switch (t.nodeName) {
    case "#comment": {
      const r = (
        /** @type {P5Comment} */
        t
      );
      return n2 = { type: "comment", value: r.data }, dn(e2, r, n2), n2;
    }
    case "#document":
    case "#document-fragment": {
      const r = (
        /** @type {P5Document | P5DocumentFragment} */
        t
      ), a3 = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : false;
      if (n2 = {
        type: "root",
        children: gu(e2, t.childNodes),
        data: { quirksMode: a3 }
      }, e2.file && e2.location) {
        const u2 = String(e2.file), i2 = rf(u2), o2 = i2.toPoint(0), l = i2.toPoint(u2.length);
        n2.position = { start: o2, end: l };
      }
      return n2;
    }
    case "#documentType": {
      const r = (
        /** @type {P5DocumentType} */
        t
      );
      return n2 = { type: "doctype" }, dn(e2, r, n2), n2;
    }
    case "#text": {
      const r = (
        /** @type {P5Text} */
        t
      );
      return n2 = { type: "text", value: r.value }, dn(e2, r, n2), n2;
    }
    default:
      return n2 = sf(
        e2,
        /** @type {P5Element} */
        t
      ), n2;
  }
}
function gu(e2, t) {
  let n2 = -1;
  const r = [];
  for (; ++n2 < t.length; ) {
    const a3 = (
      /** @type {RootContent} */
      Pr2(e2, t[n2])
    );
    r.push(a3);
  }
  return r;
}
function sf(e2, t) {
  const n2 = e2.schema;
  e2.schema = t.namespaceURI === ot2.svg ? et2 : Xt3;
  let r = -1;
  const a3 = {};
  for (; ++r < t.attrs.length; ) {
    const o2 = t.attrs[r], l = (o2.prefix ? o2.prefix + ":" : "") + o2.name;
    mu.call(af, l) || (a3[l] = o2.value);
  }
  const i2 = (e2.schema.space === "svg" ? nf : tf)(t.tagName, a3, gu(e2, t.childNodes));
  if (dn(e2, t, i2), i2.tagName === "template") {
    const o2 = (
      /** @type {P5Template} */
      t
    ), l = o2.sourceCodeLocation, c3 = l && l.startTag && Et3(l.startTag), f2 = l && l.endTag && Et3(l.endTag), d2 = (
      /** @type {Root} */
      Pr2(e2, o2.content)
    );
    c3 && f2 && e2.file && (d2.position = { start: c3.end, end: f2.start }), i2.content = d2;
  }
  return e2.schema = n2, i2;
}
function dn(e2, t, n2) {
  if ("sourceCodeLocation" in t && t.sourceCodeLocation && e2.file) {
    const r = of(e2, n2, t.sourceCodeLocation);
    r && (e2.location = true, n2.position = r);
  }
}
function of(e2, t, n2) {
  const r = Et3(n2);
  if (t.type === "element") {
    const a3 = t.children[t.children.length - 1];
    if (r && !n2.endTag && a3 && a3.position && a3.position.end && (r.end = Object.assign({}, a3.position.end)), e2.verbose) {
      const u2 = {};
      let i2;
      if (n2.attrs)
        for (i2 in n2.attrs)
          mu.call(n2.attrs, i2) && (u2[_n(e2.schema, i2).property] = Et3(
            n2.attrs[i2]
          ));
      n2.startTag;
      const o2 = Et3(n2.startTag), l = n2.endTag ? Et3(n2.endTag) : void 0, c3 = { opening: o2 };
      l && (c3.closing = l), c3.properties = u2, t.data = { position: c3 };
    }
  }
  return r;
}
function Et3(e2) {
  const t = Va({
    line: e2.startLine,
    column: e2.startCol,
    offset: e2.startOffset
  }), n2 = Va({
    line: e2.endLine,
    column: e2.endCol,
    offset: e2.endOffset
  });
  return t || n2 ? { start: t, end: n2 } : void 0;
}
function Va(e2) {
  return e2.line && e2.column ? e2 : void 0;
}
var Qa = {}.hasOwnProperty;
function bu(e2, t) {
  const n2 = t || {};
  function r(a3, ...u2) {
    let i2 = r.invalid;
    const o2 = r.handlers;
    if (a3 && Qa.call(a3, e2)) {
      const l = String(a3[e2]);
      i2 = Qa.call(o2, l) ? o2[l] : r.unknown;
    }
    if (i2)
      return i2.call(this, a3, ...u2);
  }
  return r.handlers = n2.handlers || {}, r.invalid = n2.invalid, r.unknown = n2.unknown, r;
}
var lf = {};
var cf = {}.hasOwnProperty;
var Eu = bu("type", { handlers: { root: ff, element: bf, text: mf, comment: gf, doctype: pf } });
function df(e2, t) {
  const r = (t || lf).space;
  return Eu(e2, r === "svg" ? et2 : Xt3);
}
function ff(e2, t) {
  const n2 = {
    nodeName: "#document",
    // @ts-expect-error: `parse5` uses enums, which are actually strings.
    mode: (e2.data || {}).quirksMode ? "quirks" : "no-quirks",
    childNodes: []
  };
  return n2.childNodes = Mr(e2.children, n2, t), St4(e2, n2), n2;
}
function hf(e2, t) {
  const n2 = { nodeName: "#document-fragment", childNodes: [] };
  return n2.childNodes = Mr(e2.children, n2, t), St4(e2, n2), n2;
}
function pf(e2) {
  const t = {
    nodeName: "#documentType",
    name: "html",
    publicId: "",
    systemId: "",
    parentNode: null
  };
  return St4(e2, t), t;
}
function mf(e2) {
  const t = {
    nodeName: "#text",
    value: e2.value,
    parentNode: null
  };
  return St4(e2, t), t;
}
function gf(e2) {
  const t = {
    nodeName: "#comment",
    data: e2.value,
    parentNode: null
  };
  return St4(e2, t), t;
}
function bf(e2, t) {
  const n2 = t;
  let r = n2;
  e2.type === "element" && e2.tagName.toLowerCase() === "svg" && n2.space === "html" && (r = et2);
  const a3 = [];
  let u2;
  if (e2.properties) {
    for (u2 in e2.properties)
      if (u2 !== "children" && cf.call(e2.properties, u2)) {
        const l = Ef(
          r,
          u2,
          e2.properties[u2]
        );
        l && a3.push(l);
      }
  }
  const i2 = r.space, o2 = {
    nodeName: e2.tagName,
    tagName: e2.tagName,
    attrs: a3,
    // @ts-expect-error: `parse5` types are wrong.
    namespaceURI: ot2[i2],
    childNodes: [],
    parentNode: null
  };
  return o2.childNodes = Mr(e2.children, o2, r), St4(e2, o2), e2.tagName === "template" && e2.content && (o2.content = hf(e2.content, r)), o2;
}
function Ef(e2, t, n2) {
  const r = _n(e2, t);
  if (n2 === false || n2 === null || n2 === void 0 || typeof n2 == "number" && Number.isNaN(n2) || !n2 && r.boolean)
    return;
  Array.isArray(n2) && (n2 = r.commaSeparated ? Ri(n2) : vi(n2));
  const a3 = {
    name: r.attribute,
    value: n2 === true ? "" : String(n2)
  };
  if (r.space && r.space !== "html" && r.space !== "svg") {
    const u2 = a3.name.indexOf(":");
    u2 < 0 ? a3.prefix = "" : (a3.name = a3.name.slice(u2 + 1), a3.prefix = r.attribute.slice(0, u2)), a3.namespace = ot2[r.space];
  }
  return a3;
}
function Mr(e2, t, n2) {
  let r = -1;
  const a3 = [];
  if (e2)
    for (; ++r < e2.length; ) {
      const u2 = Eu(e2[r], n2);
      u2.parentNode = t, a3.push(u2);
    }
  return a3;
}
function St4(e2, t) {
  const n2 = e2.position;
  n2 && n2.start && n2.end && (n2.start.offset, n2.end.offset, t.sourceCodeLocation = {
    startLine: n2.start.line,
    startCol: n2.start.column,
    startOffset: n2.start.offset,
    endLine: n2.end.line,
    endCol: n2.end.column,
    endOffset: n2.end.offset
  });
}
var Tf = [
  "area",
  "base",
  "basefont",
  "bgsound",
  "br",
  "col",
  "command",
  "embed",
  "frame",
  "hr",
  "image",
  "img",
  "input",
  "keygen",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
var yf = /* @__PURE__ */ new Set([
  65534,
  65535,
  131070,
  131071,
  196606,
  196607,
  262142,
  262143,
  327678,
  327679,
  393214,
  393215,
  458750,
  458751,
  524286,
  524287,
  589822,
  589823,
  655358,
  655359,
  720894,
  720895,
  786430,
  786431,
  851966,
  851967,
  917502,
  917503,
  983038,
  983039,
  1048574,
  1048575,
  1114110,
  1114111
]);
var le3 = "�";
var p2;
(function(e2) {
  e2[e2.EOF = -1] = "EOF", e2[e2.NULL = 0] = "NULL", e2[e2.TABULATION = 9] = "TABULATION", e2[e2.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e2[e2.LINE_FEED = 10] = "LINE_FEED", e2[e2.FORM_FEED = 12] = "FORM_FEED", e2[e2.SPACE = 32] = "SPACE", e2[e2.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e2[e2.QUOTATION_MARK = 34] = "QUOTATION_MARK", e2[e2.NUMBER_SIGN = 35] = "NUMBER_SIGN", e2[e2.AMPERSAND = 38] = "AMPERSAND", e2[e2.APOSTROPHE = 39] = "APOSTROPHE", e2[e2.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e2[e2.SOLIDUS = 47] = "SOLIDUS", e2[e2.DIGIT_0 = 48] = "DIGIT_0", e2[e2.DIGIT_9 = 57] = "DIGIT_9", e2[e2.SEMICOLON = 59] = "SEMICOLON", e2[e2.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e2[e2.EQUALS_SIGN = 61] = "EQUALS_SIGN", e2[e2.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e2[e2.QUESTION_MARK = 63] = "QUESTION_MARK", e2[e2.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e2[e2.LATIN_CAPITAL_F = 70] = "LATIN_CAPITAL_F", e2[e2.LATIN_CAPITAL_X = 88] = "LATIN_CAPITAL_X", e2[e2.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e2[e2.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e2[e2.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e2[e2.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e2[e2.LATIN_SMALL_F = 102] = "LATIN_SMALL_F", e2[e2.LATIN_SMALL_X = 120] = "LATIN_SMALL_X", e2[e2.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z", e2[e2.REPLACEMENT_CHARACTER = 65533] = "REPLACEMENT_CHARACTER";
})(p2 = p2 || (p2 = {}));
var _e2 = {
  DASH_DASH: "--",
  CDATA_START: "[CDATA[",
  DOCTYPE: "doctype",
  SCRIPT: "script",
  PUBLIC: "public",
  SYSTEM: "system"
};
function Tu(e2) {
  return e2 >= 55296 && e2 <= 57343;
}
function Af(e2) {
  return e2 >= 56320 && e2 <= 57343;
}
function _f(e2, t) {
  return (e2 - 55296) * 1024 + 9216 + t;
}
function yu(e2) {
  return e2 !== 32 && e2 !== 10 && e2 !== 13 && e2 !== 9 && e2 !== 12 && e2 >= 1 && e2 <= 31 || e2 >= 127 && e2 <= 159;
}
function Au(e2) {
  return e2 >= 64976 && e2 <= 65007 || yf.has(e2);
}
var N;
(function(e2) {
  e2.controlCharacterInInputStream = "control-character-in-input-stream", e2.noncharacterInInputStream = "noncharacter-in-input-stream", e2.surrogateInInputStream = "surrogate-in-input-stream", e2.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e2.endTagWithAttributes = "end-tag-with-attributes", e2.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e2.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e2.unexpectedNullCharacter = "unexpected-null-character", e2.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e2.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e2.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e2.missingEndTagName = "missing-end-tag-name", e2.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e2.unknownNamedCharacterReference = "unknown-named-character-reference", e2.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e2.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e2.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e2.eofBeforeTagName = "eof-before-tag-name", e2.eofInTag = "eof-in-tag", e2.missingAttributeValue = "missing-attribute-value", e2.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e2.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e2.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e2.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e2.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e2.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e2.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e2.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e2.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e2.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e2.cdataInHtmlContent = "cdata-in-html-content", e2.incorrectlyOpenedComment = "incorrectly-opened-comment", e2.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e2.eofInDoctype = "eof-in-doctype", e2.nestedComment = "nested-comment", e2.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e2.eofInComment = "eof-in-comment", e2.incorrectlyClosedComment = "incorrectly-closed-comment", e2.eofInCdata = "eof-in-cdata", e2.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e2.nullCharacterReference = "null-character-reference", e2.surrogateCharacterReference = "surrogate-character-reference", e2.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e2.controlCharacterReference = "control-character-reference", e2.noncharacterCharacterReference = "noncharacter-character-reference", e2.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e2.missingDoctypeName = "missing-doctype-name", e2.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e2.duplicateAttribute = "duplicate-attribute", e2.nonConformingDoctype = "non-conforming-doctype", e2.missingDoctype = "missing-doctype", e2.misplacedDoctype = "misplaced-doctype", e2.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e2.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e2.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e2.openElementsLeftAfterEof = "open-elements-left-after-eof", e2.abandonedHeadElementChild = "abandoned-head-element-child", e2.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e2.nestedNoscriptInHead = "nested-noscript-in-head", e2.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text";
})(N = N || (N = {}));
var Cf = 65536;
var xf = class {
  constructor(t) {
    this.handler = t, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = false, this.lastChunkWritten = false, this.endOfChunkHit = false, this.bufferWaterline = Cf, this.isEol = false, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1;
  }
  /** The column on the current line. If we just saw a gap (eg. a surrogate pair), return the index before. */
  get col() {
    return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos);
  }
  get offset() {
    return this.droppedBufferSize + this.pos;
  }
  getError(t) {
    const { line: n2, col: r, offset: a3 } = this;
    return {
      code: t,
      startLine: n2,
      endLine: n2,
      startCol: r,
      endCol: r,
      startOffset: a3,
      endOffset: a3
    };
  }
  _err(t) {
    this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t)));
  }
  _addGap() {
    this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos;
  }
  _processSurrogate(t) {
    if (this.pos !== this.html.length - 1) {
      const n2 = this.html.charCodeAt(this.pos + 1);
      if (Af(n2))
        return this.pos++, this._addGap(), _f(t, n2);
    } else if (!this.lastChunkWritten)
      return this.endOfChunkHit = true, p2.EOF;
    return this._err(N.surrogateInInputStream), t;
  }
  willDropParsedChunk() {
    return this.pos > this.bufferWaterline;
  }
  dropParsedChunk() {
    this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0);
  }
  write(t, n2) {
    this.html.length > 0 ? this.html += t : this.html = t, this.endOfChunkHit = false, this.lastChunkWritten = n2;
  }
  insertHtmlAtCurrentPos(t) {
    this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1), this.endOfChunkHit = false;
  }
  startsWith(t, n2) {
    if (this.pos + t.length > this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, false;
    if (n2)
      return this.html.startsWith(t, this.pos);
    for (let r = 0; r < t.length; r++)
      if ((this.html.charCodeAt(this.pos + r) | 32) !== t.charCodeAt(r))
        return false;
    return true;
  }
  peek(t) {
    const n2 = this.pos + t;
    if (n2 >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, p2.EOF;
    const r = this.html.charCodeAt(n2);
    return r === p2.CARRIAGE_RETURN ? p2.LINE_FEED : r;
  }
  advance() {
    if (this.pos++, this.isEol && (this.isEol = false, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length)
      return this.endOfChunkHit = !this.lastChunkWritten, p2.EOF;
    let t = this.html.charCodeAt(this.pos);
    return t === p2.CARRIAGE_RETURN ? (this.isEol = true, this.skipNextNewLine = true, p2.LINE_FEED) : t === p2.LINE_FEED && (this.isEol = true, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = false, this._addGap(), this.advance()) : (this.skipNextNewLine = false, Tu(t) && (t = this._processSurrogate(t)), this.handler.onParseError === null || t > 31 && t < 127 || t === p2.LINE_FEED || t === p2.CARRIAGE_RETURN || t > 159 && t < 64976 || this._checkForProblematicCharacters(t), t);
  }
  _checkForProblematicCharacters(t) {
    yu(t) ? this._err(N.controlCharacterInInputStream) : Au(t) && this._err(N.noncharacterInInputStream);
  }
  retreat(t) {
    for (this.pos -= t; this.pos < this.lastGapPos; )
      this.lastGapPos = this.gapStack.pop(), this.pos--;
    this.isEol = false;
  }
};
var X2;
(function(e2) {
  e2[e2.CHARACTER = 0] = "CHARACTER", e2[e2.NULL_CHARACTER = 1] = "NULL_CHARACTER", e2[e2.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e2[e2.START_TAG = 3] = "START_TAG", e2[e2.END_TAG = 4] = "END_TAG", e2[e2.COMMENT = 5] = "COMMENT", e2[e2.DOCTYPE = 6] = "DOCTYPE", e2[e2.EOF = 7] = "EOF", e2[e2.HIBERNATION = 8] = "HIBERNATION";
})(X2 = X2 || (X2 = {}));
function _u(e2, t) {
  for (let n2 = e2.attrs.length - 1; n2 >= 0; n2--)
    if (e2.attrs[n2].name === t)
      return e2.attrs[n2].value;
  return null;
}
var Ke3 = new Uint16Array(
  // prettier-ignore
  'ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((e2) => e2.charCodeAt(0))
);
var kf = new Uint16Array(
  // prettier-ignore
  "Ȁaglq	\x1Bɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((e2) => e2.charCodeAt(0))
);
var Vn;
var If = /* @__PURE__ */ new Map([
  [0, 65533],
  // C1 Unicode control character reference replacements
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var Sf = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
  (Vn = String.fromCodePoint) !== null && Vn !== void 0 ? Vn : function(e2) {
    let t = "";
    return e2 > 65535 && (e2 -= 65536, t += String.fromCharCode(e2 >>> 10 & 1023 | 55296), e2 = 56320 | e2 & 1023), t += String.fromCharCode(e2), t;
  }
);
function Nf(e2) {
  var t;
  return e2 >= 55296 && e2 <= 57343 || e2 > 1114111 ? 65533 : (t = If.get(e2)) !== null && t !== void 0 ? t : e2;
}
var pe4;
(function(e2) {
  e2[e2.NUM = 35] = "NUM", e2[e2.SEMI = 59] = "SEMI", e2[e2.EQUALS = 61] = "EQUALS", e2[e2.ZERO = 48] = "ZERO", e2[e2.NINE = 57] = "NINE", e2[e2.LOWER_A = 97] = "LOWER_A", e2[e2.LOWER_F = 102] = "LOWER_F", e2[e2.LOWER_X = 120] = "LOWER_X", e2[e2.LOWER_Z = 122] = "LOWER_Z", e2[e2.UPPER_A = 65] = "UPPER_A", e2[e2.UPPER_F = 70] = "UPPER_F", e2[e2.UPPER_Z = 90] = "UPPER_Z";
})(pe4 || (pe4 = {}));
var Rf = 32;
var Ue3;
(function(e2) {
  e2[e2.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e2[e2.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e2[e2.JUMP_TABLE = 127] = "JUMP_TABLE";
})(Ue3 || (Ue3 = {}));
function hr2(e2) {
  return e2 >= pe4.ZERO && e2 <= pe4.NINE;
}
function Lf(e2) {
  return e2 >= pe4.UPPER_A && e2 <= pe4.UPPER_F || e2 >= pe4.LOWER_A && e2 <= pe4.LOWER_F;
}
function Of(e2) {
  return e2 >= pe4.UPPER_A && e2 <= pe4.UPPER_Z || e2 >= pe4.LOWER_A && e2 <= pe4.LOWER_Z || hr2(e2);
}
function wf(e2) {
  return e2 === pe4.EQUALS || Of(e2);
}
var he2;
(function(e2) {
  e2[e2.EntityStart = 0] = "EntityStart", e2[e2.NumericStart = 1] = "NumericStart", e2[e2.NumericDecimal = 2] = "NumericDecimal", e2[e2.NumericHex = 3] = "NumericHex", e2[e2.NamedEntity = 4] = "NamedEntity";
})(he2 || (he2 = {}));
var st3;
(function(e2) {
  e2[e2.Legacy = 0] = "Legacy", e2[e2.Strict = 1] = "Strict", e2[e2.Attribute = 2] = "Attribute";
})(st3 || (st3 = {}));
var Df = class {
  constructor(t, n2, r) {
    this.decodeTree = t, this.emitCodePoint = n2, this.errors = r, this.state = he2.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = st3.Strict;
  }
  /** Resets the instance to make it reusable. */
  startEntity(t) {
    this.decodeMode = t, this.state = he2.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1;
  }
  /**
   * Write an entity to the decoder. This can be called multiple times with partial entities.
   * If the entity is incomplete, the decoder will return -1.
   *
   * Mirrors the implementation of `getDecoder`, but with the ability to stop decoding if the
   * entity is incomplete, and resume when the next string is written.
   *
   * @param string The string containing the entity (or a continuation of the entity).
   * @param offset The offset at which the entity begins. Should be 0 if this is not the first call.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  write(t, n2) {
    switch (this.state) {
      case he2.EntityStart:
        return t.charCodeAt(n2) === pe4.NUM ? (this.state = he2.NumericStart, this.consumed += 1, this.stateNumericStart(t, n2 + 1)) : (this.state = he2.NamedEntity, this.stateNamedEntity(t, n2));
      case he2.NumericStart:
        return this.stateNumericStart(t, n2);
      case he2.NumericDecimal:
        return this.stateNumericDecimal(t, n2);
      case he2.NumericHex:
        return this.stateNumericHex(t, n2);
      case he2.NamedEntity:
        return this.stateNamedEntity(t, n2);
    }
  }
  /**
   * Switches between the numeric decimal and hexadecimal states.
   *
   * Equivalent to the `Numeric character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericStart(t, n2) {
    return n2 >= t.length ? -1 : (t.charCodeAt(n2) | Rf) === pe4.LOWER_X ? (this.state = he2.NumericHex, this.consumed += 1, this.stateNumericHex(t, n2 + 1)) : (this.state = he2.NumericDecimal, this.stateNumericDecimal(t, n2));
  }
  addToNumericResult(t, n2, r, a3) {
    if (n2 !== r) {
      const u2 = r - n2;
      this.result = this.result * Math.pow(a3, u2) + parseInt(t.substr(n2, u2), a3), this.consumed += u2;
    }
  }
  /**
   * Parses a hexadecimal numeric entity.
   *
   * Equivalent to the `Hexademical character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericHex(t, n2) {
    const r = n2;
    for (; n2 < t.length; ) {
      const a3 = t.charCodeAt(n2);
      if (hr2(a3) || Lf(a3))
        n2 += 1;
      else
        return this.addToNumericResult(t, r, n2, 16), this.emitNumericEntity(a3, 3);
    }
    return this.addToNumericResult(t, r, n2, 16), -1;
  }
  /**
   * Parses a decimal numeric entity.
   *
   * Equivalent to the `Decimal character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNumericDecimal(t, n2) {
    const r = n2;
    for (; n2 < t.length; ) {
      const a3 = t.charCodeAt(n2);
      if (hr2(a3))
        n2 += 1;
      else
        return this.addToNumericResult(t, r, n2, 10), this.emitNumericEntity(a3, 2);
    }
    return this.addToNumericResult(t, r, n2, 10), -1;
  }
  /**
   * Validate and emit a numeric entity.
   *
   * Implements the logic from the `Hexademical character reference start
   * state` and `Numeric character reference end state` in the HTML spec.
   *
   * @param lastCp The last code point of the entity. Used to see if the
   *               entity was terminated with a semicolon.
   * @param expectedLength The minimum number of characters that should be
   *                       consumed. Used to validate that at least one digit
   *                       was consumed.
   * @returns The number of characters that were consumed.
   */
  emitNumericEntity(t, n2) {
    var r;
    if (this.consumed <= n2)
      return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
    if (t === pe4.SEMI)
      this.consumed += 1;
    else if (this.decodeMode === st3.Strict)
      return 0;
    return this.emitCodePoint(Nf(this.result), this.consumed), this.errors && (t !== pe4.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed;
  }
  /**
   * Parses a named entity.
   *
   * Equivalent to the `Named character reference state` in the HTML spec.
   *
   * @param str The string containing the entity (or a continuation of the entity).
   * @param offset The current offset.
   * @returns The number of characters that were consumed, or -1 if the entity is incomplete.
   */
  stateNamedEntity(t, n2) {
    const { decodeTree: r } = this;
    let a3 = r[this.treeIndex], u2 = (a3 & Ue3.VALUE_LENGTH) >> 14;
    for (; n2 < t.length; n2++, this.excess++) {
      const i2 = t.charCodeAt(n2);
      if (this.treeIndex = xu(r, a3, this.treeIndex + Math.max(1, u2), i2), this.treeIndex < 0)
        return this.result === 0 || // If we are parsing an attribute
        this.decodeMode === st3.Attribute && // We shouldn't have consumed any characters after the entity,
        (u2 === 0 || // And there should be no invalid characters.
        wf(i2)) ? 0 : this.emitNotTerminatedNamedEntity();
      if (a3 = r[this.treeIndex], u2 = (a3 & Ue3.VALUE_LENGTH) >> 14, u2 !== 0) {
        if (i2 === pe4.SEMI)
          return this.emitNamedEntityData(this.treeIndex, u2, this.consumed + this.excess);
        this.decodeMode !== st3.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0);
      }
    }
    return -1;
  }
  /**
   * Emit a named entity that was not terminated with a semicolon.
   *
   * @returns The number of characters consumed.
   */
  emitNotTerminatedNamedEntity() {
    var t;
    const { result: n2, decodeTree: r } = this, a3 = (r[n2] & Ue3.VALUE_LENGTH) >> 14;
    return this.emitNamedEntityData(n2, a3, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed;
  }
  /**
   * Emit a named entity.
   *
   * @param result The index of the entity in the decode tree.
   * @param valueLength The number of bytes in the entity.
   * @param consumed The number of characters consumed.
   *
   * @returns The number of characters consumed.
   */
  emitNamedEntityData(t, n2, r) {
    const { decodeTree: a3 } = this;
    return this.emitCodePoint(n2 === 1 ? a3[t] & ~Ue3.VALUE_LENGTH : a3[t + 1], r), n2 === 3 && this.emitCodePoint(a3[t + 2], r), r;
  }
  /**
   * Signal to the parser that the end of the input was reached.
   *
   * Remaining data will be emitted and relevant errors will be produced.
   *
   * @returns The number of characters consumed.
   */
  end() {
    var t;
    switch (this.state) {
      case he2.NamedEntity:
        return this.result !== 0 && (this.decodeMode !== st3.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
      case he2.NumericDecimal:
        return this.emitNumericEntity(0, 2);
      case he2.NumericHex:
        return this.emitNumericEntity(0, 3);
      case he2.NumericStart:
        return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0;
      case he2.EntityStart:
        return 0;
    }
  }
};
function Cu(e2) {
  let t = "";
  const n2 = new Df(e2, (r) => t += Sf(r));
  return function(a3, u2) {
    let i2 = 0, o2 = 0;
    for (; (o2 = a3.indexOf("&", o2)) >= 0; ) {
      t += a3.slice(i2, o2), n2.startEntity(u2);
      const c3 = n2.write(
        a3,
        // Skip the "&"
        o2 + 1
      );
      if (c3 < 0) {
        i2 = o2 + n2.end();
        break;
      }
      i2 = o2 + c3, o2 = c3 === 0 ? i2 + 1 : i2;
    }
    const l = t + a3.slice(i2);
    return t = "", l;
  };
}
function xu(e2, t, n2, r) {
  const a3 = (t & Ue3.BRANCH_LENGTH) >> 7, u2 = t & Ue3.JUMP_TABLE;
  if (a3 === 0)
    return u2 !== 0 && r === u2 ? n2 : -1;
  if (u2) {
    const l = r - u2;
    return l < 0 || l >= a3 ? -1 : e2[n2 + l] - 1;
  }
  let i2 = n2, o2 = i2 + a3 - 1;
  for (; i2 <= o2; ) {
    const l = i2 + o2 >>> 1, c3 = e2[l];
    if (c3 < r)
      i2 = l + 1;
    else if (c3 > r)
      o2 = l - 1;
    else
      return e2[l + a3];
  }
  return -1;
}
Cu(Ke3);
Cu(kf);
var L3;
(function(e2) {
  e2.HTML = "http://www.w3.org/1999/xhtml", e2.MATHML = "http://www.w3.org/1998/Math/MathML", e2.SVG = "http://www.w3.org/2000/svg", e2.XLINK = "http://www.w3.org/1999/xlink", e2.XML = "http://www.w3.org/XML/1998/namespace", e2.XMLNS = "http://www.w3.org/2000/xmlns/";
})(L3 = L3 || (L3 = {}));
var Je2;
(function(e2) {
  e2.TYPE = "type", e2.ACTION = "action", e2.ENCODING = "encoding", e2.PROMPT = "prompt", e2.NAME = "name", e2.COLOR = "color", e2.FACE = "face", e2.SIZE = "size";
})(Je2 = Je2 || (Je2 = {}));
var Se2;
(function(e2) {
  e2.NO_QUIRKS = "no-quirks", e2.QUIRKS = "quirks", e2.LIMITED_QUIRKS = "limited-quirks";
})(Se2 = Se2 || (Se2 = {}));
var k2;
(function(e2) {
  e2.A = "a", e2.ADDRESS = "address", e2.ANNOTATION_XML = "annotation-xml", e2.APPLET = "applet", e2.AREA = "area", e2.ARTICLE = "article", e2.ASIDE = "aside", e2.B = "b", e2.BASE = "base", e2.BASEFONT = "basefont", e2.BGSOUND = "bgsound", e2.BIG = "big", e2.BLOCKQUOTE = "blockquote", e2.BODY = "body", e2.BR = "br", e2.BUTTON = "button", e2.CAPTION = "caption", e2.CENTER = "center", e2.CODE = "code", e2.COL = "col", e2.COLGROUP = "colgroup", e2.DD = "dd", e2.DESC = "desc", e2.DETAILS = "details", e2.DIALOG = "dialog", e2.DIR = "dir", e2.DIV = "div", e2.DL = "dl", e2.DT = "dt", e2.EM = "em", e2.EMBED = "embed", e2.FIELDSET = "fieldset", e2.FIGCAPTION = "figcaption", e2.FIGURE = "figure", e2.FONT = "font", e2.FOOTER = "footer", e2.FOREIGN_OBJECT = "foreignObject", e2.FORM = "form", e2.FRAME = "frame", e2.FRAMESET = "frameset", e2.H1 = "h1", e2.H2 = "h2", e2.H3 = "h3", e2.H4 = "h4", e2.H5 = "h5", e2.H6 = "h6", e2.HEAD = "head", e2.HEADER = "header", e2.HGROUP = "hgroup", e2.HR = "hr", e2.HTML = "html", e2.I = "i", e2.IMG = "img", e2.IMAGE = "image", e2.INPUT = "input", e2.IFRAME = "iframe", e2.KEYGEN = "keygen", e2.LABEL = "label", e2.LI = "li", e2.LINK = "link", e2.LISTING = "listing", e2.MAIN = "main", e2.MALIGNMARK = "malignmark", e2.MARQUEE = "marquee", e2.MATH = "math", e2.MENU = "menu", e2.META = "meta", e2.MGLYPH = "mglyph", e2.MI = "mi", e2.MO = "mo", e2.MN = "mn", e2.MS = "ms", e2.MTEXT = "mtext", e2.NAV = "nav", e2.NOBR = "nobr", e2.NOFRAMES = "noframes", e2.NOEMBED = "noembed", e2.NOSCRIPT = "noscript", e2.OBJECT = "object", e2.OL = "ol", e2.OPTGROUP = "optgroup", e2.OPTION = "option", e2.P = "p", e2.PARAM = "param", e2.PLAINTEXT = "plaintext", e2.PRE = "pre", e2.RB = "rb", e2.RP = "rp", e2.RT = "rt", e2.RTC = "rtc", e2.RUBY = "ruby", e2.S = "s", e2.SCRIPT = "script", e2.SECTION = "section", e2.SELECT = "select", e2.SOURCE = "source", e2.SMALL = "small", e2.SPAN = "span", e2.STRIKE = "strike", e2.STRONG = "strong", e2.STYLE = "style", e2.SUB = "sub", e2.SUMMARY = "summary", e2.SUP = "sup", e2.TABLE = "table", e2.TBODY = "tbody", e2.TEMPLATE = "template", e2.TEXTAREA = "textarea", e2.TFOOT = "tfoot", e2.TD = "td", e2.TH = "th", e2.THEAD = "thead", e2.TITLE = "title", e2.TR = "tr", e2.TRACK = "track", e2.TT = "tt", e2.U = "u", e2.UL = "ul", e2.SVG = "svg", e2.VAR = "var", e2.WBR = "wbr", e2.XMP = "xmp";
})(k2 = k2 || (k2 = {}));
var s;
(function(e2) {
  e2[e2.UNKNOWN = 0] = "UNKNOWN", e2[e2.A = 1] = "A", e2[e2.ADDRESS = 2] = "ADDRESS", e2[e2.ANNOTATION_XML = 3] = "ANNOTATION_XML", e2[e2.APPLET = 4] = "APPLET", e2[e2.AREA = 5] = "AREA", e2[e2.ARTICLE = 6] = "ARTICLE", e2[e2.ASIDE = 7] = "ASIDE", e2[e2.B = 8] = "B", e2[e2.BASE = 9] = "BASE", e2[e2.BASEFONT = 10] = "BASEFONT", e2[e2.BGSOUND = 11] = "BGSOUND", e2[e2.BIG = 12] = "BIG", e2[e2.BLOCKQUOTE = 13] = "BLOCKQUOTE", e2[e2.BODY = 14] = "BODY", e2[e2.BR = 15] = "BR", e2[e2.BUTTON = 16] = "BUTTON", e2[e2.CAPTION = 17] = "CAPTION", e2[e2.CENTER = 18] = "CENTER", e2[e2.CODE = 19] = "CODE", e2[e2.COL = 20] = "COL", e2[e2.COLGROUP = 21] = "COLGROUP", e2[e2.DD = 22] = "DD", e2[e2.DESC = 23] = "DESC", e2[e2.DETAILS = 24] = "DETAILS", e2[e2.DIALOG = 25] = "DIALOG", e2[e2.DIR = 26] = "DIR", e2[e2.DIV = 27] = "DIV", e2[e2.DL = 28] = "DL", e2[e2.DT = 29] = "DT", e2[e2.EM = 30] = "EM", e2[e2.EMBED = 31] = "EMBED", e2[e2.FIELDSET = 32] = "FIELDSET", e2[e2.FIGCAPTION = 33] = "FIGCAPTION", e2[e2.FIGURE = 34] = "FIGURE", e2[e2.FONT = 35] = "FONT", e2[e2.FOOTER = 36] = "FOOTER", e2[e2.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e2[e2.FORM = 38] = "FORM", e2[e2.FRAME = 39] = "FRAME", e2[e2.FRAMESET = 40] = "FRAMESET", e2[e2.H1 = 41] = "H1", e2[e2.H2 = 42] = "H2", e2[e2.H3 = 43] = "H3", e2[e2.H4 = 44] = "H4", e2[e2.H5 = 45] = "H5", e2[e2.H6 = 46] = "H6", e2[e2.HEAD = 47] = "HEAD", e2[e2.HEADER = 48] = "HEADER", e2[e2.HGROUP = 49] = "HGROUP", e2[e2.HR = 50] = "HR", e2[e2.HTML = 51] = "HTML", e2[e2.I = 52] = "I", e2[e2.IMG = 53] = "IMG", e2[e2.IMAGE = 54] = "IMAGE", e2[e2.INPUT = 55] = "INPUT", e2[e2.IFRAME = 56] = "IFRAME", e2[e2.KEYGEN = 57] = "KEYGEN", e2[e2.LABEL = 58] = "LABEL", e2[e2.LI = 59] = "LI", e2[e2.LINK = 60] = "LINK", e2[e2.LISTING = 61] = "LISTING", e2[e2.MAIN = 62] = "MAIN", e2[e2.MALIGNMARK = 63] = "MALIGNMARK", e2[e2.MARQUEE = 64] = "MARQUEE", e2[e2.MATH = 65] = "MATH", e2[e2.MENU = 66] = "MENU", e2[e2.META = 67] = "META", e2[e2.MGLYPH = 68] = "MGLYPH", e2[e2.MI = 69] = "MI", e2[e2.MO = 70] = "MO", e2[e2.MN = 71] = "MN", e2[e2.MS = 72] = "MS", e2[e2.MTEXT = 73] = "MTEXT", e2[e2.NAV = 74] = "NAV", e2[e2.NOBR = 75] = "NOBR", e2[e2.NOFRAMES = 76] = "NOFRAMES", e2[e2.NOEMBED = 77] = "NOEMBED", e2[e2.NOSCRIPT = 78] = "NOSCRIPT", e2[e2.OBJECT = 79] = "OBJECT", e2[e2.OL = 80] = "OL", e2[e2.OPTGROUP = 81] = "OPTGROUP", e2[e2.OPTION = 82] = "OPTION", e2[e2.P = 83] = "P", e2[e2.PARAM = 84] = "PARAM", e2[e2.PLAINTEXT = 85] = "PLAINTEXT", e2[e2.PRE = 86] = "PRE", e2[e2.RB = 87] = "RB", e2[e2.RP = 88] = "RP", e2[e2.RT = 89] = "RT", e2[e2.RTC = 90] = "RTC", e2[e2.RUBY = 91] = "RUBY", e2[e2.S = 92] = "S", e2[e2.SCRIPT = 93] = "SCRIPT", e2[e2.SECTION = 94] = "SECTION", e2[e2.SELECT = 95] = "SELECT", e2[e2.SOURCE = 96] = "SOURCE", e2[e2.SMALL = 97] = "SMALL", e2[e2.SPAN = 98] = "SPAN", e2[e2.STRIKE = 99] = "STRIKE", e2[e2.STRONG = 100] = "STRONG", e2[e2.STYLE = 101] = "STYLE", e2[e2.SUB = 102] = "SUB", e2[e2.SUMMARY = 103] = "SUMMARY", e2[e2.SUP = 104] = "SUP", e2[e2.TABLE = 105] = "TABLE", e2[e2.TBODY = 106] = "TBODY", e2[e2.TEMPLATE = 107] = "TEMPLATE", e2[e2.TEXTAREA = 108] = "TEXTAREA", e2[e2.TFOOT = 109] = "TFOOT", e2[e2.TD = 110] = "TD", e2[e2.TH = 111] = "TH", e2[e2.THEAD = 112] = "THEAD", e2[e2.TITLE = 113] = "TITLE", e2[e2.TR = 114] = "TR", e2[e2.TRACK = 115] = "TRACK", e2[e2.TT = 116] = "TT", e2[e2.U = 117] = "U", e2[e2.UL = 118] = "UL", e2[e2.SVG = 119] = "SVG", e2[e2.VAR = 120] = "VAR", e2[e2.WBR = 121] = "WBR", e2[e2.XMP = 122] = "XMP";
})(s = s || (s = {}));
var Pf = /* @__PURE__ */ new Map([
  [k2.A, s.A],
  [k2.ADDRESS, s.ADDRESS],
  [k2.ANNOTATION_XML, s.ANNOTATION_XML],
  [k2.APPLET, s.APPLET],
  [k2.AREA, s.AREA],
  [k2.ARTICLE, s.ARTICLE],
  [k2.ASIDE, s.ASIDE],
  [k2.B, s.B],
  [k2.BASE, s.BASE],
  [k2.BASEFONT, s.BASEFONT],
  [k2.BGSOUND, s.BGSOUND],
  [k2.BIG, s.BIG],
  [k2.BLOCKQUOTE, s.BLOCKQUOTE],
  [k2.BODY, s.BODY],
  [k2.BR, s.BR],
  [k2.BUTTON, s.BUTTON],
  [k2.CAPTION, s.CAPTION],
  [k2.CENTER, s.CENTER],
  [k2.CODE, s.CODE],
  [k2.COL, s.COL],
  [k2.COLGROUP, s.COLGROUP],
  [k2.DD, s.DD],
  [k2.DESC, s.DESC],
  [k2.DETAILS, s.DETAILS],
  [k2.DIALOG, s.DIALOG],
  [k2.DIR, s.DIR],
  [k2.DIV, s.DIV],
  [k2.DL, s.DL],
  [k2.DT, s.DT],
  [k2.EM, s.EM],
  [k2.EMBED, s.EMBED],
  [k2.FIELDSET, s.FIELDSET],
  [k2.FIGCAPTION, s.FIGCAPTION],
  [k2.FIGURE, s.FIGURE],
  [k2.FONT, s.FONT],
  [k2.FOOTER, s.FOOTER],
  [k2.FOREIGN_OBJECT, s.FOREIGN_OBJECT],
  [k2.FORM, s.FORM],
  [k2.FRAME, s.FRAME],
  [k2.FRAMESET, s.FRAMESET],
  [k2.H1, s.H1],
  [k2.H2, s.H2],
  [k2.H3, s.H3],
  [k2.H4, s.H4],
  [k2.H5, s.H5],
  [k2.H6, s.H6],
  [k2.HEAD, s.HEAD],
  [k2.HEADER, s.HEADER],
  [k2.HGROUP, s.HGROUP],
  [k2.HR, s.HR],
  [k2.HTML, s.HTML],
  [k2.I, s.I],
  [k2.IMG, s.IMG],
  [k2.IMAGE, s.IMAGE],
  [k2.INPUT, s.INPUT],
  [k2.IFRAME, s.IFRAME],
  [k2.KEYGEN, s.KEYGEN],
  [k2.LABEL, s.LABEL],
  [k2.LI, s.LI],
  [k2.LINK, s.LINK],
  [k2.LISTING, s.LISTING],
  [k2.MAIN, s.MAIN],
  [k2.MALIGNMARK, s.MALIGNMARK],
  [k2.MARQUEE, s.MARQUEE],
  [k2.MATH, s.MATH],
  [k2.MENU, s.MENU],
  [k2.META, s.META],
  [k2.MGLYPH, s.MGLYPH],
  [k2.MI, s.MI],
  [k2.MO, s.MO],
  [k2.MN, s.MN],
  [k2.MS, s.MS],
  [k2.MTEXT, s.MTEXT],
  [k2.NAV, s.NAV],
  [k2.NOBR, s.NOBR],
  [k2.NOFRAMES, s.NOFRAMES],
  [k2.NOEMBED, s.NOEMBED],
  [k2.NOSCRIPT, s.NOSCRIPT],
  [k2.OBJECT, s.OBJECT],
  [k2.OL, s.OL],
  [k2.OPTGROUP, s.OPTGROUP],
  [k2.OPTION, s.OPTION],
  [k2.P, s.P],
  [k2.PARAM, s.PARAM],
  [k2.PLAINTEXT, s.PLAINTEXT],
  [k2.PRE, s.PRE],
  [k2.RB, s.RB],
  [k2.RP, s.RP],
  [k2.RT, s.RT],
  [k2.RTC, s.RTC],
  [k2.RUBY, s.RUBY],
  [k2.S, s.S],
  [k2.SCRIPT, s.SCRIPT],
  [k2.SECTION, s.SECTION],
  [k2.SELECT, s.SELECT],
  [k2.SOURCE, s.SOURCE],
  [k2.SMALL, s.SMALL],
  [k2.SPAN, s.SPAN],
  [k2.STRIKE, s.STRIKE],
  [k2.STRONG, s.STRONG],
  [k2.STYLE, s.STYLE],
  [k2.SUB, s.SUB],
  [k2.SUMMARY, s.SUMMARY],
  [k2.SUP, s.SUP],
  [k2.TABLE, s.TABLE],
  [k2.TBODY, s.TBODY],
  [k2.TEMPLATE, s.TEMPLATE],
  [k2.TEXTAREA, s.TEXTAREA],
  [k2.TFOOT, s.TFOOT],
  [k2.TD, s.TD],
  [k2.TH, s.TH],
  [k2.THEAD, s.THEAD],
  [k2.TITLE, s.TITLE],
  [k2.TR, s.TR],
  [k2.TRACK, s.TRACK],
  [k2.TT, s.TT],
  [k2.U, s.U],
  [k2.UL, s.UL],
  [k2.SVG, s.SVG],
  [k2.VAR, s.VAR],
  [k2.WBR, s.WBR],
  [k2.XMP, s.XMP]
]);
function Nt3(e2) {
  var t;
  return (t = Pf.get(e2)) !== null && t !== void 0 ? t : s.UNKNOWN;
}
var D3 = s;
var Mf = {
  [L3.HTML]: /* @__PURE__ */ new Set([
    D3.ADDRESS,
    D3.APPLET,
    D3.AREA,
    D3.ARTICLE,
    D3.ASIDE,
    D3.BASE,
    D3.BASEFONT,
    D3.BGSOUND,
    D3.BLOCKQUOTE,
    D3.BODY,
    D3.BR,
    D3.BUTTON,
    D3.CAPTION,
    D3.CENTER,
    D3.COL,
    D3.COLGROUP,
    D3.DD,
    D3.DETAILS,
    D3.DIR,
    D3.DIV,
    D3.DL,
    D3.DT,
    D3.EMBED,
    D3.FIELDSET,
    D3.FIGCAPTION,
    D3.FIGURE,
    D3.FOOTER,
    D3.FORM,
    D3.FRAME,
    D3.FRAMESET,
    D3.H1,
    D3.H2,
    D3.H3,
    D3.H4,
    D3.H5,
    D3.H6,
    D3.HEAD,
    D3.HEADER,
    D3.HGROUP,
    D3.HR,
    D3.HTML,
    D3.IFRAME,
    D3.IMG,
    D3.INPUT,
    D3.LI,
    D3.LINK,
    D3.LISTING,
    D3.MAIN,
    D3.MARQUEE,
    D3.MENU,
    D3.META,
    D3.NAV,
    D3.NOEMBED,
    D3.NOFRAMES,
    D3.NOSCRIPT,
    D3.OBJECT,
    D3.OL,
    D3.P,
    D3.PARAM,
    D3.PLAINTEXT,
    D3.PRE,
    D3.SCRIPT,
    D3.SECTION,
    D3.SELECT,
    D3.SOURCE,
    D3.STYLE,
    D3.SUMMARY,
    D3.TABLE,
    D3.TBODY,
    D3.TD,
    D3.TEMPLATE,
    D3.TEXTAREA,
    D3.TFOOT,
    D3.TH,
    D3.THEAD,
    D3.TITLE,
    D3.TR,
    D3.TRACK,
    D3.UL,
    D3.WBR,
    D3.XMP
  ]),
  [L3.MATHML]: /* @__PURE__ */ new Set([D3.MI, D3.MO, D3.MN, D3.MS, D3.MTEXT, D3.ANNOTATION_XML]),
  [L3.SVG]: /* @__PURE__ */ new Set([D3.TITLE, D3.FOREIGN_OBJECT, D3.DESC]),
  [L3.XLINK]: /* @__PURE__ */ new Set(),
  [L3.XML]: /* @__PURE__ */ new Set(),
  [L3.XMLNS]: /* @__PURE__ */ new Set()
};
function ku(e2) {
  return e2 === D3.H1 || e2 === D3.H2 || e2 === D3.H3 || e2 === D3.H4 || e2 === D3.H5 || e2 === D3.H6;
}
k2.STYLE, k2.SCRIPT, k2.XMP, k2.IFRAME, k2.NOEMBED, k2.NOFRAMES, k2.PLAINTEXT;
var Ff = /* @__PURE__ */ new Map([
  [128, 8364],
  [130, 8218],
  [131, 402],
  [132, 8222],
  [133, 8230],
  [134, 8224],
  [135, 8225],
  [136, 710],
  [137, 8240],
  [138, 352],
  [139, 8249],
  [140, 338],
  [142, 381],
  [145, 8216],
  [146, 8217],
  [147, 8220],
  [148, 8221],
  [149, 8226],
  [150, 8211],
  [151, 8212],
  [152, 732],
  [153, 8482],
  [154, 353],
  [155, 8250],
  [156, 339],
  [158, 382],
  [159, 376]
]);
var g;
(function(e2) {
  e2[e2.DATA = 0] = "DATA", e2[e2.RCDATA = 1] = "RCDATA", e2[e2.RAWTEXT = 2] = "RAWTEXT", e2[e2.SCRIPT_DATA = 3] = "SCRIPT_DATA", e2[e2.PLAINTEXT = 4] = "PLAINTEXT", e2[e2.TAG_OPEN = 5] = "TAG_OPEN", e2[e2.END_TAG_OPEN = 6] = "END_TAG_OPEN", e2[e2.TAG_NAME = 7] = "TAG_NAME", e2[e2.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e2[e2.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e2[e2.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e2[e2.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e2[e2.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e2[e2.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e2[e2.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e2[e2.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e2[e2.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e2[e2.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e2[e2.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e2[e2.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e2[e2.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e2[e2.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e2[e2.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e2[e2.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e2[e2.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e2[e2.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e2[e2.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e2[e2.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e2[e2.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e2[e2.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e2[e2.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e2[e2.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e2[e2.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e2[e2.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e2[e2.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e2[e2.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e2[e2.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e2[e2.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e2[e2.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e2[e2.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e2[e2.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e2[e2.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e2[e2.COMMENT_START = 42] = "COMMENT_START", e2[e2.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e2[e2.COMMENT = 44] = "COMMENT", e2[e2.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e2[e2.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e2[e2.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e2[e2.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e2[e2.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e2[e2.COMMENT_END = 50] = "COMMENT_END", e2[e2.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e2[e2.DOCTYPE = 52] = "DOCTYPE", e2[e2.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e2[e2.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e2[e2.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e2[e2.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e2[e2.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e2[e2.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e2[e2.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e2[e2.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e2[e2.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e2[e2.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e2[e2.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e2[e2.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e2[e2.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e2[e2.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e2[e2.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e2[e2.CDATA_SECTION = 68] = "CDATA_SECTION", e2[e2.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e2[e2.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e2[e2.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e2[e2.NAMED_CHARACTER_REFERENCE = 72] = "NAMED_CHARACTER_REFERENCE", e2[e2.AMBIGUOUS_AMPERSAND = 73] = "AMBIGUOUS_AMPERSAND", e2[e2.NUMERIC_CHARACTER_REFERENCE = 74] = "NUMERIC_CHARACTER_REFERENCE", e2[e2.HEXADEMICAL_CHARACTER_REFERENCE_START = 75] = "HEXADEMICAL_CHARACTER_REFERENCE_START", e2[e2.HEXADEMICAL_CHARACTER_REFERENCE = 76] = "HEXADEMICAL_CHARACTER_REFERENCE", e2[e2.DECIMAL_CHARACTER_REFERENCE = 77] = "DECIMAL_CHARACTER_REFERENCE", e2[e2.NUMERIC_CHARACTER_REFERENCE_END = 78] = "NUMERIC_CHARACTER_REFERENCE_END";
})(g || (g = {}));
var de2 = {
  DATA: g.DATA,
  RCDATA: g.RCDATA,
  RAWTEXT: g.RAWTEXT,
  SCRIPT_DATA: g.SCRIPT_DATA,
  PLAINTEXT: g.PLAINTEXT,
  CDATA_SECTION: g.CDATA_SECTION
};
function Ut3(e2) {
  return e2 >= p2.DIGIT_0 && e2 <= p2.DIGIT_9;
}
function Bt2(e2) {
  return e2 >= p2.LATIN_CAPITAL_A && e2 <= p2.LATIN_CAPITAL_Z;
}
function Bf(e2) {
  return e2 >= p2.LATIN_SMALL_A && e2 <= p2.LATIN_SMALL_Z;
}
function Ze2(e2) {
  return Bf(e2) || Bt2(e2);
}
function pr2(e2) {
  return Ze2(e2) || Ut3(e2);
}
function Iu(e2) {
  return e2 >= p2.LATIN_CAPITAL_A && e2 <= p2.LATIN_CAPITAL_F;
}
function Su(e2) {
  return e2 >= p2.LATIN_SMALL_A && e2 <= p2.LATIN_SMALL_F;
}
function vf(e2) {
  return Ut3(e2) || Iu(e2) || Su(e2);
}
function un(e2) {
  return e2 + 32;
}
function Nu(e2) {
  return e2 === p2.SPACE || e2 === p2.LINE_FEED || e2 === p2.TABULATION || e2 === p2.FORM_FEED;
}
function Hf(e2) {
  return e2 === p2.EQUALS_SIGN || pr2(e2);
}
function Xa(e2) {
  return Nu(e2) || e2 === p2.SOLIDUS || e2 === p2.GREATER_THAN_SIGN;
}
var Uf = class {
  constructor(t, n2) {
    this.options = t, this.handler = n2, this.paused = false, this.inLoop = false, this.inForeignNode = false, this.lastStartTagName = "", this.active = false, this.state = g.DATA, this.returnState = g.DATA, this.charRefCode = -1, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new xf(n2), this.currentLocation = this.getCurrentLocation(-1);
  }
  //Errors
  _err(t) {
    var n2, r;
    (r = (n2 = this.handler).onParseError) === null || r === void 0 || r.call(n2, this.preprocessor.getError(t));
  }
  // NOTE: `offset` may never run across line boundaries.
  getCurrentLocation(t) {
    return this.options.sourceCodeLocationInfo ? {
      startLine: this.preprocessor.line,
      startCol: this.preprocessor.col - t,
      startOffset: this.preprocessor.offset - t,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    } : null;
  }
  _runParsingLoop() {
    if (!this.inLoop) {
      for (this.inLoop = true; this.active && !this.paused; ) {
        this.consumedAfterSnapshot = 0;
        const t = this._consume();
        this._ensureHibernation() || this._callState(t);
      }
      this.inLoop = false;
    }
  }
  //API
  pause() {
    this.paused = true;
  }
  resume(t) {
    if (!this.paused)
      throw new Error("Parser was already resumed");
    this.paused = false, !this.inLoop && (this._runParsingLoop(), this.paused || t == null || t());
  }
  write(t, n2, r) {
    this.active = true, this.preprocessor.write(t, n2), this._runParsingLoop(), this.paused || r == null || r();
  }
  insertHtmlAtCurrentPos(t) {
    this.active = true, this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop();
  }
  //Hibernation
  _ensureHibernation() {
    return this.preprocessor.endOfChunkHit ? (this._unconsume(this.consumedAfterSnapshot), this.active = false, true) : false;
  }
  //Consumption
  _consume() {
    return this.consumedAfterSnapshot++, this.preprocessor.advance();
  }
  _unconsume(t) {
    this.consumedAfterSnapshot -= t, this.preprocessor.retreat(t);
  }
  _reconsumeInState(t, n2) {
    this.state = t, this._callState(n2);
  }
  _advanceBy(t) {
    this.consumedAfterSnapshot += t;
    for (let n2 = 0; n2 < t; n2++)
      this.preprocessor.advance();
  }
  _consumeSequenceIfMatch(t, n2) {
    return this.preprocessor.startsWith(t, n2) ? (this._advanceBy(t.length - 1), true) : false;
  }
  //Token creation
  _createStartTagToken() {
    this.currentToken = {
      type: X2.START_TAG,
      tagName: "",
      tagID: s.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(1)
    };
  }
  _createEndTagToken() {
    this.currentToken = {
      type: X2.END_TAG,
      tagName: "",
      tagID: s.UNKNOWN,
      selfClosing: false,
      ackSelfClosing: false,
      attrs: [],
      location: this.getCurrentLocation(2)
    };
  }
  _createCommentToken(t) {
    this.currentToken = {
      type: X2.COMMENT,
      data: "",
      location: this.getCurrentLocation(t)
    };
  }
  _createDoctypeToken(t) {
    this.currentToken = {
      type: X2.DOCTYPE,
      name: t,
      forceQuirks: false,
      publicId: null,
      systemId: null,
      location: this.currentLocation
    };
  }
  _createCharacterToken(t, n2) {
    this.currentCharacterToken = {
      type: t,
      chars: n2,
      location: this.currentLocation
    };
  }
  //Tag attributes
  _createAttr(t) {
    this.currentAttr = {
      name: t,
      value: ""
    }, this.currentLocation = this.getCurrentLocation(0);
  }
  _leaveAttrName() {
    var t, n2;
    const r = this.currentToken;
    if (_u(r, this.currentAttr.name) === null) {
      if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) {
        const a3 = (t = (n2 = r.location).attrs) !== null && t !== void 0 ? t : n2.attrs = /* @__PURE__ */ Object.create(null);
        a3[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue();
      }
    } else
      this._err(N.duplicateAttribute);
  }
  _leaveAttrValue() {
    this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset);
  }
  //Token emission
  prepareToken(t) {
    this._emitCurrentCharacterToken(t.location), this.currentToken = null, t.location && (t.location.endLine = this.preprocessor.line, t.location.endCol = this.preprocessor.col + 1, t.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1);
  }
  emitCurrentTagToken() {
    const t = this.currentToken;
    this.prepareToken(t), t.tagID = Nt3(t.tagName), t.type === X2.START_TAG ? (this.lastStartTagName = t.tagName, this.handler.onStartTag(t)) : (t.attrs.length > 0 && this._err(N.endTagWithAttributes), t.selfClosing && this._err(N.endTagWithTrailingSolidus), this.handler.onEndTag(t)), this.preprocessor.dropParsedChunk();
  }
  emitCurrentComment(t) {
    this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk();
  }
  emitCurrentDoctype(t) {
    this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk();
  }
  _emitCurrentCharacterToken(t) {
    if (this.currentCharacterToken) {
      switch (t && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t.startLine, this.currentCharacterToken.location.endCol = t.startCol, this.currentCharacterToken.location.endOffset = t.startOffset), this.currentCharacterToken.type) {
        case X2.CHARACTER: {
          this.handler.onCharacter(this.currentCharacterToken);
          break;
        }
        case X2.NULL_CHARACTER: {
          this.handler.onNullCharacter(this.currentCharacterToken);
          break;
        }
        case X2.WHITESPACE_CHARACTER: {
          this.handler.onWhitespaceCharacter(this.currentCharacterToken);
          break;
        }
      }
      this.currentCharacterToken = null;
    }
  }
  _emitEOFToken() {
    const t = this.getCurrentLocation(0);
    t && (t.endLine = t.startLine, t.endCol = t.startCol, t.endOffset = t.startOffset), this._emitCurrentCharacterToken(t), this.handler.onEof({ type: X2.EOF, location: t }), this.active = false;
  }
  //Characters emission
  //OPTIMIZATION: specification uses only one type of character tokens (one token per character).
  //This causes a huge memory overhead and a lot of unnecessary parser loops. parse5 uses 3 groups of characters.
  //If we have a sequence of characters that belong to the same group, the parser can process it
  //as a single solid character token.
  //So, there are 3 types of character tokens in parse5:
  //1)TokenType.NULL_CHARACTER - \u0000-character sequences (e.g. '\u0000\u0000\u0000')
  //2)TokenType.WHITESPACE_CHARACTER - any whitespace/new-line character sequences (e.g. '\n  \r\t   \f')
  //3)TokenType.CHARACTER - any character sequence which don't belong to groups 1 and 2 (e.g. 'abcdef1234@@#$%^')
  _appendCharToCurrentCharacterToken(t, n2) {
    if (this.currentCharacterToken)
      if (this.currentCharacterToken.type !== t)
        this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk();
      else {
        this.currentCharacterToken.chars += n2;
        return;
      }
    this._createCharacterToken(t, n2);
  }
  _emitCodePoint(t) {
    const n2 = Nu(t) ? X2.WHITESPACE_CHARACTER : t === p2.NULL ? X2.NULL_CHARACTER : X2.CHARACTER;
    this._appendCharToCurrentCharacterToken(n2, String.fromCodePoint(t));
  }
  //NOTE: used when we emit characters explicitly.
  //This is always for non-whitespace and non-null characters, which allows us to avoid additional checks.
  _emitChars(t) {
    this._appendCharToCurrentCharacterToken(X2.CHARACTER, t);
  }
  // Character reference helpers
  _matchNamedCharacterReference(t) {
    let n2 = null, r = 0, a3 = false;
    for (let u2 = 0, i2 = Ke3[0]; u2 >= 0 && (u2 = xu(Ke3, i2, u2 + 1, t), !(u2 < 0)); t = this._consume()) {
      r += 1, i2 = Ke3[u2];
      const o2 = i2 & Ue3.VALUE_LENGTH;
      if (o2) {
        const l = (o2 >> 14) - 1;
        if (t !== p2.SEMICOLON && this._isCharacterReferenceInAttribute() && Hf(this.preprocessor.peek(1)) ? (n2 = [p2.AMPERSAND], u2 += l) : (n2 = l === 0 ? [Ke3[u2] & ~Ue3.VALUE_LENGTH] : l === 1 ? [Ke3[++u2]] : [Ke3[++u2], Ke3[++u2]], r = 0, a3 = t !== p2.SEMICOLON), l === 0) {
          this._consume();
          break;
        }
      }
    }
    return this._unconsume(r), a3 && !this.preprocessor.endOfChunkHit && this._err(N.missingSemicolonAfterCharacterReference), this._unconsume(1), n2;
  }
  _isCharacterReferenceInAttribute() {
    return this.returnState === g.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === g.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === g.ATTRIBUTE_VALUE_UNQUOTED;
  }
  _flushCodePointConsumedAsCharacterReference(t) {
    this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t) : this._emitCodePoint(t);
  }
  // Calling states this way turns out to be much faster than any other approach.
  _callState(t) {
    switch (this.state) {
      case g.DATA: {
        this._stateData(t);
        break;
      }
      case g.RCDATA: {
        this._stateRcdata(t);
        break;
      }
      case g.RAWTEXT: {
        this._stateRawtext(t);
        break;
      }
      case g.SCRIPT_DATA: {
        this._stateScriptData(t);
        break;
      }
      case g.PLAINTEXT: {
        this._statePlaintext(t);
        break;
      }
      case g.TAG_OPEN: {
        this._stateTagOpen(t);
        break;
      }
      case g.END_TAG_OPEN: {
        this._stateEndTagOpen(t);
        break;
      }
      case g.TAG_NAME: {
        this._stateTagName(t);
        break;
      }
      case g.RCDATA_LESS_THAN_SIGN: {
        this._stateRcdataLessThanSign(t);
        break;
      }
      case g.RCDATA_END_TAG_OPEN: {
        this._stateRcdataEndTagOpen(t);
        break;
      }
      case g.RCDATA_END_TAG_NAME: {
        this._stateRcdataEndTagName(t);
        break;
      }
      case g.RAWTEXT_LESS_THAN_SIGN: {
        this._stateRawtextLessThanSign(t);
        break;
      }
      case g.RAWTEXT_END_TAG_OPEN: {
        this._stateRawtextEndTagOpen(t);
        break;
      }
      case g.RAWTEXT_END_TAG_NAME: {
        this._stateRawtextEndTagName(t);
        break;
      }
      case g.SCRIPT_DATA_LESS_THAN_SIGN: {
        this._stateScriptDataLessThanSign(t);
        break;
      }
      case g.SCRIPT_DATA_END_TAG_OPEN: {
        this._stateScriptDataEndTagOpen(t);
        break;
      }
      case g.SCRIPT_DATA_END_TAG_NAME: {
        this._stateScriptDataEndTagName(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPE_START: {
        this._stateScriptDataEscapeStart(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPE_START_DASH: {
        this._stateScriptDataEscapeStartDash(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPED: {
        this._stateScriptDataEscaped(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPED_DASH: {
        this._stateScriptDataEscapedDash(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPED_DASH_DASH: {
        this._stateScriptDataEscapedDashDash(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataEscapedLessThanSign(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: {
        this._stateScriptDataEscapedEndTagOpen(t);
        break;
      }
      case g.SCRIPT_DATA_ESCAPED_END_TAG_NAME: {
        this._stateScriptDataEscapedEndTagName(t);
        break;
      }
      case g.SCRIPT_DATA_DOUBLE_ESCAPE_START: {
        this._stateScriptDataDoubleEscapeStart(t);
        break;
      }
      case g.SCRIPT_DATA_DOUBLE_ESCAPED: {
        this._stateScriptDataDoubleEscaped(t);
        break;
      }
      case g.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: {
        this._stateScriptDataDoubleEscapedDash(t);
        break;
      }
      case g.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: {
        this._stateScriptDataDoubleEscapedDashDash(t);
        break;
      }
      case g.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: {
        this._stateScriptDataDoubleEscapedLessThanSign(t);
        break;
      }
      case g.SCRIPT_DATA_DOUBLE_ESCAPE_END: {
        this._stateScriptDataDoubleEscapeEnd(t);
        break;
      }
      case g.BEFORE_ATTRIBUTE_NAME: {
        this._stateBeforeAttributeName(t);
        break;
      }
      case g.ATTRIBUTE_NAME: {
        this._stateAttributeName(t);
        break;
      }
      case g.AFTER_ATTRIBUTE_NAME: {
        this._stateAfterAttributeName(t);
        break;
      }
      case g.BEFORE_ATTRIBUTE_VALUE: {
        this._stateBeforeAttributeValue(t);
        break;
      }
      case g.ATTRIBUTE_VALUE_DOUBLE_QUOTED: {
        this._stateAttributeValueDoubleQuoted(t);
        break;
      }
      case g.ATTRIBUTE_VALUE_SINGLE_QUOTED: {
        this._stateAttributeValueSingleQuoted(t);
        break;
      }
      case g.ATTRIBUTE_VALUE_UNQUOTED: {
        this._stateAttributeValueUnquoted(t);
        break;
      }
      case g.AFTER_ATTRIBUTE_VALUE_QUOTED: {
        this._stateAfterAttributeValueQuoted(t);
        break;
      }
      case g.SELF_CLOSING_START_TAG: {
        this._stateSelfClosingStartTag(t);
        break;
      }
      case g.BOGUS_COMMENT: {
        this._stateBogusComment(t);
        break;
      }
      case g.MARKUP_DECLARATION_OPEN: {
        this._stateMarkupDeclarationOpen(t);
        break;
      }
      case g.COMMENT_START: {
        this._stateCommentStart(t);
        break;
      }
      case g.COMMENT_START_DASH: {
        this._stateCommentStartDash(t);
        break;
      }
      case g.COMMENT: {
        this._stateComment(t);
        break;
      }
      case g.COMMENT_LESS_THAN_SIGN: {
        this._stateCommentLessThanSign(t);
        break;
      }
      case g.COMMENT_LESS_THAN_SIGN_BANG: {
        this._stateCommentLessThanSignBang(t);
        break;
      }
      case g.COMMENT_LESS_THAN_SIGN_BANG_DASH: {
        this._stateCommentLessThanSignBangDash(t);
        break;
      }
      case g.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: {
        this._stateCommentLessThanSignBangDashDash(t);
        break;
      }
      case g.COMMENT_END_DASH: {
        this._stateCommentEndDash(t);
        break;
      }
      case g.COMMENT_END: {
        this._stateCommentEnd(t);
        break;
      }
      case g.COMMENT_END_BANG: {
        this._stateCommentEndBang(t);
        break;
      }
      case g.DOCTYPE: {
        this._stateDoctype(t);
        break;
      }
      case g.BEFORE_DOCTYPE_NAME: {
        this._stateBeforeDoctypeName(t);
        break;
      }
      case g.DOCTYPE_NAME: {
        this._stateDoctypeName(t);
        break;
      }
      case g.AFTER_DOCTYPE_NAME: {
        this._stateAfterDoctypeName(t);
        break;
      }
      case g.AFTER_DOCTYPE_PUBLIC_KEYWORD: {
        this._stateAfterDoctypePublicKeyword(t);
        break;
      }
      case g.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateBeforeDoctypePublicIdentifier(t);
        break;
      }
      case g.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypePublicIdentifierDoubleQuoted(t);
        break;
      }
      case g.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypePublicIdentifierSingleQuoted(t);
        break;
      }
      case g.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: {
        this._stateAfterDoctypePublicIdentifier(t);
        break;
      }
      case g.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: {
        this._stateBetweenDoctypePublicAndSystemIdentifiers(t);
        break;
      }
      case g.AFTER_DOCTYPE_SYSTEM_KEYWORD: {
        this._stateAfterDoctypeSystemKeyword(t);
        break;
      }
      case g.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateBeforeDoctypeSystemIdentifier(t);
        break;
      }
      case g.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: {
        this._stateDoctypeSystemIdentifierDoubleQuoted(t);
        break;
      }
      case g.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: {
        this._stateDoctypeSystemIdentifierSingleQuoted(t);
        break;
      }
      case g.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: {
        this._stateAfterDoctypeSystemIdentifier(t);
        break;
      }
      case g.BOGUS_DOCTYPE: {
        this._stateBogusDoctype(t);
        break;
      }
      case g.CDATA_SECTION: {
        this._stateCdataSection(t);
        break;
      }
      case g.CDATA_SECTION_BRACKET: {
        this._stateCdataSectionBracket(t);
        break;
      }
      case g.CDATA_SECTION_END: {
        this._stateCdataSectionEnd(t);
        break;
      }
      case g.CHARACTER_REFERENCE: {
        this._stateCharacterReference(t);
        break;
      }
      case g.NAMED_CHARACTER_REFERENCE: {
        this._stateNamedCharacterReference(t);
        break;
      }
      case g.AMBIGUOUS_AMPERSAND: {
        this._stateAmbiguousAmpersand(t);
        break;
      }
      case g.NUMERIC_CHARACTER_REFERENCE: {
        this._stateNumericCharacterReference(t);
        break;
      }
      case g.HEXADEMICAL_CHARACTER_REFERENCE_START: {
        this._stateHexademicalCharacterReferenceStart(t);
        break;
      }
      case g.HEXADEMICAL_CHARACTER_REFERENCE: {
        this._stateHexademicalCharacterReference(t);
        break;
      }
      case g.DECIMAL_CHARACTER_REFERENCE: {
        this._stateDecimalCharacterReference(t);
        break;
      }
      case g.NUMERIC_CHARACTER_REFERENCE_END: {
        this._stateNumericCharacterReferenceEnd(t);
        break;
      }
      default:
        throw new Error("Unknown state");
    }
  }
  // State machine
  // Data state
  //------------------------------------------------------------------
  _stateData(t) {
    switch (t) {
      case p2.LESS_THAN_SIGN: {
        this.state = g.TAG_OPEN;
        break;
      }
      case p2.AMPERSAND: {
        this.returnState = g.DATA, this.state = g.CHARACTER_REFERENCE;
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), this._emitCodePoint(t);
        break;
      }
      case p2.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  //  RCDATA state
  //------------------------------------------------------------------
  _stateRcdata(t) {
    switch (t) {
      case p2.AMPERSAND: {
        this.returnState = g.RCDATA, this.state = g.CHARACTER_REFERENCE;
        break;
      }
      case p2.LESS_THAN_SIGN: {
        this.state = g.RCDATA_LESS_THAN_SIGN;
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), this._emitChars(le3);
        break;
      }
      case p2.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // RAWTEXT state
  //------------------------------------------------------------------
  _stateRawtext(t) {
    switch (t) {
      case p2.LESS_THAN_SIGN: {
        this.state = g.RAWTEXT_LESS_THAN_SIGN;
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), this._emitChars(le3);
        break;
      }
      case p2.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data state
  //------------------------------------------------------------------
  _stateScriptData(t) {
    switch (t) {
      case p2.LESS_THAN_SIGN: {
        this.state = g.SCRIPT_DATA_LESS_THAN_SIGN;
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), this._emitChars(le3);
        break;
      }
      case p2.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // PLAINTEXT state
  //------------------------------------------------------------------
  _statePlaintext(t) {
    switch (t) {
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), this._emitChars(le3);
        break;
      }
      case p2.EOF: {
        this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Tag open state
  //------------------------------------------------------------------
  _stateTagOpen(t) {
    if (Ze2(t))
      this._createStartTagToken(), this.state = g.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case p2.EXCLAMATION_MARK: {
          this.state = g.MARKUP_DECLARATION_OPEN;
          break;
        }
        case p2.SOLIDUS: {
          this.state = g.END_TAG_OPEN;
          break;
        }
        case p2.QUESTION_MARK: {
          this._err(N.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = g.BOGUS_COMMENT, this._stateBogusComment(t);
          break;
        }
        case p2.EOF: {
          this._err(N.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken();
          break;
        }
        default:
          this._err(N.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = g.DATA, this._stateData(t);
      }
  }
  // End tag open state
  //------------------------------------------------------------------
  _stateEndTagOpen(t) {
    if (Ze2(t))
      this._createEndTagToken(), this.state = g.TAG_NAME, this._stateTagName(t);
    else
      switch (t) {
        case p2.GREATER_THAN_SIGN: {
          this._err(N.missingEndTagName), this.state = g.DATA;
          break;
        }
        case p2.EOF: {
          this._err(N.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken();
          break;
        }
        default:
          this._err(N.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = g.BOGUS_COMMENT, this._stateBogusComment(t);
      }
  }
  // Tag name state
  //------------------------------------------------------------------
  _stateTagName(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED: {
        this.state = g.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case p2.SOLIDUS: {
        this.state = g.SELF_CLOSING_START_TAG;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this.state = g.DATA, this.emitCurrentTagToken();
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), n2.tagName += le3;
        break;
      }
      case p2.EOF: {
        this._err(N.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        n2.tagName += String.fromCodePoint(Bt2(t) ? un(t) : t);
    }
  }
  // RCDATA less-than sign state
  //------------------------------------------------------------------
  _stateRcdataLessThanSign(t) {
    t === p2.SOLIDUS ? this.state = g.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = g.RCDATA, this._stateRcdata(t));
  }
  // RCDATA end tag open state
  //------------------------------------------------------------------
  _stateRcdataEndTagOpen(t) {
    Ze2(t) ? (this.state = g.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t)) : (this._emitChars("</"), this.state = g.RCDATA, this._stateRcdata(t));
  }
  handleSpecialEndTag(t) {
    if (!this.preprocessor.startsWith(this.lastStartTagName, false))
      return !this._ensureHibernation();
    this._createEndTagToken();
    const n2 = this.currentToken;
    switch (n2.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED:
        return this._advanceBy(this.lastStartTagName.length), this.state = g.BEFORE_ATTRIBUTE_NAME, false;
      case p2.SOLIDUS:
        return this._advanceBy(this.lastStartTagName.length), this.state = g.SELF_CLOSING_START_TAG, false;
      case p2.GREATER_THAN_SIGN:
        return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = g.DATA, false;
      default:
        return !this._ensureHibernation();
    }
  }
  // RCDATA end tag name state
  //------------------------------------------------------------------
  _stateRcdataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = g.RCDATA, this._stateRcdata(t));
  }
  // RAWTEXT less-than sign state
  //------------------------------------------------------------------
  _stateRawtextLessThanSign(t) {
    t === p2.SOLIDUS ? this.state = g.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = g.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag open state
  //------------------------------------------------------------------
  _stateRawtextEndTagOpen(t) {
    Ze2(t) ? (this.state = g.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t)) : (this._emitChars("</"), this.state = g.RAWTEXT, this._stateRawtext(t));
  }
  // RAWTEXT end tag name state
  //------------------------------------------------------------------
  _stateRawtextEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = g.RAWTEXT, this._stateRawtext(t));
  }
  // Script data less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataLessThanSign(t) {
    switch (t) {
      case p2.SOLIDUS: {
        this.state = g.SCRIPT_DATA_END_TAG_OPEN;
        break;
      }
      case p2.EXCLAMATION_MARK: {
        this.state = g.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!");
        break;
      }
      default:
        this._emitChars("<"), this.state = g.SCRIPT_DATA, this._stateScriptData(t);
    }
  }
  // Script data end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEndTagOpen(t) {
    Ze2(t) ? (this.state = g.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t)) : (this._emitChars("</"), this.state = g.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = g.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStart(t) {
    t === p2.HYPHEN_MINUS ? (this.state = g.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = g.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escape start dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapeStartDash(t) {
    t === p2.HYPHEN_MINUS ? (this.state = g.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = g.SCRIPT_DATA, this._stateScriptData(t));
  }
  // Script data escaped state
  //------------------------------------------------------------------
  _stateScriptDataEscaped(t) {
    switch (t) {
      case p2.HYPHEN_MINUS: {
        this.state = g.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case p2.LESS_THAN_SIGN: {
        this.state = g.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), this._emitChars(le3);
        break;
      }
      case p2.EOF: {
        this._err(N.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDash(t) {
    switch (t) {
      case p2.HYPHEN_MINUS: {
        this.state = g.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case p2.LESS_THAN_SIGN: {
        this.state = g.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), this.state = g.SCRIPT_DATA_ESCAPED, this._emitChars(le3);
        break;
      }
      case p2.EOF: {
        this._err(N.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = g.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataEscapedDashDash(t) {
    switch (t) {
      case p2.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case p2.LESS_THAN_SIGN: {
        this.state = g.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this.state = g.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), this.state = g.SCRIPT_DATA_ESCAPED, this._emitChars(le3);
        break;
      }
      case p2.EOF: {
        this._err(N.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = g.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataEscapedLessThanSign(t) {
    t === p2.SOLIDUS ? this.state = g.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : Ze2(t) ? (this._emitChars("<"), this.state = g.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t)) : (this._emitChars("<"), this.state = g.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag open state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagOpen(t) {
    Ze2(t) ? (this.state = g.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t)) : (this._emitChars("</"), this.state = g.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data escaped end tag name state
  //------------------------------------------------------------------
  _stateScriptDataEscapedEndTagName(t) {
    this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = g.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escape start state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeStart(t) {
    if (this.preprocessor.startsWith(_e2.SCRIPT, false) && Xa(this.preprocessor.peek(_e2.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n2 = 0; n2 < _e2.SCRIPT.length; n2++)
        this._emitCodePoint(this._consume());
      this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED;
    } else this._ensureHibernation() || (this.state = g.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t));
  }
  // Script data double escaped state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscaped(t) {
    switch (t) {
      case p2.HYPHEN_MINUS: {
        this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-");
        break;
      }
      case p2.LESS_THAN_SIGN: {
        this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), this._emitChars(le3);
        break;
      }
      case p2.EOF: {
        this._err(N.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDash(t) {
    switch (t) {
      case p2.HYPHEN_MINUS: {
        this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-");
        break;
      }
      case p2.LESS_THAN_SIGN: {
        this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(le3);
        break;
      }
      case p2.EOF: {
        this._err(N.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped dash dash state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedDashDash(t) {
    switch (t) {
      case p2.HYPHEN_MINUS: {
        this._emitChars("-");
        break;
      }
      case p2.LESS_THAN_SIGN: {
        this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<");
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this.state = g.SCRIPT_DATA, this._emitChars(">");
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(le3);
        break;
      }
      case p2.EOF: {
        this._err(N.eofInScriptHtmlCommentLikeText), this._emitEOFToken();
        break;
      }
      default:
        this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t);
    }
  }
  // Script data double escaped less-than sign state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapedLessThanSign(t) {
    t === p2.SOLIDUS ? (this.state = g.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Script data double escape end state
  //------------------------------------------------------------------
  _stateScriptDataDoubleEscapeEnd(t) {
    if (this.preprocessor.startsWith(_e2.SCRIPT, false) && Xa(this.preprocessor.peek(_e2.SCRIPT.length))) {
      this._emitCodePoint(t);
      for (let n2 = 0; n2 < _e2.SCRIPT.length; n2++)
        this._emitCodePoint(this._consume());
      this.state = g.SCRIPT_DATA_ESCAPED;
    } else this._ensureHibernation() || (this.state = g.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t));
  }
  // Before attribute name state
  //------------------------------------------------------------------
  _stateBeforeAttributeName(t) {
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED:
        break;
      case p2.SOLIDUS:
      case p2.GREATER_THAN_SIGN:
      case p2.EOF: {
        this.state = g.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case p2.EQUALS_SIGN: {
        this._err(N.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = g.ATTRIBUTE_NAME;
        break;
      }
      default:
        this._createAttr(""), this.state = g.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Attribute name state
  //------------------------------------------------------------------
  _stateAttributeName(t) {
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED:
      case p2.SOLIDUS:
      case p2.GREATER_THAN_SIGN:
      case p2.EOF: {
        this._leaveAttrName(), this.state = g.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t);
        break;
      }
      case p2.EQUALS_SIGN: {
        this._leaveAttrName(), this.state = g.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case p2.QUOTATION_MARK:
      case p2.APOSTROPHE:
      case p2.LESS_THAN_SIGN: {
        this._err(N.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t);
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), this.currentAttr.name += le3;
        break;
      }
      default:
        this.currentAttr.name += String.fromCodePoint(Bt2(t) ? un(t) : t);
    }
  }
  // After attribute name state
  //------------------------------------------------------------------
  _stateAfterAttributeName(t) {
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED:
        break;
      case p2.SOLIDUS: {
        this.state = g.SELF_CLOSING_START_TAG;
        break;
      }
      case p2.EQUALS_SIGN: {
        this.state = g.BEFORE_ATTRIBUTE_VALUE;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this.state = g.DATA, this.emitCurrentTagToken();
        break;
      }
      case p2.EOF: {
        this._err(N.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._createAttr(""), this.state = g.ATTRIBUTE_NAME, this._stateAttributeName(t);
    }
  }
  // Before attribute value state
  //------------------------------------------------------------------
  _stateBeforeAttributeValue(t) {
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED:
        break;
      case p2.QUOTATION_MARK: {
        this.state = g.ATTRIBUTE_VALUE_DOUBLE_QUOTED;
        break;
      }
      case p2.APOSTROPHE: {
        this.state = g.ATTRIBUTE_VALUE_SINGLE_QUOTED;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this._err(N.missingAttributeValue), this.state = g.DATA, this.emitCurrentTagToken();
        break;
      }
      default:
        this.state = g.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t);
    }
  }
  // Attribute value (double-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueDoubleQuoted(t) {
    switch (t) {
      case p2.QUOTATION_MARK: {
        this.state = g.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case p2.AMPERSAND: {
        this.returnState = g.ATTRIBUTE_VALUE_DOUBLE_QUOTED, this.state = g.CHARACTER_REFERENCE;
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), this.currentAttr.value += le3;
        break;
      }
      case p2.EOF: {
        this._err(N.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (single-quoted) state
  //------------------------------------------------------------------
  _stateAttributeValueSingleQuoted(t) {
    switch (t) {
      case p2.APOSTROPHE: {
        this.state = g.AFTER_ATTRIBUTE_VALUE_QUOTED;
        break;
      }
      case p2.AMPERSAND: {
        this.returnState = g.ATTRIBUTE_VALUE_SINGLE_QUOTED, this.state = g.CHARACTER_REFERENCE;
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), this.currentAttr.value += le3;
        break;
      }
      case p2.EOF: {
        this._err(N.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // Attribute value (unquoted) state
  //------------------------------------------------------------------
  _stateAttributeValueUnquoted(t) {
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED: {
        this._leaveAttrValue(), this.state = g.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case p2.AMPERSAND: {
        this.returnState = g.ATTRIBUTE_VALUE_UNQUOTED, this.state = g.CHARACTER_REFERENCE;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = g.DATA, this.emitCurrentTagToken();
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), this.currentAttr.value += le3;
        break;
      }
      case p2.QUOTATION_MARK:
      case p2.APOSTROPHE:
      case p2.LESS_THAN_SIGN:
      case p2.EQUALS_SIGN:
      case p2.GRAVE_ACCENT: {
        this._err(N.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t);
        break;
      }
      case p2.EOF: {
        this._err(N.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this.currentAttr.value += String.fromCodePoint(t);
    }
  }
  // After attribute value (quoted) state
  //------------------------------------------------------------------
  _stateAfterAttributeValueQuoted(t) {
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED: {
        this._leaveAttrValue(), this.state = g.BEFORE_ATTRIBUTE_NAME;
        break;
      }
      case p2.SOLIDUS: {
        this._leaveAttrValue(), this.state = g.SELF_CLOSING_START_TAG;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this._leaveAttrValue(), this.state = g.DATA, this.emitCurrentTagToken();
        break;
      }
      case p2.EOF: {
        this._err(N.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingWhitespaceBetweenAttributes), this.state = g.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Self-closing start tag state
  //------------------------------------------------------------------
  _stateSelfClosingStartTag(t) {
    switch (t) {
      case p2.GREATER_THAN_SIGN: {
        const n2 = this.currentToken;
        n2.selfClosing = true, this.state = g.DATA, this.emitCurrentTagToken();
        break;
      }
      case p2.EOF: {
        this._err(N.eofInTag), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.unexpectedSolidusInTag), this.state = g.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t);
    }
  }
  // Bogus comment state
  //------------------------------------------------------------------
  _stateBogusComment(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.GREATER_THAN_SIGN: {
        this.state = g.DATA, this.emitCurrentComment(n2);
        break;
      }
      case p2.EOF: {
        this.emitCurrentComment(n2), this._emitEOFToken();
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), n2.data += le3;
        break;
      }
      default:
        n2.data += String.fromCodePoint(t);
    }
  }
  // Markup declaration open state
  //------------------------------------------------------------------
  _stateMarkupDeclarationOpen(t) {
    this._consumeSequenceIfMatch(_e2.DASH_DASH, true) ? (this._createCommentToken(_e2.DASH_DASH.length + 1), this.state = g.COMMENT_START) : this._consumeSequenceIfMatch(_e2.DOCTYPE, false) ? (this.currentLocation = this.getCurrentLocation(_e2.DOCTYPE.length + 1), this.state = g.DOCTYPE) : this._consumeSequenceIfMatch(_e2.CDATA_START, true) ? this.inForeignNode ? this.state = g.CDATA_SECTION : (this._err(N.cdataInHtmlContent), this._createCommentToken(_e2.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = g.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(N.incorrectlyOpenedComment), this._createCommentToken(2), this.state = g.BOGUS_COMMENT, this._stateBogusComment(t));
  }
  // Comment start state
  //------------------------------------------------------------------
  _stateCommentStart(t) {
    switch (t) {
      case p2.HYPHEN_MINUS: {
        this.state = g.COMMENT_START_DASH;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this._err(N.abruptClosingOfEmptyComment), this.state = g.DATA;
        const n2 = this.currentToken;
        this.emitCurrentComment(n2);
        break;
      }
      default:
        this.state = g.COMMENT, this._stateComment(t);
    }
  }
  // Comment start dash state
  //------------------------------------------------------------------
  _stateCommentStartDash(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.HYPHEN_MINUS: {
        this.state = g.COMMENT_END;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this._err(N.abruptClosingOfEmptyComment), this.state = g.DATA, this.emitCurrentComment(n2);
        break;
      }
      case p2.EOF: {
        this._err(N.eofInComment), this.emitCurrentComment(n2), this._emitEOFToken();
        break;
      }
      default:
        n2.data += "-", this.state = g.COMMENT, this._stateComment(t);
    }
  }
  // Comment state
  //------------------------------------------------------------------
  _stateComment(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.HYPHEN_MINUS: {
        this.state = g.COMMENT_END_DASH;
        break;
      }
      case p2.LESS_THAN_SIGN: {
        n2.data += "<", this.state = g.COMMENT_LESS_THAN_SIGN;
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), n2.data += le3;
        break;
      }
      case p2.EOF: {
        this._err(N.eofInComment), this.emitCurrentComment(n2), this._emitEOFToken();
        break;
      }
      default:
        n2.data += String.fromCodePoint(t);
    }
  }
  // Comment less-than sign state
  //------------------------------------------------------------------
  _stateCommentLessThanSign(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.EXCLAMATION_MARK: {
        n2.data += "!", this.state = g.COMMENT_LESS_THAN_SIGN_BANG;
        break;
      }
      case p2.LESS_THAN_SIGN: {
        n2.data += "<";
        break;
      }
      default:
        this.state = g.COMMENT, this._stateComment(t);
    }
  }
  // Comment less-than sign bang state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBang(t) {
    t === p2.HYPHEN_MINUS ? this.state = g.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = g.COMMENT, this._stateComment(t));
  }
  // Comment less-than sign bang dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDash(t) {
    t === p2.HYPHEN_MINUS ? this.state = g.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = g.COMMENT_END_DASH, this._stateCommentEndDash(t));
  }
  // Comment less-than sign bang dash dash state
  //------------------------------------------------------------------
  _stateCommentLessThanSignBangDashDash(t) {
    t !== p2.GREATER_THAN_SIGN && t !== p2.EOF && this._err(N.nestedComment), this.state = g.COMMENT_END, this._stateCommentEnd(t);
  }
  // Comment end dash state
  //------------------------------------------------------------------
  _stateCommentEndDash(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.HYPHEN_MINUS: {
        this.state = g.COMMENT_END;
        break;
      }
      case p2.EOF: {
        this._err(N.eofInComment), this.emitCurrentComment(n2), this._emitEOFToken();
        break;
      }
      default:
        n2.data += "-", this.state = g.COMMENT, this._stateComment(t);
    }
  }
  // Comment end state
  //------------------------------------------------------------------
  _stateCommentEnd(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.GREATER_THAN_SIGN: {
        this.state = g.DATA, this.emitCurrentComment(n2);
        break;
      }
      case p2.EXCLAMATION_MARK: {
        this.state = g.COMMENT_END_BANG;
        break;
      }
      case p2.HYPHEN_MINUS: {
        n2.data += "-";
        break;
      }
      case p2.EOF: {
        this._err(N.eofInComment), this.emitCurrentComment(n2), this._emitEOFToken();
        break;
      }
      default:
        n2.data += "--", this.state = g.COMMENT, this._stateComment(t);
    }
  }
  // Comment end bang state
  //------------------------------------------------------------------
  _stateCommentEndBang(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.HYPHEN_MINUS: {
        n2.data += "--!", this.state = g.COMMENT_END_DASH;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this._err(N.incorrectlyClosedComment), this.state = g.DATA, this.emitCurrentComment(n2);
        break;
      }
      case p2.EOF: {
        this._err(N.eofInComment), this.emitCurrentComment(n2), this._emitEOFToken();
        break;
      }
      default:
        n2.data += "--!", this.state = g.COMMENT, this._stateComment(t);
    }
  }
  // DOCTYPE state
  //------------------------------------------------------------------
  _stateDoctype(t) {
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED: {
        this.state = g.BEFORE_DOCTYPE_NAME;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this.state = g.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
        break;
      }
      case p2.EOF: {
        this._err(N.eofInDoctype), this._createDoctypeToken(null);
        const n2 = this.currentToken;
        n2.forceQuirks = true, this.emitCurrentDoctype(n2), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingWhitespaceBeforeDoctypeName), this.state = g.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t);
    }
  }
  // Before DOCTYPE name state
  //------------------------------------------------------------------
  _stateBeforeDoctypeName(t) {
    if (Bt2(t))
      this._createDoctypeToken(String.fromCharCode(un(t))), this.state = g.DOCTYPE_NAME;
    else
      switch (t) {
        case p2.SPACE:
        case p2.LINE_FEED:
        case p2.TABULATION:
        case p2.FORM_FEED:
          break;
        case p2.NULL: {
          this._err(N.unexpectedNullCharacter), this._createDoctypeToken(le3), this.state = g.DOCTYPE_NAME;
          break;
        }
        case p2.GREATER_THAN_SIGN: {
          this._err(N.missingDoctypeName), this._createDoctypeToken(null);
          const n2 = this.currentToken;
          n2.forceQuirks = true, this.emitCurrentDoctype(n2), this.state = g.DATA;
          break;
        }
        case p2.EOF: {
          this._err(N.eofInDoctype), this._createDoctypeToken(null);
          const n2 = this.currentToken;
          n2.forceQuirks = true, this.emitCurrentDoctype(n2), this._emitEOFToken();
          break;
        }
        default:
          this._createDoctypeToken(String.fromCodePoint(t)), this.state = g.DOCTYPE_NAME;
      }
  }
  // DOCTYPE name state
  //------------------------------------------------------------------
  _stateDoctypeName(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED: {
        this.state = g.AFTER_DOCTYPE_NAME;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this.state = g.DATA, this.emitCurrentDoctype(n2);
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), n2.name += le3;
        break;
      }
      case p2.EOF: {
        this._err(N.eofInDoctype), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this._emitEOFToken();
        break;
      }
      default:
        n2.name += String.fromCodePoint(Bt2(t) ? un(t) : t);
    }
  }
  // After DOCTYPE name state
  //------------------------------------------------------------------
  _stateAfterDoctypeName(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED:
        break;
      case p2.GREATER_THAN_SIGN: {
        this.state = g.DATA, this.emitCurrentDoctype(n2);
        break;
      }
      case p2.EOF: {
        this._err(N.eofInDoctype), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this._emitEOFToken();
        break;
      }
      default:
        this._consumeSequenceIfMatch(_e2.PUBLIC, false) ? this.state = g.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(_e2.SYSTEM, false) ? this.state = g.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(N.invalidCharacterSequenceAfterDoctypeName), n2.forceQuirks = true, this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t));
    }
  }
  // After DOCTYPE public keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicKeyword(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED: {
        this.state = g.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case p2.QUOTATION_MARK: {
        this._err(N.missingWhitespaceAfterDoctypePublicKeyword), n2.publicId = "", this.state = g.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p2.APOSTROPHE: {
        this._err(N.missingWhitespaceAfterDoctypePublicKeyword), n2.publicId = "", this.state = g.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this._err(N.missingDoctypePublicIdentifier), n2.forceQuirks = true, this.state = g.DATA, this.emitCurrentDoctype(n2);
        break;
      }
      case p2.EOF: {
        this._err(N.eofInDoctype), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingQuoteBeforeDoctypePublicIdentifier), n2.forceQuirks = true, this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypePublicIdentifier(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED:
        break;
      case p2.QUOTATION_MARK: {
        n2.publicId = "", this.state = g.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p2.APOSTROPHE: {
        n2.publicId = "", this.state = g.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this._err(N.missingDoctypePublicIdentifier), n2.forceQuirks = true, this.state = g.DATA, this.emitCurrentDoctype(n2);
        break;
      }
      case p2.EOF: {
        this._err(N.eofInDoctype), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingQuoteBeforeDoctypePublicIdentifier), n2.forceQuirks = true, this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE public identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierDoubleQuoted(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.QUOTATION_MARK: {
        this.state = g.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), n2.publicId += le3;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this._err(N.abruptDoctypePublicIdentifier), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this.state = g.DATA;
        break;
      }
      case p2.EOF: {
        this._err(N.eofInDoctype), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this._emitEOFToken();
        break;
      }
      default:
        n2.publicId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE public identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypePublicIdentifierSingleQuoted(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.APOSTROPHE: {
        this.state = g.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), n2.publicId += le3;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this._err(N.abruptDoctypePublicIdentifier), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this.state = g.DATA;
        break;
      }
      case p2.EOF: {
        this._err(N.eofInDoctype), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this._emitEOFToken();
        break;
      }
      default:
        n2.publicId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE public identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypePublicIdentifier(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED: {
        this.state = g.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this.state = g.DATA, this.emitCurrentDoctype(n2);
        break;
      }
      case p2.QUOTATION_MARK: {
        this._err(N.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n2.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p2.APOSTROPHE: {
        this._err(N.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n2.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p2.EOF: {
        this._err(N.eofInDoctype), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingQuoteBeforeDoctypeSystemIdentifier), n2.forceQuirks = true, this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Between DOCTYPE public and system identifiers state
  //------------------------------------------------------------------
  _stateBetweenDoctypePublicAndSystemIdentifiers(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED:
        break;
      case p2.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n2), this.state = g.DATA;
        break;
      }
      case p2.QUOTATION_MARK: {
        n2.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p2.APOSTROPHE: {
        n2.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p2.EOF: {
        this._err(N.eofInDoctype), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingQuoteBeforeDoctypeSystemIdentifier), n2.forceQuirks = true, this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // After DOCTYPE system keyword state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemKeyword(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED: {
        this.state = g.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case p2.QUOTATION_MARK: {
        this._err(N.missingWhitespaceAfterDoctypeSystemKeyword), n2.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p2.APOSTROPHE: {
        this._err(N.missingWhitespaceAfterDoctypeSystemKeyword), n2.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this._err(N.missingDoctypeSystemIdentifier), n2.forceQuirks = true, this.state = g.DATA, this.emitCurrentDoctype(n2);
        break;
      }
      case p2.EOF: {
        this._err(N.eofInDoctype), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingQuoteBeforeDoctypeSystemIdentifier), n2.forceQuirks = true, this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Before DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateBeforeDoctypeSystemIdentifier(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED:
        break;
      case p2.QUOTATION_MARK: {
        n2.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;
        break;
      }
      case p2.APOSTROPHE: {
        n2.systemId = "", this.state = g.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this._err(N.missingDoctypeSystemIdentifier), n2.forceQuirks = true, this.state = g.DATA, this.emitCurrentDoctype(n2);
        break;
      }
      case p2.EOF: {
        this._err(N.eofInDoctype), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.missingQuoteBeforeDoctypeSystemIdentifier), n2.forceQuirks = true, this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // DOCTYPE system identifier (double-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierDoubleQuoted(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.QUOTATION_MARK: {
        this.state = g.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), n2.systemId += le3;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this._err(N.abruptDoctypeSystemIdentifier), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this.state = g.DATA;
        break;
      }
      case p2.EOF: {
        this._err(N.eofInDoctype), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this._emitEOFToken();
        break;
      }
      default:
        n2.systemId += String.fromCodePoint(t);
    }
  }
  // DOCTYPE system identifier (single-quoted) state
  //------------------------------------------------------------------
  _stateDoctypeSystemIdentifierSingleQuoted(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.APOSTROPHE: {
        this.state = g.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter), n2.systemId += le3;
        break;
      }
      case p2.GREATER_THAN_SIGN: {
        this._err(N.abruptDoctypeSystemIdentifier), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this.state = g.DATA;
        break;
      }
      case p2.EOF: {
        this._err(N.eofInDoctype), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this._emitEOFToken();
        break;
      }
      default:
        n2.systemId += String.fromCodePoint(t);
    }
  }
  // After DOCTYPE system identifier state
  //------------------------------------------------------------------
  _stateAfterDoctypeSystemIdentifier(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.SPACE:
      case p2.LINE_FEED:
      case p2.TABULATION:
      case p2.FORM_FEED:
        break;
      case p2.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n2), this.state = g.DATA;
        break;
      }
      case p2.EOF: {
        this._err(N.eofInDoctype), n2.forceQuirks = true, this.emitCurrentDoctype(n2), this._emitEOFToken();
        break;
      }
      default:
        this._err(N.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = g.BOGUS_DOCTYPE, this._stateBogusDoctype(t);
    }
  }
  // Bogus DOCTYPE state
  //------------------------------------------------------------------
  _stateBogusDoctype(t) {
    const n2 = this.currentToken;
    switch (t) {
      case p2.GREATER_THAN_SIGN: {
        this.emitCurrentDoctype(n2), this.state = g.DATA;
        break;
      }
      case p2.NULL: {
        this._err(N.unexpectedNullCharacter);
        break;
      }
      case p2.EOF: {
        this.emitCurrentDoctype(n2), this._emitEOFToken();
        break;
      }
    }
  }
  // CDATA section state
  //------------------------------------------------------------------
  _stateCdataSection(t) {
    switch (t) {
      case p2.RIGHT_SQUARE_BRACKET: {
        this.state = g.CDATA_SECTION_BRACKET;
        break;
      }
      case p2.EOF: {
        this._err(N.eofInCdata), this._emitEOFToken();
        break;
      }
      default:
        this._emitCodePoint(t);
    }
  }
  // CDATA section bracket state
  //------------------------------------------------------------------
  _stateCdataSectionBracket(t) {
    t === p2.RIGHT_SQUARE_BRACKET ? this.state = g.CDATA_SECTION_END : (this._emitChars("]"), this.state = g.CDATA_SECTION, this._stateCdataSection(t));
  }
  // CDATA section end state
  //------------------------------------------------------------------
  _stateCdataSectionEnd(t) {
    switch (t) {
      case p2.GREATER_THAN_SIGN: {
        this.state = g.DATA;
        break;
      }
      case p2.RIGHT_SQUARE_BRACKET: {
        this._emitChars("]");
        break;
      }
      default:
        this._emitChars("]]"), this.state = g.CDATA_SECTION, this._stateCdataSection(t);
    }
  }
  // Character reference state
  //------------------------------------------------------------------
  _stateCharacterReference(t) {
    t === p2.NUMBER_SIGN ? this.state = g.NUMERIC_CHARACTER_REFERENCE : pr2(t) ? (this.state = g.NAMED_CHARACTER_REFERENCE, this._stateNamedCharacterReference(t)) : (this._flushCodePointConsumedAsCharacterReference(p2.AMPERSAND), this._reconsumeInState(this.returnState, t));
  }
  // Named character reference state
  //------------------------------------------------------------------
  _stateNamedCharacterReference(t) {
    const n2 = this._matchNamedCharacterReference(t);
    if (!this._ensureHibernation()) if (n2) {
      for (let r = 0; r < n2.length; r++)
        this._flushCodePointConsumedAsCharacterReference(n2[r]);
      this.state = this.returnState;
    } else
      this._flushCodePointConsumedAsCharacterReference(p2.AMPERSAND), this.state = g.AMBIGUOUS_AMPERSAND;
  }
  // Ambiguos ampersand state
  //------------------------------------------------------------------
  _stateAmbiguousAmpersand(t) {
    pr2(t) ? this._flushCodePointConsumedAsCharacterReference(t) : (t === p2.SEMICOLON && this._err(N.unknownNamedCharacterReference), this._reconsumeInState(this.returnState, t));
  }
  // Numeric character reference state
  //------------------------------------------------------------------
  _stateNumericCharacterReference(t) {
    this.charRefCode = 0, t === p2.LATIN_SMALL_X || t === p2.LATIN_CAPITAL_X ? this.state = g.HEXADEMICAL_CHARACTER_REFERENCE_START : Ut3(t) ? (this.state = g.DECIMAL_CHARACTER_REFERENCE, this._stateDecimalCharacterReference(t)) : (this._err(N.absenceOfDigitsInNumericCharacterReference), this._flushCodePointConsumedAsCharacterReference(p2.AMPERSAND), this._flushCodePointConsumedAsCharacterReference(p2.NUMBER_SIGN), this._reconsumeInState(this.returnState, t));
  }
  // Hexademical character reference start state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReferenceStart(t) {
    vf(t) ? (this.state = g.HEXADEMICAL_CHARACTER_REFERENCE, this._stateHexademicalCharacterReference(t)) : (this._err(N.absenceOfDigitsInNumericCharacterReference), this._flushCodePointConsumedAsCharacterReference(p2.AMPERSAND), this._flushCodePointConsumedAsCharacterReference(p2.NUMBER_SIGN), this._unconsume(2), this.state = this.returnState);
  }
  // Hexademical character reference state
  //------------------------------------------------------------------
  _stateHexademicalCharacterReference(t) {
    Iu(t) ? this.charRefCode = this.charRefCode * 16 + t - 55 : Su(t) ? this.charRefCode = this.charRefCode * 16 + t - 87 : Ut3(t) ? this.charRefCode = this.charRefCode * 16 + t - 48 : t === p2.SEMICOLON ? this.state = g.NUMERIC_CHARACTER_REFERENCE_END : (this._err(N.missingSemicolonAfterCharacterReference), this.state = g.NUMERIC_CHARACTER_REFERENCE_END, this._stateNumericCharacterReferenceEnd(t));
  }
  // Decimal character reference state
  //------------------------------------------------------------------
  _stateDecimalCharacterReference(t) {
    Ut3(t) ? this.charRefCode = this.charRefCode * 10 + t - 48 : t === p2.SEMICOLON ? this.state = g.NUMERIC_CHARACTER_REFERENCE_END : (this._err(N.missingSemicolonAfterCharacterReference), this.state = g.NUMERIC_CHARACTER_REFERENCE_END, this._stateNumericCharacterReferenceEnd(t));
  }
  // Numeric character reference end state
  //------------------------------------------------------------------
  _stateNumericCharacterReferenceEnd(t) {
    if (this.charRefCode === p2.NULL)
      this._err(N.nullCharacterReference), this.charRefCode = p2.REPLACEMENT_CHARACTER;
    else if (this.charRefCode > 1114111)
      this._err(N.characterReferenceOutsideUnicodeRange), this.charRefCode = p2.REPLACEMENT_CHARACTER;
    else if (Tu(this.charRefCode))
      this._err(N.surrogateCharacterReference), this.charRefCode = p2.REPLACEMENT_CHARACTER;
    else if (Au(this.charRefCode))
      this._err(N.noncharacterCharacterReference);
    else if (yu(this.charRefCode) || this.charRefCode === p2.CARRIAGE_RETURN) {
      this._err(N.controlCharacterReference);
      const n2 = Ff.get(this.charRefCode);
      n2 !== void 0 && (this.charRefCode = n2);
    }
    this._flushCodePointConsumedAsCharacterReference(this.charRefCode), this._reconsumeInState(this.returnState, t);
  }
};
var Ru = /* @__PURE__ */ new Set([s.DD, s.DT, s.LI, s.OPTGROUP, s.OPTION, s.P, s.RB, s.RP, s.RT, s.RTC]);
var Ka = /* @__PURE__ */ new Set([
  ...Ru,
  s.CAPTION,
  s.COLGROUP,
  s.TBODY,
  s.TD,
  s.TFOOT,
  s.TH,
  s.THEAD,
  s.TR
]);
var sn = /* @__PURE__ */ new Map([
  [s.APPLET, L3.HTML],
  [s.CAPTION, L3.HTML],
  [s.HTML, L3.HTML],
  [s.MARQUEE, L3.HTML],
  [s.OBJECT, L3.HTML],
  [s.TABLE, L3.HTML],
  [s.TD, L3.HTML],
  [s.TEMPLATE, L3.HTML],
  [s.TH, L3.HTML],
  [s.ANNOTATION_XML, L3.MATHML],
  [s.MI, L3.MATHML],
  [s.MN, L3.MATHML],
  [s.MO, L3.MATHML],
  [s.MS, L3.MATHML],
  [s.MTEXT, L3.MATHML],
  [s.DESC, L3.SVG],
  [s.FOREIGN_OBJECT, L3.SVG],
  [s.TITLE, L3.SVG]
]);
var zf = [s.H1, s.H2, s.H3, s.H4, s.H5, s.H6];
var Yf = [s.TR, s.TEMPLATE, s.HTML];
var jf = [s.TBODY, s.TFOOT, s.THEAD, s.TEMPLATE, s.HTML];
var Gf = [s.TABLE, s.TEMPLATE, s.HTML];
var qf = [s.TD, s.TH];
var $f = class {
  get currentTmplContentOrNode() {
    return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current;
  }
  constructor(t, n2, r) {
    this.treeAdapter = n2, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = s.UNKNOWN, this.current = t;
  }
  //Index of element
  _indexOf(t) {
    return this.items.lastIndexOf(t, this.stackTop);
  }
  //Update current element
  _isInTemplate() {
    return this.currentTagId === s.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === L3.HTML;
  }
  _updateCurrentElement() {
    this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop];
  }
  //Mutations
  push(t, n2) {
    this.stackTop++, this.items[this.stackTop] = t, this.current = t, this.tagIDs[this.stackTop] = n2, this.currentTagId = n2, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t, n2, true);
  }
  pop() {
    const t = this.current;
    this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, true);
  }
  replace(t, n2) {
    const r = this._indexOf(t);
    this.items[r] = n2, r === this.stackTop && (this.current = n2);
  }
  insertAfter(t, n2, r) {
    const a3 = this._indexOf(t) + 1;
    this.items.splice(a3, 0, n2), this.tagIDs.splice(a3, 0, r), this.stackTop++, a3 === this.stackTop && this._updateCurrentElement(), this.handler.onItemPush(this.current, this.currentTagId, a3 === this.stackTop);
  }
  popUntilTagNamePopped(t) {
    let n2 = this.stackTop + 1;
    do
      n2 = this.tagIDs.lastIndexOf(t, n2 - 1);
    while (n2 > 0 && this.treeAdapter.getNamespaceURI(this.items[n2]) !== L3.HTML);
    this.shortenToLength(n2 < 0 ? 0 : n2);
  }
  shortenToLength(t) {
    for (; this.stackTop >= t; ) {
      const n2 = this.current;
      this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n2, this.stackTop < t);
    }
  }
  popUntilElementPopped(t) {
    const n2 = this._indexOf(t);
    this.shortenToLength(n2 < 0 ? 0 : n2);
  }
  popUntilPopped(t, n2) {
    const r = this._indexOfTagNames(t, n2);
    this.shortenToLength(r < 0 ? 0 : r);
  }
  popUntilNumberedHeaderPopped() {
    this.popUntilPopped(zf, L3.HTML);
  }
  popUntilTableCellPopped() {
    this.popUntilPopped(qf, L3.HTML);
  }
  popAllUpToHtmlElement() {
    this.tmplCount = 0, this.shortenToLength(1);
  }
  _indexOfTagNames(t, n2) {
    for (let r = this.stackTop; r >= 0; r--)
      if (t.includes(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n2)
        return r;
    return -1;
  }
  clearBackTo(t, n2) {
    const r = this._indexOfTagNames(t, n2);
    this.shortenToLength(r + 1);
  }
  clearBackToTableContext() {
    this.clearBackTo(Gf, L3.HTML);
  }
  clearBackToTableBodyContext() {
    this.clearBackTo(jf, L3.HTML);
  }
  clearBackToTableRowContext() {
    this.clearBackTo(Yf, L3.HTML);
  }
  remove(t) {
    const n2 = this._indexOf(t);
    n2 >= 0 && (n2 === this.stackTop ? this.pop() : (this.items.splice(n2, 1), this.tagIDs.splice(n2, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, false)));
  }
  //Search
  tryPeekProperlyNestedBodyElement() {
    return this.stackTop >= 1 && this.tagIDs[1] === s.BODY ? this.items[1] : null;
  }
  contains(t) {
    return this._indexOf(t) > -1;
  }
  getCommonAncestor(t) {
    const n2 = this._indexOf(t) - 1;
    return n2 >= 0 ? this.items[n2] : null;
  }
  isRootHtmlElementCurrent() {
    return this.stackTop === 0 && this.tagIDs[0] === s.HTML;
  }
  //Element in scope
  hasInScope(t) {
    for (let n2 = this.stackTop; n2 >= 0; n2--) {
      const r = this.tagIDs[n2], a3 = this.treeAdapter.getNamespaceURI(this.items[n2]);
      if (r === t && a3 === L3.HTML)
        return true;
      if (sn.get(r) === a3)
        return false;
    }
    return true;
  }
  hasNumberedHeaderInScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const n2 = this.tagIDs[t], r = this.treeAdapter.getNamespaceURI(this.items[t]);
      if (ku(n2) && r === L3.HTML)
        return true;
      if (sn.get(n2) === r)
        return false;
    }
    return true;
  }
  hasInListItemScope(t) {
    for (let n2 = this.stackTop; n2 >= 0; n2--) {
      const r = this.tagIDs[n2], a3 = this.treeAdapter.getNamespaceURI(this.items[n2]);
      if (r === t && a3 === L3.HTML)
        return true;
      if ((r === s.UL || r === s.OL) && a3 === L3.HTML || sn.get(r) === a3)
        return false;
    }
    return true;
  }
  hasInButtonScope(t) {
    for (let n2 = this.stackTop; n2 >= 0; n2--) {
      const r = this.tagIDs[n2], a3 = this.treeAdapter.getNamespaceURI(this.items[n2]);
      if (r === t && a3 === L3.HTML)
        return true;
      if (r === s.BUTTON && a3 === L3.HTML || sn.get(r) === a3)
        return false;
    }
    return true;
  }
  hasInTableScope(t) {
    for (let n2 = this.stackTop; n2 >= 0; n2--) {
      const r = this.tagIDs[n2];
      if (this.treeAdapter.getNamespaceURI(this.items[n2]) === L3.HTML) {
        if (r === t)
          return true;
        if (r === s.TABLE || r === s.TEMPLATE || r === s.HTML)
          return false;
      }
    }
    return true;
  }
  hasTableBodyContextInTableScope() {
    for (let t = this.stackTop; t >= 0; t--) {
      const n2 = this.tagIDs[t];
      if (this.treeAdapter.getNamespaceURI(this.items[t]) === L3.HTML) {
        if (n2 === s.TBODY || n2 === s.THEAD || n2 === s.TFOOT)
          return true;
        if (n2 === s.TABLE || n2 === s.HTML)
          return false;
      }
    }
    return true;
  }
  hasInSelectScope(t) {
    for (let n2 = this.stackTop; n2 >= 0; n2--) {
      const r = this.tagIDs[n2];
      if (this.treeAdapter.getNamespaceURI(this.items[n2]) === L3.HTML) {
        if (r === t)
          return true;
        if (r !== s.OPTION && r !== s.OPTGROUP)
          return false;
      }
    }
    return true;
  }
  //Implied end tags
  generateImpliedEndTags() {
    for (; Ru.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsThoroughly() {
    for (; Ka.has(this.currentTagId); )
      this.pop();
  }
  generateImpliedEndTagsWithExclusion(t) {
    for (; this.currentTagId !== t && Ka.has(this.currentTagId); )
      this.pop();
  }
};
var Qn = 3;
var we2;
(function(e2) {
  e2[e2.Marker = 0] = "Marker", e2[e2.Element = 1] = "Element";
})(we2 = we2 || (we2 = {}));
var Za = { type: we2.Marker };
var Wf = class {
  constructor(t) {
    this.treeAdapter = t, this.entries = [], this.bookmark = null;
  }
  //Noah Ark's condition
  //OPTIMIZATION: at first we try to find possible candidates for exclusion using
  //lightweight heuristics without thorough attributes check.
  _getNoahArkConditionCandidates(t, n2) {
    const r = [], a3 = n2.length, u2 = this.treeAdapter.getTagName(t), i2 = this.treeAdapter.getNamespaceURI(t);
    for (let o2 = 0; o2 < this.entries.length; o2++) {
      const l = this.entries[o2];
      if (l.type === we2.Marker)
        break;
      const { element: c3 } = l;
      if (this.treeAdapter.getTagName(c3) === u2 && this.treeAdapter.getNamespaceURI(c3) === i2) {
        const f2 = this.treeAdapter.getAttrList(c3);
        f2.length === a3 && r.push({ idx: o2, attrs: f2 });
      }
    }
    return r;
  }
  _ensureNoahArkCondition(t) {
    if (this.entries.length < Qn)
      return;
    const n2 = this.treeAdapter.getAttrList(t), r = this._getNoahArkConditionCandidates(t, n2);
    if (r.length < Qn)
      return;
    const a3 = new Map(n2.map((i2) => [i2.name, i2.value]));
    let u2 = 0;
    for (let i2 = 0; i2 < r.length; i2++) {
      const o2 = r[i2];
      o2.attrs.every((l) => a3.get(l.name) === l.value) && (u2 += 1, u2 >= Qn && this.entries.splice(o2.idx, 1));
    }
  }
  //Mutations
  insertMarker() {
    this.entries.unshift(Za);
  }
  pushElement(t, n2) {
    this._ensureNoahArkCondition(t), this.entries.unshift({
      type: we2.Element,
      element: t,
      token: n2
    });
  }
  insertElementAfterBookmark(t, n2) {
    const r = this.entries.indexOf(this.bookmark);
    this.entries.splice(r, 0, {
      type: we2.Element,
      element: t,
      token: n2
    });
  }
  removeEntry(t) {
    const n2 = this.entries.indexOf(t);
    n2 >= 0 && this.entries.splice(n2, 1);
  }
  /**
   * Clears the list of formatting elements up to the last marker.
   *
   * @see https://html.spec.whatwg.org/multipage/parsing.html#clear-the-list-of-active-formatting-elements-up-to-the-last-marker
   */
  clearToLastMarker() {
    const t = this.entries.indexOf(Za);
    t >= 0 ? this.entries.splice(0, t + 1) : this.entries.length = 0;
  }
  //Search
  getElementEntryInScopeWithTagName(t) {
    const n2 = this.entries.find((r) => r.type === we2.Marker || this.treeAdapter.getTagName(r.element) === t);
    return n2 && n2.type === we2.Element ? n2 : null;
  }
  getElementEntry(t) {
    return this.entries.find((n2) => n2.type === we2.Element && n2.element === t);
  }
};
function Ja(e2) {
  return {
    nodeName: "#text",
    value: e2,
    parentNode: null
  };
}
var mt4 = {
  //Node construction
  createDocument() {
    return {
      nodeName: "#document",
      mode: Se2.NO_QUIRKS,
      childNodes: []
    };
  },
  createDocumentFragment() {
    return {
      nodeName: "#document-fragment",
      childNodes: []
    };
  },
  createElement(e2, t, n2) {
    return {
      nodeName: e2,
      tagName: e2,
      attrs: n2,
      namespaceURI: t,
      childNodes: [],
      parentNode: null
    };
  },
  createCommentNode(e2) {
    return {
      nodeName: "#comment",
      data: e2,
      parentNode: null
    };
  },
  //Tree mutation
  appendChild(e2, t) {
    e2.childNodes.push(t), t.parentNode = e2;
  },
  insertBefore(e2, t, n2) {
    const r = e2.childNodes.indexOf(n2);
    e2.childNodes.splice(r, 0, t), t.parentNode = e2;
  },
  setTemplateContent(e2, t) {
    e2.content = t;
  },
  getTemplateContent(e2) {
    return e2.content;
  },
  setDocumentType(e2, t, n2, r) {
    const a3 = e2.childNodes.find((u2) => u2.nodeName === "#documentType");
    if (a3)
      a3.name = t, a3.publicId = n2, a3.systemId = r;
    else {
      const u2 = {
        nodeName: "#documentType",
        name: t,
        publicId: n2,
        systemId: r,
        parentNode: null
      };
      mt4.appendChild(e2, u2);
    }
  },
  setDocumentMode(e2, t) {
    e2.mode = t;
  },
  getDocumentMode(e2) {
    return e2.mode;
  },
  detachNode(e2) {
    if (e2.parentNode) {
      const t = e2.parentNode.childNodes.indexOf(e2);
      e2.parentNode.childNodes.splice(t, 1), e2.parentNode = null;
    }
  },
  insertText(e2, t) {
    if (e2.childNodes.length > 0) {
      const n2 = e2.childNodes[e2.childNodes.length - 1];
      if (mt4.isTextNode(n2)) {
        n2.value += t;
        return;
      }
    }
    mt4.appendChild(e2, Ja(t));
  },
  insertTextBefore(e2, t, n2) {
    const r = e2.childNodes[e2.childNodes.indexOf(n2) - 1];
    r && mt4.isTextNode(r) ? r.value += t : mt4.insertBefore(e2, Ja(t), n2);
  },
  adoptAttributes(e2, t) {
    const n2 = new Set(e2.attrs.map((r) => r.name));
    for (let r = 0; r < t.length; r++)
      n2.has(t[r].name) || e2.attrs.push(t[r]);
  },
  //Tree traversing
  getFirstChild(e2) {
    return e2.childNodes[0];
  },
  getChildNodes(e2) {
    return e2.childNodes;
  },
  getParentNode(e2) {
    return e2.parentNode;
  },
  getAttrList(e2) {
    return e2.attrs;
  },
  //Node data
  getTagName(e2) {
    return e2.tagName;
  },
  getNamespaceURI(e2) {
    return e2.namespaceURI;
  },
  getTextNodeContent(e2) {
    return e2.value;
  },
  getCommentNodeContent(e2) {
    return e2.data;
  },
  getDocumentTypeNodeName(e2) {
    return e2.name;
  },
  getDocumentTypeNodePublicId(e2) {
    return e2.publicId;
  },
  getDocumentTypeNodeSystemId(e2) {
    return e2.systemId;
  },
  //Node types
  isTextNode(e2) {
    return e2.nodeName === "#text";
  },
  isCommentNode(e2) {
    return e2.nodeName === "#comment";
  },
  isDocumentTypeNode(e2) {
    return e2.nodeName === "#documentType";
  },
  isElementNode(e2) {
    return Object.prototype.hasOwnProperty.call(e2, "tagName");
  },
  // Source code location
  setNodeSourceCodeLocation(e2, t) {
    e2.sourceCodeLocation = t;
  },
  getNodeSourceCodeLocation(e2) {
    return e2.sourceCodeLocation;
  },
  updateNodeSourceCodeLocation(e2, t) {
    e2.sourceCodeLocation = { ...e2.sourceCodeLocation, ...t };
  }
};
var Lu = "html";
var Vf = "about:legacy-compat";
var Qf = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd";
var Ou = [
  "+//silmaril//dtd html pro v0r11 19970101//",
  "-//as//dtd html 3.0 aswedit + extensions//",
  "-//advasoft ltd//dtd html 3.0 aswedit + extensions//",
  "-//ietf//dtd html 2.0 level 1//",
  "-//ietf//dtd html 2.0 level 2//",
  "-//ietf//dtd html 2.0 strict level 1//",
  "-//ietf//dtd html 2.0 strict level 2//",
  "-//ietf//dtd html 2.0 strict//",
  "-//ietf//dtd html 2.0//",
  "-//ietf//dtd html 2.1e//",
  "-//ietf//dtd html 3.0//",
  "-//ietf//dtd html 3.2 final//",
  "-//ietf//dtd html 3.2//",
  "-//ietf//dtd html 3//",
  "-//ietf//dtd html level 0//",
  "-//ietf//dtd html level 1//",
  "-//ietf//dtd html level 2//",
  "-//ietf//dtd html level 3//",
  "-//ietf//dtd html strict level 0//",
  "-//ietf//dtd html strict level 1//",
  "-//ietf//dtd html strict level 2//",
  "-//ietf//dtd html strict level 3//",
  "-//ietf//dtd html strict//",
  "-//ietf//dtd html//",
  "-//metrius//dtd metrius presentational//",
  "-//microsoft//dtd internet explorer 2.0 html strict//",
  "-//microsoft//dtd internet explorer 2.0 html//",
  "-//microsoft//dtd internet explorer 2.0 tables//",
  "-//microsoft//dtd internet explorer 3.0 html strict//",
  "-//microsoft//dtd internet explorer 3.0 html//",
  "-//microsoft//dtd internet explorer 3.0 tables//",
  "-//netscape comm. corp.//dtd html//",
  "-//netscape comm. corp.//dtd strict html//",
  "-//o'reilly and associates//dtd html 2.0//",
  "-//o'reilly and associates//dtd html extended 1.0//",
  "-//o'reilly and associates//dtd html extended relaxed 1.0//",
  "-//sq//dtd html 2.0 hotmetal + extensions//",
  "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//",
  "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//",
  "-//spyglass//dtd html 2.0 extended//",
  "-//sun microsystems corp.//dtd hotjava html//",
  "-//sun microsystems corp.//dtd hotjava strict html//",
  "-//w3c//dtd html 3 1995-03-24//",
  "-//w3c//dtd html 3.2 draft//",
  "-//w3c//dtd html 3.2 final//",
  "-//w3c//dtd html 3.2//",
  "-//w3c//dtd html 3.2s draft//",
  "-//w3c//dtd html 4.0 frameset//",
  "-//w3c//dtd html 4.0 transitional//",
  "-//w3c//dtd html experimental 19960712//",
  "-//w3c//dtd html experimental 970421//",
  "-//w3c//dtd w3 html//",
  "-//w3o//dtd w3 html 3.0//",
  "-//webtechs//dtd mozilla html 2.0//",
  "-//webtechs//dtd mozilla html//"
];
var Xf = [
  ...Ou,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
var Kf = /* @__PURE__ */ new Set([
  "-//w3o//dtd w3 html strict 3.0//en//",
  "-/w3c/dtd html 4.0 transitional/en",
  "html"
]);
var wu = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"];
var Zf = [
  ...wu,
  "-//w3c//dtd html 4.01 frameset//",
  "-//w3c//dtd html 4.01 transitional//"
];
function ei(e2, t) {
  return t.some((n2) => e2.startsWith(n2));
}
function Jf(e2) {
  return e2.name === Lu && e2.publicId === null && (e2.systemId === null || e2.systemId === Vf);
}
function eh(e2) {
  if (e2.name !== Lu)
    return Se2.QUIRKS;
  const { systemId: t } = e2;
  if (t && t.toLowerCase() === Qf)
    return Se2.QUIRKS;
  let { publicId: n2 } = e2;
  if (n2 !== null) {
    if (n2 = n2.toLowerCase(), Kf.has(n2))
      return Se2.QUIRKS;
    let r = t === null ? Xf : Ou;
    if (ei(n2, r))
      return Se2.QUIRKS;
    if (r = t === null ? wu : Zf, ei(n2, r))
      return Se2.LIMITED_QUIRKS;
  }
  return Se2.NO_QUIRKS;
}
var ti = {
  TEXT_HTML: "text/html",
  APPLICATION_XML: "application/xhtml+xml"
};
var th = "definitionurl";
var nh = "definitionURL";
var rh = new Map([
  "attributeName",
  "attributeType",
  "baseFrequency",
  "baseProfile",
  "calcMode",
  "clipPathUnits",
  "diffuseConstant",
  "edgeMode",
  "filterUnits",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "kernelMatrix",
  "kernelUnitLength",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "limitingConeAngle",
  "markerHeight",
  "markerUnits",
  "markerWidth",
  "maskContentUnits",
  "maskUnits",
  "numOctaves",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "refX",
  "refY",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "specularConstant",
  "specularExponent",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stitchTiles",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textLength",
  "viewBox",
  "viewTarget",
  "xChannelSelector",
  "yChannelSelector",
  "zoomAndPan"
].map((e2) => [e2.toLowerCase(), e2]));
var ah = /* @__PURE__ */ new Map([
  ["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: L3.XLINK }],
  ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: L3.XLINK }],
  ["xlink:href", { prefix: "xlink", name: "href", namespace: L3.XLINK }],
  ["xlink:role", { prefix: "xlink", name: "role", namespace: L3.XLINK }],
  ["xlink:show", { prefix: "xlink", name: "show", namespace: L3.XLINK }],
  ["xlink:title", { prefix: "xlink", name: "title", namespace: L3.XLINK }],
  ["xlink:type", { prefix: "xlink", name: "type", namespace: L3.XLINK }],
  ["xml:base", { prefix: "xml", name: "base", namespace: L3.XML }],
  ["xml:lang", { prefix: "xml", name: "lang", namespace: L3.XML }],
  ["xml:space", { prefix: "xml", name: "space", namespace: L3.XML }],
  ["xmlns", { prefix: "", name: "xmlns", namespace: L3.XMLNS }],
  ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: L3.XMLNS }]
]);
var ih = new Map([
  "altGlyph",
  "altGlyphDef",
  "altGlyphItem",
  "animateColor",
  "animateMotion",
  "animateTransform",
  "clipPath",
  "feBlend",
  "feColorMatrix",
  "feComponentTransfer",
  "feComposite",
  "feConvolveMatrix",
  "feDiffuseLighting",
  "feDisplacementMap",
  "feDistantLight",
  "feFlood",
  "feFuncA",
  "feFuncB",
  "feFuncG",
  "feFuncR",
  "feGaussianBlur",
  "feImage",
  "feMerge",
  "feMergeNode",
  "feMorphology",
  "feOffset",
  "fePointLight",
  "feSpecularLighting",
  "feSpotLight",
  "feTile",
  "feTurbulence",
  "foreignObject",
  "glyphRef",
  "linearGradient",
  "radialGradient",
  "textPath"
].map((e2) => [e2.toLowerCase(), e2]));
var uh = /* @__PURE__ */ new Set([
  s.B,
  s.BIG,
  s.BLOCKQUOTE,
  s.BODY,
  s.BR,
  s.CENTER,
  s.CODE,
  s.DD,
  s.DIV,
  s.DL,
  s.DT,
  s.EM,
  s.EMBED,
  s.H1,
  s.H2,
  s.H3,
  s.H4,
  s.H5,
  s.H6,
  s.HEAD,
  s.HR,
  s.I,
  s.IMG,
  s.LI,
  s.LISTING,
  s.MENU,
  s.META,
  s.NOBR,
  s.OL,
  s.P,
  s.PRE,
  s.RUBY,
  s.S,
  s.SMALL,
  s.SPAN,
  s.STRONG,
  s.STRIKE,
  s.SUB,
  s.SUP,
  s.TABLE,
  s.TT,
  s.U,
  s.UL,
  s.VAR
]);
function sh(e2) {
  const t = e2.tagID;
  return t === s.FONT && e2.attrs.some(({ name: r }) => r === Je2.COLOR || r === Je2.SIZE || r === Je2.FACE) || uh.has(t);
}
function Du(e2) {
  for (let t = 0; t < e2.attrs.length; t++)
    if (e2.attrs[t].name === th) {
      e2.attrs[t].name = nh;
      break;
    }
}
function Pu(e2) {
  for (let t = 0; t < e2.attrs.length; t++) {
    const n2 = rh.get(e2.attrs[t].name);
    n2 != null && (e2.attrs[t].name = n2);
  }
}
function Fr2(e2) {
  for (let t = 0; t < e2.attrs.length; t++) {
    const n2 = ah.get(e2.attrs[t].name);
    n2 && (e2.attrs[t].prefix = n2.prefix, e2.attrs[t].name = n2.name, e2.attrs[t].namespace = n2.namespace);
  }
}
function oh(e2) {
  const t = ih.get(e2.tagName);
  t != null && (e2.tagName = t, e2.tagID = Nt3(e2.tagName));
}
function lh(e2, t) {
  return t === L3.MATHML && (e2 === s.MI || e2 === s.MO || e2 === s.MN || e2 === s.MS || e2 === s.MTEXT);
}
function ch(e2, t, n2) {
  if (t === L3.MATHML && e2 === s.ANNOTATION_XML) {
    for (let r = 0; r < n2.length; r++)
      if (n2[r].name === Je2.ENCODING) {
        const a3 = n2[r].value.toLowerCase();
        return a3 === ti.TEXT_HTML || a3 === ti.APPLICATION_XML;
      }
  }
  return t === L3.SVG && (e2 === s.FOREIGN_OBJECT || e2 === s.DESC || e2 === s.TITLE);
}
function dh(e2, t, n2, r) {
  return (!r || r === L3.HTML) && ch(e2, t, n2) || (!r || r === L3.MATHML) && lh(e2, t);
}
var fh = "hidden";
var hh = 8;
var ph = 3;
var T;
(function(e2) {
  e2[e2.INITIAL = 0] = "INITIAL", e2[e2.BEFORE_HTML = 1] = "BEFORE_HTML", e2[e2.BEFORE_HEAD = 2] = "BEFORE_HEAD", e2[e2.IN_HEAD = 3] = "IN_HEAD", e2[e2.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e2[e2.AFTER_HEAD = 5] = "AFTER_HEAD", e2[e2.IN_BODY = 6] = "IN_BODY", e2[e2.TEXT = 7] = "TEXT", e2[e2.IN_TABLE = 8] = "IN_TABLE", e2[e2.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e2[e2.IN_CAPTION = 10] = "IN_CAPTION", e2[e2.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e2[e2.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e2[e2.IN_ROW = 13] = "IN_ROW", e2[e2.IN_CELL = 14] = "IN_CELL", e2[e2.IN_SELECT = 15] = "IN_SELECT", e2[e2.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e2[e2.IN_TEMPLATE = 17] = "IN_TEMPLATE", e2[e2.AFTER_BODY = 18] = "AFTER_BODY", e2[e2.IN_FRAMESET = 19] = "IN_FRAMESET", e2[e2.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e2[e2.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e2[e2.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET";
})(T || (T = {}));
var mh = {
  startLine: -1,
  startCol: -1,
  startOffset: -1,
  endLine: -1,
  endCol: -1,
  endOffset: -1
};
var Mu = /* @__PURE__ */ new Set([s.TABLE, s.TBODY, s.TFOOT, s.THEAD, s.TR]);
var ni = {
  scriptingEnabled: true,
  sourceCodeLocationInfo: false,
  treeAdapter: mt4,
  onParseError: null
};
var ri = class {
  constructor(t, n2, r = null, a3 = null) {
    this.fragmentContext = r, this.scriptHandler = a3, this.currentToken = null, this.stopped = false, this.insertionMode = T.INITIAL, this.originalInsertionMode = T.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = false, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = false, this.framesetOk = true, this.skipNextNewLine = false, this.fosterParentingEnabled = false, this.options = {
      ...ni,
      ...t
    }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = true), this.document = n2 ?? this.treeAdapter.createDocument(), this.tokenizer = new Uf(this.options, this), this.activeFormattingElements = new Wf(this.treeAdapter), this.fragmentContextID = r ? Nt3(this.treeAdapter.getTagName(r)) : s.UNKNOWN, this._setContextModes(r ?? this.document, this.fragmentContextID), this.openElements = new $f(this.document, this.treeAdapter, this);
  }
  // API
  static parse(t, n2) {
    const r = new this(n2);
    return r.tokenizer.write(t, true), r.document;
  }
  static getFragmentParser(t, n2) {
    const r = {
      ...ni,
      ...n2
    };
    t ?? (t = r.treeAdapter.createElement(k2.TEMPLATE, L3.HTML, []));
    const a3 = r.treeAdapter.createElement("documentmock", L3.HTML, []), u2 = new this(r, a3, t);
    return u2.fragmentContextID === s.TEMPLATE && u2.tmplInsertionModeStack.unshift(T.IN_TEMPLATE), u2._initTokenizerForFragmentParsing(), u2._insertFakeRootElement(), u2._resetInsertionMode(), u2._findFormInFragmentContext(), u2;
  }
  getFragment() {
    const t = this.treeAdapter.getFirstChild(this.document), n2 = this.treeAdapter.createDocumentFragment();
    return this._adoptNodes(t, n2), n2;
  }
  //Errors
  _err(t, n2, r) {
    var a3;
    if (!this.onParseError)
      return;
    const u2 = (a3 = t.location) !== null && a3 !== void 0 ? a3 : mh, i2 = {
      code: n2,
      startLine: u2.startLine,
      startCol: u2.startCol,
      startOffset: u2.startOffset,
      endLine: r ? u2.startLine : u2.endLine,
      endCol: r ? u2.startCol : u2.endCol,
      endOffset: r ? u2.startOffset : u2.endOffset
    };
    this.onParseError(i2);
  }
  //Stack events
  onItemPush(t, n2, r) {
    var a3, u2;
    (u2 = (a3 = this.treeAdapter).onItemPush) === null || u2 === void 0 || u2.call(a3, t), r && this.openElements.stackTop > 0 && this._setContextModes(t, n2);
  }
  onItemPop(t, n2) {
    var r, a3;
    if (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken), (a3 = (r = this.treeAdapter).onItemPop) === null || a3 === void 0 || a3.call(r, t, this.openElements.current), n2) {
      let u2, i2;
      this.openElements.stackTop === 0 && this.fragmentContext ? (u2 = this.fragmentContext, i2 = this.fragmentContextID) : { current: u2, currentTagId: i2 } = this.openElements, this._setContextModes(u2, i2);
    }
  }
  _setContextModes(t, n2) {
    const r = t === this.document || this.treeAdapter.getNamespaceURI(t) === L3.HTML;
    this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && !this._isIntegrationPoint(n2, t);
  }
  _switchToTextParsing(t, n2) {
    this._insertElement(t, L3.HTML), this.tokenizer.state = n2, this.originalInsertionMode = this.insertionMode, this.insertionMode = T.TEXT;
  }
  switchToPlaintextParsing() {
    this.insertionMode = T.TEXT, this.originalInsertionMode = T.IN_BODY, this.tokenizer.state = de2.PLAINTEXT;
  }
  //Fragment parsing
  _getAdjustedCurrentElement() {
    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;
  }
  _findFormInFragmentContext() {
    let t = this.fragmentContext;
    for (; t; ) {
      if (this.treeAdapter.getTagName(t) === k2.FORM) {
        this.formElement = t;
        break;
      }
      t = this.treeAdapter.getParentNode(t);
    }
  }
  _initTokenizerForFragmentParsing() {
    if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== L3.HTML))
      switch (this.fragmentContextID) {
        case s.TITLE:
        case s.TEXTAREA: {
          this.tokenizer.state = de2.RCDATA;
          break;
        }
        case s.STYLE:
        case s.XMP:
        case s.IFRAME:
        case s.NOEMBED:
        case s.NOFRAMES:
        case s.NOSCRIPT: {
          this.tokenizer.state = de2.RAWTEXT;
          break;
        }
        case s.SCRIPT: {
          this.tokenizer.state = de2.SCRIPT_DATA;
          break;
        }
        case s.PLAINTEXT: {
          this.tokenizer.state = de2.PLAINTEXT;
          break;
        }
      }
  }
  //Tree mutation
  _setDocumentType(t) {
    const n2 = t.name || "", r = t.publicId || "", a3 = t.systemId || "";
    if (this.treeAdapter.setDocumentType(this.document, n2, r, a3), t.location) {
      const i2 = this.treeAdapter.getChildNodes(this.document).find((o2) => this.treeAdapter.isDocumentTypeNode(o2));
      i2 && this.treeAdapter.setNodeSourceCodeLocation(i2, t.location);
    }
  }
  _attachElementToTree(t, n2) {
    if (this.options.sourceCodeLocationInfo) {
      const r = n2 && {
        ...n2,
        startTag: n2
      };
      this.treeAdapter.setNodeSourceCodeLocation(t, r);
    }
    if (this._shouldFosterParentOnInsertion())
      this._fosterParentElement(t);
    else {
      const r = this.openElements.currentTmplContentOrNode;
      this.treeAdapter.appendChild(r, t);
    }
  }
  _appendElement(t, n2) {
    const r = this.treeAdapter.createElement(t.tagName, n2, t.attrs);
    this._attachElementToTree(r, t.location);
  }
  _insertElement(t, n2) {
    const r = this.treeAdapter.createElement(t.tagName, n2, t.attrs);
    this._attachElementToTree(r, t.location), this.openElements.push(r, t.tagID);
  }
  _insertFakeElement(t, n2) {
    const r = this.treeAdapter.createElement(t, L3.HTML, []);
    this._attachElementToTree(r, null), this.openElements.push(r, n2);
  }
  _insertTemplate(t) {
    const n2 = this.treeAdapter.createElement(t.tagName, L3.HTML, t.attrs), r = this.treeAdapter.createDocumentFragment();
    this.treeAdapter.setTemplateContent(n2, r), this._attachElementToTree(n2, t.location), this.openElements.push(n2, t.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null);
  }
  _insertFakeRootElement() {
    const t = this.treeAdapter.createElement(k2.HTML, L3.HTML, []);
    this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null), this.treeAdapter.appendChild(this.openElements.current, t), this.openElements.push(t, s.HTML);
  }
  _appendCommentNode(t, n2) {
    const r = this.treeAdapter.createCommentNode(t.data);
    this.treeAdapter.appendChild(n2, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, t.location);
  }
  _insertCharacters(t) {
    let n2, r;
    if (this._shouldFosterParentOnInsertion() ? ({ parent: n2, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(n2, t.chars, r) : this.treeAdapter.insertText(n2, t.chars)) : (n2 = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n2, t.chars)), !t.location)
      return;
    const a3 = this.treeAdapter.getChildNodes(n2), u2 = r ? a3.lastIndexOf(r) : a3.length, i2 = a3[u2 - 1];
    if (this.treeAdapter.getNodeSourceCodeLocation(i2)) {
      const { endLine: l, endCol: c3, endOffset: f2 } = t.location;
      this.treeAdapter.updateNodeSourceCodeLocation(i2, { endLine: l, endCol: c3, endOffset: f2 });
    } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(i2, t.location);
  }
  _adoptNodes(t, n2) {
    for (let r = this.treeAdapter.getFirstChild(t); r; r = this.treeAdapter.getFirstChild(t))
      this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n2, r);
  }
  _setEndLocation(t, n2) {
    if (this.treeAdapter.getNodeSourceCodeLocation(t) && n2.location) {
      const r = n2.location, a3 = this.treeAdapter.getTagName(t), u2 = (
        // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing
        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.
        n2.type === X2.END_TAG && a3 === n2.tagName ? {
          endTag: { ...r },
          endLine: r.endLine,
          endCol: r.endCol,
          endOffset: r.endOffset
        } : {
          endLine: r.startLine,
          endCol: r.startCol,
          endOffset: r.startOffset
        }
      );
      this.treeAdapter.updateNodeSourceCodeLocation(t, u2);
    }
  }
  //Token processing
  shouldProcessStartTagTokenInForeignContent(t) {
    if (!this.currentNotInHTML)
      return false;
    let n2, r;
    return this.openElements.stackTop === 0 && this.fragmentContext ? (n2 = this.fragmentContext, r = this.fragmentContextID) : { current: n2, currentTagId: r } = this.openElements, t.tagID === s.SVG && this.treeAdapter.getTagName(n2) === k2.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n2) === L3.MATHML ? false : (
      // Check that `current` is not an integration point for HTML or MathML elements.
      this.tokenizer.inForeignNode || // If it _is_ an integration point, then we might have to check that it is not an HTML
      // integration point.
      (t.tagID === s.MGLYPH || t.tagID === s.MALIGNMARK) && !this._isIntegrationPoint(r, n2, L3.HTML)
    );
  }
  _processToken(t) {
    switch (t.type) {
      case X2.CHARACTER: {
        this.onCharacter(t);
        break;
      }
      case X2.NULL_CHARACTER: {
        this.onNullCharacter(t);
        break;
      }
      case X2.COMMENT: {
        this.onComment(t);
        break;
      }
      case X2.DOCTYPE: {
        this.onDoctype(t);
        break;
      }
      case X2.START_TAG: {
        this._processStartTag(t);
        break;
      }
      case X2.END_TAG: {
        this.onEndTag(t);
        break;
      }
      case X2.EOF: {
        this.onEof(t);
        break;
      }
      case X2.WHITESPACE_CHARACTER: {
        this.onWhitespaceCharacter(t);
        break;
      }
    }
  }
  //Integration points
  _isIntegrationPoint(t, n2, r) {
    const a3 = this.treeAdapter.getNamespaceURI(n2), u2 = this.treeAdapter.getAttrList(n2);
    return dh(t, a3, u2, r);
  }
  //Active formatting elements reconstruction
  _reconstructActiveFormattingElements() {
    const t = this.activeFormattingElements.entries.length;
    if (t) {
      const n2 = this.activeFormattingElements.entries.findIndex((a3) => a3.type === we2.Marker || this.openElements.contains(a3.element)), r = n2 < 0 ? t - 1 : n2 - 1;
      for (let a3 = r; a3 >= 0; a3--) {
        const u2 = this.activeFormattingElements.entries[a3];
        this._insertElement(u2.token, this.treeAdapter.getNamespaceURI(u2.element)), u2.element = this.openElements.current;
      }
    }
  }
  //Close elements
  _closeTableCell() {
    this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = T.IN_ROW;
  }
  _closePElement() {
    this.openElements.generateImpliedEndTagsWithExclusion(s.P), this.openElements.popUntilTagNamePopped(s.P);
  }
  //Insertion modes
  _resetInsertionMode() {
    for (let t = this.openElements.stackTop; t >= 0; t--)
      switch (t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]) {
        case s.TR: {
          this.insertionMode = T.IN_ROW;
          return;
        }
        case s.TBODY:
        case s.THEAD:
        case s.TFOOT: {
          this.insertionMode = T.IN_TABLE_BODY;
          return;
        }
        case s.CAPTION: {
          this.insertionMode = T.IN_CAPTION;
          return;
        }
        case s.COLGROUP: {
          this.insertionMode = T.IN_COLUMN_GROUP;
          return;
        }
        case s.TABLE: {
          this.insertionMode = T.IN_TABLE;
          return;
        }
        case s.BODY: {
          this.insertionMode = T.IN_BODY;
          return;
        }
        case s.FRAMESET: {
          this.insertionMode = T.IN_FRAMESET;
          return;
        }
        case s.SELECT: {
          this._resetInsertionModeForSelect(t);
          return;
        }
        case s.TEMPLATE: {
          this.insertionMode = this.tmplInsertionModeStack[0];
          return;
        }
        case s.HTML: {
          this.insertionMode = this.headElement ? T.AFTER_HEAD : T.BEFORE_HEAD;
          return;
        }
        case s.TD:
        case s.TH: {
          if (t > 0) {
            this.insertionMode = T.IN_CELL;
            return;
          }
          break;
        }
        case s.HEAD: {
          if (t > 0) {
            this.insertionMode = T.IN_HEAD;
            return;
          }
          break;
        }
      }
    this.insertionMode = T.IN_BODY;
  }
  _resetInsertionModeForSelect(t) {
    if (t > 0)
      for (let n2 = t - 1; n2 > 0; n2--) {
        const r = this.openElements.tagIDs[n2];
        if (r === s.TEMPLATE)
          break;
        if (r === s.TABLE) {
          this.insertionMode = T.IN_SELECT_IN_TABLE;
          return;
        }
      }
    this.insertionMode = T.IN_SELECT;
  }
  //Foster parenting
  _isElementCausesFosterParenting(t) {
    return Mu.has(t);
  }
  _shouldFosterParentOnInsertion() {
    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.currentTagId);
  }
  _findFosterParentingLocation() {
    for (let t = this.openElements.stackTop; t >= 0; t--) {
      const n2 = this.openElements.items[t];
      switch (this.openElements.tagIDs[t]) {
        case s.TEMPLATE: {
          if (this.treeAdapter.getNamespaceURI(n2) === L3.HTML)
            return { parent: this.treeAdapter.getTemplateContent(n2), beforeElement: null };
          break;
        }
        case s.TABLE: {
          const r = this.treeAdapter.getParentNode(n2);
          return r ? { parent: r, beforeElement: n2 } : { parent: this.openElements.items[t - 1], beforeElement: null };
        }
      }
    }
    return { parent: this.openElements.items[0], beforeElement: null };
  }
  _fosterParentElement(t) {
    const n2 = this._findFosterParentingLocation();
    n2.beforeElement ? this.treeAdapter.insertBefore(n2.parent, t, n2.beforeElement) : this.treeAdapter.appendChild(n2.parent, t);
  }
  //Special elements
  _isSpecialElement(t, n2) {
    const r = this.treeAdapter.getNamespaceURI(t);
    return Mf[r].has(n2);
  }
  onCharacter(t) {
    if (this.skipNextNewLine = false, this.tokenizer.inForeignNode) {
      qp(this, t);
      return;
    }
    switch (this.insertionMode) {
      case T.INITIAL: {
        Mt2(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        zt3(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Yt3(this, t);
        break;
      }
      case T.IN_HEAD: {
        jt2(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        Gt3(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        qt3(this, t);
        break;
      }
      case T.IN_BODY:
      case T.IN_CAPTION:
      case T.IN_CELL:
      case T.IN_TEMPLATE: {
        Bu(this, t);
        break;
      }
      case T.TEXT:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE: {
        this._insertCharacters(t);
        break;
      }
      case T.IN_TABLE:
      case T.IN_TABLE_BODY:
      case T.IN_ROW: {
        Xn(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        ju(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        Tn(this, t);
        break;
      }
      case T.AFTER_BODY: {
        yn(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        fn(this, t);
        break;
      }
    }
  }
  onNullCharacter(t) {
    if (this.skipNextNewLine = false, this.tokenizer.inForeignNode) {
      Gp(this, t);
      return;
    }
    switch (this.insertionMode) {
      case T.INITIAL: {
        Mt2(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        zt3(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Yt3(this, t);
        break;
      }
      case T.IN_HEAD: {
        jt2(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        Gt3(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        qt3(this, t);
        break;
      }
      case T.TEXT: {
        this._insertCharacters(t);
        break;
      }
      case T.IN_TABLE:
      case T.IN_TABLE_BODY:
      case T.IN_ROW: {
        Xn(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        Tn(this, t);
        break;
      }
      case T.AFTER_BODY: {
        yn(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        fn(this, t);
        break;
      }
    }
  }
  onComment(t) {
    if (this.skipNextNewLine = false, this.currentNotInHTML) {
      mr2(this, t);
      return;
    }
    switch (this.insertionMode) {
      case T.INITIAL:
      case T.BEFORE_HTML:
      case T.BEFORE_HEAD:
      case T.IN_HEAD:
      case T.IN_HEAD_NO_SCRIPT:
      case T.AFTER_HEAD:
      case T.IN_BODY:
      case T.IN_TABLE:
      case T.IN_CAPTION:
      case T.IN_COLUMN_GROUP:
      case T.IN_TABLE_BODY:
      case T.IN_ROW:
      case T.IN_CELL:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE:
      case T.IN_TEMPLATE:
      case T.IN_FRAMESET:
      case T.AFTER_FRAMESET: {
        mr2(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        Ft3(this, t);
        break;
      }
      case T.AFTER_BODY: {
        _h(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY:
      case T.AFTER_AFTER_FRAMESET: {
        Ch(this, t);
        break;
      }
    }
  }
  onDoctype(t) {
    switch (this.skipNextNewLine = false, this.insertionMode) {
      case T.INITIAL: {
        xh(this, t);
        break;
      }
      case T.BEFORE_HEAD:
      case T.IN_HEAD:
      case T.IN_HEAD_NO_SCRIPT:
      case T.AFTER_HEAD: {
        this._err(t, N.misplacedDoctype);
        break;
      }
      case T.IN_TABLE_TEXT: {
        Ft3(this, t);
        break;
      }
    }
  }
  onStartTag(t) {
    this.skipNextNewLine = false, this.currentToken = t, this._processStartTag(t), t.selfClosing && !t.ackSelfClosing && this._err(t, N.nonVoidHtmlElementStartTagWithTrailingSolidus);
  }
  /**
   * Processes a given start tag.
   *
   * `onStartTag` checks if a self-closing tag was recognized. When a token
   * is moved inbetween multiple insertion modes, this check for self-closing
   * could lead to false positives. To avoid this, `_processStartTag` is used
   * for nested calls.
   *
   * @param token The token to process.
   */
  _processStartTag(t) {
    this.shouldProcessStartTagTokenInForeignContent(t) ? $p(this, t) : this._startTagOutsideForeignContent(t);
  }
  _startTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case T.INITIAL: {
        Mt2(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        kh(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Sh(this, t);
        break;
      }
      case T.IN_HEAD: {
        Pe3(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        Lh(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        wh(this, t);
        break;
      }
      case T.IN_BODY: {
        Ee3(this, t);
        break;
      }
      case T.IN_TABLE: {
        Ct3(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        Ft3(this, t);
        break;
      }
      case T.IN_CAPTION: {
        Np(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        Hr2(this, t);
        break;
      }
      case T.IN_TABLE_BODY: {
        On(this, t);
        break;
      }
      case T.IN_ROW: {
        wn(this, t);
        break;
      }
      case T.IN_CELL: {
        Op(this, t);
        break;
      }
      case T.IN_SELECT: {
        $u(this, t);
        break;
      }
      case T.IN_SELECT_IN_TABLE: {
        Dp(this, t);
        break;
      }
      case T.IN_TEMPLATE: {
        Mp(this, t);
        break;
      }
      case T.AFTER_BODY: {
        Bp(this, t);
        break;
      }
      case T.IN_FRAMESET: {
        vp(this, t);
        break;
      }
      case T.AFTER_FRAMESET: {
        Up(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        Yp(this, t);
        break;
      }
      case T.AFTER_AFTER_FRAMESET: {
        jp(this, t);
        break;
      }
    }
  }
  onEndTag(t) {
    this.skipNextNewLine = false, this.currentToken = t, this.currentNotInHTML ? Wp(this, t) : this._endTagOutsideForeignContent(t);
  }
  _endTagOutsideForeignContent(t) {
    switch (this.insertionMode) {
      case T.INITIAL: {
        Mt2(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        Ih(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Nh(this, t);
        break;
      }
      case T.IN_HEAD: {
        Rh(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        Oh(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        Dh(this, t);
        break;
      }
      case T.IN_BODY: {
        Ln(this, t);
        break;
      }
      case T.TEXT: {
        Ep(this, t);
        break;
      }
      case T.IN_TABLE: {
        Vt3(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        Ft3(this, t);
        break;
      }
      case T.IN_CAPTION: {
        Rp(this, t);
        break;
      }
      case T.IN_COLUMN_GROUP: {
        Lp(this, t);
        break;
      }
      case T.IN_TABLE_BODY: {
        gr2(this, t);
        break;
      }
      case T.IN_ROW: {
        qu(this, t);
        break;
      }
      case T.IN_CELL: {
        wp(this, t);
        break;
      }
      case T.IN_SELECT: {
        Wu(this, t);
        break;
      }
      case T.IN_SELECT_IN_TABLE: {
        Pp(this, t);
        break;
      }
      case T.IN_TEMPLATE: {
        Fp(this, t);
        break;
      }
      case T.AFTER_BODY: {
        Qu(this, t);
        break;
      }
      case T.IN_FRAMESET: {
        Hp(this, t);
        break;
      }
      case T.AFTER_FRAMESET: {
        zp(this, t);
        break;
      }
      case T.AFTER_AFTER_BODY: {
        fn(this, t);
        break;
      }
    }
  }
  onEof(t) {
    switch (this.insertionMode) {
      case T.INITIAL: {
        Mt2(this, t);
        break;
      }
      case T.BEFORE_HTML: {
        zt3(this, t);
        break;
      }
      case T.BEFORE_HEAD: {
        Yt3(this, t);
        break;
      }
      case T.IN_HEAD: {
        jt2(this, t);
        break;
      }
      case T.IN_HEAD_NO_SCRIPT: {
        Gt3(this, t);
        break;
      }
      case T.AFTER_HEAD: {
        qt3(this, t);
        break;
      }
      case T.IN_BODY:
      case T.IN_TABLE:
      case T.IN_CAPTION:
      case T.IN_COLUMN_GROUP:
      case T.IN_TABLE_BODY:
      case T.IN_ROW:
      case T.IN_CELL:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE: {
        zu(this, t);
        break;
      }
      case T.TEXT: {
        Tp(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        Ft3(this, t);
        break;
      }
      case T.IN_TEMPLATE: {
        Vu(this, t);
        break;
      }
      case T.AFTER_BODY:
      case T.IN_FRAMESET:
      case T.AFTER_FRAMESET:
      case T.AFTER_AFTER_BODY:
      case T.AFTER_AFTER_FRAMESET: {
        vr2(this, t);
        break;
      }
    }
  }
  onWhitespaceCharacter(t) {
    if (this.skipNextNewLine && (this.skipNextNewLine = false, t.chars.charCodeAt(0) === p2.LINE_FEED)) {
      if (t.chars.length === 1)
        return;
      t.chars = t.chars.substr(1);
    }
    if (this.tokenizer.inForeignNode) {
      this._insertCharacters(t);
      return;
    }
    switch (this.insertionMode) {
      case T.IN_HEAD:
      case T.IN_HEAD_NO_SCRIPT:
      case T.AFTER_HEAD:
      case T.TEXT:
      case T.IN_COLUMN_GROUP:
      case T.IN_SELECT:
      case T.IN_SELECT_IN_TABLE:
      case T.IN_FRAMESET:
      case T.AFTER_FRAMESET: {
        this._insertCharacters(t);
        break;
      }
      case T.IN_BODY:
      case T.IN_CAPTION:
      case T.IN_CELL:
      case T.IN_TEMPLATE:
      case T.AFTER_BODY:
      case T.AFTER_AFTER_BODY:
      case T.AFTER_AFTER_FRAMESET: {
        Fu(this, t);
        break;
      }
      case T.IN_TABLE:
      case T.IN_TABLE_BODY:
      case T.IN_ROW: {
        Xn(this, t);
        break;
      }
      case T.IN_TABLE_TEXT: {
        Yu(this, t);
        break;
      }
    }
  }
};
function gh(e2, t) {
  let n2 = e2.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);
  return n2 ? e2.openElements.contains(n2.element) ? e2.openElements.hasInScope(t.tagID) || (n2 = null) : (e2.activeFormattingElements.removeEntry(n2), n2 = null) : Uu(e2, t), n2;
}
function bh(e2, t) {
  let n2 = null, r = e2.openElements.stackTop;
  for (; r >= 0; r--) {
    const a3 = e2.openElements.items[r];
    if (a3 === t.element)
      break;
    e2._isSpecialElement(a3, e2.openElements.tagIDs[r]) && (n2 = a3);
  }
  return n2 || (e2.openElements.shortenToLength(r < 0 ? 0 : r), e2.activeFormattingElements.removeEntry(t)), n2;
}
function Eh(e2, t, n2) {
  let r = t, a3 = e2.openElements.getCommonAncestor(t);
  for (let u2 = 0, i2 = a3; i2 !== n2; u2++, i2 = a3) {
    a3 = e2.openElements.getCommonAncestor(i2);
    const o2 = e2.activeFormattingElements.getElementEntry(i2), l = o2 && u2 >= ph;
    !o2 || l ? (l && e2.activeFormattingElements.removeEntry(o2), e2.openElements.remove(i2)) : (i2 = Th(e2, o2), r === t && (e2.activeFormattingElements.bookmark = o2), e2.treeAdapter.detachNode(r), e2.treeAdapter.appendChild(i2, r), r = i2);
  }
  return r;
}
function Th(e2, t) {
  const n2 = e2.treeAdapter.getNamespaceURI(t.element), r = e2.treeAdapter.createElement(t.token.tagName, n2, t.token.attrs);
  return e2.openElements.replace(t.element, r), t.element = r, r;
}
function yh(e2, t, n2) {
  const r = e2.treeAdapter.getTagName(t), a3 = Nt3(r);
  if (e2._isElementCausesFosterParenting(a3))
    e2._fosterParentElement(n2);
  else {
    const u2 = e2.treeAdapter.getNamespaceURI(t);
    a3 === s.TEMPLATE && u2 === L3.HTML && (t = e2.treeAdapter.getTemplateContent(t)), e2.treeAdapter.appendChild(t, n2);
  }
}
function Ah(e2, t, n2) {
  const r = e2.treeAdapter.getNamespaceURI(n2.element), { token: a3 } = n2, u2 = e2.treeAdapter.createElement(a3.tagName, r, a3.attrs);
  e2._adoptNodes(t, u2), e2.treeAdapter.appendChild(t, u2), e2.activeFormattingElements.insertElementAfterBookmark(u2, a3), e2.activeFormattingElements.removeEntry(n2), e2.openElements.remove(n2.element), e2.openElements.insertAfter(t, u2, a3.tagID);
}
function Br2(e2, t) {
  for (let n2 = 0; n2 < hh; n2++) {
    const r = gh(e2, t);
    if (!r)
      break;
    const a3 = bh(e2, r);
    if (!a3)
      break;
    e2.activeFormattingElements.bookmark = r;
    const u2 = Eh(e2, a3, r.element), i2 = e2.openElements.getCommonAncestor(r.element);
    e2.treeAdapter.detachNode(u2), i2 && yh(e2, i2, u2), Ah(e2, a3, r);
  }
}
function mr2(e2, t) {
  e2._appendCommentNode(t, e2.openElements.currentTmplContentOrNode);
}
function _h(e2, t) {
  e2._appendCommentNode(t, e2.openElements.items[0]);
}
function Ch(e2, t) {
  e2._appendCommentNode(t, e2.document);
}
function vr2(e2, t) {
  if (e2.stopped = true, t.location) {
    const n2 = e2.fragmentContext ? 0 : 2;
    for (let r = e2.openElements.stackTop; r >= n2; r--)
      e2._setEndLocation(e2.openElements.items[r], t);
    if (!e2.fragmentContext && e2.openElements.stackTop >= 0) {
      const r = e2.openElements.items[0], a3 = e2.treeAdapter.getNodeSourceCodeLocation(r);
      if (a3 && !a3.endTag && (e2._setEndLocation(r, t), e2.openElements.stackTop >= 1)) {
        const u2 = e2.openElements.items[1], i2 = e2.treeAdapter.getNodeSourceCodeLocation(u2);
        i2 && !i2.endTag && e2._setEndLocation(u2, t);
      }
    }
  }
}
function xh(e2, t) {
  e2._setDocumentType(t);
  const n2 = t.forceQuirks ? Se2.QUIRKS : eh(t);
  Jf(t) || e2._err(t, N.nonConformingDoctype), e2.treeAdapter.setDocumentMode(e2.document, n2), e2.insertionMode = T.BEFORE_HTML;
}
function Mt2(e2, t) {
  e2._err(t, N.missingDoctype, true), e2.treeAdapter.setDocumentMode(e2.document, Se2.QUIRKS), e2.insertionMode = T.BEFORE_HTML, e2._processToken(t);
}
function kh(e2, t) {
  t.tagID === s.HTML ? (e2._insertElement(t, L3.HTML), e2.insertionMode = T.BEFORE_HEAD) : zt3(e2, t);
}
function Ih(e2, t) {
  const n2 = t.tagID;
  (n2 === s.HTML || n2 === s.HEAD || n2 === s.BODY || n2 === s.BR) && zt3(e2, t);
}
function zt3(e2, t) {
  e2._insertFakeRootElement(), e2.insertionMode = T.BEFORE_HEAD, e2._processToken(t);
}
function Sh(e2, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee3(e2, t);
      break;
    }
    case s.HEAD: {
      e2._insertElement(t, L3.HTML), e2.headElement = e2.openElements.current, e2.insertionMode = T.IN_HEAD;
      break;
    }
    default:
      Yt3(e2, t);
  }
}
function Nh(e2, t) {
  const n2 = t.tagID;
  n2 === s.HEAD || n2 === s.BODY || n2 === s.HTML || n2 === s.BR ? Yt3(e2, t) : e2._err(t, N.endTagWithoutMatchingOpenElement);
}
function Yt3(e2, t) {
  e2._insertFakeElement(k2.HEAD, s.HEAD), e2.headElement = e2.openElements.current, e2.insertionMode = T.IN_HEAD, e2._processToken(t);
}
function Pe3(e2, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee3(e2, t);
      break;
    }
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META: {
      e2._appendElement(t, L3.HTML), t.ackSelfClosing = true;
      break;
    }
    case s.TITLE: {
      e2._switchToTextParsing(t, de2.RCDATA);
      break;
    }
    case s.NOSCRIPT: {
      e2.options.scriptingEnabled ? e2._switchToTextParsing(t, de2.RAWTEXT) : (e2._insertElement(t, L3.HTML), e2.insertionMode = T.IN_HEAD_NO_SCRIPT);
      break;
    }
    case s.NOFRAMES:
    case s.STYLE: {
      e2._switchToTextParsing(t, de2.RAWTEXT);
      break;
    }
    case s.SCRIPT: {
      e2._switchToTextParsing(t, de2.SCRIPT_DATA);
      break;
    }
    case s.TEMPLATE: {
      e2._insertTemplate(t), e2.activeFormattingElements.insertMarker(), e2.framesetOk = false, e2.insertionMode = T.IN_TEMPLATE, e2.tmplInsertionModeStack.unshift(T.IN_TEMPLATE);
      break;
    }
    case s.HEAD: {
      e2._err(t, N.misplacedStartTagForHeadElement);
      break;
    }
    default:
      jt2(e2, t);
  }
}
function Rh(e2, t) {
  switch (t.tagID) {
    case s.HEAD: {
      e2.openElements.pop(), e2.insertionMode = T.AFTER_HEAD;
      break;
    }
    case s.BODY:
    case s.BR:
    case s.HTML: {
      jt2(e2, t);
      break;
    }
    case s.TEMPLATE: {
      dt3(e2, t);
      break;
    }
    default:
      e2._err(t, N.endTagWithoutMatchingOpenElement);
  }
}
function dt3(e2, t) {
  e2.openElements.tmplCount > 0 ? (e2.openElements.generateImpliedEndTagsThoroughly(), e2.openElements.currentTagId !== s.TEMPLATE && e2._err(t, N.closingOfElementWithOpenChildElements), e2.openElements.popUntilTagNamePopped(s.TEMPLATE), e2.activeFormattingElements.clearToLastMarker(), e2.tmplInsertionModeStack.shift(), e2._resetInsertionMode()) : e2._err(t, N.endTagWithoutMatchingOpenElement);
}
function jt2(e2, t) {
  e2.openElements.pop(), e2.insertionMode = T.AFTER_HEAD, e2._processToken(t);
}
function Lh(e2, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee3(e2, t);
      break;
    }
    case s.BASEFONT:
    case s.BGSOUND:
    case s.HEAD:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.STYLE: {
      Pe3(e2, t);
      break;
    }
    case s.NOSCRIPT: {
      e2._err(t, N.nestedNoscriptInHead);
      break;
    }
    default:
      Gt3(e2, t);
  }
}
function Oh(e2, t) {
  switch (t.tagID) {
    case s.NOSCRIPT: {
      e2.openElements.pop(), e2.insertionMode = T.IN_HEAD;
      break;
    }
    case s.BR: {
      Gt3(e2, t);
      break;
    }
    default:
      e2._err(t, N.endTagWithoutMatchingOpenElement);
  }
}
function Gt3(e2, t) {
  const n2 = t.type === X2.EOF ? N.openElementsLeftAfterEof : N.disallowedContentInNoscriptInHead;
  e2._err(t, n2), e2.openElements.pop(), e2.insertionMode = T.IN_HEAD, e2._processToken(t);
}
function wh(e2, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee3(e2, t);
      break;
    }
    case s.BODY: {
      e2._insertElement(t, L3.HTML), e2.framesetOk = false, e2.insertionMode = T.IN_BODY;
      break;
    }
    case s.FRAMESET: {
      e2._insertElement(t, L3.HTML), e2.insertionMode = T.IN_FRAMESET;
      break;
    }
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.SCRIPT:
    case s.STYLE:
    case s.TEMPLATE:
    case s.TITLE: {
      e2._err(t, N.abandonedHeadElementChild), e2.openElements.push(e2.headElement, s.HEAD), Pe3(e2, t), e2.openElements.remove(e2.headElement);
      break;
    }
    case s.HEAD: {
      e2._err(t, N.misplacedStartTagForHeadElement);
      break;
    }
    default:
      qt3(e2, t);
  }
}
function Dh(e2, t) {
  switch (t.tagID) {
    case s.BODY:
    case s.HTML:
    case s.BR: {
      qt3(e2, t);
      break;
    }
    case s.TEMPLATE: {
      dt3(e2, t);
      break;
    }
    default:
      e2._err(t, N.endTagWithoutMatchingOpenElement);
  }
}
function qt3(e2, t) {
  e2._insertFakeElement(k2.BODY, s.BODY), e2.insertionMode = T.IN_BODY, Rn(e2, t);
}
function Rn(e2, t) {
  switch (t.type) {
    case X2.CHARACTER: {
      Bu(e2, t);
      break;
    }
    case X2.WHITESPACE_CHARACTER: {
      Fu(e2, t);
      break;
    }
    case X2.COMMENT: {
      mr2(e2, t);
      break;
    }
    case X2.START_TAG: {
      Ee3(e2, t);
      break;
    }
    case X2.END_TAG: {
      Ln(e2, t);
      break;
    }
    case X2.EOF: {
      zu(e2, t);
      break;
    }
  }
}
function Fu(e2, t) {
  e2._reconstructActiveFormattingElements(), e2._insertCharacters(t);
}
function Bu(e2, t) {
  e2._reconstructActiveFormattingElements(), e2._insertCharacters(t), e2.framesetOk = false;
}
function Ph(e2, t) {
  e2.openElements.tmplCount === 0 && e2.treeAdapter.adoptAttributes(e2.openElements.items[0], t.attrs);
}
function Mh(e2, t) {
  const n2 = e2.openElements.tryPeekProperlyNestedBodyElement();
  n2 && e2.openElements.tmplCount === 0 && (e2.framesetOk = false, e2.treeAdapter.adoptAttributes(n2, t.attrs));
}
function Fh(e2, t) {
  const n2 = e2.openElements.tryPeekProperlyNestedBodyElement();
  e2.framesetOk && n2 && (e2.treeAdapter.detachNode(n2), e2.openElements.popAllUpToHtmlElement(), e2._insertElement(t, L3.HTML), e2.insertionMode = T.IN_FRAMESET);
}
function Bh(e2, t) {
  e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._insertElement(t, L3.HTML);
}
function vh(e2, t) {
  e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), ku(e2.openElements.currentTagId) && e2.openElements.pop(), e2._insertElement(t, L3.HTML);
}
function Hh(e2, t) {
  e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._insertElement(t, L3.HTML), e2.skipNextNewLine = true, e2.framesetOk = false;
}
function Uh(e2, t) {
  const n2 = e2.openElements.tmplCount > 0;
  (!e2.formElement || n2) && (e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._insertElement(t, L3.HTML), n2 || (e2.formElement = e2.openElements.current));
}
function zh(e2, t) {
  e2.framesetOk = false;
  const n2 = t.tagID;
  for (let r = e2.openElements.stackTop; r >= 0; r--) {
    const a3 = e2.openElements.tagIDs[r];
    if (n2 === s.LI && a3 === s.LI || (n2 === s.DD || n2 === s.DT) && (a3 === s.DD || a3 === s.DT)) {
      e2.openElements.generateImpliedEndTagsWithExclusion(a3), e2.openElements.popUntilTagNamePopped(a3);
      break;
    }
    if (a3 !== s.ADDRESS && a3 !== s.DIV && a3 !== s.P && e2._isSpecialElement(e2.openElements.items[r], a3))
      break;
  }
  e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._insertElement(t, L3.HTML);
}
function Yh(e2, t) {
  e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._insertElement(t, L3.HTML), e2.tokenizer.state = de2.PLAINTEXT;
}
function jh(e2, t) {
  e2.openElements.hasInScope(s.BUTTON) && (e2.openElements.generateImpliedEndTags(), e2.openElements.popUntilTagNamePopped(s.BUTTON)), e2._reconstructActiveFormattingElements(), e2._insertElement(t, L3.HTML), e2.framesetOk = false;
}
function Gh(e2, t) {
  const n2 = e2.activeFormattingElements.getElementEntryInScopeWithTagName(k2.A);
  n2 && (Br2(e2, t), e2.openElements.remove(n2.element), e2.activeFormattingElements.removeEntry(n2)), e2._reconstructActiveFormattingElements(), e2._insertElement(t, L3.HTML), e2.activeFormattingElements.pushElement(e2.openElements.current, t);
}
function qh(e2, t) {
  e2._reconstructActiveFormattingElements(), e2._insertElement(t, L3.HTML), e2.activeFormattingElements.pushElement(e2.openElements.current, t);
}
function $h(e2, t) {
  e2._reconstructActiveFormattingElements(), e2.openElements.hasInScope(s.NOBR) && (Br2(e2, t), e2._reconstructActiveFormattingElements()), e2._insertElement(t, L3.HTML), e2.activeFormattingElements.pushElement(e2.openElements.current, t);
}
function Wh(e2, t) {
  e2._reconstructActiveFormattingElements(), e2._insertElement(t, L3.HTML), e2.activeFormattingElements.insertMarker(), e2.framesetOk = false;
}
function Vh(e2, t) {
  e2.treeAdapter.getDocumentMode(e2.document) !== Se2.QUIRKS && e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._insertElement(t, L3.HTML), e2.framesetOk = false, e2.insertionMode = T.IN_TABLE;
}
function vu(e2, t) {
  e2._reconstructActiveFormattingElements(), e2._appendElement(t, L3.HTML), e2.framesetOk = false, t.ackSelfClosing = true;
}
function Hu(e2) {
  const t = _u(e2, Je2.TYPE);
  return t != null && t.toLowerCase() === fh;
}
function Qh(e2, t) {
  e2._reconstructActiveFormattingElements(), e2._appendElement(t, L3.HTML), Hu(t) || (e2.framesetOk = false), t.ackSelfClosing = true;
}
function Xh(e2, t) {
  e2._appendElement(t, L3.HTML), t.ackSelfClosing = true;
}
function Kh(e2, t) {
  e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._appendElement(t, L3.HTML), e2.framesetOk = false, t.ackSelfClosing = true;
}
function Zh(e2, t) {
  t.tagName = k2.IMG, t.tagID = s.IMG, vu(e2, t);
}
function Jh(e2, t) {
  e2._insertElement(t, L3.HTML), e2.skipNextNewLine = true, e2.tokenizer.state = de2.RCDATA, e2.originalInsertionMode = e2.insertionMode, e2.framesetOk = false, e2.insertionMode = T.TEXT;
}
function ep(e2, t) {
  e2.openElements.hasInButtonScope(s.P) && e2._closePElement(), e2._reconstructActiveFormattingElements(), e2.framesetOk = false, e2._switchToTextParsing(t, de2.RAWTEXT);
}
function tp(e2, t) {
  e2.framesetOk = false, e2._switchToTextParsing(t, de2.RAWTEXT);
}
function ai(e2, t) {
  e2._switchToTextParsing(t, de2.RAWTEXT);
}
function np(e2, t) {
  e2._reconstructActiveFormattingElements(), e2._insertElement(t, L3.HTML), e2.framesetOk = false, e2.insertionMode = e2.insertionMode === T.IN_TABLE || e2.insertionMode === T.IN_CAPTION || e2.insertionMode === T.IN_TABLE_BODY || e2.insertionMode === T.IN_ROW || e2.insertionMode === T.IN_CELL ? T.IN_SELECT_IN_TABLE : T.IN_SELECT;
}
function rp(e2, t) {
  e2.openElements.currentTagId === s.OPTION && e2.openElements.pop(), e2._reconstructActiveFormattingElements(), e2._insertElement(t, L3.HTML);
}
function ap(e2, t) {
  e2.openElements.hasInScope(s.RUBY) && e2.openElements.generateImpliedEndTags(), e2._insertElement(t, L3.HTML);
}
function ip(e2, t) {
  e2.openElements.hasInScope(s.RUBY) && e2.openElements.generateImpliedEndTagsWithExclusion(s.RTC), e2._insertElement(t, L3.HTML);
}
function up(e2, t) {
  e2._reconstructActiveFormattingElements(), Du(t), Fr2(t), t.selfClosing ? e2._appendElement(t, L3.MATHML) : e2._insertElement(t, L3.MATHML), t.ackSelfClosing = true;
}
function sp(e2, t) {
  e2._reconstructActiveFormattingElements(), Pu(t), Fr2(t), t.selfClosing ? e2._appendElement(t, L3.SVG) : e2._insertElement(t, L3.SVG), t.ackSelfClosing = true;
}
function ii(e2, t) {
  e2._reconstructActiveFormattingElements(), e2._insertElement(t, L3.HTML);
}
function Ee3(e2, t) {
  switch (t.tagID) {
    case s.I:
    case s.S:
    case s.B:
    case s.U:
    case s.EM:
    case s.TT:
    case s.BIG:
    case s.CODE:
    case s.FONT:
    case s.SMALL:
    case s.STRIKE:
    case s.STRONG: {
      qh(e2, t);
      break;
    }
    case s.A: {
      Gh(e2, t);
      break;
    }
    case s.H1:
    case s.H2:
    case s.H3:
    case s.H4:
    case s.H5:
    case s.H6: {
      vh(e2, t);
      break;
    }
    case s.P:
    case s.DL:
    case s.OL:
    case s.UL:
    case s.DIV:
    case s.DIR:
    case s.NAV:
    case s.MAIN:
    case s.MENU:
    case s.ASIDE:
    case s.CENTER:
    case s.FIGURE:
    case s.FOOTER:
    case s.HEADER:
    case s.HGROUP:
    case s.DIALOG:
    case s.DETAILS:
    case s.ADDRESS:
    case s.ARTICLE:
    case s.SECTION:
    case s.SUMMARY:
    case s.FIELDSET:
    case s.BLOCKQUOTE:
    case s.FIGCAPTION: {
      Bh(e2, t);
      break;
    }
    case s.LI:
    case s.DD:
    case s.DT: {
      zh(e2, t);
      break;
    }
    case s.BR:
    case s.IMG:
    case s.WBR:
    case s.AREA:
    case s.EMBED:
    case s.KEYGEN: {
      vu(e2, t);
      break;
    }
    case s.HR: {
      Kh(e2, t);
      break;
    }
    case s.RB:
    case s.RTC: {
      ap(e2, t);
      break;
    }
    case s.RT:
    case s.RP: {
      ip(e2, t);
      break;
    }
    case s.PRE:
    case s.LISTING: {
      Hh(e2, t);
      break;
    }
    case s.XMP: {
      ep(e2, t);
      break;
    }
    case s.SVG: {
      sp(e2, t);
      break;
    }
    case s.HTML: {
      Ph(e2, t);
      break;
    }
    case s.BASE:
    case s.LINK:
    case s.META:
    case s.STYLE:
    case s.TITLE:
    case s.SCRIPT:
    case s.BGSOUND:
    case s.BASEFONT:
    case s.TEMPLATE: {
      Pe3(e2, t);
      break;
    }
    case s.BODY: {
      Mh(e2, t);
      break;
    }
    case s.FORM: {
      Uh(e2, t);
      break;
    }
    case s.NOBR: {
      $h(e2, t);
      break;
    }
    case s.MATH: {
      up(e2, t);
      break;
    }
    case s.TABLE: {
      Vh(e2, t);
      break;
    }
    case s.INPUT: {
      Qh(e2, t);
      break;
    }
    case s.PARAM:
    case s.TRACK:
    case s.SOURCE: {
      Xh(e2, t);
      break;
    }
    case s.IMAGE: {
      Zh(e2, t);
      break;
    }
    case s.BUTTON: {
      jh(e2, t);
      break;
    }
    case s.APPLET:
    case s.OBJECT:
    case s.MARQUEE: {
      Wh(e2, t);
      break;
    }
    case s.IFRAME: {
      tp(e2, t);
      break;
    }
    case s.SELECT: {
      np(e2, t);
      break;
    }
    case s.OPTION:
    case s.OPTGROUP: {
      rp(e2, t);
      break;
    }
    case s.NOEMBED: {
      ai(e2, t);
      break;
    }
    case s.FRAMESET: {
      Fh(e2, t);
      break;
    }
    case s.TEXTAREA: {
      Jh(e2, t);
      break;
    }
    case s.NOSCRIPT: {
      e2.options.scriptingEnabled ? ai(e2, t) : ii(e2, t);
      break;
    }
    case s.PLAINTEXT: {
      Yh(e2, t);
      break;
    }
    case s.COL:
    case s.TH:
    case s.TD:
    case s.TR:
    case s.HEAD:
    case s.FRAME:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.CAPTION:
    case s.COLGROUP:
      break;
    default:
      ii(e2, t);
  }
}
function op(e2, t) {
  if (e2.openElements.hasInScope(s.BODY) && (e2.insertionMode = T.AFTER_BODY, e2.options.sourceCodeLocationInfo)) {
    const n2 = e2.openElements.tryPeekProperlyNestedBodyElement();
    n2 && e2._setEndLocation(n2, t);
  }
}
function lp(e2, t) {
  e2.openElements.hasInScope(s.BODY) && (e2.insertionMode = T.AFTER_BODY, Qu(e2, t));
}
function cp(e2, t) {
  const n2 = t.tagID;
  e2.openElements.hasInScope(n2) && (e2.openElements.generateImpliedEndTags(), e2.openElements.popUntilTagNamePopped(n2));
}
function dp(e2) {
  const t = e2.openElements.tmplCount > 0, { formElement: n2 } = e2;
  t || (e2.formElement = null), (n2 || t) && e2.openElements.hasInScope(s.FORM) && (e2.openElements.generateImpliedEndTags(), t ? e2.openElements.popUntilTagNamePopped(s.FORM) : n2 && e2.openElements.remove(n2));
}
function fp(e2) {
  e2.openElements.hasInButtonScope(s.P) || e2._insertFakeElement(k2.P, s.P), e2._closePElement();
}
function hp(e2) {
  e2.openElements.hasInListItemScope(s.LI) && (e2.openElements.generateImpliedEndTagsWithExclusion(s.LI), e2.openElements.popUntilTagNamePopped(s.LI));
}
function pp(e2, t) {
  const n2 = t.tagID;
  e2.openElements.hasInScope(n2) && (e2.openElements.generateImpliedEndTagsWithExclusion(n2), e2.openElements.popUntilTagNamePopped(n2));
}
function mp(e2) {
  e2.openElements.hasNumberedHeaderInScope() && (e2.openElements.generateImpliedEndTags(), e2.openElements.popUntilNumberedHeaderPopped());
}
function gp(e2, t) {
  const n2 = t.tagID;
  e2.openElements.hasInScope(n2) && (e2.openElements.generateImpliedEndTags(), e2.openElements.popUntilTagNamePopped(n2), e2.activeFormattingElements.clearToLastMarker());
}
function bp(e2) {
  e2._reconstructActiveFormattingElements(), e2._insertFakeElement(k2.BR, s.BR), e2.openElements.pop(), e2.framesetOk = false;
}
function Uu(e2, t) {
  const n2 = t.tagName, r = t.tagID;
  for (let a3 = e2.openElements.stackTop; a3 > 0; a3--) {
    const u2 = e2.openElements.items[a3], i2 = e2.openElements.tagIDs[a3];
    if (r === i2 && (r !== s.UNKNOWN || e2.treeAdapter.getTagName(u2) === n2)) {
      e2.openElements.generateImpliedEndTagsWithExclusion(r), e2.openElements.stackTop >= a3 && e2.openElements.shortenToLength(a3);
      break;
    }
    if (e2._isSpecialElement(u2, i2))
      break;
  }
}
function Ln(e2, t) {
  switch (t.tagID) {
    case s.A:
    case s.B:
    case s.I:
    case s.S:
    case s.U:
    case s.EM:
    case s.TT:
    case s.BIG:
    case s.CODE:
    case s.FONT:
    case s.NOBR:
    case s.SMALL:
    case s.STRIKE:
    case s.STRONG: {
      Br2(e2, t);
      break;
    }
    case s.P: {
      fp(e2);
      break;
    }
    case s.DL:
    case s.UL:
    case s.OL:
    case s.DIR:
    case s.DIV:
    case s.NAV:
    case s.PRE:
    case s.MAIN:
    case s.MENU:
    case s.ASIDE:
    case s.BUTTON:
    case s.CENTER:
    case s.FIGURE:
    case s.FOOTER:
    case s.HEADER:
    case s.HGROUP:
    case s.DIALOG:
    case s.ADDRESS:
    case s.ARTICLE:
    case s.DETAILS:
    case s.SECTION:
    case s.SUMMARY:
    case s.LISTING:
    case s.FIELDSET:
    case s.BLOCKQUOTE:
    case s.FIGCAPTION: {
      cp(e2, t);
      break;
    }
    case s.LI: {
      hp(e2);
      break;
    }
    case s.DD:
    case s.DT: {
      pp(e2, t);
      break;
    }
    case s.H1:
    case s.H2:
    case s.H3:
    case s.H4:
    case s.H5:
    case s.H6: {
      mp(e2);
      break;
    }
    case s.BR: {
      bp(e2);
      break;
    }
    case s.BODY: {
      op(e2, t);
      break;
    }
    case s.HTML: {
      lp(e2, t);
      break;
    }
    case s.FORM: {
      dp(e2);
      break;
    }
    case s.APPLET:
    case s.OBJECT:
    case s.MARQUEE: {
      gp(e2, t);
      break;
    }
    case s.TEMPLATE: {
      dt3(e2, t);
      break;
    }
    default:
      Uu(e2, t);
  }
}
function zu(e2, t) {
  e2.tmplInsertionModeStack.length > 0 ? Vu(e2, t) : vr2(e2, t);
}
function Ep(e2, t) {
  var n2;
  t.tagID === s.SCRIPT && ((n2 = e2.scriptHandler) === null || n2 === void 0 || n2.call(e2, e2.openElements.current)), e2.openElements.pop(), e2.insertionMode = e2.originalInsertionMode;
}
function Tp(e2, t) {
  e2._err(t, N.eofInElementThatCanContainOnlyText), e2.openElements.pop(), e2.insertionMode = e2.originalInsertionMode, e2.onEof(t);
}
function Xn(e2, t) {
  if (Mu.has(e2.openElements.currentTagId))
    switch (e2.pendingCharacterTokens.length = 0, e2.hasNonWhitespacePendingCharacterToken = false, e2.originalInsertionMode = e2.insertionMode, e2.insertionMode = T.IN_TABLE_TEXT, t.type) {
      case X2.CHARACTER: {
        ju(e2, t);
        break;
      }
      case X2.WHITESPACE_CHARACTER: {
        Yu(e2, t);
        break;
      }
    }
  else
    en(e2, t);
}
function yp(e2, t) {
  e2.openElements.clearBackToTableContext(), e2.activeFormattingElements.insertMarker(), e2._insertElement(t, L3.HTML), e2.insertionMode = T.IN_CAPTION;
}
function Ap(e2, t) {
  e2.openElements.clearBackToTableContext(), e2._insertElement(t, L3.HTML), e2.insertionMode = T.IN_COLUMN_GROUP;
}
function _p(e2, t) {
  e2.openElements.clearBackToTableContext(), e2._insertFakeElement(k2.COLGROUP, s.COLGROUP), e2.insertionMode = T.IN_COLUMN_GROUP, Hr2(e2, t);
}
function Cp(e2, t) {
  e2.openElements.clearBackToTableContext(), e2._insertElement(t, L3.HTML), e2.insertionMode = T.IN_TABLE_BODY;
}
function xp(e2, t) {
  e2.openElements.clearBackToTableContext(), e2._insertFakeElement(k2.TBODY, s.TBODY), e2.insertionMode = T.IN_TABLE_BODY, On(e2, t);
}
function kp(e2, t) {
  e2.openElements.hasInTableScope(s.TABLE) && (e2.openElements.popUntilTagNamePopped(s.TABLE), e2._resetInsertionMode(), e2._processStartTag(t));
}
function Ip(e2, t) {
  Hu(t) ? e2._appendElement(t, L3.HTML) : en(e2, t), t.ackSelfClosing = true;
}
function Sp(e2, t) {
  !e2.formElement && e2.openElements.tmplCount === 0 && (e2._insertElement(t, L3.HTML), e2.formElement = e2.openElements.current, e2.openElements.pop());
}
function Ct3(e2, t) {
  switch (t.tagID) {
    case s.TD:
    case s.TH:
    case s.TR: {
      xp(e2, t);
      break;
    }
    case s.STYLE:
    case s.SCRIPT:
    case s.TEMPLATE: {
      Pe3(e2, t);
      break;
    }
    case s.COL: {
      _p(e2, t);
      break;
    }
    case s.FORM: {
      Sp(e2, t);
      break;
    }
    case s.TABLE: {
      kp(e2, t);
      break;
    }
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      Cp(e2, t);
      break;
    }
    case s.INPUT: {
      Ip(e2, t);
      break;
    }
    case s.CAPTION: {
      yp(e2, t);
      break;
    }
    case s.COLGROUP: {
      Ap(e2, t);
      break;
    }
    default:
      en(e2, t);
  }
}
function Vt3(e2, t) {
  switch (t.tagID) {
    case s.TABLE: {
      e2.openElements.hasInTableScope(s.TABLE) && (e2.openElements.popUntilTagNamePopped(s.TABLE), e2._resetInsertionMode());
      break;
    }
    case s.TEMPLATE: {
      dt3(e2, t);
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TBODY:
    case s.TD:
    case s.TFOOT:
    case s.TH:
    case s.THEAD:
    case s.TR:
      break;
    default:
      en(e2, t);
  }
}
function en(e2, t) {
  const n2 = e2.fosterParentingEnabled;
  e2.fosterParentingEnabled = true, Rn(e2, t), e2.fosterParentingEnabled = n2;
}
function Yu(e2, t) {
  e2.pendingCharacterTokens.push(t);
}
function ju(e2, t) {
  e2.pendingCharacterTokens.push(t), e2.hasNonWhitespacePendingCharacterToken = true;
}
function Ft3(e2, t) {
  let n2 = 0;
  if (e2.hasNonWhitespacePendingCharacterToken)
    for (; n2 < e2.pendingCharacterTokens.length; n2++)
      en(e2, e2.pendingCharacterTokens[n2]);
  else
    for (; n2 < e2.pendingCharacterTokens.length; n2++)
      e2._insertCharacters(e2.pendingCharacterTokens[n2]);
  e2.insertionMode = e2.originalInsertionMode, e2._processToken(t);
}
var Gu = /* @__PURE__ */ new Set([s.CAPTION, s.COL, s.COLGROUP, s.TBODY, s.TD, s.TFOOT, s.TH, s.THEAD, s.TR]);
function Np(e2, t) {
  const n2 = t.tagID;
  Gu.has(n2) ? e2.openElements.hasInTableScope(s.CAPTION) && (e2.openElements.generateImpliedEndTags(), e2.openElements.popUntilTagNamePopped(s.CAPTION), e2.activeFormattingElements.clearToLastMarker(), e2.insertionMode = T.IN_TABLE, Ct3(e2, t)) : Ee3(e2, t);
}
function Rp(e2, t) {
  const n2 = t.tagID;
  switch (n2) {
    case s.CAPTION:
    case s.TABLE: {
      e2.openElements.hasInTableScope(s.CAPTION) && (e2.openElements.generateImpliedEndTags(), e2.openElements.popUntilTagNamePopped(s.CAPTION), e2.activeFormattingElements.clearToLastMarker(), e2.insertionMode = T.IN_TABLE, n2 === s.TABLE && Vt3(e2, t));
      break;
    }
    case s.BODY:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TBODY:
    case s.TD:
    case s.TFOOT:
    case s.TH:
    case s.THEAD:
    case s.TR:
      break;
    default:
      Ln(e2, t);
  }
}
function Hr2(e2, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee3(e2, t);
      break;
    }
    case s.COL: {
      e2._appendElement(t, L3.HTML), t.ackSelfClosing = true;
      break;
    }
    case s.TEMPLATE: {
      Pe3(e2, t);
      break;
    }
    default:
      Tn(e2, t);
  }
}
function Lp(e2, t) {
  switch (t.tagID) {
    case s.COLGROUP: {
      e2.openElements.currentTagId === s.COLGROUP && (e2.openElements.pop(), e2.insertionMode = T.IN_TABLE);
      break;
    }
    case s.TEMPLATE: {
      dt3(e2, t);
      break;
    }
    case s.COL:
      break;
    default:
      Tn(e2, t);
  }
}
function Tn(e2, t) {
  e2.openElements.currentTagId === s.COLGROUP && (e2.openElements.pop(), e2.insertionMode = T.IN_TABLE, e2._processToken(t));
}
function On(e2, t) {
  switch (t.tagID) {
    case s.TR: {
      e2.openElements.clearBackToTableBodyContext(), e2._insertElement(t, L3.HTML), e2.insertionMode = T.IN_ROW;
      break;
    }
    case s.TH:
    case s.TD: {
      e2.openElements.clearBackToTableBodyContext(), e2._insertFakeElement(k2.TR, s.TR), e2.insertionMode = T.IN_ROW, wn(e2, t);
      break;
    }
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e2.openElements.hasTableBodyContextInTableScope() && (e2.openElements.clearBackToTableBodyContext(), e2.openElements.pop(), e2.insertionMode = T.IN_TABLE, Ct3(e2, t));
      break;
    }
    default:
      Ct3(e2, t);
  }
}
function gr2(e2, t) {
  const n2 = t.tagID;
  switch (t.tagID) {
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e2.openElements.hasInTableScope(n2) && (e2.openElements.clearBackToTableBodyContext(), e2.openElements.pop(), e2.insertionMode = T.IN_TABLE);
      break;
    }
    case s.TABLE: {
      e2.openElements.hasTableBodyContextInTableScope() && (e2.openElements.clearBackToTableBodyContext(), e2.openElements.pop(), e2.insertionMode = T.IN_TABLE, Vt3(e2, t));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TD:
    case s.TH:
    case s.TR:
      break;
    default:
      Vt3(e2, t);
  }
}
function wn(e2, t) {
  switch (t.tagID) {
    case s.TH:
    case s.TD: {
      e2.openElements.clearBackToTableRowContext(), e2._insertElement(t, L3.HTML), e2.insertionMode = T.IN_CELL, e2.activeFormattingElements.insertMarker();
      break;
    }
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.TR: {
      e2.openElements.hasInTableScope(s.TR) && (e2.openElements.clearBackToTableRowContext(), e2.openElements.pop(), e2.insertionMode = T.IN_TABLE_BODY, On(e2, t));
      break;
    }
    default:
      Ct3(e2, t);
  }
}
function qu(e2, t) {
  switch (t.tagID) {
    case s.TR: {
      e2.openElements.hasInTableScope(s.TR) && (e2.openElements.clearBackToTableRowContext(), e2.openElements.pop(), e2.insertionMode = T.IN_TABLE_BODY);
      break;
    }
    case s.TABLE: {
      e2.openElements.hasInTableScope(s.TR) && (e2.openElements.clearBackToTableRowContext(), e2.openElements.pop(), e2.insertionMode = T.IN_TABLE_BODY, gr2(e2, t));
      break;
    }
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      (e2.openElements.hasInTableScope(t.tagID) || e2.openElements.hasInTableScope(s.TR)) && (e2.openElements.clearBackToTableRowContext(), e2.openElements.pop(), e2.insertionMode = T.IN_TABLE_BODY, gr2(e2, t));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
    case s.TD:
    case s.TH:
      break;
    default:
      Vt3(e2, t);
  }
}
function Op(e2, t) {
  const n2 = t.tagID;
  Gu.has(n2) ? (e2.openElements.hasInTableScope(s.TD) || e2.openElements.hasInTableScope(s.TH)) && (e2._closeTableCell(), wn(e2, t)) : Ee3(e2, t);
}
function wp(e2, t) {
  const n2 = t.tagID;
  switch (n2) {
    case s.TD:
    case s.TH: {
      e2.openElements.hasInTableScope(n2) && (e2.openElements.generateImpliedEndTags(), e2.openElements.popUntilTagNamePopped(n2), e2.activeFormattingElements.clearToLastMarker(), e2.insertionMode = T.IN_ROW);
      break;
    }
    case s.TABLE:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD:
    case s.TR: {
      e2.openElements.hasInTableScope(n2) && (e2._closeTableCell(), qu(e2, t));
      break;
    }
    case s.BODY:
    case s.CAPTION:
    case s.COL:
    case s.COLGROUP:
    case s.HTML:
      break;
    default:
      Ln(e2, t);
  }
}
function $u(e2, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee3(e2, t);
      break;
    }
    case s.OPTION: {
      e2.openElements.currentTagId === s.OPTION && e2.openElements.pop(), e2._insertElement(t, L3.HTML);
      break;
    }
    case s.OPTGROUP: {
      e2.openElements.currentTagId === s.OPTION && e2.openElements.pop(), e2.openElements.currentTagId === s.OPTGROUP && e2.openElements.pop(), e2._insertElement(t, L3.HTML);
      break;
    }
    case s.INPUT:
    case s.KEYGEN:
    case s.TEXTAREA:
    case s.SELECT: {
      e2.openElements.hasInSelectScope(s.SELECT) && (e2.openElements.popUntilTagNamePopped(s.SELECT), e2._resetInsertionMode(), t.tagID !== s.SELECT && e2._processStartTag(t));
      break;
    }
    case s.SCRIPT:
    case s.TEMPLATE: {
      Pe3(e2, t);
      break;
    }
  }
}
function Wu(e2, t) {
  switch (t.tagID) {
    case s.OPTGROUP: {
      e2.openElements.stackTop > 0 && e2.openElements.currentTagId === s.OPTION && e2.openElements.tagIDs[e2.openElements.stackTop - 1] === s.OPTGROUP && e2.openElements.pop(), e2.openElements.currentTagId === s.OPTGROUP && e2.openElements.pop();
      break;
    }
    case s.OPTION: {
      e2.openElements.currentTagId === s.OPTION && e2.openElements.pop();
      break;
    }
    case s.SELECT: {
      e2.openElements.hasInSelectScope(s.SELECT) && (e2.openElements.popUntilTagNamePopped(s.SELECT), e2._resetInsertionMode());
      break;
    }
    case s.TEMPLATE: {
      dt3(e2, t);
      break;
    }
  }
}
function Dp(e2, t) {
  const n2 = t.tagID;
  n2 === s.CAPTION || n2 === s.TABLE || n2 === s.TBODY || n2 === s.TFOOT || n2 === s.THEAD || n2 === s.TR || n2 === s.TD || n2 === s.TH ? (e2.openElements.popUntilTagNamePopped(s.SELECT), e2._resetInsertionMode(), e2._processStartTag(t)) : $u(e2, t);
}
function Pp(e2, t) {
  const n2 = t.tagID;
  n2 === s.CAPTION || n2 === s.TABLE || n2 === s.TBODY || n2 === s.TFOOT || n2 === s.THEAD || n2 === s.TR || n2 === s.TD || n2 === s.TH ? e2.openElements.hasInTableScope(n2) && (e2.openElements.popUntilTagNamePopped(s.SELECT), e2._resetInsertionMode(), e2.onEndTag(t)) : Wu(e2, t);
}
function Mp(e2, t) {
  switch (t.tagID) {
    case s.BASE:
    case s.BASEFONT:
    case s.BGSOUND:
    case s.LINK:
    case s.META:
    case s.NOFRAMES:
    case s.SCRIPT:
    case s.STYLE:
    case s.TEMPLATE:
    case s.TITLE: {
      Pe3(e2, t);
      break;
    }
    case s.CAPTION:
    case s.COLGROUP:
    case s.TBODY:
    case s.TFOOT:
    case s.THEAD: {
      e2.tmplInsertionModeStack[0] = T.IN_TABLE, e2.insertionMode = T.IN_TABLE, Ct3(e2, t);
      break;
    }
    case s.COL: {
      e2.tmplInsertionModeStack[0] = T.IN_COLUMN_GROUP, e2.insertionMode = T.IN_COLUMN_GROUP, Hr2(e2, t);
      break;
    }
    case s.TR: {
      e2.tmplInsertionModeStack[0] = T.IN_TABLE_BODY, e2.insertionMode = T.IN_TABLE_BODY, On(e2, t);
      break;
    }
    case s.TD:
    case s.TH: {
      e2.tmplInsertionModeStack[0] = T.IN_ROW, e2.insertionMode = T.IN_ROW, wn(e2, t);
      break;
    }
    default:
      e2.tmplInsertionModeStack[0] = T.IN_BODY, e2.insertionMode = T.IN_BODY, Ee3(e2, t);
  }
}
function Fp(e2, t) {
  t.tagID === s.TEMPLATE && dt3(e2, t);
}
function Vu(e2, t) {
  e2.openElements.tmplCount > 0 ? (e2.openElements.popUntilTagNamePopped(s.TEMPLATE), e2.activeFormattingElements.clearToLastMarker(), e2.tmplInsertionModeStack.shift(), e2._resetInsertionMode(), e2.onEof(t)) : vr2(e2, t);
}
function Bp(e2, t) {
  t.tagID === s.HTML ? Ee3(e2, t) : yn(e2, t);
}
function Qu(e2, t) {
  var n2;
  if (t.tagID === s.HTML) {
    if (e2.fragmentContext || (e2.insertionMode = T.AFTER_AFTER_BODY), e2.options.sourceCodeLocationInfo && e2.openElements.tagIDs[0] === s.HTML) {
      e2._setEndLocation(e2.openElements.items[0], t);
      const r = e2.openElements.items[1];
      r && !(!((n2 = e2.treeAdapter.getNodeSourceCodeLocation(r)) === null || n2 === void 0) && n2.endTag) && e2._setEndLocation(r, t);
    }
  } else
    yn(e2, t);
}
function yn(e2, t) {
  e2.insertionMode = T.IN_BODY, Rn(e2, t);
}
function vp(e2, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee3(e2, t);
      break;
    }
    case s.FRAMESET: {
      e2._insertElement(t, L3.HTML);
      break;
    }
    case s.FRAME: {
      e2._appendElement(t, L3.HTML), t.ackSelfClosing = true;
      break;
    }
    case s.NOFRAMES: {
      Pe3(e2, t);
      break;
    }
  }
}
function Hp(e2, t) {
  t.tagID === s.FRAMESET && !e2.openElements.isRootHtmlElementCurrent() && (e2.openElements.pop(), !e2.fragmentContext && e2.openElements.currentTagId !== s.FRAMESET && (e2.insertionMode = T.AFTER_FRAMESET));
}
function Up(e2, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee3(e2, t);
      break;
    }
    case s.NOFRAMES: {
      Pe3(e2, t);
      break;
    }
  }
}
function zp(e2, t) {
  t.tagID === s.HTML && (e2.insertionMode = T.AFTER_AFTER_FRAMESET);
}
function Yp(e2, t) {
  t.tagID === s.HTML ? Ee3(e2, t) : fn(e2, t);
}
function fn(e2, t) {
  e2.insertionMode = T.IN_BODY, Rn(e2, t);
}
function jp(e2, t) {
  switch (t.tagID) {
    case s.HTML: {
      Ee3(e2, t);
      break;
    }
    case s.NOFRAMES: {
      Pe3(e2, t);
      break;
    }
  }
}
function Gp(e2, t) {
  t.chars = le3, e2._insertCharacters(t);
}
function qp(e2, t) {
  e2._insertCharacters(t), e2.framesetOk = false;
}
function Xu(e2) {
  for (; e2.treeAdapter.getNamespaceURI(e2.openElements.current) !== L3.HTML && !e2._isIntegrationPoint(e2.openElements.currentTagId, e2.openElements.current); )
    e2.openElements.pop();
}
function $p(e2, t) {
  if (sh(t))
    Xu(e2), e2._startTagOutsideForeignContent(t);
  else {
    const n2 = e2._getAdjustedCurrentElement(), r = e2.treeAdapter.getNamespaceURI(n2);
    r === L3.MATHML ? Du(t) : r === L3.SVG && (oh(t), Pu(t)), Fr2(t), t.selfClosing ? e2._appendElement(t, r) : e2._insertElement(t, r), t.ackSelfClosing = true;
  }
}
function Wp(e2, t) {
  if (t.tagID === s.P || t.tagID === s.BR) {
    Xu(e2), e2._endTagOutsideForeignContent(t);
    return;
  }
  for (let n2 = e2.openElements.stackTop; n2 > 0; n2--) {
    const r = e2.openElements.items[n2];
    if (e2.treeAdapter.getNamespaceURI(r) === L3.HTML) {
      e2._endTagOutsideForeignContent(t);
      break;
    }
    const a3 = e2.treeAdapter.getTagName(r);
    if (a3.toLowerCase() === t.tagName) {
      t.tagName = a3, e2.openElements.shortenToLength(n2);
      break;
    }
  }
}
k2.AREA, k2.BASE, k2.BASEFONT, k2.BGSOUND, k2.BR, k2.COL, k2.EMBED, k2.FRAME, k2.HR, k2.IMG, k2.INPUT, k2.KEYGEN, k2.LINK, k2.META, k2.PARAM, k2.SOURCE, k2.TRACK, k2.WBR;
var Vp = /* @__PURE__ */ new Set([
  "mdxFlowExpression",
  "mdxJsxFlowElement",
  "mdxJsxTextElement",
  "mdxTextExpression",
  "mdxjsEsm"
]);
var ui = { sourceCodeLocationInfo: true, scriptingEnabled: false };
function Ku(e2, t) {
  const n2 = am(e2), r = bu("type", {
    handlers: { root: Qp, element: Xp, text: Kp, comment: Ju, doctype: Zp, raw: em },
    unknown: tm
  }), a3 = {
    parser: n2 ? new ri(ui) : ri.getFragmentParser(void 0, ui),
    handle(o2) {
      r(o2, a3);
    },
    stitches: false,
    options: t || {}
  };
  r(e2, a3), Rt3(a3, Ye4());
  const u2 = n2 ? a3.parser.document : a3.parser.getFragment(), i2 = uf(u2, {
    // To do: support `space`?
    file: a3.options.file
  });
  return a3.stitches && Zt3(i2, "comment", function(o2, l, c3) {
    const f2 = (
      /** @type {Stitch} */
      /** @type {unknown} */
      o2
    );
    if (f2.value.stitch && c3 && l !== void 0) {
      const d2 = c3.children;
      return d2[l] = f2.value.stitch, l;
    }
  }), i2.type === "root" && i2.children.length === 1 && i2.children[0].type === e2.type ? i2.children[0] : i2;
}
function Zu(e2, t) {
  let n2 = -1;
  if (e2)
    for (; ++n2 < e2.length; )
      t.handle(e2[n2]);
}
function Qp(e2, t) {
  Zu(e2.children, t);
}
function Xp(e2, t) {
  nm(e2, t), Zu(e2.children, t), rm(e2, t);
}
function Kp(e2, t) {
  t.parser.tokenizer.state > 4 && (t.parser.tokenizer.state = 0);
  const n2 = {
    type: X2.CHARACTER,
    chars: e2.value,
    location: tn(e2)
  };
  Rt3(t, Ye4(e2)), t.parser.currentToken = n2, t.parser._processToken(t.parser.currentToken);
}
function Zp(e2, t) {
  const n2 = {
    type: X2.DOCTYPE,
    name: "html",
    forceQuirks: false,
    publicId: "",
    systemId: "",
    location: tn(e2)
  };
  Rt3(t, Ye4(e2)), t.parser.currentToken = n2, t.parser._processToken(t.parser.currentToken);
}
function Jp(e2, t) {
  t.stitches = true;
  const n2 = im(e2);
  if ("children" in e2 && "children" in n2) {
    const r = (
      /** @type {Root} */
      Ku({ type: "root", children: e2.children }, t.options)
    );
    n2.children = r.children;
  }
  Ju({ type: "comment", value: { stitch: n2 } }, t);
}
function Ju(e2, t) {
  const n2 = e2.value, r = {
    type: X2.COMMENT,
    data: n2,
    location: tn(e2)
  };
  Rt3(t, Ye4(e2)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken);
}
function em(e2, t) {
  if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = false, t.parser.tokenizer.preprocessor.lastChunkWritten = false, t.parser.tokenizer.preprocessor.endOfChunkHit = false, t.parser.tokenizer.preprocessor.isEol = false, es(t, Ye4(e2)), t.parser.tokenizer.write(e2.value, false), t.parser.tokenizer._runParsingLoop(), t.parser.tokenizer.state === 72 || t.parser.tokenizer.state === 78) {
    t.parser.tokenizer.preprocessor.lastChunkWritten = true;
    const n2 = t.parser.tokenizer._consume();
    t.parser.tokenizer._callState(n2);
  }
}
function tm(e2, t) {
  const n2 = (
    /** @type {Nodes} */
    e2
  );
  if (t.options.passThrough && t.options.passThrough.includes(n2.type))
    Jp(n2, t);
  else {
    let r = "";
    throw Vp.has(n2.type) && (r = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n2.type + "` node" + r);
  }
}
function Rt3(e2, t) {
  es(e2, t);
  const n2 = e2.parser.tokenizer.currentCharacterToken;
  n2 && n2.location && (n2.location.endLine = e2.parser.tokenizer.preprocessor.line, n2.location.endCol = e2.parser.tokenizer.preprocessor.col + 1, n2.location.endOffset = e2.parser.tokenizer.preprocessor.offset + 1, e2.parser.currentToken = n2, e2.parser._processToken(e2.parser.currentToken)), e2.parser.tokenizer.paused = false, e2.parser.tokenizer.inLoop = false, e2.parser.tokenizer.active = false, e2.parser.tokenizer.returnState = de2.DATA, e2.parser.tokenizer.charRefCode = -1, e2.parser.tokenizer.consumedAfterSnapshot = -1, e2.parser.tokenizer.currentLocation = null, e2.parser.tokenizer.currentCharacterToken = null, e2.parser.tokenizer.currentToken = null, e2.parser.tokenizer.currentAttr = { name: "", value: "" };
}
function es(e2, t) {
  if (t && t.offset !== void 0) {
    const n2 = {
      startLine: t.line,
      startCol: t.column,
      startOffset: t.offset,
      endLine: -1,
      endCol: -1,
      endOffset: -1
    };
    e2.parser.tokenizer.preprocessor.lineStartPos = -t.column + 1, e2.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e2.parser.tokenizer.preprocessor.line = t.line, e2.parser.tokenizer.currentLocation = n2;
  }
}
function nm(e2, t) {
  const n2 = e2.tagName.toLowerCase();
  if (t.parser.tokenizer.state === de2.PLAINTEXT) return;
  Rt3(t, Ye4(e2));
  const r = t.parser.openElements.current;
  let a3 = "namespaceURI" in r ? r.namespaceURI : ot2.html;
  a3 === ot2.html && n2 === "svg" && (a3 = ot2.svg);
  const u2 = df(
    // Shallow clone to not delve into `children`: we only need the attributes.
    { ...e2, children: [] },
    { space: a3 === ot2.svg ? "svg" : "html" }
  ), i2 = {
    type: X2.START_TAG,
    tagName: n2,
    tagID: Nt3(n2),
    // We always send start and end tags.
    selfClosing: false,
    ackSelfClosing: false,
    // Always element.
    /* c8 ignore next */
    attrs: "attrs" in u2 ? u2.attrs : [],
    location: tn(e2)
  };
  t.parser.currentToken = i2, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = n2;
}
function rm(e2, t) {
  const n2 = e2.tagName.toLowerCase();
  if (!t.parser.tokenizer.inForeignNode && Tf.includes(n2) || t.parser.tokenizer.state === de2.PLAINTEXT) return;
  Rt3(t, Cn(e2));
  const r = {
    type: X2.END_TAG,
    tagName: n2,
    tagID: Nt3(n2),
    selfClosing: false,
    ackSelfClosing: false,
    attrs: [],
    location: tn(e2)
  };
  t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken), // Current element is closed.
  n2 === t.parser.tokenizer.lastStartTagName && // `<textarea>` and `<title>`
  (t.parser.tokenizer.state === de2.RCDATA || // `<iframe>`, `<noembed>`, `<style>`, `<xmp>`
  t.parser.tokenizer.state === de2.RAWTEXT || // `<script>`
  t.parser.tokenizer.state === de2.SCRIPT_DATA) && (t.parser.tokenizer.state = de2.DATA);
}
function am(e2) {
  const t = e2.type === "root" ? e2.children[0] : e2;
  return !!(t && (t.type === "doctype" || t.type === "element" && t.tagName.toLowerCase() === "html"));
}
function tn(e2) {
  const t = Ye4(e2) || {
    line: void 0,
    column: void 0,
    offset: void 0
  }, n2 = Cn(e2) || {
    line: void 0,
    column: void 0,
    offset: void 0
  };
  return {
    startLine: t.line,
    startCol: t.column,
    startOffset: t.offset,
    endLine: n2.line,
    endCol: n2.column,
    endOffset: n2.offset
  };
}
function im(e2) {
  return "children" in e2 ? _t2({ ...e2, children: [] }) : _t2(e2);
}
function um(e2) {
  return function(t, n2) {
    return (
      /** @type {Root} */
      Ku(t, { ...e2, file: n2 })
    );
  };
}
function si(e2, t) {
  const n2 = String(e2);
  if (typeof t != "string")
    throw new TypeError("Expected character");
  let r = 0, a3 = n2.indexOf(t);
  for (; a3 !== -1; )
    r++, a3 = n2.indexOf(t, a3 + t.length);
  return r;
}
function sm(e2, t, n2) {
  const a3 = Sn((n2 || {}).ignore || []), u2 = om(t);
  let i2 = -1;
  for (; ++i2 < u2.length; )
    du(e2, "text", o2);
  function o2(c3, f2) {
    let d2 = -1, b2;
    for (; ++d2 < f2.length; ) {
      const m = f2[d2], h = b2 ? b2.children : void 0;
      if (a3(
        m,
        h ? h.indexOf(m) : void 0,
        b2
      ))
        return;
      b2 = m;
    }
    if (b2)
      return l(c3, f2);
  }
  function l(c3, f2) {
    const d2 = f2[f2.length - 1], b2 = u2[i2][0], m = u2[i2][1];
    let h = 0;
    const y2 = d2.children.indexOf(c3);
    let _3 = false, x2 = [];
    b2.lastIndex = 0;
    let I3 = b2.exec(c3.value);
    for (; I3; ) {
      const M3 = I3.index, B4 = {
        index: I3.index,
        input: I3.input,
        stack: [...f2, c3]
      };
      let R = m(...I3, B4);
      if (typeof R == "string" && (R = R.length > 0 ? { type: "text", value: R } : void 0), R === false ? b2.lastIndex = M3 + 1 : (h !== M3 && x2.push({
        type: "text",
        value: c3.value.slice(h, M3)
      }), Array.isArray(R) ? x2.push(...R) : R && x2.push(R), h = M3 + I3[0].length, _3 = true), !b2.global)
        break;
      I3 = b2.exec(c3.value);
    }
    return _3 ? (h < c3.value.length && x2.push({ type: "text", value: c3.value.slice(h) }), d2.children.splice(y2, 1, ...x2)) : x2 = [c3], y2 + x2.length;
  }
}
function om(e2) {
  const t = [];
  if (!Array.isArray(e2))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const n2 = !e2[0] || Array.isArray(e2[0]) ? e2 : [e2];
  let r = -1;
  for (; ++r < n2.length; ) {
    const a3 = n2[r];
    t.push([lm(a3[0]), cm(a3[1])]);
  }
  return t;
}
function lm(e2) {
  return typeof e2 == "string" ? new RegExp(c(e2), "g") : e2;
}
function cm(e2) {
  return typeof e2 == "function" ? e2 : function() {
    return e2;
  };
}
var Kn = "phrasing";
var Zn = ["autolink", "link", "image", "label"];
function dm() {
  return {
    transforms: [Em],
    enter: {
      literalAutolink: hm,
      literalAutolinkEmail: Jn,
      literalAutolinkHttp: Jn,
      literalAutolinkWww: Jn
    },
    exit: {
      literalAutolink: bm,
      literalAutolinkEmail: gm,
      literalAutolinkHttp: pm,
      literalAutolinkWww: mm
    }
  };
}
function fm() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct: Kn,
        notInConstruct: Zn
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct: Kn,
        notInConstruct: Zn
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct: Kn,
        notInConstruct: Zn
      }
    ]
  };
}
function hm(e2) {
  this.enter({ type: "link", title: null, url: "", children: [] }, e2);
}
function Jn(e2) {
  this.config.enter.autolinkProtocol.call(this, e2);
}
function pm(e2) {
  this.config.exit.autolinkProtocol.call(this, e2);
}
function mm(e2) {
  this.config.exit.data.call(this, e2);
  const t = this.stack[this.stack.length - 1];
  t.type, t.url = "http://" + this.sliceSerialize(e2);
}
function gm(e2) {
  this.config.exit.autolinkEmail.call(this, e2);
}
function bm(e2) {
  this.exit(e2);
}
function Em(e2) {
  sm(
    e2,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, Tm],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, ym]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function Tm(e2, t, n2, r, a3) {
  let u2 = "";
  if (!ts(a3) || (/^w/i.test(t) && (n2 = t + n2, t = "", u2 = "http://"), !Am(n2)))
    return false;
  const i2 = _m(n2 + r);
  if (!i2[0]) return false;
  const o2 = {
    type: "link",
    title: null,
    url: u2 + t + i2[0],
    children: [{ type: "text", value: t + i2[0] }]
  };
  return i2[1] ? [o2, { type: "text", value: i2[1] }] : o2;
}
function ym(e2, t, n2, r) {
  return (
    // Not an expected previous character.
    !ts(r, true) || // Label ends in not allowed character.
    /[-\d_]$/.test(n2) ? false : {
      type: "link",
      title: null,
      url: "mailto:" + t + "@" + n2,
      children: [{ type: "text", value: t + "@" + n2 }]
    }
  );
}
function Am(e2) {
  const t = e2.split(".");
  return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2])));
}
function _m(e2) {
  const t = /[!"&'),.:;<>?\]}]+$/.exec(e2);
  if (!t)
    return [e2, void 0];
  e2 = e2.slice(0, t.index);
  let n2 = t[0], r = n2.indexOf(")");
  const a3 = si(e2, "(");
  let u2 = si(e2, ")");
  for (; r !== -1 && a3 > u2; )
    e2 += n2.slice(0, r + 1), n2 = n2.slice(r + 1), r = n2.indexOf(")"), u2++;
  return [e2, n2];
}
function ts(e2, t) {
  const n2 = e2.input.charCodeAt(e2.index - 1);
  return (e2.index === 0 || lt4(n2) || xn(n2)) && (!t || n2 !== 47);
}
ns.peek = Dm;
function Cm() {
  return {
    enter: {
      gfmFootnoteDefinition: km,
      gfmFootnoteDefinitionLabelString: Im,
      gfmFootnoteCall: Rm,
      gfmFootnoteCallString: Lm
    },
    exit: {
      gfmFootnoteDefinition: Nm,
      gfmFootnoteDefinitionLabelString: Sm,
      gfmFootnoteCall: wm,
      gfmFootnoteCallString: Om
    }
  };
}
function xm() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition: Pm, footnoteReference: ns }
  };
}
function km(e2) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    e2
  );
}
function Im() {
  this.buffer();
}
function Sm(e2) {
  const t = this.resume(), n2 = this.stack[this.stack.length - 1];
  n2.type, n2.label = t, n2.identifier = De3(
    this.sliceSerialize(e2)
  ).toLowerCase();
}
function Nm(e2) {
  this.exit(e2);
}
function Rm(e2) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, e2);
}
function Lm() {
  this.buffer();
}
function Om(e2) {
  const t = this.resume(), n2 = this.stack[this.stack.length - 1];
  n2.type, n2.label = t, n2.identifier = De3(
    this.sliceSerialize(e2)
  ).toLowerCase();
}
function wm(e2) {
  this.exit(e2);
}
function ns(e2, t, n2, r) {
  const a3 = n2.createTracker(r);
  let u2 = a3.move("[^");
  const i2 = n2.enter("footnoteReference"), o2 = n2.enter("reference");
  return u2 += a3.move(
    n2.safe(n2.associationId(e2), {
      ...a3.current(),
      before: u2,
      after: "]"
    })
  ), o2(), i2(), u2 += a3.move("]"), u2;
}
function Dm() {
  return "[";
}
function Pm(e2, t, n2, r) {
  const a3 = n2.createTracker(r);
  let u2 = a3.move("[^");
  const i2 = n2.enter("footnoteDefinition"), o2 = n2.enter("label");
  return u2 += a3.move(
    n2.safe(n2.associationId(e2), {
      ...a3.current(),
      before: u2,
      after: "]"
    })
  ), o2(), u2 += a3.move(
    "]:" + (e2.children && e2.children.length > 0 ? " " : "")
  ), a3.shift(4), u2 += a3.move(
    n2.indentLines(n2.containerFlow(e2, a3.current()), Mm)
  ), i2(), u2;
}
function Mm(e2, t, n2) {
  return t === 0 ? e2 : (n2 ? "" : "    ") + e2;
}
var Fm = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
rs.peek = zm;
function Bm() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: Hm },
    exit: { strikethrough: Um }
  };
}
function vm() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: Fm
      }
    ],
    handlers: { delete: rs }
  };
}
function Hm(e2) {
  this.enter({ type: "delete", children: [] }, e2);
}
function Um(e2) {
  this.exit(e2);
}
function rs(e2, t, n2, r) {
  const a3 = n2.createTracker(r), u2 = n2.enter("strikethrough");
  let i2 = a3.move("~~");
  return i2 += n2.containerPhrasing(e2, {
    ...a3.current(),
    before: i2,
    after: "~"
  }), i2 += a3.move("~~"), u2(), i2;
}
function zm() {
  return "~";
}
function Ym(e2, t = {}) {
  const n2 = (t.align || []).concat(), r = t.stringLength || Gm, a3 = [], u2 = [], i2 = [], o2 = [];
  let l = 0, c3 = -1;
  for (; ++c3 < e2.length; ) {
    const h = [], E = [];
    let y2 = -1;
    for (e2[c3].length > l && (l = e2[c3].length); ++y2 < e2[c3].length; ) {
      const _3 = jm(e2[c3][y2]);
      if (t.alignDelimiters !== false) {
        const x2 = r(_3);
        E[y2] = x2, (o2[y2] === void 0 || x2 > o2[y2]) && (o2[y2] = x2);
      }
      h.push(_3);
    }
    u2[c3] = h, i2[c3] = E;
  }
  let f2 = -1;
  if (typeof n2 == "object" && "length" in n2)
    for (; ++f2 < l; )
      a3[f2] = oi(n2[f2]);
  else {
    const h = oi(n2);
    for (; ++f2 < l; )
      a3[f2] = h;
  }
  f2 = -1;
  const d2 = [], b2 = [];
  for (; ++f2 < l; ) {
    const h = a3[f2];
    let E = "", y2 = "";
    h === 99 ? (E = ":", y2 = ":") : h === 108 ? E = ":" : h === 114 && (y2 = ":");
    let _3 = t.alignDelimiters === false ? 1 : Math.max(
      1,
      o2[f2] - E.length - y2.length
    );
    const x2 = E + "-".repeat(_3) + y2;
    t.alignDelimiters !== false && (_3 = E.length + _3 + y2.length, _3 > o2[f2] && (o2[f2] = _3), b2[f2] = _3), d2[f2] = x2;
  }
  u2.splice(1, 0, d2), i2.splice(1, 0, b2), c3 = -1;
  const m = [];
  for (; ++c3 < u2.length; ) {
    const h = u2[c3], E = i2[c3];
    f2 = -1;
    const y2 = [];
    for (; ++f2 < l; ) {
      const _3 = h[f2] || "";
      let x2 = "", I3 = "";
      if (t.alignDelimiters !== false) {
        const M3 = o2[f2] - (E[f2] || 0), B4 = a3[f2];
        B4 === 114 ? x2 = " ".repeat(M3) : B4 === 99 ? M3 % 2 ? (x2 = " ".repeat(M3 / 2 + 0.5), I3 = " ".repeat(M3 / 2 - 0.5)) : (x2 = " ".repeat(M3 / 2), I3 = x2) : I3 = " ".repeat(M3);
      }
      t.delimiterStart !== false && !f2 && y2.push("|"), t.padding !== false && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(t.alignDelimiters === false && _3 === "") && (t.delimiterStart !== false || f2) && y2.push(" "), t.alignDelimiters !== false && y2.push(x2), y2.push(_3), t.alignDelimiters !== false && y2.push(I3), t.padding !== false && y2.push(" "), (t.delimiterEnd !== false || f2 !== l - 1) && y2.push("|");
    }
    m.push(
      t.delimiterEnd === false ? y2.join("").replace(/ +$/, "") : y2.join("")
    );
  }
  return m.join(`
`);
}
function jm(e2) {
  return e2 == null ? "" : String(e2);
}
function Gm(e2) {
  return e2.length;
}
function oi(e2) {
  const t = typeof e2 == "string" ? e2.codePointAt(0) : 0;
  return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0;
}
function qm(e2, t, n2, r) {
  const a3 = n2.enter("blockquote"), u2 = n2.createTracker(r);
  u2.move("> "), u2.shift(2);
  const i2 = n2.indentLines(
    n2.containerFlow(e2, u2.current()),
    $m
  );
  return a3(), i2;
}
function $m(e2, t, n2) {
  return ">" + (n2 ? "" : " ") + e2;
}
function Wm(e2, t) {
  return li(e2, t.inConstruct, true) && !li(e2, t.notInConstruct, false);
}
function li(e2, t, n2) {
  if (typeof t == "string" && (t = [t]), !t || t.length === 0)
    return n2;
  let r = -1;
  for (; ++r < t.length; )
    if (e2.includes(t[r]))
      return true;
  return false;
}
function ci(e2, t, n2, r) {
  let a3 = -1;
  for (; ++a3 < n2.unsafe.length; )
    if (n2.unsafe[a3].character === `
` && Wm(n2.stack, n2.unsafe[a3]))
      return /[ \t]/.test(r.before) ? "" : " ";
  return `\\
`;
}
function Vm(e2, t) {
  const n2 = String(e2);
  let r = n2.indexOf(t), a3 = r, u2 = 0, i2 = 0;
  if (typeof t != "string")
    throw new TypeError("Expected substring");
  for (; r !== -1; )
    r === a3 ? ++u2 > i2 && (i2 = u2) : u2 = 1, a3 = r + t.length, r = n2.indexOf(t, a3);
  return i2;
}
function Qm(e2, t) {
  return !!(t.options.fences === false && e2.value && // If there’s no info…
  !e2.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(e2.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e2.value));
}
function Xm(e2) {
  const t = e2.options.fence || "`";
  if (t !== "`" && t !== "~")
    throw new Error(
      "Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return t;
}
function Km(e2, t, n2, r) {
  const a3 = Xm(n2), u2 = e2.value || "", i2 = a3 === "`" ? "GraveAccent" : "Tilde";
  if (Qm(e2, n2)) {
    const d2 = n2.enter("codeIndented"), b2 = n2.indentLines(u2, Zm);
    return d2(), b2;
  }
  const o2 = n2.createTracker(r), l = a3.repeat(Math.max(Vm(u2, a3) + 1, 3)), c3 = n2.enter("codeFenced");
  let f2 = o2.move(l);
  if (e2.lang) {
    const d2 = n2.enter(`codeFencedLang${i2}`);
    f2 += o2.move(
      n2.safe(e2.lang, {
        before: f2,
        after: " ",
        encode: ["`"],
        ...o2.current()
      })
    ), d2();
  }
  if (e2.lang && e2.meta) {
    const d2 = n2.enter(`codeFencedMeta${i2}`);
    f2 += o2.move(" "), f2 += o2.move(
      n2.safe(e2.meta, {
        before: f2,
        after: `
`,
        encode: ["`"],
        ...o2.current()
      })
    ), d2();
  }
  return f2 += o2.move(`
`), u2 && (f2 += o2.move(u2 + `
`)), f2 += o2.move(l), c3(), f2;
}
function Zm(e2, t, n2) {
  return (n2 ? "" : "    ") + e2;
}
function Ur2(e2) {
  const t = e2.options.quote || '"';
  if (t !== '"' && t !== "'")
    throw new Error(
      "Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"
    );
  return t;
}
function Jm(e2, t, n2, r) {
  const a3 = Ur2(n2), u2 = a3 === '"' ? "Quote" : "Apostrophe", i2 = n2.enter("definition");
  let o2 = n2.enter("label");
  const l = n2.createTracker(r);
  let c3 = l.move("[");
  return c3 += l.move(
    n2.safe(n2.associationId(e2), {
      before: c3,
      after: "]",
      ...l.current()
    })
  ), c3 += l.move("]: "), o2(), // If there’s no url, or…
  !e2.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e2.url) ? (o2 = n2.enter("destinationLiteral"), c3 += l.move("<"), c3 += l.move(
    n2.safe(e2.url, { before: c3, after: ">", ...l.current() })
  ), c3 += l.move(">")) : (o2 = n2.enter("destinationRaw"), c3 += l.move(
    n2.safe(e2.url, {
      before: c3,
      after: e2.title ? " " : `
`,
      ...l.current()
    })
  )), o2(), e2.title && (o2 = n2.enter(`title${u2}`), c3 += l.move(" " + a3), c3 += l.move(
    n2.safe(e2.title, {
      before: c3,
      after: a3,
      ...l.current()
    })
  ), c3 += l.move(a3), o2()), i2(), c3;
}
function eg(e2) {
  const t = e2.options.emphasis || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return t;
}
as.peek = tg;
function as(e2, t, n2, r) {
  const a3 = eg(n2), u2 = n2.enter("emphasis"), i2 = n2.createTracker(r);
  let o2 = i2.move(a3);
  return o2 += i2.move(
    n2.containerPhrasing(e2, {
      before: o2,
      after: a3,
      ...i2.current()
    })
  ), o2 += i2.move(a3), u2(), o2;
}
function tg(e2, t, n2) {
  return n2.options.emphasis || "*";
}
function ng(e2, t) {
  let n2 = false;
  return Zt3(e2, function(r) {
    if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break")
      return n2 = true, sr2;
  }), !!((!e2.depth || e2.depth < 3) && Ir2(e2) && (t.options.setext || n2));
}
function rg(e2, t, n2, r) {
  const a3 = Math.max(Math.min(6, e2.depth || 1), 1), u2 = n2.createTracker(r);
  if (ng(e2, n2)) {
    const f2 = n2.enter("headingSetext"), d2 = n2.enter("phrasing"), b2 = n2.containerPhrasing(e2, {
      ...u2.current(),
      before: `
`,
      after: `
`
    });
    return d2(), f2(), b2 + `
` + (a3 === 1 ? "=" : "-").repeat(
      // The whole size…
      b2.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(b2.lastIndexOf("\r"), b2.lastIndexOf(`
`)) + 1)
    );
  }
  const i2 = "#".repeat(a3), o2 = n2.enter("headingAtx"), l = n2.enter("phrasing");
  u2.move(i2 + " ");
  let c3 = n2.containerPhrasing(e2, {
    before: "# ",
    after: `
`,
    ...u2.current()
  });
  return /^[\t ]/.test(c3) && (c3 = "&#x" + c3.charCodeAt(0).toString(16).toUpperCase() + ";" + c3.slice(1)), c3 = c3 ? i2 + " " + c3 : i2, n2.options.closeAtx && (c3 += " " + i2), l(), o2(), c3;
}
is.peek = ag;
function is(e2) {
  return e2.value || "";
}
function ag() {
  return "<";
}
us.peek = ig;
function us(e2, t, n2, r) {
  const a3 = Ur2(n2), u2 = a3 === '"' ? "Quote" : "Apostrophe", i2 = n2.enter("image");
  let o2 = n2.enter("label");
  const l = n2.createTracker(r);
  let c3 = l.move("![");
  return c3 += l.move(
    n2.safe(e2.alt, { before: c3, after: "]", ...l.current() })
  ), c3 += l.move("]("), o2(), // If there’s no url but there is a title…
  !e2.url && e2.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e2.url) ? (o2 = n2.enter("destinationLiteral"), c3 += l.move("<"), c3 += l.move(
    n2.safe(e2.url, { before: c3, after: ">", ...l.current() })
  ), c3 += l.move(">")) : (o2 = n2.enter("destinationRaw"), c3 += l.move(
    n2.safe(e2.url, {
      before: c3,
      after: e2.title ? " " : ")",
      ...l.current()
    })
  )), o2(), e2.title && (o2 = n2.enter(`title${u2}`), c3 += l.move(" " + a3), c3 += l.move(
    n2.safe(e2.title, {
      before: c3,
      after: a3,
      ...l.current()
    })
  ), c3 += l.move(a3), o2()), c3 += l.move(")"), i2(), c3;
}
function ig() {
  return "!";
}
ss.peek = ug;
function ss(e2, t, n2, r) {
  const a3 = e2.referenceType, u2 = n2.enter("imageReference");
  let i2 = n2.enter("label");
  const o2 = n2.createTracker(r);
  let l = o2.move("![");
  const c3 = n2.safe(e2.alt, {
    before: l,
    after: "]",
    ...o2.current()
  });
  l += o2.move(c3 + "]["), i2();
  const f2 = n2.stack;
  n2.stack = [], i2 = n2.enter("reference");
  const d2 = n2.safe(n2.associationId(e2), {
    before: l,
    after: "]",
    ...o2.current()
  });
  return i2(), n2.stack = f2, u2(), a3 === "full" || !c3 || c3 !== d2 ? l += o2.move(d2 + "]") : a3 === "shortcut" ? l = l.slice(0, -1) : l += o2.move("]"), l;
}
function ug() {
  return "!";
}
os.peek = sg;
function os(e2, t, n2) {
  let r = e2.value || "", a3 = "`", u2 = -1;
  for (; new RegExp("(^|[^`])" + a3 + "([^`]|$)").test(r); )
    a3 += "`";
  for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++u2 < n2.unsafe.length; ) {
    const i2 = n2.unsafe[u2], o2 = n2.compilePattern(i2);
    let l;
    if (i2.atBreak)
      for (; l = o2.exec(r); ) {
        let c3 = l.index;
        r.charCodeAt(c3) === 10 && r.charCodeAt(c3 - 1) === 13 && c3--, r = r.slice(0, c3) + " " + r.slice(l.index + 1);
      }
  }
  return a3 + r + a3;
}
function sg() {
  return "`";
}
function ls(e2, t) {
  const n2 = Ir2(e2);
  return !!(!t.options.resourceLink && // If there’s a url…
  e2.url && // And there’s a no title…
  !e2.title && // And the content of `node` is a single text node…
  e2.children && e2.children.length === 1 && e2.children[0].type === "text" && // And if the url is the same as the content…
  (n2 === e2.url || "mailto:" + n2 === e2.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(e2.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(e2.url));
}
cs.peek = og;
function cs(e2, t, n2, r) {
  const a3 = Ur2(n2), u2 = a3 === '"' ? "Quote" : "Apostrophe", i2 = n2.createTracker(r);
  let o2, l;
  if (ls(e2, n2)) {
    const f2 = n2.stack;
    n2.stack = [], o2 = n2.enter("autolink");
    let d2 = i2.move("<");
    return d2 += i2.move(
      n2.containerPhrasing(e2, {
        before: d2,
        after: ">",
        ...i2.current()
      })
    ), d2 += i2.move(">"), o2(), n2.stack = f2, d2;
  }
  o2 = n2.enter("link"), l = n2.enter("label");
  let c3 = i2.move("[");
  return c3 += i2.move(
    n2.containerPhrasing(e2, {
      before: c3,
      after: "](",
      ...i2.current()
    })
  ), c3 += i2.move("]("), l(), // If there’s no url but there is a title…
  !e2.url && e2.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(e2.url) ? (l = n2.enter("destinationLiteral"), c3 += i2.move("<"), c3 += i2.move(
    n2.safe(e2.url, { before: c3, after: ">", ...i2.current() })
  ), c3 += i2.move(">")) : (l = n2.enter("destinationRaw"), c3 += i2.move(
    n2.safe(e2.url, {
      before: c3,
      after: e2.title ? " " : ")",
      ...i2.current()
    })
  )), l(), e2.title && (l = n2.enter(`title${u2}`), c3 += i2.move(" " + a3), c3 += i2.move(
    n2.safe(e2.title, {
      before: c3,
      after: a3,
      ...i2.current()
    })
  ), c3 += i2.move(a3), l()), c3 += i2.move(")"), o2(), c3;
}
function og(e2, t, n2) {
  return ls(e2, n2) ? "<" : "[";
}
ds.peek = lg;
function ds(e2, t, n2, r) {
  const a3 = e2.referenceType, u2 = n2.enter("linkReference");
  let i2 = n2.enter("label");
  const o2 = n2.createTracker(r);
  let l = o2.move("[");
  const c3 = n2.containerPhrasing(e2, {
    before: l,
    after: "]",
    ...o2.current()
  });
  l += o2.move(c3 + "]["), i2();
  const f2 = n2.stack;
  n2.stack = [], i2 = n2.enter("reference");
  const d2 = n2.safe(n2.associationId(e2), {
    before: l,
    after: "]",
    ...o2.current()
  });
  return i2(), n2.stack = f2, u2(), a3 === "full" || !c3 || c3 !== d2 ? l += o2.move(d2 + "]") : a3 === "shortcut" ? l = l.slice(0, -1) : l += o2.move("]"), l;
}
function lg() {
  return "[";
}
function zr(e2) {
  const t = e2.options.bullet || "*";
  if (t !== "*" && t !== "+" && t !== "-")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return t;
}
function cg(e2) {
  const t = zr(e2), n2 = e2.options.bulletOther;
  if (!n2)
    return t === "*" ? "-" : "*";
  if (n2 !== "*" && n2 !== "+" && n2 !== "-")
    throw new Error(
      "Cannot serialize items with `" + n2 + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (n2 === t)
    throw new Error(
      "Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n2 + "`) to be different"
    );
  return n2;
}
function dg(e2) {
  const t = e2.options.bulletOrdered || ".";
  if (t !== "." && t !== ")")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return t;
}
function fs(e2) {
  const t = e2.options.rule || "*";
  if (t !== "*" && t !== "-" && t !== "_")
    throw new Error(
      "Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return t;
}
function fg(e2, t, n2, r) {
  const a3 = n2.enter("list"), u2 = n2.bulletCurrent;
  let i2 = e2.ordered ? dg(n2) : zr(n2);
  const o2 = e2.ordered ? i2 === "." ? ")" : "." : cg(n2);
  let l = t && n2.bulletLastUsed ? i2 === n2.bulletLastUsed : false;
  if (!e2.ordered) {
    const f2 = e2.children ? e2.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (i2 === "*" || i2 === "-") && // Empty first list item:
      f2 && (!f2.children || !f2.children[0]) && // Directly in two other list items:
      n2.stack[n2.stack.length - 1] === "list" && n2.stack[n2.stack.length - 2] === "listItem" && n2.stack[n2.stack.length - 3] === "list" && n2.stack[n2.stack.length - 4] === "listItem" && // That are each the first child.
      n2.indexStack[n2.indexStack.length - 1] === 0 && n2.indexStack[n2.indexStack.length - 2] === 0 && n2.indexStack[n2.indexStack.length - 3] === 0 && (l = true), fs(n2) === i2 && f2
    ) {
      let d2 = -1;
      for (; ++d2 < e2.children.length; ) {
        const b2 = e2.children[d2];
        if (b2 && b2.type === "listItem" && b2.children && b2.children[0] && b2.children[0].type === "thematicBreak") {
          l = true;
          break;
        }
      }
    }
  }
  l && (i2 = o2), n2.bulletCurrent = i2;
  const c3 = n2.containerFlow(e2, r);
  return n2.bulletLastUsed = i2, n2.bulletCurrent = u2, a3(), c3;
}
function hg(e2) {
  const t = e2.options.listItemIndent || "one";
  if (t !== "tab" && t !== "one" && t !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return t;
}
function pg(e2, t, n2, r) {
  const a3 = hg(n2);
  let u2 = n2.bulletCurrent || zr(n2);
  t && t.type === "list" && t.ordered && (u2 = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n2.options.incrementListMarker === false ? 0 : t.children.indexOf(e2)) + u2);
  let i2 = u2.length + 1;
  (a3 === "tab" || a3 === "mixed" && (t && t.type === "list" && t.spread || e2.spread)) && (i2 = Math.ceil(i2 / 4) * 4);
  const o2 = n2.createTracker(r);
  o2.move(u2 + " ".repeat(i2 - u2.length)), o2.shift(i2);
  const l = n2.enter("listItem"), c3 = n2.indentLines(
    n2.containerFlow(e2, o2.current()),
    f2
  );
  return l(), c3;
  function f2(d2, b2, m) {
    return b2 ? (m ? "" : " ".repeat(i2)) + d2 : (m ? u2 : u2 + " ".repeat(i2 - u2.length)) + d2;
  }
}
function mg(e2, t, n2, r) {
  const a3 = n2.enter("paragraph"), u2 = n2.enter("phrasing"), i2 = n2.containerPhrasing(e2, r);
  return u2(), a3(), i2;
}
var gg = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  Sn([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function bg(e2, t, n2, r) {
  return (e2.children.some(function(i2) {
    return gg(i2);
  }) ? n2.containerPhrasing : n2.containerFlow).call(n2, e2, r);
}
function Eg(e2) {
  const t = e2.options.strong || "*";
  if (t !== "*" && t !== "_")
    throw new Error(
      "Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"
    );
  return t;
}
hs.peek = Tg;
function hs(e2, t, n2, r) {
  const a3 = Eg(n2), u2 = n2.enter("strong"), i2 = n2.createTracker(r);
  let o2 = i2.move(a3 + a3);
  return o2 += i2.move(
    n2.containerPhrasing(e2, {
      before: o2,
      after: a3,
      ...i2.current()
    })
  ), o2 += i2.move(a3 + a3), u2(), o2;
}
function Tg(e2, t, n2) {
  return n2.options.strong || "*";
}
function yg(e2, t, n2, r) {
  return n2.safe(e2.value, r);
}
function Ag(e2) {
  const t = e2.options.ruleRepetition || 3;
  if (t < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return t;
}
function _g(e2, t, n2) {
  const r = (fs(n2) + (n2.options.ruleSpaces ? " " : "")).repeat(Ag(n2));
  return n2.options.ruleSpaces ? r.slice(0, -1) : r;
}
var ps = {
  blockquote: qm,
  break: ci,
  code: Km,
  definition: Jm,
  emphasis: as,
  hardBreak: ci,
  heading: rg,
  html: is,
  image: us,
  imageReference: ss,
  inlineCode: os,
  link: cs,
  linkReference: ds,
  list: fg,
  listItem: pg,
  paragraph: mg,
  root: bg,
  strong: hs,
  text: yg,
  thematicBreak: _g
};
function Cg() {
  return {
    enter: {
      table: xg,
      tableData: di,
      tableHeader: di,
      tableRow: Ig
    },
    exit: {
      codeText: Sg,
      table: kg,
      tableData: er3,
      tableHeader: er3,
      tableRow: er3
    }
  };
}
function xg(e2) {
  const t = e2._align;
  this.enter(
    {
      type: "table",
      align: t.map(function(n2) {
        return n2 === "none" ? null : n2;
      }),
      children: []
    },
    e2
  ), this.data.inTable = true;
}
function kg(e2) {
  this.exit(e2), this.data.inTable = void 0;
}
function Ig(e2) {
  this.enter({ type: "tableRow", children: [] }, e2);
}
function er3(e2) {
  this.exit(e2);
}
function di(e2) {
  this.enter({ type: "tableCell", children: [] }, e2);
}
function Sg(e2) {
  let t = this.resume();
  this.data.inTable && (t = t.replace(/\\([\\|])/g, Ng));
  const n2 = this.stack[this.stack.length - 1];
  n2.type, n2.value = t, this.exit(e2);
}
function Ng(e2, t) {
  return t === "|" ? t : e2;
}
function Rg(e2) {
  const t = e2 || {}, n2 = t.tableCellPadding, r = t.tablePipeAlign, a3 = t.stringLength, u2 = n2 ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: true, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: true, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: b2,
      table: i2,
      tableCell: l,
      tableRow: o2
    }
  };
  function i2(m, h, E, y2) {
    return c3(f2(m, E, y2), m.align);
  }
  function o2(m, h, E, y2) {
    const _3 = d2(m, E, y2), x2 = c3([_3]);
    return x2.slice(0, x2.indexOf(`
`));
  }
  function l(m, h, E, y2) {
    const _3 = E.enter("tableCell"), x2 = E.enter("phrasing"), I3 = E.containerPhrasing(m, {
      ...y2,
      before: u2,
      after: u2
    });
    return x2(), _3(), I3;
  }
  function c3(m, h) {
    return Ym(m, {
      align: h,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: r,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: n2,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: a3
    });
  }
  function f2(m, h, E) {
    const y2 = m.children;
    let _3 = -1;
    const x2 = [], I3 = h.enter("table");
    for (; ++_3 < y2.length; )
      x2[_3] = d2(y2[_3], h, E);
    return I3(), x2;
  }
  function d2(m, h, E) {
    const y2 = m.children;
    let _3 = -1;
    const x2 = [], I3 = h.enter("tableRow");
    for (; ++_3 < y2.length; )
      x2[_3] = l(y2[_3], m, h, E);
    return I3(), x2;
  }
  function b2(m, h, E) {
    let y2 = ps.inlineCode(m, h, E);
    return E.stack.includes("tableCell") && (y2 = y2.replace(/\|/g, "\\$&")), y2;
  }
}
function Lg() {
  return {
    exit: {
      taskListCheckValueChecked: fi,
      taskListCheckValueUnchecked: fi,
      paragraph: wg
    }
  };
}
function Og() {
  return {
    unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
    handlers: { listItem: Dg }
  };
}
function fi(e2) {
  const t = this.stack[this.stack.length - 2];
  t.type, t.checked = e2.type === "taskListCheckValueChecked";
}
function wg(e2) {
  const t = this.stack[this.stack.length - 2];
  if (t && t.type === "listItem" && typeof t.checked == "boolean") {
    const n2 = this.stack[this.stack.length - 1];
    n2.type;
    const r = n2.children[0];
    if (r && r.type === "text") {
      const a3 = t.children;
      let u2 = -1, i2;
      for (; ++u2 < a3.length; ) {
        const o2 = a3[u2];
        if (o2.type === "paragraph") {
          i2 = o2;
          break;
        }
      }
      i2 === n2 && (r.value = r.value.slice(1), r.value.length === 0 ? n2.children.shift() : n2.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n2.position.start = Object.assign({}, r.position.start)));
    }
  }
  this.exit(e2);
}
function Dg(e2, t, n2, r) {
  const a3 = e2.children[0], u2 = typeof e2.checked == "boolean" && a3 && a3.type === "paragraph", i2 = "[" + (e2.checked ? "x" : " ") + "] ", o2 = n2.createTracker(r);
  u2 && o2.move(i2);
  let l = ps.listItem(e2, t, n2, {
    ...r,
    ...o2.current()
  });
  return u2 && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, c3)), l;
  function c3(f2) {
    return f2 + i2;
  }
}
function Pg() {
  return [
    dm(),
    Cm(),
    Bm(),
    Cg(),
    Lg()
  ];
}
function Mg(e2) {
  return {
    extensions: [
      fm(),
      xm(),
      vm(),
      Rg(e2),
      Og()
    ]
  };
}
var Fg = {
  tokenize: Yg,
  partial: true
};
var ms = {
  tokenize: jg,
  partial: true
};
var gs = {
  tokenize: Gg,
  partial: true
};
var bs = {
  tokenize: qg,
  partial: true
};
var Bg = {
  tokenize: $g,
  partial: true
};
var Es = {
  tokenize: Ug,
  previous: ys
};
var Ts = {
  tokenize: zg,
  previous: As
};
var We3 = {
  tokenize: Hg,
  previous: _s
};
var je3 = {};
function vg() {
  return {
    text: je3
  };
}
var it3 = 48;
for (; it3 < 123; )
  je3[it3] = We3, it3++, it3 === 58 ? it3 = 65 : it3 === 91 && (it3 = 97);
je3[43] = We3;
je3[45] = We3;
je3[46] = We3;
je3[95] = We3;
je3[72] = [We3, Ts];
je3[104] = [We3, Ts];
je3[87] = [We3, Es];
je3[119] = [We3, Es];
function Hg(e2, t, n2) {
  const r = this;
  let a3, u2;
  return i2;
  function i2(d2) {
    return !br2(d2) || !_s.call(r, r.previous) || Yr(r.events) ? n2(d2) : (e2.enter("literalAutolink"), e2.enter("literalAutolinkEmail"), o2(d2));
  }
  function o2(d2) {
    return br2(d2) ? (e2.consume(d2), o2) : d2 === 64 ? (e2.consume(d2), l) : n2(d2);
  }
  function l(d2) {
    return d2 === 46 ? e2.check(
      Bg,
      f2,
      c3
    )(d2) : d2 === 45 || d2 === 95 || ge3(d2) ? (u2 = true, e2.consume(d2), l) : f2(d2);
  }
  function c3(d2) {
    return e2.consume(d2), a3 = true, l;
  }
  function f2(d2) {
    return u2 && a3 && ye2(r.previous) ? (e2.exit("literalAutolinkEmail"), e2.exit("literalAutolink"), t(d2)) : n2(d2);
  }
}
function Ug(e2, t, n2) {
  const r = this;
  return a3;
  function a3(i2) {
    return i2 !== 87 && i2 !== 119 || !ys.call(r, r.previous) || Yr(r.events) ? n2(i2) : (e2.enter("literalAutolink"), e2.enter("literalAutolinkWww"), e2.check(
      Fg,
      e2.attempt(ms, e2.attempt(gs, u2), n2),
      n2
    )(i2));
  }
  function u2(i2) {
    return e2.exit("literalAutolinkWww"), e2.exit("literalAutolink"), t(i2);
  }
}
function zg(e2, t, n2) {
  const r = this;
  let a3 = "", u2 = false;
  return i2;
  function i2(d2) {
    return (d2 === 72 || d2 === 104) && As.call(r, r.previous) && !Yr(r.events) ? (e2.enter("literalAutolink"), e2.enter("literalAutolinkHttp"), a3 += String.fromCodePoint(d2), e2.consume(d2), o2) : n2(d2);
  }
  function o2(d2) {
    if (ye2(d2) && a3.length < 5)
      return a3 += String.fromCodePoint(d2), e2.consume(d2), o2;
    if (d2 === 58) {
      const b2 = a3.toLowerCase();
      if (b2 === "http" || b2 === "https")
        return e2.consume(d2), l;
    }
    return n2(d2);
  }
  function l(d2) {
    return d2 === 47 ? (e2.consume(d2), u2 ? c3 : (u2 = true, l)) : n2(d2);
  }
  function c3(d2) {
    return d2 === null || mn(d2) || ie4(d2) || lt4(d2) || xn(d2) ? n2(d2) : e2.attempt(ms, e2.attempt(gs, f2), n2)(d2);
  }
  function f2(d2) {
    return e2.exit("literalAutolinkHttp"), e2.exit("literalAutolink"), t(d2);
  }
}
function Yg(e2, t, n2) {
  let r = 0;
  return a3;
  function a3(i2) {
    return (i2 === 87 || i2 === 119) && r < 3 ? (r++, e2.consume(i2), a3) : i2 === 46 && r === 3 ? (e2.consume(i2), u2) : n2(i2);
  }
  function u2(i2) {
    return i2 === null ? n2(i2) : t(i2);
  }
}
function jg(e2, t, n2) {
  let r, a3, u2;
  return i2;
  function i2(c3) {
    return c3 === 46 || c3 === 95 ? e2.check(bs, l, o2)(c3) : c3 === null || ie4(c3) || lt4(c3) || c3 !== 45 && xn(c3) ? l(c3) : (u2 = true, e2.consume(c3), i2);
  }
  function o2(c3) {
    return c3 === 95 ? r = true : (a3 = r, r = void 0), e2.consume(c3), i2;
  }
  function l(c3) {
    return a3 || r || !u2 ? n2(c3) : t(c3);
  }
}
function Gg(e2, t) {
  let n2 = 0, r = 0;
  return a3;
  function a3(i2) {
    return i2 === 40 ? (n2++, e2.consume(i2), a3) : i2 === 41 && r < n2 ? u2(i2) : i2 === 33 || i2 === 34 || i2 === 38 || i2 === 39 || i2 === 41 || i2 === 42 || i2 === 44 || i2 === 46 || i2 === 58 || i2 === 59 || i2 === 60 || i2 === 63 || i2 === 93 || i2 === 95 || i2 === 126 ? e2.check(bs, t, u2)(i2) : i2 === null || ie4(i2) || lt4(i2) ? t(i2) : (e2.consume(i2), a3);
  }
  function u2(i2) {
    return i2 === 41 && r++, e2.consume(i2), a3;
  }
}
function qg(e2, t, n2) {
  return r;
  function r(o2) {
    return o2 === 33 || o2 === 34 || o2 === 39 || o2 === 41 || o2 === 42 || o2 === 44 || o2 === 46 || o2 === 58 || o2 === 59 || o2 === 63 || o2 === 95 || o2 === 126 ? (e2.consume(o2), r) : o2 === 38 ? (e2.consume(o2), u2) : o2 === 93 ? (e2.consume(o2), a3) : (
      // `<` is an end.
      o2 === 60 || // So is whitespace.
      o2 === null || ie4(o2) || lt4(o2) ? t(o2) : n2(o2)
    );
  }
  function a3(o2) {
    return o2 === null || o2 === 40 || o2 === 91 || ie4(o2) || lt4(o2) ? t(o2) : r(o2);
  }
  function u2(o2) {
    return ye2(o2) ? i2(o2) : n2(o2);
  }
  function i2(o2) {
    return o2 === 59 ? (e2.consume(o2), r) : ye2(o2) ? (e2.consume(o2), i2) : n2(o2);
  }
}
function $g(e2, t, n2) {
  return r;
  function r(u2) {
    return e2.consume(u2), a3;
  }
  function a3(u2) {
    return ge3(u2) ? n2(u2) : t(u2);
  }
}
function ys(e2) {
  return e2 === null || e2 === 40 || e2 === 42 || e2 === 95 || e2 === 91 || e2 === 93 || e2 === 126 || ie4(e2);
}
function As(e2) {
  return !ye2(e2);
}
function _s(e2) {
  return !(e2 === 47 || br2(e2));
}
function br2(e2) {
  return e2 === 43 || e2 === 45 || e2 === 46 || e2 === 95 || ge3(e2);
}
function Yr(e2) {
  let t = e2.length, n2 = false;
  for (; t--; ) {
    const r = e2[t][1];
    if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) {
      n2 = true;
      break;
    }
    if (r._gfmAutolinkLiteralWalkedInto) {
      n2 = false;
      break;
    }
  }
  return e2.length > 0 && !n2 && (e2[e2.length - 1][1]._gfmAutolinkLiteralWalkedInto = true), n2;
}
var Wg = {
  tokenize: t1,
  partial: true
};
function Vg() {
  return {
    document: {
      91: {
        tokenize: Zg,
        continuation: {
          tokenize: Jg
        },
        exit: e1
      }
    },
    text: {
      91: {
        tokenize: Kg
      },
      93: {
        add: "after",
        tokenize: Qg,
        resolveTo: Xg
      }
    }
  };
}
function Qg(e2, t, n2) {
  const r = this;
  let a3 = r.events.length;
  const u2 = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let i2;
  for (; a3--; ) {
    const l = r.events[a3][1];
    if (l.type === "labelImage") {
      i2 = l;
      break;
    }
    if (l.type === "gfmFootnoteCall" || l.type === "labelLink" || l.type === "label" || l.type === "image" || l.type === "link")
      break;
  }
  return o2;
  function o2(l) {
    if (!i2 || !i2._balanced)
      return n2(l);
    const c3 = De3(
      r.sliceSerialize({
        start: i2.end,
        end: r.now()
      })
    );
    return c3.codePointAt(0) !== 94 || !u2.includes(c3.slice(1)) ? n2(l) : (e2.enter("gfmFootnoteCallLabelMarker"), e2.consume(l), e2.exit("gfmFootnoteCallLabelMarker"), t(l));
  }
}
function Xg(e2, t) {
  let n2 = e2.length;
  for (; n2--; )
    if (e2[n2][1].type === "labelImage" && e2[n2][0] === "enter") {
      e2[n2][1];
      break;
    }
  e2[n2 + 1][1].type = "data", e2[n2 + 3][1].type = "gfmFootnoteCallLabelMarker";
  const r = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, e2[n2 + 3][1].start),
    end: Object.assign({}, e2[e2.length - 1][1].end)
  }, a3 = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, e2[n2 + 3][1].end),
    end: Object.assign({}, e2[n2 + 3][1].end)
  };
  a3.end.column++, a3.end.offset++, a3.end._bufferIndex++;
  const u2 = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, a3.end),
    end: Object.assign({}, e2[e2.length - 1][1].start)
  }, i2 = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, u2.start),
    end: Object.assign({}, u2.end)
  }, o2 = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    e2[n2 + 1],
    e2[n2 + 2],
    ["enter", r, t],
    // The `[`
    e2[n2 + 3],
    e2[n2 + 4],
    // The `^`.
    ["enter", a3, t],
    ["exit", a3, t],
    // Everything in between.
    ["enter", u2, t],
    ["enter", i2, t],
    ["exit", i2, t],
    ["exit", u2, t],
    // The ending (`]`, properly parsed and labelled).
    e2[e2.length - 2],
    e2[e2.length - 1],
    ["exit", r, t]
  ];
  return e2.splice(n2, e2.length - n2 + 1, ...o2), e2;
}
function Kg(e2, t, n2) {
  const r = this, a3 = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let u2 = 0, i2;
  return o2;
  function o2(d2) {
    return e2.enter("gfmFootnoteCall"), e2.enter("gfmFootnoteCallLabelMarker"), e2.consume(d2), e2.exit("gfmFootnoteCallLabelMarker"), l;
  }
  function l(d2) {
    return d2 !== 94 ? n2(d2) : (e2.enter("gfmFootnoteCallMarker"), e2.consume(d2), e2.exit("gfmFootnoteCallMarker"), e2.enter("gfmFootnoteCallString"), e2.enter("chunkString").contentType = "string", c3);
  }
  function c3(d2) {
    if (
      // Too long.
      u2 > 999 || // Closing brace with nothing.
      d2 === 93 && !i2 || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      d2 === null || d2 === 91 || ie4(d2)
    )
      return n2(d2);
    if (d2 === 93) {
      e2.exit("chunkString");
      const b2 = e2.exit("gfmFootnoteCallString");
      return a3.includes(De3(r.sliceSerialize(b2))) ? (e2.enter("gfmFootnoteCallLabelMarker"), e2.consume(d2), e2.exit("gfmFootnoteCallLabelMarker"), e2.exit("gfmFootnoteCall"), t) : n2(d2);
    }
    return ie4(d2) || (i2 = true), u2++, e2.consume(d2), d2 === 92 ? f2 : c3;
  }
  function f2(d2) {
    return d2 === 91 || d2 === 92 || d2 === 93 ? (e2.consume(d2), u2++, c3) : c3(d2);
  }
}
function Zg(e2, t, n2) {
  const r = this, a3 = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []);
  let u2, i2 = 0, o2;
  return l;
  function l(h) {
    return e2.enter("gfmFootnoteDefinition")._container = true, e2.enter("gfmFootnoteDefinitionLabel"), e2.enter("gfmFootnoteDefinitionLabelMarker"), e2.consume(h), e2.exit("gfmFootnoteDefinitionLabelMarker"), c3;
  }
  function c3(h) {
    return h === 94 ? (e2.enter("gfmFootnoteDefinitionMarker"), e2.consume(h), e2.exit("gfmFootnoteDefinitionMarker"), e2.enter("gfmFootnoteDefinitionLabelString"), e2.enter("chunkString").contentType = "string", f2) : n2(h);
  }
  function f2(h) {
    if (
      // Too long.
      i2 > 999 || // Closing brace with nothing.
      h === 93 && !o2 || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      h === null || h === 91 || ie4(h)
    )
      return n2(h);
    if (h === 93) {
      e2.exit("chunkString");
      const E = e2.exit("gfmFootnoteDefinitionLabelString");
      return u2 = De3(r.sliceSerialize(E)), e2.enter("gfmFootnoteDefinitionLabelMarker"), e2.consume(h), e2.exit("gfmFootnoteDefinitionLabelMarker"), e2.exit("gfmFootnoteDefinitionLabel"), b2;
    }
    return ie4(h) || (o2 = true), i2++, e2.consume(h), h === 92 ? d2 : f2;
  }
  function d2(h) {
    return h === 91 || h === 92 || h === 93 ? (e2.consume(h), i2++, f2) : f2(h);
  }
  function b2(h) {
    return h === 58 ? (e2.enter("definitionMarker"), e2.consume(h), e2.exit("definitionMarker"), a3.includes(u2) || a3.push(u2), J2(
      e2,
      m,
      "gfmFootnoteDefinitionWhitespace"
    )) : n2(h);
  }
  function m(h) {
    return t(h);
  }
}
function Jg(e2, t, n2) {
  return e2.check(Kt, t, e2.attempt(Wg, t, n2));
}
function e1(e2) {
  e2.exit("gfmFootnoteDefinition");
}
function t1(e2, t, n2) {
  const r = this;
  return J2(
    e2,
    a3,
    "gfmFootnoteDefinitionIndent",
    5
  );
  function a3(u2) {
    const i2 = r.events[r.events.length - 1];
    return i2 && i2[1].type === "gfmFootnoteDefinitionIndent" && i2[2].sliceSerialize(i2[1], true).length === 4 ? t(u2) : n2(u2);
  }
}
function n1(e2) {
  let n2 = (e2 || {}).singleTilde;
  const r = {
    tokenize: u2,
    resolveAll: a3
  };
  return n2 == null && (n2 = true), {
    text: {
      126: r
    },
    insideSpan: {
      null: [r]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function a3(i2, o2) {
    let l = -1;
    for (; ++l < i2.length; )
      if (i2[l][0] === "enter" && i2[l][1].type === "strikethroughSequenceTemporary" && i2[l][1]._close) {
        let c3 = l;
        for (; c3--; )
          if (i2[c3][0] === "exit" && i2[c3][1].type === "strikethroughSequenceTemporary" && i2[c3][1]._open && // If the sizes are the same:
          i2[l][1].end.offset - i2[l][1].start.offset === i2[c3][1].end.offset - i2[c3][1].start.offset) {
            i2[l][1].type = "strikethroughSequence", i2[c3][1].type = "strikethroughSequence";
            const f2 = {
              type: "strikethrough",
              start: Object.assign({}, i2[c3][1].start),
              end: Object.assign({}, i2[l][1].end)
            }, d2 = {
              type: "strikethroughText",
              start: Object.assign({}, i2[c3][1].end),
              end: Object.assign({}, i2[l][1].start)
            }, b2 = [
              ["enter", f2, o2],
              ["enter", i2[c3][1], o2],
              ["exit", i2[c3][1], o2],
              ["enter", d2, o2]
            ], m = o2.parser.constructs.insideSpan.null;
            m && Ne3(
              b2,
              b2.length,
              0,
              kn(m, i2.slice(c3 + 1, l), o2)
            ), Ne3(b2, b2.length, 0, [
              ["exit", d2, o2],
              ["enter", i2[l][1], o2],
              ["exit", i2[l][1], o2],
              ["exit", f2, o2]
            ]), Ne3(i2, c3 - 1, l - c3 + 3, b2), l = c3 + b2.length - 2;
            break;
          }
      }
    for (l = -1; ++l < i2.length; )
      i2[l][1].type === "strikethroughSequenceTemporary" && (i2[l][1].type = "data");
    return i2;
  }
  function u2(i2, o2, l) {
    const c3 = this.previous, f2 = this.events;
    let d2 = 0;
    return b2;
    function b2(h) {
      return c3 === 126 && f2[f2.length - 1][1].type !== "characterEscape" ? l(h) : (i2.enter("strikethroughSequenceTemporary"), m(h));
    }
    function m(h) {
      const E = gn(c3);
      if (h === 126)
        return d2 > 1 ? l(h) : (i2.consume(h), d2++, m);
      if (d2 < 2 && !n2) return l(h);
      const y2 = i2.exit("strikethroughSequenceTemporary"), _3 = gn(h);
      return y2._open = !_3 || _3 === 2 && !!E, y2._close = !E || E === 2 && !!_3, o2(h);
    }
  }
}
var r1 = class {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(t, n2, r) {
    a1(this, t, n2, r);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImpl(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(t) {
    if (this.map.sort(function(u2, i2) {
      return u2[0] - i2[0];
    }), this.map.length === 0)
      return;
    let n2 = this.map.length;
    const r = [];
    for (; n2 > 0; )
      n2 -= 1, r.push(
        t.slice(this.map[n2][0] + this.map[n2][1]),
        this.map[n2][2]
      ), t.length = this.map[n2][0];
    r.push([...t]), t.length = 0;
    let a3 = r.pop();
    for (; a3; )
      t.push(...a3), a3 = r.pop();
    this.map.length = 0;
  }
};
function a1(e2, t, n2, r) {
  let a3 = 0;
  if (!(n2 === 0 && r.length === 0)) {
    for (; a3 < e2.map.length; ) {
      if (e2.map[a3][0] === t) {
        e2.map[a3][1] += n2, e2.map[a3][2].push(...r);
        return;
      }
      a3 += 1;
    }
    e2.map.push([t, n2, r]);
  }
}
function i1(e2, t) {
  let n2 = false;
  const r = [];
  for (; t < e2.length; ) {
    const a3 = e2[t];
    if (n2) {
      if (a3[0] === "enter")
        a3[1].type === "tableContent" && r.push(
          e2[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none"
        );
      else if (a3[1].type === "tableContent") {
        if (e2[t - 1][1].type === "tableDelimiterMarker") {
          const u2 = r.length - 1;
          r[u2] = r[u2] === "left" ? "center" : "right";
        }
      } else if (a3[1].type === "tableDelimiterRow")
        break;
    } else a3[0] === "enter" && a3[1].type === "tableDelimiterRow" && (n2 = true);
    t += 1;
  }
  return r;
}
function u1() {
  return {
    flow: {
      null: {
        tokenize: s1,
        resolveAll: o1
      }
    }
  };
}
function s1(e2, t, n2) {
  const r = this;
  let a3 = 0, u2 = 0, i2;
  return o2;
  function o2(S2) {
    let H3 = r.events.length - 1;
    for (; H3 > -1; ) {
      const G2 = r.events[H3][1].type;
      if (G2 === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      G2 === "linePrefix")
        H3--;
      else break;
    }
    const F2 = H3 > -1 ? r.events[H3][1].type : null, ee3 = F2 === "tableHead" || F2 === "tableRow" ? R : l;
    return ee3 === R && r.parser.lazy[r.now().line] ? n2(S2) : ee3(S2);
  }
  function l(S2) {
    return e2.enter("tableHead"), e2.enter("tableRow"), c3(S2);
  }
  function c3(S2) {
    return S2 === 124 || (i2 = true, u2 += 1), f2(S2);
  }
  function f2(S2) {
    return S2 === null ? n2(S2) : z2(S2) ? u2 > 1 ? (u2 = 0, r.interrupt = true, e2.exit("tableRow"), e2.enter("lineEnding"), e2.consume(S2), e2.exit("lineEnding"), m) : n2(S2) : K2(S2) ? J2(e2, f2, "whitespace")(S2) : (u2 += 1, i2 && (i2 = false, a3 += 1), S2 === 124 ? (e2.enter("tableCellDivider"), e2.consume(S2), e2.exit("tableCellDivider"), i2 = true, f2) : (e2.enter("data"), d2(S2)));
  }
  function d2(S2) {
    return S2 === null || S2 === 124 || ie4(S2) ? (e2.exit("data"), f2(S2)) : (e2.consume(S2), S2 === 92 ? b2 : d2);
  }
  function b2(S2) {
    return S2 === 92 || S2 === 124 ? (e2.consume(S2), d2) : d2(S2);
  }
  function m(S2) {
    return r.interrupt = false, r.parser.lazy[r.now().line] ? n2(S2) : (e2.enter("tableDelimiterRow"), i2 = false, K2(S2) ? J2(
      e2,
      h,
      "linePrefix",
      r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
    )(S2) : h(S2));
  }
  function h(S2) {
    return S2 === 45 || S2 === 58 ? y2(S2) : S2 === 124 ? (i2 = true, e2.enter("tableCellDivider"), e2.consume(S2), e2.exit("tableCellDivider"), E) : B4(S2);
  }
  function E(S2) {
    return K2(S2) ? J2(e2, y2, "whitespace")(S2) : y2(S2);
  }
  function y2(S2) {
    return S2 === 58 ? (u2 += 1, i2 = true, e2.enter("tableDelimiterMarker"), e2.consume(S2), e2.exit("tableDelimiterMarker"), _3) : S2 === 45 ? (u2 += 1, _3(S2)) : S2 === null || z2(S2) ? M3(S2) : B4(S2);
  }
  function _3(S2) {
    return S2 === 45 ? (e2.enter("tableDelimiterFiller"), x2(S2)) : B4(S2);
  }
  function x2(S2) {
    return S2 === 45 ? (e2.consume(S2), x2) : S2 === 58 ? (i2 = true, e2.exit("tableDelimiterFiller"), e2.enter("tableDelimiterMarker"), e2.consume(S2), e2.exit("tableDelimiterMarker"), I3) : (e2.exit("tableDelimiterFiller"), I3(S2));
  }
  function I3(S2) {
    return K2(S2) ? J2(e2, M3, "whitespace")(S2) : M3(S2);
  }
  function M3(S2) {
    return S2 === 124 ? h(S2) : S2 === null || z2(S2) ? !i2 || a3 !== u2 ? B4(S2) : (e2.exit("tableDelimiterRow"), e2.exit("tableHead"), t(S2)) : B4(S2);
  }
  function B4(S2) {
    return n2(S2);
  }
  function R(S2) {
    return e2.enter("tableRow"), U2(S2);
  }
  function U2(S2) {
    return S2 === 124 ? (e2.enter("tableCellDivider"), e2.consume(S2), e2.exit("tableCellDivider"), U2) : S2 === null || z2(S2) ? (e2.exit("tableRow"), t(S2)) : K2(S2) ? J2(e2, U2, "whitespace")(S2) : (e2.enter("data"), q3(S2));
  }
  function q3(S2) {
    return S2 === null || S2 === 124 || ie4(S2) ? (e2.exit("data"), U2(S2)) : (e2.consume(S2), S2 === 92 ? Y3 : q3);
  }
  function Y3(S2) {
    return S2 === 92 || S2 === 124 ? (e2.consume(S2), q3) : q3(S2);
  }
}
function o1(e2, t) {
  let n2 = -1, r = true, a3 = 0, u2 = [0, 0, 0, 0], i2 = [0, 0, 0, 0], o2 = false, l = 0, c3, f2, d2;
  const b2 = new r1();
  for (; ++n2 < e2.length; ) {
    const m = e2[n2], h = m[1];
    m[0] === "enter" ? h.type === "tableHead" ? (o2 = false, l !== 0 && (hi(b2, t, l, c3, f2), f2 = void 0, l = 0), c3 = {
      type: "table",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, b2.add(n2, 0, [["enter", c3, t]])) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (r = true, d2 = void 0, u2 = [0, 0, 0, 0], i2 = [0, n2 + 1, 0, 0], o2 && (o2 = false, f2 = {
      type: "tableBody",
      start: Object.assign({}, h.start),
      // Note: correct end is set later.
      end: Object.assign({}, h.end)
    }, b2.add(n2, 0, [["enter", f2, t]])), a3 = h.type === "tableDelimiterRow" ? 2 : f2 ? 3 : 1) : a3 && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") ? (r = false, i2[2] === 0 && (u2[1] !== 0 && (i2[0] = i2[1], d2 = on(
      b2,
      t,
      u2,
      a3,
      void 0,
      d2
    ), u2 = [0, 0, 0, 0]), i2[2] = n2)) : h.type === "tableCellDivider" && (r ? r = false : (u2[1] !== 0 && (i2[0] = i2[1], d2 = on(
      b2,
      t,
      u2,
      a3,
      void 0,
      d2
    )), u2 = i2, i2 = [u2[1], n2, 0, 0])) : h.type === "tableHead" ? (o2 = true, l = n2) : h.type === "tableRow" || h.type === "tableDelimiterRow" ? (l = n2, u2[1] !== 0 ? (i2[0] = i2[1], d2 = on(
      b2,
      t,
      u2,
      a3,
      n2,
      d2
    )) : i2[1] !== 0 && (d2 = on(b2, t, i2, a3, n2, d2)), a3 = 0) : a3 && (h.type === "data" || h.type === "tableDelimiterMarker" || h.type === "tableDelimiterFiller") && (i2[3] = n2);
  }
  for (l !== 0 && hi(b2, t, l, c3, f2), b2.consume(t.events), n2 = -1; ++n2 < t.events.length; ) {
    const m = t.events[n2];
    m[0] === "enter" && m[1].type === "table" && (m[1]._align = i1(t.events, n2));
  }
  return e2;
}
function on(e2, t, n2, r, a3, u2) {
  const i2 = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", o2 = "tableContent";
  n2[0] !== 0 && (u2.end = Object.assign({}, gt3(t.events, n2[0])), e2.add(n2[0], 0, [["exit", u2, t]]));
  const l = gt3(t.events, n2[1]);
  if (u2 = {
    type: i2,
    start: Object.assign({}, l),
    // Note: correct end is set later.
    end: Object.assign({}, l)
  }, e2.add(n2[1], 0, [["enter", u2, t]]), n2[2] !== 0) {
    const c3 = gt3(t.events, n2[2]), f2 = gt3(t.events, n2[3]), d2 = {
      type: o2,
      start: Object.assign({}, c3),
      end: Object.assign({}, f2)
    };
    if (e2.add(n2[2], 0, [["enter", d2, t]]), r !== 2) {
      const b2 = t.events[n2[2]], m = t.events[n2[3]];
      if (b2[1].end = Object.assign({}, m[1].end), b2[1].type = "chunkText", b2[1].contentType = "text", n2[3] > n2[2] + 1) {
        const h = n2[2] + 1, E = n2[3] - n2[2] - 1;
        e2.add(h, E, []);
      }
    }
    e2.add(n2[3] + 1, 0, [["exit", d2, t]]);
  }
  return a3 !== void 0 && (u2.end = Object.assign({}, gt3(t.events, a3)), e2.add(a3, 0, [["exit", u2, t]]), u2 = void 0), u2;
}
function hi(e2, t, n2, r, a3) {
  const u2 = [], i2 = gt3(t.events, n2);
  a3 && (a3.end = Object.assign({}, i2), u2.push(["exit", a3, t])), r.end = Object.assign({}, i2), u2.push(["exit", r, t]), e2.add(n2 + 1, 0, u2);
}
function gt3(e2, t) {
  const n2 = e2[t], r = n2[0] === "enter" ? "start" : "end";
  return n2[1][r];
}
var l1 = {
  tokenize: d1
};
function c1() {
  return {
    text: {
      91: l1
    }
  };
}
function d1(e2, t, n2) {
  const r = this;
  return a3;
  function a3(l) {
    return (
      // Exit if there’s stuff before.
      r.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !r._gfmTasklistFirstContentOfListItem ? n2(l) : (e2.enter("taskListCheck"), e2.enter("taskListCheckMarker"), e2.consume(l), e2.exit("taskListCheckMarker"), u2)
    );
  }
  function u2(l) {
    return ie4(l) ? (e2.enter("taskListCheckValueUnchecked"), e2.consume(l), e2.exit("taskListCheckValueUnchecked"), i2) : l === 88 || l === 120 ? (e2.enter("taskListCheckValueChecked"), e2.consume(l), e2.exit("taskListCheckValueChecked"), i2) : n2(l);
  }
  function i2(l) {
    return l === 93 ? (e2.enter("taskListCheckMarker"), e2.consume(l), e2.exit("taskListCheckMarker"), e2.exit("taskListCheck"), o2) : n2(l);
  }
  function o2(l) {
    return z2(l) ? t(l) : K2(l) ? e2.check(
      {
        tokenize: f1
      },
      t,
      n2
    )(l) : n2(l);
  }
}
function f1(e2, t, n2) {
  return J2(e2, r, "whitespace");
  function r(a3) {
    return a3 === null ? n2(a3) : t(a3);
  }
}
function h1(e2) {
  return $i([
    vg(),
    Vg(),
    n1(e2),
    u1(),
    c1()
  ]);
}
var p1 = {};
function m1(e2) {
  const t = (
    /** @type {Processor} */
    this
  ), n2 = e2 || p1, r = t.data(), a3 = r.micromarkExtensions || (r.micromarkExtensions = []), u2 = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), i2 = r.toMarkdownExtensions || (r.toMarkdownExtensions = []);
  a3.push(h1(n2)), u2.push(Pg()), i2.push(Mg(n2));
}
var g1 = ({
  className: e2,
  children: t,
  selectOnClick: n2
}) => dr.jsx(
  "code",
  {
    onClick: (r) => {
      if (!n2) return;
      const a3 = window.getSelection(), u2 = document.createRange();
      u2.selectNodeContents(r.currentTarget), a3 == null || a3.removeAllRanges(), a3 == null || a3.addRange(u2);
    },
    className: bt3(
      "font-mono border p-1 py-0.5 rounded bg-border/50 dark:bg-border/70 whitespace-nowrap",
      e2
    ),
    children: t
  }
);
var b1 = Object.create;
var Dn = Object.defineProperty;
var E1 = Object.defineProperties;
var T1 = Object.getOwnPropertyDescriptor;
var y1 = Object.getOwnPropertyDescriptors;
var Cs = Object.getOwnPropertyNames;
var An = Object.getOwnPropertySymbols;
var A1 = Object.getPrototypeOf;
var jr2 = Object.prototype.hasOwnProperty;
var xs = Object.prototype.propertyIsEnumerable;
var pi = (e2, t, n2) => t in e2 ? Dn(e2, t, { enumerable: true, configurable: true, writable: true, value: n2 }) : e2[t] = n2;
var ze3 = (e2, t) => {
  for (var n2 in t || (t = {}))
    jr2.call(t, n2) && pi(e2, n2, t[n2]);
  if (An)
    for (var n2 of An(t))
      xs.call(t, n2) && pi(e2, n2, t[n2]);
  return e2;
};
var Pn = (e2, t) => E1(e2, y1(t));
var ks = (e2, t) => {
  var n2 = {};
  for (var r in e2)
    jr2.call(e2, r) && t.indexOf(r) < 0 && (n2[r] = e2[r]);
  if (e2 != null && An)
    for (var r of An(e2))
      t.indexOf(r) < 0 && xs.call(e2, r) && (n2[r] = e2[r]);
  return n2;
};
var _1 = (e2, t) => function() {
  return t || (0, e2[Cs(e2)[0]])((t = { exports: {} }).exports, t), t.exports;
};
var C1 = (e2, t) => {
  for (var n2 in t)
    Dn(e2, n2, { get: t[n2], enumerable: true });
};
var x1 = (e2, t, n2, r) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let a3 of Cs(t))
      !jr2.call(e2, a3) && a3 !== n2 && Dn(e2, a3, { get: () => t[a3], enumerable: !(r = T1(t, a3)) || r.enumerable });
  return e2;
};
var k1 = (e2, t, n2) => (n2 = e2 != null ? b1(A1(e2)) : {}, x1(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  !e2 || !e2.__esModule ? Dn(n2, "default", { value: e2, enumerable: true }) : n2,
  e2
));
var I1 = _1({
  "../../node_modules/.pnpm/prismjs@1.29.0_patch_hash=vrxx3pzkik6jpmgpayxfjunetu/node_modules/prismjs/prism.js"(e2, t) {
    var n2 = function() {
      var r = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, a3 = 0, u2 = {}, i2 = {
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function h(E) {
            return E instanceof o2 ? new o2(E.type, h(E.content), E.alias) : Array.isArray(E) ? E.map(h) : E.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(h) {
            return Object.prototype.toString.call(h).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(h) {
            return h.__id || Object.defineProperty(h, "__id", { value: ++a3 }), h.__id;
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function h(E, y2) {
            y2 = y2 || {};
            var _3, x2;
            switch (i2.util.type(E)) {
              case "Object":
                if (x2 = i2.util.objId(E), y2[x2])
                  return y2[x2];
                _3 = /** @type {Record<string, any>} */
                {}, y2[x2] = _3;
                for (var I3 in E)
                  E.hasOwnProperty(I3) && (_3[I3] = h(E[I3], y2));
                return (
                  /** @type {any} */
                  _3
                );
              case "Array":
                return x2 = i2.util.objId(E), y2[x2] ? y2[x2] : (_3 = [], y2[x2] = _3, E.forEach(function(M3, B4) {
                  _3[B4] = h(M3, y2);
                }), /** @type {any} */
                _3);
              default:
                return E;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(h) {
            for (; h; ) {
              var E = r.exec(h.className);
              if (E)
                return E[1].toLowerCase();
              h = h.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(h, E) {
            h.className = h.className.replace(RegExp(r, "gi"), ""), h.classList.add("language-" + E);
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(h, E, y2) {
            for (var _3 = "no-" + E; h; ) {
              var x2 = h.classList;
              if (x2.contains(E))
                return true;
              if (x2.contains(_3))
                return false;
              h = h.parentElement;
            }
            return !!y2;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: u2,
          plaintext: u2,
          text: u2,
          txt: u2,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(h, E) {
            var y2 = i2.util.clone(i2.languages[h]);
            for (var _3 in E)
              y2[_3] = E[_3];
            return y2;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(h, E, y2, _3) {
            _3 = _3 || /** @type {any} */
            i2.languages;
            var x2 = _3[h], I3 = {};
            for (var M3 in x2)
              if (x2.hasOwnProperty(M3)) {
                if (M3 == E)
                  for (var B4 in y2)
                    y2.hasOwnProperty(B4) && (I3[B4] = y2[B4]);
                y2.hasOwnProperty(M3) || (I3[M3] = x2[M3]);
              }
            var R = _3[h];
            return _3[h] = I3, i2.languages.DFS(i2.languages, function(U2, q3) {
              q3 === R && U2 != h && (this[U2] = I3);
            }), I3;
          },
          // Traverse a language definition with Depth First Search
          DFS: function h(E, y2, _3, x2) {
            x2 = x2 || {};
            var I3 = i2.util.objId;
            for (var M3 in E)
              if (E.hasOwnProperty(M3)) {
                y2.call(E, M3, E[M3], _3 || M3);
                var B4 = E[M3], R = i2.util.type(B4);
                R === "Object" && !x2[I3(B4)] ? (x2[I3(B4)] = true, h(B4, y2, null, x2)) : R === "Array" && !x2[I3(B4)] && (x2[I3(B4)] = true, h(B4, y2, M3, x2));
              }
          }
        },
        plugins: {},
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(h, E, y2) {
          var _3 = {
            code: h,
            grammar: E,
            language: y2
          };
          if (i2.hooks.run("before-tokenize", _3), !_3.grammar)
            throw new Error('The language "' + _3.language + '" has no grammar.');
          return _3.tokens = i2.tokenize(_3.code, _3.grammar), i2.hooks.run("after-tokenize", _3), o2.stringify(i2.util.encode(_3.tokens), _3.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(h, E) {
          var y2 = E.rest;
          if (y2) {
            for (var _3 in y2)
              E[_3] = y2[_3];
            delete E.rest;
          }
          var x2 = new f2();
          return d2(x2, x2.head, h), c3(h, x2, E, x2.head, 0), m(x2);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(h, E) {
            var y2 = i2.hooks.all;
            y2[h] = y2[h] || [], y2[h].push(E);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(h, E) {
            var y2 = i2.hooks.all[h];
            if (!(!y2 || !y2.length))
              for (var _3 = 0, x2; x2 = y2[_3++]; )
                x2(E);
          }
        },
        Token: o2
      };
      function o2(h, E, y2, _3) {
        this.type = h, this.content = E, this.alias = y2, this.length = (_3 || "").length | 0;
      }
      o2.stringify = function h(E, y2) {
        if (typeof E == "string")
          return E;
        if (Array.isArray(E)) {
          var _3 = "";
          return E.forEach(function(R) {
            _3 += h(R, y2);
          }), _3;
        }
        var x2 = {
          type: E.type,
          content: h(E.content, y2),
          tag: "span",
          classes: ["token", E.type],
          attributes: {},
          language: y2
        }, I3 = E.alias;
        I3 && (Array.isArray(I3) ? Array.prototype.push.apply(x2.classes, I3) : x2.classes.push(I3)), i2.hooks.run("wrap", x2);
        var M3 = "";
        for (var B4 in x2.attributes)
          M3 += " " + B4 + '="' + (x2.attributes[B4] || "").replace(/"/g, "&quot;") + '"';
        return "<" + x2.tag + ' class="' + x2.classes.join(" ") + '"' + M3 + ">" + x2.content + "</" + x2.tag + ">";
      };
      function l(h, E, y2, _3) {
        h.lastIndex = E;
        var x2 = h.exec(y2);
        if (x2 && _3 && x2[1]) {
          var I3 = x2[1].length;
          x2.index += I3, x2[0] = x2[0].slice(I3);
        }
        return x2;
      }
      function c3(h, E, y2, _3, x2, I3) {
        for (var M3 in y2)
          if (!(!y2.hasOwnProperty(M3) || !y2[M3])) {
            var B4 = y2[M3];
            B4 = Array.isArray(B4) ? B4 : [B4];
            for (var R = 0; R < B4.length; ++R) {
              if (I3 && I3.cause == M3 + "," + R)
                return;
              var U2 = B4[R], q3 = U2.inside, Y3 = !!U2.lookbehind, S2 = !!U2.greedy, H3 = U2.alias;
              if (S2 && !U2.pattern.global) {
                var F2 = U2.pattern.toString().match(/[imsuy]*$/)[0];
                U2.pattern = RegExp(U2.pattern.source, F2 + "g");
              }
              for (var ee3 = U2.pattern || U2, G2 = _3.next, j3 = x2; G2 !== E.tail && !(I3 && j3 >= I3.reach); j3 += G2.value.length, G2 = G2.next) {
                var te3 = G2.value;
                if (E.length > h.length)
                  return;
                if (!(te3 instanceof o2)) {
                  var se4 = 1, re3;
                  if (S2) {
                    if (re3 = l(ee3, j3, h, Y3), !re3 || re3.index >= h.length)
                      break;
                    var Ae3 = re3.index, me3 = re3.index + re3[0].length, A3 = j3;
                    for (A3 += G2.value.length; Ae3 >= A3; )
                      G2 = G2.next, A3 += G2.value.length;
                    if (A3 -= G2.value.length, j3 = A3, G2.value instanceof o2)
                      continue;
                    for (var ae3 = G2; ae3 !== E.tail && (A3 < me3 || typeof ae3.value == "string"); ae3 = ae3.next)
                      se4++, A3 += ae3.value.length;
                    se4--, te3 = h.slice(j3, A3), re3.index -= j3;
                  } else if (re3 = l(ee3, 0, te3, Y3), !re3)
                    continue;
                  var Ae3 = re3.index, C2 = re3[0], Te3 = te3.slice(0, Ae3), Me2 = te3.slice(Ae3 + C2.length), ce2 = j3 + te3.length;
                  I3 && ce2 > I3.reach && (I3.reach = ce2);
                  var Fe3 = G2.prev;
                  Te3 && (Fe3 = d2(E, Fe3, Te3), j3 += Te3.length), b2(E, Fe3, se4);
                  var Be3 = new o2(M3, q3 ? i2.tokenize(C2, q3) : C2, H3, C2);
                  if (G2 = d2(E, Fe3, Be3), Me2 && d2(E, G2, Me2), se4 > 1) {
                    var ve3 = {
                      cause: M3 + "," + R,
                      reach: ce2
                    };
                    c3(h, E, y2, G2.prev, j3, ve3), I3 && ve3.reach > I3.reach && (I3.reach = ve3.reach);
                  }
                }
              }
            }
          }
      }
      function f2() {
        var h = { value: null, prev: null, next: null }, E = { value: null, prev: h, next: null };
        h.next = E, this.head = h, this.tail = E, this.length = 0;
      }
      function d2(h, E, y2) {
        var _3 = E.next, x2 = { value: y2, prev: E, next: _3 };
        return E.next = x2, _3.prev = x2, h.length++, x2;
      }
      function b2(h, E, y2) {
        for (var _3 = E.next, x2 = 0; x2 < y2 && _3 !== h.tail; x2++)
          _3 = _3.next;
        E.next = _3, _3.prev = E, h.length -= x2;
      }
      function m(h) {
        for (var E = [], y2 = h.head.next; y2 !== h.tail; )
          E.push(y2.value), y2 = y2.next;
        return E;
      }
      return i2;
    }();
    t.exports = n2, n2.default = n2;
  }
});
var w = k1(I1());
w.languages.markup = { comment: { pattern: /<!--(?:(?!<!--)[\s\S])*?-->/, greedy: true }, prolog: { pattern: /<\?[\s\S]+?\?>/, greedy: true }, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i, greedy: true, inside: { "internal-subset": { pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/, lookbehind: true, greedy: true, inside: null }, string: { pattern: /"[^"]*"|'[^']*'/, greedy: true }, punctuation: /^<!|>$|[[\]]/, "doctype-tag": /^DOCTYPE/i, name: /[^\s<>'"]+/ } }, cdata: { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, greedy: true }, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/, greedy: true, inside: { tag: { pattern: /^<\/?[^\s>\/]+/, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, "special-attr": [], "attr-value": { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/, inside: { punctuation: [{ pattern: /^=/, alias: "attr-equals" }, { pattern: /^(\s*)["']|["']$/, lookbehind: true }] } }, punctuation: /\/?>/, "attr-name": { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: [{ pattern: /&[\da-z]{1,8};/i, alias: "named-entity" }, /&#x?[\da-f]{1,8};/i] }, w.languages.markup.tag.inside["attr-value"].inside.entity = w.languages.markup.entity, w.languages.markup.doctype.inside["internal-subset"].inside = w.languages.markup, w.hooks.add("wrap", function(e2) {
  e2.type === "entity" && (e2.attributes.title = e2.content.replace(/&amp;/, "&"));
}), Object.defineProperty(w.languages.markup.tag, "addInlined", { value: function(e2, r) {
  var n2 = {}, n2 = (n2["language-" + r] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: true, inside: w.languages[r] }, n2.cdata = /^<!\[CDATA\[|\]\]>$/i, { "included-cdata": { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: n2 } }), r = (n2["language-" + r] = { pattern: /[\s\S]+/, inside: w.languages[r] }, {});
  r[e2] = { pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
    return e2;
  }), "i"), lookbehind: true, greedy: true, inside: n2 }, w.languages.insertBefore("markup", "cdata", r);
} }), Object.defineProperty(w.languages.markup.tag, "addAttribute", { value: function(e2, t) {
  w.languages.markup.tag.inside["special-attr"].push({ pattern: RegExp(/(^|["'\s])/.source + "(?:" + e2 + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source, "i"), lookbehind: true, inside: { "attr-name": /^[^\s=]+/, "attr-value": { pattern: /=[\s\S]+/, inside: { value: { pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/, lookbehind: true, alias: [t, "language-" + t], inside: w.languages[t] }, punctuation: [{ pattern: /^=/, alias: "attr-equals" }, /"|'/] } } } });
} }), w.languages.html = w.languages.markup, w.languages.mathml = w.languages.markup, w.languages.svg = w.languages.markup, w.languages.xml = w.languages.extend("markup", {}), w.languages.ssml = w.languages.xml, w.languages.atom = w.languages.xml, w.languages.rss = w.languages.xml, function(e2) {
  var t = { pattern: /\\[\\(){}[\]^$+*?|.]/, alias: "escape" }, n2 = /\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/, r = "(?:[^\\\\-]|" + n2.source + ")", r = RegExp(r + "-" + r), a3 = { pattern: /(<|')[^<>']+(?=[>']$)/, lookbehind: true, alias: "variable" };
  e2.languages.regex = { "char-class": { pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/, lookbehind: true, inside: { "char-class-negation": { pattern: /(^\[)\^/, lookbehind: true, alias: "operator" }, "char-class-punctuation": { pattern: /^\[|\]$/, alias: "punctuation" }, range: { pattern: r, inside: { escape: n2, "range-punctuation": { pattern: /-/, alias: "operator" } } }, "special-escape": t, "char-set": { pattern: /\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" }, escape: n2 } }, "special-escape": t, "char-set": { pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i, alias: "class-name" }, backreference: [{ pattern: /\\(?![123][0-7]{2})[1-9]/, alias: "keyword" }, { pattern: /\\k<[^<>']+>/, alias: "keyword", inside: { "group-name": a3 } }], anchor: { pattern: /[$^]|\\[ABbGZz]/, alias: "function" }, escape: n2, group: [{ pattern: /\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/, alias: "punctuation", inside: { "group-name": a3 } }, { pattern: /\)/, alias: "punctuation" }], quantifier: { pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/, alias: "number" }, alternation: { pattern: /\|/, alias: "keyword" } };
}(w), w.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: true, greedy: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: true }, "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: true, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/, boolean: /\b(?:false|true)\b/, function: /\b\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/, punctuation: /[{}[\];(),.:]/ }, w.languages.javascript = w.languages.extend("clike", { "class-name": [w.languages.clike["class-name"], { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/, lookbehind: true }], keyword: [{ pattern: /((?:^|\})\s*)catch\b/, lookbehind: true }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: true }], function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, number: { pattern: RegExp(/(^|[^\w$])/.source + "(?:" + /NaN|Infinity/.source + "|" + /0[bB][01]+(?:_[01]+)*n?/.source + "|" + /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + /\d+(?:_\d+)*n/.source + "|" + /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source + ")" + /(?![\w$])/.source), lookbehind: true }, operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/ }), w.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, w.languages.insertBefore("javascript", "keyword", { regex: { pattern: RegExp(/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source), lookbehind: true, greedy: true, inside: { "regex-source": { pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/, lookbehind: true, alias: "language-regex", inside: w.languages.regex }, "regex-delimiter": /^\/|\/$/, "regex-flags": /^[a-z]+$/ } }, "function-variable": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/, alias: "function" }, parameter: [{ pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/, lookbehind: true, inside: w.languages.javascript }, { pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i, lookbehind: true, inside: w.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/, lookbehind: true, inside: w.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/, lookbehind: true, inside: w.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ }), w.languages.insertBefore("javascript", "string", { hashbang: { pattern: /^#!.*/, greedy: true, alias: "comment" }, "template-string": { pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/, greedy: true, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/, lookbehind: true, inside: { "interpolation-punctuation": { pattern: /^\$\{|\}$/, alias: "punctuation" }, rest: w.languages.javascript } }, string: /[\s\S]+/ } }, "string-property": { pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m, lookbehind: true, greedy: true, alias: "property" } }), w.languages.insertBefore("javascript", "operator", { "literal-property": { pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m, lookbehind: true, alias: "property" } }), w.languages.markup && (w.languages.markup.tag.addInlined("script", "javascript"), w.languages.markup.tag.addAttribute(/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source, "javascript")), w.languages.js = w.languages.javascript, w.languages.actionscript = w.languages.extend("javascript", { keyword: /\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/, operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/ }), w.languages.actionscript["class-name"].alias = "function", delete w.languages.actionscript.parameter, delete w.languages.actionscript["literal-property"], w.languages.markup && w.languages.insertBefore("actionscript", "string", { xml: { pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/, lookbehind: true, inside: w.languages.markup } }), function(e2) {
  var t = /#(?!\{).+/, n2 = { pattern: /#\{[^}]+\}/, alias: "variable" };
  e2.languages.coffeescript = e2.languages.extend("javascript", { comment: t, string: [{ pattern: /'(?:\\[\s\S]|[^\\'])*'/, greedy: true }, { pattern: /"(?:\\[\s\S]|[^\\"])*"/, greedy: true, inside: { interpolation: n2 } }], keyword: /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/, "class-member": { pattern: /@(?!\d)\w+/, alias: "variable" } }), e2.languages.insertBefore("coffeescript", "comment", { "multiline-comment": { pattern: /###[\s\S]+?###/, alias: "comment" }, "block-regex": { pattern: /\/{3}[\s\S]*?\/{3}/, alias: "regex", inside: { comment: t, interpolation: n2 } } }), e2.languages.insertBefore("coffeescript", "string", { "inline-javascript": { pattern: /`(?:\\[\s\S]|[^\\`])*`/, inside: { delimiter: { pattern: /^`|`$/, alias: "punctuation" }, script: { pattern: /[\s\S]+/, alias: "language-javascript", inside: e2.languages.javascript } } }, "multiline-string": [{ pattern: /'''[\s\S]*?'''/, greedy: true, alias: "string" }, { pattern: /"""[\s\S]*?"""/, greedy: true, alias: "string", inside: { interpolation: n2 } }] }), e2.languages.insertBefore("coffeescript", "keyword", { property: /(?!\d)\w+(?=\s*:(?!:))/ }), delete e2.languages.coffeescript["template-string"], e2.languages.coffee = e2.languages.coffeescript;
}(w), function(e2) {
  var t = e2.languages.javadoclike = { parameter: { pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m, lookbehind: true }, keyword: { pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m, lookbehind: true }, punctuation: /[{}]/ };
  Object.defineProperty(t, "addSupport", { value: function(n2, r) {
    (n2 = typeof n2 == "string" ? [n2] : n2).forEach(function(a3) {
      var u2 = function(d2) {
        d2.inside || (d2.inside = {}), d2.inside.rest = r;
      }, i2 = "doc-comment";
      if (o2 = e2.languages[a3]) {
        var o2, l = o2[i2];
        if ((l = l || (o2 = e2.languages.insertBefore(a3, "comment", { "doc-comment": { pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/, lookbehind: true, alias: "comment" } }))[i2]) instanceof RegExp && (l = o2[i2] = { pattern: l }), Array.isArray(l))
          for (var c3 = 0, f2 = l.length; c3 < f2; c3++)
            l[c3] instanceof RegExp && (l[c3] = { pattern: l[c3] }), u2(l[c3]);
        else
          u2(l);
      }
    });
  } }), t.addSupport(["java", "javascript", "php"], t);
}(w), function(e2) {
  var t = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/, t = (e2.languages.css = { comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + t.source + ")*?" + /(?:;|(?=\s*\{))/.source), inside: { rule: /^@[\w-]+/, "selector-function-argument": { pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/, lookbehind: true, alias: "selector" }, keyword: { pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/, lookbehind: true } } }, url: { pattern: RegExp("\\burl\\((?:" + t.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"), greedy: true, inside: { function: /^url/i, punctuation: /^\(|\)$/, string: { pattern: RegExp("^" + t.source + "$"), alias: "url" } } }, selector: { pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + t.source + ")*(?=\\s*\\{)"), lookbehind: true }, string: { pattern: t, greedy: true }, property: { pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i, lookbehind: true }, important: /!important\b/i, function: { pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i, lookbehind: true }, punctuation: /[(){};:,]/ }, e2.languages.css.atrule.inside.rest = e2.languages.css, e2.languages.markup);
  t && (t.tag.addInlined("style", "css"), t.tag.addAttribute("style", "css"));
}(w), function(e2) {
  var t = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, t = (e2.languages.css.selector = { pattern: e2.languages.css.selector.pattern, lookbehind: true, inside: t = { "pseudo-element": /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/, "pseudo-class": /:[-\w]+/, class: /\.[-\w]+/, id: /#[-\w]+/, attribute: { pattern: RegExp(`\\[(?:[^[\\]"']|` + t.source + ")*\\]"), greedy: true, inside: { punctuation: /^\[|\]$/, "case-sensitivity": { pattern: /(\s)[si]$/i, lookbehind: true, alias: "keyword" }, namespace: { pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/, lookbehind: true, inside: { punctuation: /\|$/ } }, "attr-name": { pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/, lookbehind: true }, "attr-value": [t, { pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/, lookbehind: true }], operator: /[|~*^$]?=/ } }, "n-th": [{ pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/, lookbehind: true, inside: { number: /[\dn]+/, operator: /[+-]/ } }, { pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i, lookbehind: true }], combinator: />|\+|~|\|\|/, punctuation: /[(),]/ } }, e2.languages.css.atrule.inside["selector-function-argument"].inside = t, e2.languages.insertBefore("css", "property", { variable: { pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i, lookbehind: true } }), { pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/, lookbehind: true }), n2 = { pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/, lookbehind: true };
  e2.languages.insertBefore("css", "function", { operator: { pattern: /(\s)[+\-*\/](?=\s)/, lookbehind: true }, hexcode: { pattern: /\B#[\da-f]{3,8}\b/i, alias: "color" }, color: [{ pattern: /(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|RebeccaPurple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i, lookbehind: true }, { pattern: /\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i, inside: { unit: t, number: n2, function: /[\w-]+(?=\()/, punctuation: /[(),]/ } }], entity: /\\[\da-f]{1,8}/i, unit: t, number: n2 });
}(w), function(e2) {
  var t = /[*&][^\s[\]{},]+/, n2 = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/, r = "(?:" + n2.source + "(?:[ 	]+" + t.source + ")?|" + t.source + "(?:[ 	]+" + n2.source + ")?)", a3 = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  }), u2 = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function i2(o2, l) {
    l = (l || "").replace(/m/g, "") + "m";
    var c3 = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return r;
    }).replace(/<<value>>/g, function() {
      return o2;
    });
    return RegExp(c3, l);
  }
  e2.languages.yaml = { scalar: { pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
    return r;
  })), lookbehind: true, alias: "string" }, comment: /#.*/, key: { pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
    return r;
  }).replace(/<<key>>/g, function() {
    return "(?:" + a3 + "|" + u2 + ")";
  })), lookbehind: true, greedy: true, alias: "atrule" }, directive: { pattern: /(^[ \t]*)%.+/m, lookbehind: true, alias: "important" }, datetime: { pattern: i2(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source), lookbehind: true, alias: "number" }, boolean: { pattern: i2(/false|true/.source, "i"), lookbehind: true, alias: "important" }, null: { pattern: i2(/null|~/.source, "i"), lookbehind: true, alias: "important" }, string: { pattern: i2(u2), lookbehind: true, greedy: true }, number: { pattern: i2(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"), lookbehind: true }, tag: n2, important: t, punctuation: /---|[:[\]{}\-,|>?]|\.\.\./ }, e2.languages.yml = e2.languages.yaml;
}(w), function(e2) {
  var t = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function n2(c3) {
    return c3 = c3.replace(/<inner>/g, function() {
      return t;
    }), RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + c3 + ")");
  }
  var r = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source, a3 = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return r;
  }), u2 = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source, i2 = (e2.languages.markdown = e2.languages.extend("markup", {}), e2.languages.insertBefore("markdown", "prolog", { "front-matter-block": { pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/, lookbehind: true, greedy: true, inside: { punctuation: /^---|---$/, "front-matter": { pattern: /\S+(?:\s+\S+)*/, alias: ["yaml", "language-yaml"], inside: e2.languages.yaml } } }, blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: "punctuation" }, table: { pattern: RegExp("^" + a3 + u2 + "(?:" + a3 + ")*", "m"), inside: { "table-data-rows": { pattern: RegExp("^(" + a3 + u2 + ")(?:" + a3 + ")*$"), lookbehind: true, inside: { "table-data": { pattern: RegExp(r), inside: e2.languages.markdown }, punctuation: /\|/ } }, "table-line": { pattern: RegExp("^(" + a3 + ")" + u2 + "$"), lookbehind: true, inside: { punctuation: /\||:?-{3,}:?/ } }, "table-header-row": { pattern: RegExp("^" + a3 + "$"), inside: { "table-header": { pattern: RegExp(r), alias: "important", inside: e2.languages.markdown }, punctuation: /\|/ } } } }, code: [{ pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/, lookbehind: true, alias: "keyword" }, { pattern: /^```[\s\S]*?^```$/m, greedy: true, inside: { "code-block": { pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m, lookbehind: true }, "code-language": { pattern: /^(```).+/, lookbehind: true }, punctuation: /```/ } }], title: [{ pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m, alias: "important", inside: { punctuation: /==+$|--+$/ } }, { pattern: /(^\s*)#.+/m, lookbehind: true, alias: "important", inside: { punctuation: /^#+|#+$/ } }], hr: { pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m, lookbehind: true, alias: "punctuation" }, list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: true, alias: "punctuation" }, "url-reference": { pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/, inside: { variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: true }, string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/, punctuation: /^[\[\]!:]|[<>]/ }, alias: "url" }, bold: { pattern: n2(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^..)[\s\S]+(?=..$)/, lookbehind: true, inside: {} }, punctuation: /\*\*|__/ } }, italic: { pattern: n2(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^.)[\s\S]+(?=.$)/, lookbehind: true, inside: {} }, punctuation: /[*_]/ } }, strike: { pattern: n2(/(~~?)(?:(?!~)<inner>)+\2/.source), lookbehind: true, greedy: true, inside: { content: { pattern: /(^~~?)[\s\S]+(?=\1$)/, lookbehind: true, inside: {} }, punctuation: /~~?/ } }, "code-snippet": { pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/, lookbehind: true, greedy: true, alias: ["code", "keyword"] }, url: { pattern: n2(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source), lookbehind: true, greedy: true, inside: { operator: /^!/, content: { pattern: /(^\[)[^\]]+(?=\])/, lookbehind: true, inside: {} }, variable: { pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/, lookbehind: true }, url: { pattern: /(^\]\()[^\s)]+/, lookbehind: true }, string: { pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/, lookbehind: true } } } }), ["url", "bold", "italic", "strike"].forEach(function(c3) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(f2) {
      c3 !== f2 && (e2.languages.markdown[c3].inside.content.inside[f2] = e2.languages.markdown[f2]);
    });
  }), e2.hooks.add("after-tokenize", function(c3) {
    c3.language !== "markdown" && c3.language !== "md" || function f2(d2) {
      if (d2 && typeof d2 != "string")
        for (var b2 = 0, m = d2.length; b2 < m; b2++) {
          var h, E = d2[b2];
          E.type !== "code" ? f2(E.content) : (h = E.content[1], E = E.content[3], h && E && h.type === "code-language" && E.type === "code-block" && typeof h.content == "string" && (h = h.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp"), h = "language-" + (h = (/[a-z][\w-]*/i.exec(h) || [""])[0].toLowerCase()), E.alias ? typeof E.alias == "string" ? E.alias = [E.alias, h] : E.alias.push(h) : E.alias = [h]));
        }
    }(c3.tokens);
  }), e2.hooks.add("wrap", function(c3) {
    if (c3.type === "code-block") {
      for (var f2 = "", d2 = 0, b2 = c3.classes.length; d2 < b2; d2++) {
        var m = c3.classes[d2], m = /language-(.+)/.exec(m);
        if (m) {
          f2 = m[1];
          break;
        }
      }
      var h, E = e2.languages[f2];
      E ? c3.content = e2.highlight(function(y2) {
        return y2 = y2.replace(i2, ""), y2 = y2.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(_3, x2) {
          var I3;
          return (x2 = x2.toLowerCase())[0] === "#" ? (I3 = x2[1] === "x" ? parseInt(x2.slice(2), 16) : Number(x2.slice(1)), l(I3)) : o2[x2] || _3;
        });
      }(c3.content), E, f2) : f2 && f2 !== "none" && e2.plugins.autoloader && (h = "md-" + (/* @__PURE__ */ new Date()).valueOf() + "-" + Math.floor(1e16 * Math.random()), c3.attributes.id = h, e2.plugins.autoloader.loadLanguages(f2, function() {
        var y2 = document.getElementById(h);
        y2 && (y2.innerHTML = e2.highlight(y2.textContent, e2.languages[f2], f2));
      }));
    }
  }), RegExp(e2.languages.markup.tag.pattern.source, "gi")), o2 = { amp: "&", lt: "<", gt: ">", quot: '"' }, l = String.fromCodePoint || String.fromCharCode;
  e2.languages.md = e2.languages.markdown;
}(w), w.languages.graphql = { comment: /#.*/, description: { pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i, greedy: true, alias: "string", inside: { "language-markdown": { pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/, lookbehind: true, inside: w.languages.markdown } } }, string: { pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/, greedy: true }, number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, boolean: /\b(?:false|true)\b/, variable: /\$[a-z_]\w*/i, directive: { pattern: /@[a-z_]\w*/i, alias: "function" }, "attr-name": { pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i, greedy: true }, "atom-input": { pattern: /\b[A-Z]\w*Input\b/, alias: "class-name" }, scalar: /\b(?:Boolean|Float|ID|Int|String)\b/, constant: /\b[A-Z][A-Z_\d]*\b/, "class-name": { pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/, lookbehind: true }, fragment: { pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, "definition-mutation": { pattern: /(\bmutation\s+)[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, "definition-query": { pattern: /(\bquery\s+)[a-zA-Z_]\w*/, lookbehind: true, alias: "function" }, keyword: /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/, operator: /[!=|&]|\.{3}/, "property-query": /\w+(?=\s*\()/, object: /\w+(?=\s*\{)/, punctuation: /[!(){}\[\]:=,]/, property: /\w+/ }, w.hooks.add("after-tokenize", function(e2) {
  if (e2.language === "graphql")
    for (var t = e2.tokens.filter(function(h) {
      return typeof h != "string" && h.type !== "comment" && h.type !== "scalar";
    }), n2 = 0; n2 < t.length; ) {
      var r = t[n2++];
      if (r.type === "keyword" && r.content === "mutation") {
        var a3 = [];
        if (d2(["definition-mutation", "punctuation"]) && f2(1).content === "(") {
          n2 += 2;
          var u2 = b2(/^\($/, /^\)$/);
          if (u2 === -1)
            continue;
          for (; n2 < u2; n2++) {
            var i2 = f2(0);
            i2.type === "variable" && (m(i2, "variable-input"), a3.push(i2.content));
          }
          n2 = u2 + 1;
        }
        if (d2(["punctuation", "property-query"]) && f2(0).content === "{" && (n2++, m(f2(0), "property-mutation"), 0 < a3.length)) {
          var o2 = b2(/^\{$/, /^\}$/);
          if (o2 !== -1)
            for (var l = n2; l < o2; l++) {
              var c3 = t[l];
              c3.type === "variable" && 0 <= a3.indexOf(c3.content) && m(c3, "variable-input");
            }
        }
      }
    }
  function f2(h) {
    return t[n2 + h];
  }
  function d2(h, E) {
    E = E || 0;
    for (var y2 = 0; y2 < h.length; y2++) {
      var _3 = f2(y2 + E);
      if (!_3 || _3.type !== h[y2])
        return;
    }
    return 1;
  }
  function b2(h, E) {
    for (var y2 = 1, _3 = n2; _3 < t.length; _3++) {
      var x2 = t[_3], I3 = x2.content;
      if (x2.type === "punctuation" && typeof I3 == "string") {
        if (h.test(I3))
          y2++;
        else if (E.test(I3) && --y2 === 0)
          return _3;
      }
    }
    return -1;
  }
  function m(h, E) {
    var y2 = h.alias;
    y2 ? Array.isArray(y2) || (h.alias = y2 = [y2]) : h.alias = y2 = [], y2.push(E);
  }
}), w.languages.sql = { comment: { pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/, lookbehind: true }, variable: [{ pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/, greedy: true }, /@[\w.$]+/], string: { pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/, greedy: true, lookbehind: true }, identifier: { pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/, greedy: true, lookbehind: true, inside: { punctuation: /^`|`$/ } }, function: /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i, keyword: /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i, boolean: /\b(?:FALSE|NULL|TRUE)\b/i, number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i, operator: /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i, punctuation: /[;[\]()`,.]/ }, function(e2) {
  var t = e2.languages.javascript["template-string"], n2 = t.pattern.source, r = t.inside.interpolation, a3 = r.inside["interpolation-punctuation"], u2 = r.pattern.source;
  function i2(d2, b2) {
    if (e2.languages[d2])
      return { pattern: RegExp("((?:" + b2 + ")\\s*)" + n2), lookbehind: true, greedy: true, inside: { "template-punctuation": { pattern: /^`|`$/, alias: "string" }, "embedded-code": { pattern: /[\s\S]+/, alias: d2 } } };
  }
  function o2(d2, b2, m) {
    return d2 = { code: d2, grammar: b2, language: m }, e2.hooks.run("before-tokenize", d2), d2.tokens = e2.tokenize(d2.code, d2.grammar), e2.hooks.run("after-tokenize", d2), d2.tokens;
  }
  function l(d2, b2, m) {
    var y2 = e2.tokenize(d2, { interpolation: { pattern: RegExp(u2), lookbehind: true } }), h = 0, E = {}, y2 = o2(y2.map(function(x2) {
      if (typeof x2 == "string")
        return x2;
      for (var I3, M3, x2 = x2.content; d2.indexOf((M3 = h++, I3 = "___" + m.toUpperCase() + "_" + M3 + "___")) !== -1; )
        ;
      return E[I3] = x2, I3;
    }).join(""), b2, m), _3 = Object.keys(E);
    return h = 0, function x2(I3) {
      for (var M3 = 0; M3 < I3.length; M3++) {
        if (h >= _3.length)
          return;
        var B4, R, U2, q3, Y3, S2, H3, F2 = I3[M3];
        typeof F2 == "string" || typeof F2.content == "string" ? (B4 = _3[h], (H3 = (S2 = typeof F2 == "string" ? F2 : F2.content).indexOf(B4)) !== -1 && (++h, R = S2.substring(0, H3), Y3 = E[B4], U2 = void 0, (q3 = {})["interpolation-punctuation"] = a3, (q3 = e2.tokenize(Y3, q3)).length === 3 && ((U2 = [1, 1]).push.apply(U2, o2(q3[1], e2.languages.javascript, "javascript")), q3.splice.apply(q3, U2)), U2 = new e2.Token("interpolation", q3, r.alias, Y3), q3 = S2.substring(H3 + B4.length), Y3 = [], R && Y3.push(R), Y3.push(U2), q3 && (x2(S2 = [q3]), Y3.push.apply(Y3, S2)), typeof F2 == "string" ? (I3.splice.apply(I3, [M3, 1].concat(Y3)), M3 += Y3.length - 1) : F2.content = Y3)) : (H3 = F2.content, Array.isArray(H3) ? x2(H3) : x2([H3]));
      }
    }(y2), new e2.Token(m, y2, "language-" + m, d2);
  }
  e2.languages.javascript["template-string"] = [i2("css", /\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/.source), i2("html", /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source), i2("svg", /\bsvg/.source), i2("markdown", /\b(?:markdown|md)/.source), i2("graphql", /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source), i2("sql", /\bsql/.source), t].filter(Boolean);
  var c3 = { javascript: true, js: true, typescript: true, ts: true, jsx: true, tsx: true };
  function f2(d2) {
    return typeof d2 == "string" ? d2 : Array.isArray(d2) ? d2.map(f2).join("") : f2(d2.content);
  }
  e2.hooks.add("after-tokenize", function(d2) {
    d2.language in c3 && function b2(m) {
      for (var h = 0, E = m.length; h < E; h++) {
        var y2, _3, x2, I3 = m[h];
        typeof I3 != "string" && (y2 = I3.content, Array.isArray(y2) ? I3.type === "template-string" ? (I3 = y2[1], y2.length === 3 && typeof I3 != "string" && I3.type === "embedded-code" && (_3 = f2(I3), I3 = I3.alias, I3 = Array.isArray(I3) ? I3[0] : I3, x2 = e2.languages[I3]) && (y2[1] = l(_3, x2, I3))) : b2(y2) : typeof y2 != "string" && b2([y2]));
      }
    }(d2.tokens);
  });
}(w), function(e2) {
  e2.languages.typescript = e2.languages.extend("javascript", { "class-name": { pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/, lookbehind: true, greedy: true, inside: null }, builtin: /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/ }), e2.languages.typescript.keyword.push(/\b(?:abstract|declare|is|keyof|readonly|require)\b/, /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/, /\btype\b(?=\s*(?:[\{*]|$))/), delete e2.languages.typescript.parameter, delete e2.languages.typescript["literal-property"];
  var t = e2.languages.extend("typescript", {});
  delete t["class-name"], e2.languages.typescript["class-name"].inside = t, e2.languages.insertBefore("typescript", "function", { decorator: { pattern: /@[$\w\xA0-\uFFFF]+/, inside: { at: { pattern: /^@/, alias: "operator" }, function: /^[\s\S]+/ } }, "generic-function": { pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/, greedy: true, inside: { function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: t } } } }), e2.languages.ts = e2.languages.typescript;
}(w), function(e2) {
  var t = e2.languages.javascript, n2 = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source, r = "(@(?:arg|argument|param|property)\\s+(?:" + n2 + "\\s+)?)";
  e2.languages.jsdoc = e2.languages.extend("javadoclike", { parameter: { pattern: RegExp(r + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source), lookbehind: true, inside: { punctuation: /\./ } } }), e2.languages.insertBefore("jsdoc", "keyword", { "optional-parameter": { pattern: RegExp(r + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source), lookbehind: true, inside: { parameter: { pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/, lookbehind: true, inside: { punctuation: /\./ } }, code: { pattern: /(=)[\s\S]*(?=\]$)/, lookbehind: true, inside: t, alias: "language-javascript" }, punctuation: /[=[\]]/ } }, "class-name": [{ pattern: RegExp(/(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(/<TYPE>/g, function() {
    return n2;
  })), lookbehind: true, inside: { punctuation: /\./ } }, { pattern: RegExp("(@[a-z]+\\s+)" + n2), lookbehind: true, inside: { string: t.string, number: t.number, boolean: t.boolean, keyword: e2.languages.typescript.keyword, operator: /=>|\.\.\.|[&|?:*]/, punctuation: /[.,;=<>{}()[\]]/ } }], example: { pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/, lookbehind: true, inside: { code: { pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m, lookbehind: true, inside: t, alias: "language-javascript" } } } }), e2.languages.javadoclike.addSupport("javascript", e2.languages.jsdoc);
}(w), function(e2) {
  e2.languages.flow = e2.languages.extend("javascript", {}), e2.languages.insertBefore("flow", "keyword", { type: [{ pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|[Ss]ymbol|any|mixed|null|void)\b/, alias: "class-name" }] }), e2.languages.flow["function-variable"].pattern = /(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i, delete e2.languages.flow.parameter, e2.languages.insertBefore("flow", "operator", { "flow-punctuation": { pattern: /\{\||\|\}/, alias: "punctuation" } }), Array.isArray(e2.languages.flow.keyword) || (e2.languages.flow.keyword = [e2.languages.flow.keyword]), e2.languages.flow.keyword.unshift({ pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/, lookbehind: true }, { pattern: /(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/, lookbehind: true });
}(w), w.languages.n4js = w.languages.extend("javascript", { keyword: /\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/ }), w.languages.insertBefore("n4js", "constant", { annotation: { pattern: /@+\w+/, alias: "operator" } }), w.languages.n4jsd = w.languages.n4js, function(e2) {
  function t(i2, o2) {
    return RegExp(i2.replace(/<ID>/g, function() {
      return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
    }), o2);
  }
  e2.languages.insertBefore("javascript", "function-variable", { "method-variable": { pattern: RegExp("(\\.\\s*)" + e2.languages.javascript["function-variable"].pattern.source), lookbehind: true, alias: ["function-variable", "method", "function", "property-access"] } }), e2.languages.insertBefore("javascript", "function", { method: { pattern: RegExp("(\\.\\s*)" + e2.languages.javascript.function.source), lookbehind: true, alias: ["function", "property-access"] } }), e2.languages.insertBefore("javascript", "constant", { "known-class-name": [{ pattern: /\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/, alias: "class-name" }, { pattern: /\b(?:[A-Z]\w*)Error\b/, alias: "class-name" }] }), e2.languages.insertBefore("javascript", "keyword", { imports: { pattern: t(/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/.source), lookbehind: true, inside: e2.languages.javascript }, exports: { pattern: t(/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source), lookbehind: true, inside: e2.languages.javascript } }), e2.languages.javascript.keyword.unshift({ pattern: /\b(?:as|default|export|from|import)\b/, alias: "module" }, { pattern: /\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/, alias: "control-flow" }, { pattern: /\bnull\b/, alias: ["null", "nil"] }, { pattern: /\bundefined\b/, alias: "nil" }), e2.languages.insertBefore("javascript", "operator", { spread: { pattern: /\.{3}/, alias: "operator" }, arrow: { pattern: /=>/, alias: "operator" } }), e2.languages.insertBefore("javascript", "punctuation", { "property-access": { pattern: t(/(\.\s*)#?<ID>/.source), lookbehind: true }, "maybe-class-name": { pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/, lookbehind: true }, dom: { pattern: /\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/, alias: "variable" }, console: { pattern: /\bconsole(?=\s*\.)/, alias: "class-name" } });
  for (var n2 = ["function", "function-variable", "method", "method-variable", "property-access"], r = 0; r < n2.length; r++) {
    var u2 = n2[r], a3 = e2.languages.javascript[u2], u2 = (a3 = e2.util.type(a3) === "RegExp" ? e2.languages.javascript[u2] = { pattern: a3 } : a3).inside || {};
    (a3.inside = u2)["maybe-class-name"] = /^[A-Z][\s\S]*/;
  }
}(w), function(e2) {
  var t = e2.util.clone(e2.languages.javascript), n2 = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source, r = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source, a3 = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  function u2(l, c3) {
    return l = l.replace(/<S>/g, function() {
      return n2;
    }).replace(/<BRACES>/g, function() {
      return r;
    }).replace(/<SPREAD>/g, function() {
      return a3;
    }), RegExp(l, c3);
  }
  a3 = u2(a3).source, e2.languages.jsx = e2.languages.extend("markup", t), e2.languages.jsx.tag.pattern = u2(/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source), e2.languages.jsx.tag.inside.tag.pattern = /^<\/?[^\s>\/]*/, e2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/, e2.languages.jsx.tag.inside.tag.inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/, e2.languages.jsx.tag.inside.comment = t.comment, e2.languages.insertBefore("inside", "attr-name", { spread: { pattern: u2(/<SPREAD>/.source), inside: e2.languages.jsx } }, e2.languages.jsx.tag), e2.languages.insertBefore("inside", "special-attr", { script: { pattern: u2(/=<BRACES>/.source), alias: "language-javascript", inside: { "script-punctuation": { pattern: /^=(?=\{)/, alias: "punctuation" }, rest: e2.languages.jsx } } }, e2.languages.jsx.tag);
  function i2(l) {
    for (var c3 = [], f2 = 0; f2 < l.length; f2++) {
      var d2 = l[f2], b2 = false;
      typeof d2 != "string" && (d2.type === "tag" && d2.content[0] && d2.content[0].type === "tag" ? d2.content[0].content[0].content === "</" ? 0 < c3.length && c3[c3.length - 1].tagName === o2(d2.content[0].content[1]) && c3.pop() : d2.content[d2.content.length - 1].content !== "/>" && c3.push({ tagName: o2(d2.content[0].content[1]), openedBraces: 0 }) : 0 < c3.length && d2.type === "punctuation" && d2.content === "{" ? c3[c3.length - 1].openedBraces++ : 0 < c3.length && 0 < c3[c3.length - 1].openedBraces && d2.type === "punctuation" && d2.content === "}" ? c3[c3.length - 1].openedBraces-- : b2 = true), (b2 || typeof d2 == "string") && 0 < c3.length && c3[c3.length - 1].openedBraces === 0 && (b2 = o2(d2), f2 < l.length - 1 && (typeof l[f2 + 1] == "string" || l[f2 + 1].type === "plain-text") && (b2 += o2(l[f2 + 1]), l.splice(f2 + 1, 1)), 0 < f2 && (typeof l[f2 - 1] == "string" || l[f2 - 1].type === "plain-text") && (b2 = o2(l[f2 - 1]) + b2, l.splice(f2 - 1, 1), f2--), l[f2] = new e2.Token("plain-text", b2, null, b2)), d2.content && typeof d2.content != "string" && i2(d2.content);
    }
  }
  var o2 = function(l) {
    return l ? typeof l == "string" ? l : typeof l.content == "string" ? l.content : l.content.map(o2).join("") : "";
  };
  e2.hooks.add("after-tokenize", function(l) {
    l.language !== "jsx" && l.language !== "tsx" || i2(l.tokens);
  });
}(w), function(e2) {
  var t = e2.util.clone(e2.languages.typescript), t = (e2.languages.tsx = e2.languages.extend("jsx", t), delete e2.languages.tsx.parameter, delete e2.languages.tsx["literal-property"], e2.languages.tsx.tag);
  t.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + t.pattern.source + ")", t.pattern.flags), t.lookbehind = true;
}(w), w.languages.swift = { comment: { pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/, lookbehind: true, greedy: true }, "string-literal": [{ pattern: RegExp(/(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source), lookbehind: true, greedy: true, inside: { interpolation: { pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: true, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\\($/, alias: "punctuation" }, punctuation: /\\(?=[\r\n])/, string: /[\s\S]+/ } }, { pattern: RegExp(/(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"), lookbehind: true, greedy: true, inside: { interpolation: { pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/, lookbehind: true, inside: null }, "interpolation-punctuation": { pattern: /^\)|\\#+\($/, alias: "punctuation" }, string: /[\s\S]+/ } }], directive: { pattern: RegExp(/#/.source + "(?:" + /(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+|" + /(?:else|endif)\b/.source + ")"), alias: "property", inside: { "directive-name": /^#\w+/, boolean: /\b(?:false|true)\b/, number: /\b\d+(?:\.\d+)*\b/, operator: /!|&&|\|\||[<>]=?/, punctuation: /[(),]/ } }, literal: { pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/, alias: "constant" }, "other-directive": { pattern: /#\w+\b/, alias: "property" }, attribute: { pattern: /@\w+/, alias: "atrule" }, "function-definition": { pattern: /(\bfunc\s+)\w+/, lookbehind: true, alias: "function" }, label: { pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/, lookbehind: true, alias: "important" }, keyword: /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/, boolean: /\b(?:false|true)\b/, nil: { pattern: /\bnil\b/, alias: "constant" }, "short-argument": /\$\d+\b/, omit: { pattern: /\b_\b/, alias: "keyword" }, number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i, "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/, function: /\b[a-z_]\w*(?=\s*\()/i, constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/, operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/, punctuation: /[{}[\]();,.:\\]/ }, w.languages.swift["string-literal"].forEach(function(e2) {
  e2.inside.interpolation.inside = w.languages.swift;
}), function(e2) {
  e2.languages.kotlin = e2.languages.extend("clike", { keyword: { pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/, lookbehind: true }, function: [{ pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/, greedy: true }, { pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/, lookbehind: true, greedy: true }], number: /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/, operator: /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/ }), delete e2.languages.kotlin["class-name"];
  var t = { "interpolation-punctuation": { pattern: /^\$\{?|\}$/, alias: "punctuation" }, expression: { pattern: /[\s\S]+/, inside: e2.languages.kotlin } };
  e2.languages.insertBefore("kotlin", "string", { "string-literal": [{ pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/, alias: "multiline", inside: { interpolation: { pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i, inside: t }, string: /[\s\S]+/ } }, { pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/, alias: "singleline", inside: { interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i, lookbehind: true, inside: t }, string: /[\s\S]+/ } }], char: { pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/, greedy: true } }), delete e2.languages.kotlin.string, e2.languages.insertBefore("kotlin", "keyword", { annotation: { pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/, alias: "builtin" } }), e2.languages.insertBefore("kotlin", "function", { label: { pattern: /\b\w+@|@\w+\b/, alias: "symbol" } }), e2.languages.kt = e2.languages.kotlin, e2.languages.kts = e2.languages.kotlin;
}(w), w.languages.c = w.languages.extend("clike", { comment: { pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true }, string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: true }, "class-name": { pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/, lookbehind: true }, keyword: /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/, function: /\b[a-z_]\w*(?=\s*\()/i, number: /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i, operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/ }), w.languages.insertBefore("c", "string", { char: { pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/, greedy: true } }), w.languages.insertBefore("c", "string", { macro: { pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im, lookbehind: true, greedy: true, alias: "property", inside: { string: [{ pattern: /^(#\s*include\s*)<[^>]+>/, lookbehind: true }, w.languages.c.string], char: w.languages.c.char, comment: w.languages.c.comment, "macro-name": [{ pattern: /(^#\s*define\s+)\w+\b(?!\()/i, lookbehind: true }, { pattern: /(^#\s*define\s+)\w+\b(?=\()/i, lookbehind: true, alias: "function" }], directive: { pattern: /^(#\s*)[a-z]+/, lookbehind: true, alias: "keyword" }, "directive-hash": /^#/, punctuation: /##|\\(?=[\r\n])/, expression: { pattern: /\S[\s\S]*/, inside: w.languages.c } } } }), w.languages.insertBefore("c", "function", { constant: /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/ }), delete w.languages.c.boolean, w.languages.objectivec = w.languages.extend("c", { string: { pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/, greedy: true }, keyword: /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/, operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/ }), delete w.languages.objectivec["class-name"], w.languages.objc = w.languages.objectivec, w.languages.reason = w.languages.extend("clike", { string: { pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/, greedy: true }, "class-name": /\b[A-Z]\w*/, keyword: /\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/, operator: /\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/ }), w.languages.insertBefore("reason", "class-name", { char: { pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/, greedy: true }, constructor: /\b[A-Z]\w*\b(?!\s*\.)/, label: { pattern: /\b[a-z]\w*(?=::)/, alias: "symbol" } }), delete w.languages.reason.function, function(e2) {
  for (var t = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source, n2 = 0; n2 < 2; n2++)
    t = t.replace(/<self>/g, function() {
      return t;
    });
  t = t.replace(/<self>/g, function() {
    return /[^\s\S]/.source;
  }), e2.languages.rust = { comment: [{ pattern: RegExp(/(^|[^\\])/.source + t), lookbehind: true, greedy: true }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: true, greedy: true }], string: { pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/, greedy: true }, char: { pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/, greedy: true }, attribute: { pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/, greedy: true, alias: "attr-name", inside: { string: null } }, "closure-params": { pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/, lookbehind: true, greedy: true, inside: { "closure-punctuation": { pattern: /^\||\|$/, alias: "punctuation" }, rest: null } }, "lifetime-annotation": { pattern: /'\w+/, alias: "symbol" }, "fragment-specifier": { pattern: /(\$\w+:)[a-z]+/, lookbehind: true, alias: "punctuation" }, variable: /\$\w+/, "function-definition": { pattern: /(\bfn\s+)\w+/, lookbehind: true, alias: "function" }, "type-definition": { pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/, lookbehind: true, alias: "class-name" }, "module-declaration": [{ pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/, lookbehind: true, alias: "namespace" }, { pattern: /(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/, lookbehind: true, alias: "namespace", inside: { punctuation: /::/ } }], keyword: [/\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/, /\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/], function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/, macro: { pattern: /\b\w+!/, alias: "property" }, constant: /\b[A-Z_][A-Z_\d]+\b/, "class-name": /\b[A-Z]\w*\b/, namespace: { pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/, inside: { punctuation: /::/ } }, number: /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/, boolean: /\b(?:false|true)\b/, punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/, operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/ }, e2.languages.rust["closure-params"].inside.rest = e2.languages.rust, e2.languages.rust.attribute.inside.string = e2.languages.rust.string;
}(w), w.languages.go = w.languages.extend("clike", { string: { pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/, lookbehind: true, greedy: true }, keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/, boolean: /\b(?:_|false|iota|nil|true)\b/, number: [/\b0(?:b[01_]+|o[0-7_]+)i?\b/i, /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i, /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i], operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./, builtin: /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/ }), w.languages.insertBefore("go", "string", { char: { pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/, greedy: true } }), delete w.languages.go["class-name"], function(e2) {
  var t = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, n2 = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return t.source;
  });
  e2.languages.cpp = e2.languages.extend("c", { "class-name": [{ pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
    return t.source;
  })), lookbehind: true }, /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/, /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i, /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/], keyword: t, number: { pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i, greedy: true }, operator: />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/, boolean: /\b(?:false|true)\b/ }), e2.languages.insertBefore("cpp", "string", { module: { pattern: RegExp(/(\b(?:import|module)\s+)/.source + "(?:" + /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
    return n2;
  }) + ")"), lookbehind: true, greedy: true, inside: { string: /^[<"][\s\S]+/, operator: /:/, punctuation: /\./ } }, "raw-string": { pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/, alias: "string", greedy: true } }), e2.languages.insertBefore("cpp", "keyword", { "generic-function": { pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i, inside: { function: /^\w+/, generic: { pattern: /<[\s\S]+/, alias: "class-name", inside: e2.languages.cpp } } } }), e2.languages.insertBefore("cpp", "operator", { "double-colon": { pattern: /::/, alias: "punctuation" } }), e2.languages.insertBefore("cpp", "class-name", { "base-clause": { pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/, lookbehind: true, greedy: true, inside: e2.languages.extend("cpp", {}) } }), e2.languages.insertBefore("inside", "double-colon", { "class-name": /\b[a-z_]\w*\b(?!\s*::)/i }, e2.languages.cpp["base-clause"]);
}(w), w.languages.python = { comment: { pattern: /(^|[^\\])#.*/, lookbehind: true, greedy: true }, "string-interpolation": { pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i, greedy: true, inside: { interpolation: { pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/, lookbehind: true, inside: { "format-spec": { pattern: /(:)[^:(){}]+(?=\}$)/, lookbehind: true }, "conversion-option": { pattern: /![sra](?=[:}]$)/, alias: "punctuation" }, rest: null } }, string: /[\s\S]+/ } }, "triple-quoted-string": { pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i, greedy: true, alias: "string" }, string: { pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i, greedy: true }, function: { pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g, lookbehind: true }, "class-name": { pattern: /(\bclass\s+)\w+/i, lookbehind: true }, decorator: { pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m, lookbehind: true, alias: ["annotation", "punctuation"], inside: { punctuation: /\./ } }, keyword: /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/, builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/, boolean: /\b(?:False|None|True)\b/, number: /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i, operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/, punctuation: /[{}[\];(),.:]/ }, w.languages.python["string-interpolation"].inside.interpolation.inside.rest = w.languages.python, w.languages.py = w.languages.python, w.languages.json = { property: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/, lookbehind: true, greedy: true }, string: { pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/, lookbehind: true, greedy: true }, comment: { pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: true }, number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i, punctuation: /[{}[\],]/, operator: /:/, boolean: /\b(?:false|true)\b/, null: { pattern: /\bnull\b/, alias: "keyword" } }, w.languages.webmanifest = w.languages.json;
var Er2 = {};
C1(Er2, {
  dracula: () => N1,
  duotoneDark: () => L1,
  duotoneLight: () => w1,
  github: () => P1,
  gruvboxMaterialDark: () => lb,
  gruvboxMaterialLight: () => db,
  jettwaveDark: () => tb,
  jettwaveLight: () => rb,
  nightOwl: () => F1,
  nightOwlLight: () => v1,
  oceanicNext: () => U1,
  okaidia: () => Y1,
  oneDark: () => ib,
  oneLight: () => sb,
  palenight: () => G1,
  shadesOfPurple: () => $1,
  synthwave84: () => V1,
  ultramin: () => X1,
  vsDark: () => Is,
  vsLight: () => J1
});
var S1 = {
  plain: {
    color: "#F8F8F2",
    backgroundColor: "#282A36"
  },
  styles: [
    {
      types: ["prolog", "constant", "builtin"],
      style: {
        color: "rgb(189, 147, 249)"
      }
    },
    {
      types: ["inserted", "function"],
      style: {
        color: "rgb(80, 250, 123)"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgb(255, 85, 85)"
      }
    },
    {
      types: ["changed"],
      style: {
        color: "rgb(255, 184, 108)"
      }
    },
    {
      types: ["punctuation", "symbol"],
      style: {
        color: "rgb(248, 248, 242)"
      }
    },
    {
      types: ["string", "char", "tag", "selector"],
      style: {
        color: "rgb(255, 121, 198)"
      }
    },
    {
      types: ["keyword", "variable"],
      style: {
        color: "rgb(189, 147, 249)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(98, 114, 164)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(241, 250, 140)"
      }
    }
  ]
};
var N1 = S1;
var R1 = {
  plain: {
    backgroundColor: "#2a2734",
    color: "#9a86fd"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
      style: {
        color: "#6c6783"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["tag", "operator", "number"],
      style: {
        color: "#e09142"
      }
    },
    {
      types: ["property", "function"],
      style: {
        color: "#9a86fd"
      }
    },
    {
      types: ["tag-id", "selector", "atrule-id"],
      style: {
        color: "#eeebff"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#c4b9fe"
      }
    },
    {
      types: [
        "boolean",
        "string",
        "entity",
        "url",
        "attr-value",
        "keyword",
        "control",
        "directive",
        "unit",
        "statement",
        "regex",
        "atrule",
        "placeholder",
        "variable"
      ],
      style: {
        color: "#ffcc99"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "#c4b9fe"
      }
    }
  ]
};
var L1 = R1;
var O1 = {
  plain: {
    backgroundColor: "#faf8f5",
    color: "#728fcb"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata", "punctuation"],
      style: {
        color: "#b6ad9a"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["tag", "operator", "number"],
      style: {
        color: "#063289"
      }
    },
    {
      types: ["property", "function"],
      style: {
        color: "#b29762"
      }
    },
    {
      types: ["tag-id", "selector", "atrule-id"],
      style: {
        color: "#2d2006"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#896724"
      }
    },
    {
      types: [
        "boolean",
        "string",
        "entity",
        "url",
        "attr-value",
        "keyword",
        "control",
        "directive",
        "unit",
        "statement",
        "regex",
        "atrule"
      ],
      style: {
        color: "#728fcb"
      }
    },
    {
      types: ["placeholder", "variable"],
      style: {
        color: "#93abdc"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "#896724"
      }
    }
  ]
};
var w1 = O1;
var D1 = {
  plain: {
    color: "#393A34",
    backgroundColor: "#f6f8fa"
  },
  styles: [
    {
      types: ["comment", "prolog", "doctype", "cdata"],
      style: {
        color: "#999988",
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    },
    {
      types: ["string", "attr-value"],
      style: {
        color: "#e3116c"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#393A34"
      }
    },
    {
      types: [
        "entity",
        "url",
        "symbol",
        "number",
        "boolean",
        "variable",
        "constant",
        "property",
        "regex",
        "inserted"
      ],
      style: {
        color: "#36acaa"
      }
    },
    {
      types: ["atrule", "keyword", "attr-name", "selector"],
      style: {
        color: "#00a4db"
      }
    },
    {
      types: ["function", "deleted", "tag"],
      style: {
        color: "#d73a49"
      }
    },
    {
      types: ["function-variable"],
      style: {
        color: "#6f42c1"
      }
    },
    {
      types: ["tag", "selector", "keyword"],
      style: {
        color: "#00009f"
      }
    }
  ]
};
var P1 = D1;
var M1 = {
  plain: {
    color: "#d6deeb",
    backgroundColor: "#011627"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted", "attr-name"],
      style: {
        color: "rgb(173, 219, 103)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(99, 119, 119)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "rgb(173, 219, 103)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(214, 222, 235)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(247, 140, 108)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function"],
      style: {
        color: "rgb(130, 170, 255)"
      }
    },
    {
      // This was manually added after the auto-generation
      // so that punctuations are not italicised
      types: ["punctuation"],
      style: {
        color: "rgb(199, 146, 234)"
      }
    },
    {
      types: ["selector", "doctype"],
      style: {
        color: "rgb(199, 146, 234)",
        fontStyle: "italic"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(255, 203, 139)"
      }
    },
    {
      types: ["tag", "operator", "keyword"],
      style: {
        color: "rgb(127, 219, 202)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(255, 88, 116)"
      }
    },
    {
      types: ["property"],
      style: {
        color: "rgb(128, 203, 196)"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)"
      }
    }
  ]
};
var F1 = M1;
var B1 = {
  plain: {
    color: "#403f53",
    backgroundColor: "#FBFBFB"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted", "attr-name"],
      style: {
        color: "rgb(72, 118, 214)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(152, 159, 177)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "builtin", "char", "constant", "url"],
      style: {
        color: "rgb(72, 118, 214)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(201, 103, 101)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(170, 9, 130)"
      }
    },
    {
      // This was manually added after the auto-generation
      // so that punctuations are not italicised
      types: ["punctuation"],
      style: {
        color: "rgb(153, 76, 195)"
      }
    },
    {
      types: ["function", "selector", "doctype"],
      style: {
        color: "rgb(153, 76, 195)",
        fontStyle: "italic"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(17, 17, 17)"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "rgb(153, 76, 195)"
      }
    },
    {
      types: ["operator", "property", "keyword", "namespace"],
      style: {
        color: "rgb(12, 150, 155)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(188, 84, 84)"
      }
    }
  ]
};
var v1 = B1;
var ke3 = {
  char: "#D8DEE9",
  comment: "#999999",
  keyword: "#c5a5c5",
  primitive: "#5a9bcf",
  string: "#8dc891",
  variable: "#d7deea",
  boolean: "#ff8b50",
  punctuation: "#5FB3B3",
  tag: "#fc929e",
  function: "#79b6f2",
  className: "#FAC863",
  method: "#6699CC",
  operator: "#fc929e"
};
var H1 = {
  plain: {
    backgroundColor: "#282c34",
    color: "#ffffff"
  },
  styles: [
    {
      types: ["attr-name"],
      style: {
        color: ke3.keyword
      }
    },
    {
      types: ["attr-value"],
      style: {
        color: ke3.string
      }
    },
    {
      types: [
        "comment",
        "block-comment",
        "prolog",
        "doctype",
        "cdata",
        "shebang"
      ],
      style: {
        color: ke3.comment
      }
    },
    {
      types: [
        "property",
        "number",
        "function-name",
        "constant",
        "symbol",
        "deleted"
      ],
      style: {
        color: ke3.primitive
      }
    },
    {
      types: ["boolean"],
      style: {
        color: ke3.boolean
      }
    },
    {
      types: ["tag"],
      style: {
        color: ke3.tag
      }
    },
    {
      types: ["string"],
      style: {
        color: ke3.string
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: ke3.string
      }
    },
    {
      types: ["selector", "char", "builtin", "inserted"],
      style: {
        color: ke3.char
      }
    },
    {
      types: ["function"],
      style: {
        color: ke3.function
      }
    },
    {
      types: ["operator", "entity", "url", "variable"],
      style: {
        color: ke3.variable
      }
    },
    {
      types: ["keyword"],
      style: {
        color: ke3.keyword
      }
    },
    {
      types: ["atrule", "class-name"],
      style: {
        color: ke3.className
      }
    },
    {
      types: ["important"],
      style: {
        fontWeight: "400"
      }
    },
    {
      types: ["bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        opacity: 0.7
      }
    }
  ]
};
var U1 = H1;
var z1 = {
  plain: {
    color: "#f8f8f2",
    backgroundColor: "#272822"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(162, 191, 252)",
        fontStyle: "italic"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "#f92672",
        fontStyle: "italic"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "rgb(173, 219, 103)",
        fontStyle: "italic"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#8292a2",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "#a6e22e"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "#f8f8f2"
      }
    },
    {
      types: ["number"],
      style: {
        color: "#ae81ff"
      }
    },
    {
      types: ["builtin", "char", "constant", "function", "class-name"],
      style: {
        color: "#e6db74"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "#f8f8f2"
      }
    },
    {
      types: ["selector", "doctype"],
      style: {
        color: "#a6e22e",
        fontStyle: "italic"
      }
    },
    {
      types: ["tag", "operator", "keyword"],
      style: {
        color: "#66d9ef"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "#ae81ff"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)",
        opacity: 0.7
      }
    },
    {
      types: ["tag", "property"],
      style: {
        color: "#f92672"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "#a6e22e !important"
      }
    },
    {
      types: ["doctype"],
      style: {
        color: "#8292a2"
      }
    },
    {
      types: ["rule"],
      style: {
        color: "#e6db74"
      }
    }
  ]
};
var Y1 = z1;
var j1 = {
  plain: {
    color: "#bfc7d5",
    backgroundColor: "#292d3e"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(105, 112, 152)",
        fontStyle: "italic"
      }
    },
    {
      types: ["string", "inserted"],
      style: {
        color: "rgb(195, 232, 141)"
      }
    },
    {
      types: ["number"],
      style: {
        color: "rgb(247, 140, 108)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function"],
      style: {
        color: "rgb(130, 170, 255)"
      }
    },
    {
      types: ["punctuation", "selector"],
      style: {
        color: "rgb(199, 146, 234)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(191, 199, 213)"
      }
    },
    {
      types: ["class-name", "attr-name"],
      style: {
        color: "rgb(255, 203, 107)"
      }
    },
    {
      types: ["tag", "deleted"],
      style: {
        color: "rgb(255, 85, 114)"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "rgb(137, 221, 255)"
      }
    },
    {
      types: ["boolean"],
      style: {
        color: "rgb(255, 88, 116)"
      }
    },
    {
      types: ["keyword"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["doctype"],
      style: {
        color: "rgb(199, 146, 234)",
        fontStyle: "italic"
      }
    },
    {
      types: ["namespace"],
      style: {
        color: "rgb(178, 204, 214)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "rgb(221, 221, 221)"
      }
    }
  ]
};
var G1 = j1;
var q1 = {
  plain: {
    color: "#9EFEFF",
    backgroundColor: "#2D2A55"
  },
  styles: [
    {
      types: ["changed"],
      style: {
        color: "rgb(255, 238, 128)"
      }
    },
    {
      types: ["deleted"],
      style: {
        color: "rgba(239, 83, 80, 0.56)"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "rgb(173, 219, 103)"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(179, 98, 255)",
        fontStyle: "italic"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "rgb(255, 255, 255)"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "rgb(255, 98, 140)"
      }
    },
    {
      types: ["string", "url"],
      style: {
        color: "rgb(165, 255, 144)"
      }
    },
    {
      types: ["variable"],
      style: {
        color: "rgb(255, 238, 128)"
      }
    },
    {
      types: ["number", "boolean"],
      style: {
        color: "rgb(255, 98, 140)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(255, 180, 84)"
      }
    },
    {
      types: [
        "keyword",
        "operator",
        "property",
        "namespace",
        "tag",
        "selector",
        "doctype"
      ],
      style: {
        color: "rgb(255, 157, 0)"
      }
    },
    {
      types: ["builtin", "char", "constant", "function", "class-name"],
      style: {
        color: "rgb(250, 208, 0)"
      }
    }
  ]
};
var $1 = q1;
var W1 = {
  plain: {
    backgroundColor: "linear-gradient(to bottom, #2a2139 75%, #34294f)",
    backgroundImage: "#34294f",
    color: "#f92aad",
    textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
  },
  styles: [
    {
      types: ["comment", "block-comment", "prolog", "doctype", "cdata"],
      style: {
        color: "#495495",
        fontStyle: "italic"
      }
    },
    {
      types: ["punctuation"],
      style: {
        color: "#ccc"
      }
    },
    {
      types: [
        "tag",
        "attr-name",
        "namespace",
        "number",
        "unit",
        "hexcode",
        "deleted"
      ],
      style: {
        color: "#e2777a"
      }
    },
    {
      types: ["property", "selector"],
      style: {
        color: "#72f1b8",
        textShadow: "0 0 2px #100c0f, 0 0 10px #257c5575, 0 0 35px #21272475"
      }
    },
    {
      types: ["function-name"],
      style: {
        color: "#6196cc"
      }
    },
    {
      types: ["boolean", "selector-id", "function"],
      style: {
        color: "#fdfdfd",
        textShadow: "0 0 2px #001716, 0 0 3px #03edf975, 0 0 5px #03edf975, 0 0 8px #03edf975"
      }
    },
    {
      types: ["class-name", "maybe-class-name", "builtin"],
      style: {
        color: "#fff5f6",
        textShadow: "0 0 2px #000, 0 0 10px #fc1f2c75, 0 0 5px #fc1f2c75, 0 0 25px #fc1f2c75"
      }
    },
    {
      types: ["constant", "symbol"],
      style: {
        color: "#f92aad",
        textShadow: "0 0 2px #100c0f, 0 0 5px #dc078e33, 0 0 10px #fff3"
      }
    },
    {
      types: ["important", "atrule", "keyword", "selector-class"],
      style: {
        color: "#f4eee4",
        textShadow: "0 0 2px #393a33, 0 0 8px #f39f0575, 0 0 2px #f39f0575"
      }
    },
    {
      types: ["string", "char", "attr-value", "regex", "variable"],
      style: {
        color: "#f87c32"
      }
    },
    {
      types: ["parameter"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["entity", "url"],
      style: {
        color: "#67cdcc"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "ffffffee"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["entity"],
      style: {
        cursor: "help"
      }
    },
    {
      types: ["inserted"],
      style: {
        color: "green"
      }
    }
  ]
};
var V1 = W1;
var Q1 = {
  plain: {
    color: "#282a2e",
    backgroundColor: "#ffffff"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(197, 200, 198)"
      }
    },
    {
      types: ["string", "number", "builtin", "variable"],
      style: {
        color: "rgb(150, 152, 150)"
      }
    },
    {
      types: ["class-name", "function", "tag", "attr-name"],
      style: {
        color: "rgb(40, 42, 46)"
      }
    }
  ]
};
var X1 = Q1;
var K1 = {
  plain: {
    color: "#9CDCFE",
    backgroundColor: "#1E1E1E"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "rgb(0, 0, 128)"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "rgb(106, 153, 85)"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "rgb(86, 156, 214)"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "rgb(181, 206, 168)"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "rgb(100, 102, 149)"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "rgb(156, 220, 254)"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "rgb(206, 145, 120)"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "rgb(215, 186, 125)"
      }
    },
    {
      // Fix tag color
      types: ["tag"],
      style: {
        color: "rgb(78, 201, 176)"
      }
    },
    {
      // Fix tag color for HTML
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "rgb(86, 156, 214)"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "rgb(212, 212, 212)"
      }
    },
    {
      // Fix punctuation color for HTML
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "rgb(220, 220, 170)"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(78, 201, 176)"
      }
    },
    {
      types: ["char"],
      style: {
        color: "rgb(209, 105, 105)"
      }
    }
  ]
};
var Is = K1;
var Z1 = {
  plain: {
    color: "#000000",
    backgroundColor: "#ffffff"
  },
  styles: [
    {
      types: ["comment"],
      style: {
        color: "rgb(0, 128, 0)"
      }
    },
    {
      types: ["builtin"],
      style: {
        color: "rgb(0, 112, 193)"
      }
    },
    {
      types: ["number", "variable", "inserted"],
      style: {
        color: "rgb(9, 134, 88)"
      }
    },
    {
      types: ["operator"],
      style: {
        color: "rgb(0, 0, 0)"
      }
    },
    {
      types: ["constant", "char"],
      style: {
        color: "rgb(129, 31, 63)"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "rgb(128, 0, 0)"
      }
    },
    {
      types: ["attr-name"],
      style: {
        color: "rgb(255, 0, 0)"
      }
    },
    {
      types: ["deleted", "string"],
      style: {
        color: "rgb(163, 21, 21)"
      }
    },
    {
      types: ["changed", "punctuation"],
      style: {
        color: "rgb(4, 81, 165)"
      }
    },
    {
      types: ["function", "keyword"],
      style: {
        color: "rgb(0, 0, 255)"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "rgb(38, 127, 153)"
      }
    }
  ]
};
var J1 = Z1;
var eb = {
  plain: {
    color: "#f8fafc",
    backgroundColor: "#011627"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "#000080"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#6A9955"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "#569CD6"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "#B5CEA8"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "#f8fafc"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "#9CDCFE"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "#cbd5e1"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "#D7BA7D"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#D4D4D4"
      }
    },
    {
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "#7dd3fc"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["char"],
      style: {
        color: "#D16969"
      }
    }
  ]
};
var tb = eb;
var nb = {
  plain: {
    color: "#0f172a",
    backgroundColor: "#f1f5f9"
  },
  styles: [
    {
      types: ["prolog"],
      style: {
        color: "#000080"
      }
    },
    {
      types: ["comment"],
      style: {
        color: "#6A9955"
      }
    },
    {
      types: ["builtin", "changed", "keyword", "interpolation-punctuation"],
      style: {
        color: "#0c4a6e"
      }
    },
    {
      types: ["number", "inserted"],
      style: {
        color: "#B5CEA8"
      }
    },
    {
      types: ["constant"],
      style: {
        color: "#0f172a"
      }
    },
    {
      types: ["attr-name", "variable"],
      style: {
        color: "#0c4a6e"
      }
    },
    {
      types: ["deleted", "string", "attr-value", "template-punctuation"],
      style: {
        color: "#64748b"
      }
    },
    {
      types: ["selector"],
      style: {
        color: "#D7BA7D"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["tag"],
      languages: ["markup"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["punctuation", "operator"],
      style: {
        color: "#475569"
      }
    },
    {
      types: ["punctuation"],
      languages: ["markup"],
      style: {
        color: "#808080"
      }
    },
    {
      types: ["function"],
      style: {
        color: "#0e7490"
      }
    },
    {
      types: ["class-name"],
      style: {
        color: "#0ea5e9"
      }
    },
    {
      types: ["char"],
      style: {
        color: "#D16969"
      }
    }
  ]
};
var rb = nb;
var ab = {
  plain: {
    backgroundColor: "hsl(220, 13%, 18%)",
    color: "hsl(220, 14%, 71%)",
    textShadow: "0 1px rgba(0, 0, 0, 0.3)"
  },
  styles: [
    {
      types: ["comment", "prolog", "cdata"],
      style: {
        color: "hsl(220, 10%, 40%)"
      }
    },
    {
      types: ["doctype", "punctuation", "entity"],
      style: {
        color: "hsl(220, 14%, 71%)"
      }
    },
    {
      types: [
        "attr-name",
        "class-name",
        "maybe-class-name",
        "boolean",
        "constant",
        "number",
        "atrule"
      ],
      style: { color: "hsl(29, 54%, 61%)" }
    },
    {
      types: ["keyword"],
      style: { color: "hsl(286, 60%, 67%)" }
    },
    {
      types: ["property", "tag", "symbol", "deleted", "important"],
      style: {
        color: "hsl(355, 65%, 65%)"
      }
    },
    {
      types: [
        "selector",
        "string",
        "char",
        "builtin",
        "inserted",
        "regex",
        "attr-value"
      ],
      style: {
        color: "hsl(95, 38%, 62%)"
      }
    },
    {
      types: ["variable", "operator", "function"],
      style: {
        color: "hsl(207, 82%, 66%)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "hsl(187, 47%, 55%)"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "hsl(220, 14%, 71%)"
      }
    }
  ]
};
var ib = ab;
var ub = {
  plain: {
    backgroundColor: "hsl(230, 1%, 98%)",
    color: "hsl(230, 8%, 24%)"
  },
  styles: [
    {
      types: ["comment", "prolog", "cdata"],
      style: {
        color: "hsl(230, 4%, 64%)"
      }
    },
    {
      types: ["doctype", "punctuation", "entity"],
      style: {
        color: "hsl(230, 8%, 24%)"
      }
    },
    {
      types: [
        "attr-name",
        "class-name",
        "boolean",
        "constant",
        "number",
        "atrule"
      ],
      style: {
        color: "hsl(35, 99%, 36%)"
      }
    },
    {
      types: ["keyword"],
      style: {
        color: "hsl(301, 63%, 40%)"
      }
    },
    {
      types: ["property", "tag", "symbol", "deleted", "important"],
      style: {
        color: "hsl(5, 74%, 59%)"
      }
    },
    {
      types: [
        "selector",
        "string",
        "char",
        "builtin",
        "inserted",
        "regex",
        "attr-value",
        "punctuation"
      ],
      style: {
        color: "hsl(119, 34%, 47%)"
      }
    },
    {
      types: ["variable", "operator", "function"],
      style: {
        color: "hsl(221, 87%, 60%)"
      }
    },
    {
      types: ["url"],
      style: {
        color: "hsl(198, 99%, 37%)"
      }
    },
    {
      types: ["deleted"],
      style: {
        textDecorationLine: "line-through"
      }
    },
    {
      types: ["inserted"],
      style: {
        textDecorationLine: "underline"
      }
    },
    {
      types: ["italic"],
      style: {
        fontStyle: "italic"
      }
    },
    {
      types: ["important", "bold"],
      style: {
        fontWeight: "bold"
      }
    },
    {
      types: ["important"],
      style: {
        color: "hsl(230, 8%, 24%)"
      }
    }
  ]
};
var sb = ub;
var ob = {
  plain: {
    color: "#ebdbb2",
    backgroundColor: "#292828"
  },
  styles: [
    {
      types: [
        "imports",
        "class-name",
        "maybe-class-name",
        "constant",
        "doctype",
        "builtin",
        "function"
      ],
      style: {
        color: "#d8a657"
      }
    },
    {
      types: ["property-access"],
      style: {
        color: "#7daea3"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#e78a4e"
      }
    },
    {
      types: ["attr-name", "char", "url", "regex"],
      style: {
        color: "#a9b665"
      }
    },
    {
      types: ["attr-value", "string"],
      style: {
        color: "#89b482"
      }
    },
    {
      types: ["comment", "prolog", "cdata", "operator", "inserted"],
      style: {
        color: "#a89984"
      }
    },
    {
      types: [
        "delimiter",
        "boolean",
        "keyword",
        "selector",
        "important",
        "atrule",
        "property",
        "variable",
        "deleted"
      ],
      style: {
        color: "#ea6962"
      }
    },
    {
      types: ["entity", "number", "symbol"],
      style: {
        color: "#d3869b"
      }
    }
  ]
};
var lb = ob;
var cb = {
  plain: {
    color: "#654735",
    backgroundColor: "#f9f5d7"
  },
  styles: [
    {
      types: [
        "delimiter",
        "boolean",
        "keyword",
        "selector",
        "important",
        "atrule",
        "property",
        "variable",
        "deleted"
      ],
      style: {
        color: "#af2528"
      }
    },
    {
      types: [
        "imports",
        "class-name",
        "maybe-class-name",
        "constant",
        "doctype",
        "builtin"
      ],
      style: {
        color: "#b4730e"
      }
    },
    {
      types: ["string", "attr-value"],
      style: {
        color: "#477a5b"
      }
    },
    {
      types: ["property-access"],
      style: {
        color: "#266b79"
      }
    },
    {
      types: ["function", "attr-name", "char", "url"],
      style: {
        color: "#72761e"
      }
    },
    {
      types: ["tag"],
      style: {
        color: "#b94c07"
      }
    },
    {
      types: ["comment", "prolog", "cdata", "operator", "inserted"],
      style: {
        color: "#a89984"
      }
    },
    {
      types: ["entity", "number", "symbol"],
      style: {
        color: "#924f79"
      }
    }
  ]
};
var db = cb;
var fb = (e2, t) => {
  const { plain: n2 } = e2, r = e2.styles.reduce((a3, u2) => {
    const { languages: i2, style: o2 } = u2;
    return i2 && !i2.includes(t) || u2.types.forEach((l) => {
      const c3 = ze3(ze3({}, a3[l]), o2);
      a3[l] = c3;
    }), a3;
  }, {});
  return r.root = n2, r.plain = Pn(ze3({}, n2), { backgroundColor: void 0 }), r;
};
var mi = fb;
var hb = (e2, t) => {
  const [n2, r] = (0, import_react2.useState)(
    mi(t, e2)
  ), a3 = (0, import_react2.useRef)(), u2 = (0, import_react2.useRef)();
  return (0, import_react2.useEffect)(() => {
    (t !== a3.current || e2 !== u2.current) && (a3.current = t, u2.current = e2, r(mi(t, e2)));
  }, [e2, t]), n2;
};
var pb = (e2) => (0, import_react2.useCallback)(
  (t) => {
    var n2 = t, { className: r, style: a3, line: u2 } = n2, i2 = ks(n2, ["className", "style", "line"]);
    const o2 = Pn(ze3({}, i2), {
      className: yr2("token-line", r)
    });
    return typeof e2 == "object" && "plain" in e2 && (o2.style = e2.plain), typeof a3 == "object" && (o2.style = ze3(ze3({}, o2.style || {}), a3)), o2;
  },
  [e2]
);
var mb = (e2) => {
  const t = (0, import_react2.useCallback)(
    ({ types: n2, empty: r }) => {
      if (e2 != null) {
        {
          if (n2.length === 1 && n2[0] === "plain")
            return r != null ? { display: "inline-block" } : void 0;
          if (n2.length === 1 && r != null)
            return e2[n2[0]];
        }
        return Object.assign(
          r != null ? { display: "inline-block" } : {},
          ...n2.map((a3) => e2[a3])
        );
      }
    },
    [e2]
  );
  return (0, import_react2.useCallback)(
    (n2) => {
      var r = n2, { token: a3, className: u2, style: i2 } = r, o2 = ks(r, ["token", "className", "style"]);
      const l = Pn(ze3({}, o2), {
        className: yr2("token", ...a3.types, u2),
        children: a3.content,
        style: t(a3)
      });
      return i2 != null && (l.style = ze3(ze3({}, l.style || {}), i2)), l;
    },
    [t]
  );
};
var gb = /\r\n|\r|\n/;
var gi = (e2) => {
  e2.length === 0 ? e2.push({
    types: ["plain"],
    content: `
`,
    empty: true
  }) : e2.length === 1 && e2[0].content === "" && (e2[0].content = `
`, e2[0].empty = true);
};
var bi = (e2, t) => {
  const n2 = e2.length;
  return n2 > 0 && e2[n2 - 1] === t ? e2 : e2.concat(t);
};
var bb = (e2) => {
  const t = [[]], n2 = [e2], r = [0], a3 = [e2.length];
  let u2 = 0, i2 = 0, o2 = [];
  const l = [o2];
  for (; i2 > -1; ) {
    for (; (u2 = r[i2]++) < a3[i2]; ) {
      let c3, f2 = t[i2];
      const b2 = n2[i2][u2];
      if (typeof b2 == "string" ? (f2 = i2 > 0 ? f2 : ["plain"], c3 = b2) : (f2 = bi(f2, b2.type), b2.alias && (f2 = bi(f2, b2.alias)), c3 = b2.content), typeof c3 != "string") {
        i2++, t.push(f2), n2.push(c3), r.push(0), a3.push(c3.length);
        continue;
      }
      const m = c3.split(gb), h = m.length;
      o2.push({
        types: f2,
        content: m[0]
      });
      for (let E = 1; E < h; E++)
        gi(o2), l.push(o2 = []), o2.push({
          types: f2,
          content: m[E]
        });
    }
    i2--, t.pop(), n2.pop(), r.pop(), a3.pop();
  }
  return gi(o2), l;
};
var Ei = bb;
var Eb = ({ prism: e2, code: t, grammar: n2, language: r }) => {
  const a3 = (0, import_react2.useRef)(e2);
  return (0, import_react2.useMemo)(() => {
    if (n2 == null)
      return Ei([t]);
    const u2 = {
      code: t,
      grammar: n2,
      language: r,
      tokens: []
    };
    return a3.current.hooks.run("before-tokenize", u2), u2.tokens = a3.current.tokenize(t, n2), a3.current.hooks.run("after-tokenize", u2), Ei(u2.tokens);
  }, [t, n2, r]);
};
var Tb = ({
  children: e2,
  language: t,
  code: n2,
  theme: r,
  prism: a3
}) => {
  const u2 = t.toLowerCase(), i2 = hb(u2, r), o2 = pb(i2), l = mb(i2), c3 = a3.languages[u2], f2 = Eb({ prism: a3, language: u2, code: n2, grammar: c3 });
  return e2({
    tokens: f2,
    className: `prism-code language-${u2}`,
    style: i2 != null ? i2.root : {},
    getLineProps: o2,
    getTokenProps: l
  });
};
var yb = (e2) => (0, import_react2.createElement)(Tb, Pn(ze3({}, e2), {
  prism: e2.prism || w,
  theme: e2.theme || Is,
  code: e2.code,
  language: e2.language
}));
var Ab = (0, import_react2.createContext)([
  false,
  () => {
  }
]);
var _b = () => (0, import_react2.useContext)(Ab);
globalThis.Prism = w;
import("./prism-bash.min-DadFsM4Z-U4SIIQXC.js");
import("./prism-ruby.min-C7LwcKyz-4ANKSA3N.js");
import("./prism-markup-templating-DZrrEs0A-Y4FWRPDZ.js");
import("./prism-markup-BNGj0Tvm-7ELUY47P.js");
import("./prism-php.min-o7FpoMP_-366FYTLC.js");
import("./prism-json.min-B1GJqK1k-D7QEUVJJ.js");
import("./prism-java.min-d5iT_mOd-6DYBQTWI.js");
import("./prism-csharp.min-Yizuc34Y-6CRQB63D.js");
import("./prism-objectivec.min-BXSWqpJJ-ALTZ63AS.js");
import("./prism-markdown.min-F3U-vPBi-LZNJSIQV.js");
import("./prism-javascript.min-CEqHqgbm-A3MKCJE2.js");
import("./prism-typescript.min-oSVeWCAd-KE7NU4K6.js");
var Cb = ({
  copyable: e2 = true,
  language: t = "plain",
  ...n2
}) => {
  const [r] = _b(), [a3, u2] = (0, import_react2.useState)(false);
  return n2.code ? dr.jsx(
    yb,
    {
      theme: r ? Er2.vsDark : Er2.github,
      language: t,
      ...n2,
      children: ({ className: i2, style: o2, tokens: l, getLineProps: c3, getTokenProps: f2 }) => dr.jsxs("div", { className: "relative group", children: [
        dr.jsx(
          "pre",
          {
            className: bt3(
              "relative scrollbar overflow-x-auto",
              i2,
              n2.className,
              n2.noBackground && "!bg-transparent",
              n2.wrapLines && "whitespace-pre-wrap break-words"
            ),
            style: o2,
            children: l.map((d2, b2) => (
              // eslint-disable-next-line react/no-array-index-key
              dr.jsx("div", { ...c3({ line: d2 }), children: d2.map((m, h) => (
                // eslint-disable-next-line react/no-array-index-key
                dr.jsx("span", { ...f2({ token: m }) }, h)
              )) }, b2)
            ))
          }
        ),
        n2.showLanguageIndicator && dr.jsx("span", { className: "absolute top-1.5 right-3 text-[11px] font-mono text-muted-foreground transition group-hover:opacity-0", children: t }),
        e2 && dr.jsx(
          "button",
          {
            type: "button",
            "aria-label": "Copy code",
            title: "Copy code",
            className: "absolute top-2 right-2 p-2 opacity-0 group-hover:opacity-100 group-hover:bg-zinc-100 group-hover:dark:bg-zinc-700 hover:outline hover:outline-border/75 dark:hover:outline-border rounded-md text-sm text-gray-400 hover:text-gray-600 dark:text-gray-500 dark:hover:text-gray-400 transition",
            disabled: a3,
            onClick: () => {
              u2(true), navigator.clipboard.writeText(
                l.map((d2) => d2.map(({ content: b2 }) => b2).join("")).join(`
`)
              ), setTimeout(() => u2(false), 2e3);
            },
            children: a3 ? dr.jsx(Check, { className: "text-emerald-600", size: 16 }) : dr.jsx(Copy, { size: 16 })
          }
        )
      ] })
    }
  ) : null;
};
var xb = {
  // @ts-expect-error Node is not in types but still gets passed
  img: ({ node: e2, ...t }) => /\.(mp4|webm|mov|avi)$/.test(t.src ?? "") ? dr.jsx("video", { src: t.src, controls: true, playsInline: true, autoPlay: true, loop: true }) : dr.jsx("img", { ...t, className: "rounded-md" }),
  h1: ({ children: e2, id: t }) => dr.jsx(ht3, { level: 1, id: t, children: e2 }),
  h2: ({ children: e2, id: t }) => dr.jsx(ht3, { level: 2, id: t, children: e2 }),
  h3: ({ children: e2, id: t }) => dr.jsx(ht3, { level: 3, id: t, children: e2 }),
  h4: ({ children: e2, id: t }) => dr.jsx(ht3, { level: 4, id: t, children: e2 }),
  h5: ({ children: e2, id: t }) => dr.jsx(ht3, { level: 5, id: t, children: e2 }),
  h6: ({ children: e2, id: t }) => dr.jsx(ht3, { level: 6, id: t, children: e2 }),
  // @ts-expect-error Node is not in types but still gets passed
  a: ({ href: e2, node: t, ...n2 }) => e2 && !e2.startsWith("http") ? dr.jsx(je, { to: e2, relative: "path", ...n2 }) : dr.jsx("a", { href: e2, target: "_blank", ...n2, rel: "noreferrer" }),
  Callout: at2,
  tip: (e2) => dr.jsx(at2, { type: "tip", ...e2 }),
  info: (e2) => dr.jsx(at2, { type: "info", ...e2 }),
  note: (e2) => dr.jsx(at2, { type: "note", ...e2 }),
  caution: (e2) => dr.jsx(at2, { type: "caution", ...e2 }),
  warning: (e2) => dr.jsx(at2, { type: "caution", ...e2 }),
  danger: (e2) => dr.jsx(at2, { type: "danger", ...e2 }),
  pre: ({ children: e2 }) => dr.jsx(dr.Fragment, { children: e2 }),
  code: ({ className: e2, children: t, ...n2 }) => {
    const r = n2.inline;
    if (r === true || r === "true")
      return dr.jsx(g1, { className: e2, children: t });
    const a3 = e2 == null ? void 0 : e2.match(/language?-(\w+)/);
    return dr.jsx(
      Cb,
      {
        language: a3 == null ? void 0 : a3[1],
        className: "rounded-xl p-4 border dark:!bg-foreground/10 dark:border-transparent",
        showLanguageIndicator: true,
        code: String(t).trim()
      }
    );
  }
};
var kb = () => (e2) => {
  Zt3(e2, "element", (t, n2, r) => {
    t.tagName === "code" && (t.properties.inline = String((r == null ? void 0 : r.tagName) !== "pre"));
  });
};
var Ib = [m1];
var Sb = [kb, um];
var Pb = "prose dark:prose-invert prose-neutral";
var Mb = ({
  content: e2,
  className: t
}) => dr.jsx(
  $0,
  {
    remarkPlugins: Ib,
    rehypePlugins: Sb,
    components: xb,
    className: t,
    children: e2
  }
);

// node_modules/zudoku/lib/CategoryHeading-3Qtp2yZ8.js
var a2 = ({
  children: t,
  className: r
}) => dr.jsx("div", { className: Zr("text-sm font-semibold text-primary mb-2", r), children: t });

export {
  u,
  f,
  a,
  c,
  L,
  te,
  ft,
  Ue,
  ke,
  Rt,
  jr,
  Sr,
  je,
  Ot,
  Tr,
  Hr,
  o,
  xe2 as xe,
  be,
  Gt2 as Gt,
  de,
  zt2 as zt,
  Vt2 as Vt,
  lt3 as lt,
  ge2 as ge,
  Qe,
  Se,
  $t2 as $t,
  Wt2 as Wt,
  fe,
  ft2,
  Xe,
  Ye3 as Ye,
  bt2 as bt,
  je2,
  gt2 as gt,
  Jt2 as Jt,
  wt2 as wt,
  Zt2 as Zt,
  Dt2 as Dt,
  Pt2 as Pt,
  kt2 as kt,
  Mt,
  Lt2 as Lt,
  ke2,
  Xt2 as Xt,
  Nt2 as Nt,
  Yt2 as Yt,
  Zr,
  qs,
  bt3 as bt2,
  at2 as at,
  Io,
  Db,
  ht3 as ht,
  g1,
  Ab,
  _b,
  Cb,
  xb,
  Pb,
  Mb,
  a2
};
/*! Bundled license information:

zudoku/lib/index-BRCiYFaL.js:
  (**
   * React Router v6.27.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)
  (**
   * React Router DOM v6.27.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

zudoku/lib/Markdown-CWI6lU11.js:
  (*! Bundled license information:
  
  prismjs/prism.js:
    (**
     * Prism: Lightweight, robust, elegant syntax highlighting
     *
     * @license MIT <https://opensource.org/licenses/MIT>
     * @author Lea Verou <https://lea.verou.me>
     * @namespace
     * @public
     *)
  *)
*/
//# sourceMappingURL=chunk-JRUNZBCC.js.map
