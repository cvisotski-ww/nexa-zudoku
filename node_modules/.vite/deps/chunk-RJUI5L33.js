import {
  bt,
  bt2,
  gt,
  je2 as je,
  ke2 as ke,
  qs
} from "./chunk-JRUNZBCC.js";
import {
  require_react_dom
} from "./chunk-5QLD5OAE.js";
import {
  dr
} from "./chunk-VJHVP7KM.js";
import {
  LoaderCircle
} from "./chunk-7KXO56BK.js";
import {
  require_react
} from "./chunk-DDZAXPWP.js";
import {
  __toESM
} from "./chunk-HXA6O6EE.js";

// node_modules/zudoku/lib/state-CsuHT8ZO.js
var import_react = __toESM(require_react(), 1);
var _ = (t) => {
  let s2;
  const e = /* @__PURE__ */ new Set(), o = (i2, S) => {
    const v = typeof i2 == "function" ? i2(s2) : i2;
    if (!Object.is(v, s2)) {
      const f2 = s2;
      s2 = S ?? (typeof v != "object" || v === null) ? v : Object.assign({}, s2, v), e.forEach((d) => d(s2, f2));
    }
  }, a = () => s2, u = { setState: o, getState: a, getInitialState: () => l, subscribe: (i2) => (e.add(i2), () => e.delete(i2)) }, l = s2 = t(o, a, u);
  return u;
};
var w = (t) => t ? _(t) : _;
var E = (t) => t;
function k(t, s2 = E) {
  const e = import_react.default.useSyncExternalStore(
    t.subscribe,
    () => s2(t.getState()),
    () => s2(t.getInitialState())
  );
  return import_react.default.useDebugValue(e), e;
}
var H = (t) => {
  const s2 = w(t), e = (o) => k(s2, o);
  return Object.assign(e, s2), e;
};
var O = (t) => t ? H(t) : H;
function x(t, s2) {
  let e;
  try {
    e = t();
  } catch {
    return;
  }
  return {
    getItem: (a) => {
      var n;
      const m = (l) => l === null ? null : JSON.parse(l, void 0), u = (n = e.getItem(a)) != null ? n : null;
      return u instanceof Promise ? u.then(m) : m(u);
    },
    setItem: (a, n) => e.setItem(
      a,
      JSON.stringify(n, void 0)
    ),
    removeItem: (a) => e.removeItem(a)
  };
}
var b = (t) => (s2) => {
  try {
    const e = t(s2);
    return e instanceof Promise ? e : {
      then(o) {
        return b(o)(e);
      },
      catch(o) {
        return this;
      }
    };
  } catch (e) {
    return {
      then(o) {
        return this;
      },
      catch(o) {
        return b(o)(e);
      }
    };
  }
};
var F = (t, s2) => (e, o, a) => {
  let n = {
    storage: x(() => localStorage),
    partialize: (r) => r,
    version: 0,
    merge: (r, h) => ({
      ...h,
      ...r
    }),
    ...s2
  }, m = false;
  const u = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
  let i2 = n.storage;
  if (!i2)
    return t(
      (...r) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${n.name}', the given storage is currently unavailable.`
        ), e(...r);
      },
      o,
      a
    );
  const S = () => {
    const r = n.partialize({ ...o() });
    return i2.setItem(n.name, {
      state: r,
      version: n.version
    });
  }, v = a.setState;
  a.setState = (r, h) => {
    v(r, h), S();
  };
  const f2 = t(
    (...r) => {
      e(...r), S();
    },
    o,
    a
  );
  a.getInitialState = () => f2;
  let d;
  const p = () => {
    var r, h;
    if (!i2) return;
    m = false, u.forEach((c) => {
      var g;
      return c((g = o()) != null ? g : f2);
    });
    const y = ((h = n.onRehydrateStorage) == null ? void 0 : h.call(n, (r = o()) != null ? r : f2)) || void 0;
    return b(i2.getItem.bind(i2))(n.name).then((c) => {
      if (c)
        if (typeof c.version == "number" && c.version !== n.version) {
          if (n.migrate)
            return [
              true,
              n.migrate(
                c.state,
                c.version
              )
            ];
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [false, c.state];
      return [false, void 0];
    }).then((c) => {
      var g;
      const [j2, R] = c;
      if (d = n.merge(
        R,
        (g = o()) != null ? g : f2
      ), e(d, true), j2)
        return S();
    }).then(() => {
      y == null || y(d, void 0), d = o(), m = true, l.forEach((c) => c(d));
    }).catch((c) => {
      y == null || y(void 0, c);
    });
  };
  return a.persist = {
    setOptions: (r) => {
      n = {
        ...n,
        ...r
      }, r.storage && (i2 = r.storage);
    },
    clearStorage: () => {
      i2 == null || i2.removeItem(n.name);
    },
    getOptions: () => n,
    rehydrate: () => p(),
    hasHydrated: () => m,
    onHydrate: (r) => (u.add(r), () => {
      u.delete(r);
    }),
    onFinishHydration: (r) => (l.add(r), () => {
      l.delete(r);
    })
  }, n.skipHydration || p(), d || f2;
};
var J = F;
var P = O(() => ({
  isPending: false,
  isAuthenticated: false
}));
var A = O()(
  J(
    (t) => ({
      selectedServer: void 0,
      setSelectedServer: (s2) => t({ selectedServer: s2 })
    }),
    { name: "zudoku-selected-server" }
  )
);

// node_modules/zudoku/lib/index-Do_BBSIs.js
var f = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var Ht = __toESM(require_react_dom(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var wt = (e) => {
  throw TypeError(e);
};
var He = (e, t, n) => t.has(e) || wt("Cannot " + n);
var L = (e, t, n) => (He(e, t, "read from private field"), n ? n.call(e) : t.get(e));
var we = (e, t, n) => t.has(e) ? wt("Cannot add the same private member more than once") : t instanceof WeakSet ? t.add(e) : t.set(e, n);
var xe = (e, t, n, r) => (He(e, t, "write to private field"), r ? r.call(e, n) : t.set(e, n), n);
var q = (e, t, n) => (He(e, t, "access private method"), n);
function Vn(e, t) {
  typeof e == "function" ? e(t) : e != null && (e.current = t);
}
function Vt(...e) {
  return (t) => e.forEach((n) => Vn(n, t));
}
function ce(...e) {
  return f.useCallback(Vt(...e), e);
}
var be = f.forwardRef((e, t) => {
  const { children: n, ...r } = e, o = f.Children.toArray(n), i2 = o.find(Un);
  if (i2) {
    const s2 = i2.props.children, c = o.map((a) => a === i2 ? f.Children.count(s2) > 1 ? f.Children.only(null) : f.isValidElement(s2) ? s2.props.children : null : a);
    return dr.jsx(Qe, { ...r, ref: t, children: f.isValidElement(s2) ? f.cloneElement(s2, void 0, c) : null });
  }
  return dr.jsx(Qe, { ...r, ref: t, children: n });
});
be.displayName = "Slot";
var Qe = f.forwardRef((e, t) => {
  const { children: n, ...r } = e;
  if (f.isValidElement(n)) {
    const o = Xn(n);
    return f.cloneElement(n, {
      ...Yn(r, n.props),
      // @ts-ignore
      ref: t ? Vt(t, o) : o
    });
  }
  return f.Children.count(n) > 1 ? f.Children.only(null) : null;
});
Qe.displayName = "SlotClone";
var zn = ({ children: e }) => dr.jsx(dr.Fragment, { children: e });
function Un(e) {
  return f.isValidElement(e) && e.type === zn;
}
function Yn(e, t) {
  const n = { ...t };
  for (const r in t) {
    const o = e[r], i2 = t[r];
    /^on[A-Z]/.test(r) ? o && i2 ? n[r] = (...c) => {
      i2(...c), o(...c);
    } : o && (n[r] = o) : r === "style" ? n[r] = { ...o, ...i2 } : r === "className" && (n[r] = [o, i2].filter(Boolean).join(" "));
  }
  return { ...e, ...n };
}
function Xn(e) {
  var r, o;
  let t = (r = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : r.get, n = t && "isReactWarning" in t && t.isReactWarning;
  return n ? e.ref : (t = (o = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : o.get, n = t && "isReactWarning" in t && t.isReactWarning, n ? e.props.ref : e.props.ref || e.ref);
}
var Kn = qs(
  "not-prose inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        xl: "h-14 rounded-lg px-10 text-lg",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
var Gn = f.forwardRef(
  ({ className: e, variant: t, size: n, asChild: r = false, ...o }, i2) => {
    const s2 = r ? be : "button";
    return dr.jsx(
      s2,
      {
        className: bt2(Kn({ variant: t, size: n, className: e })),
        ref: i2,
        ...o
      }
    );
  }
);
Gn.displayName = "Button";
var H2;
var F2;
var se;
var V;
var Q;
var $t;
var xi = ($t = class extends gt {
  constructor(t) {
    super();
    we(this, V);
    we(this, H2);
    we(this, F2);
    we(this, se);
    this.mutationId = t.mutationId, xe(this, F2, t.mutationCache), xe(this, H2, []), this.state = t.state || Zn(), this.setOptions(t.options), this.scheduleGc();
  }
  setOptions(t) {
    this.options = t, this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(t) {
    L(this, H2).includes(t) || (L(this, H2).push(t), this.clearGcTimeout(), L(this, F2).notify({
      type: "observerAdded",
      mutation: this,
      observer: t
    }));
  }
  removeObserver(t) {
    xe(this, H2, L(this, H2).filter((n) => n !== t)), this.scheduleGc(), L(this, F2).notify({
      type: "observerRemoved",
      mutation: this,
      observer: t
    });
  }
  optionalRemove() {
    L(this, H2).length || (this.state.status === "pending" ? this.scheduleGc() : L(this, F2).remove(this));
  }
  continue() {
    var t;
    return ((t = L(this, se)) == null ? void 0 : t.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(t) {
    var o, i2, s2, c, a, l, h, d, p, m, v, u, g, y, w3, b2, x3, E3, C, S;
    xe(this, se, bt({
      fn: () => this.options.mutationFn ? this.options.mutationFn(t) : Promise.reject(new Error("No mutationFn found")),
      onFail: (A3, O3) => {
        q(this, V, Q).call(this, { type: "failed", failureCount: A3, error: O3 });
      },
      onPause: () => {
        q(this, V, Q).call(this, { type: "pause" });
      },
      onContinue: () => {
        q(this, V, Q).call(this, { type: "continue" });
      },
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => L(this, F2).canRun(this)
    }));
    const n = this.state.status === "pending", r = !L(this, se).canStart();
    try {
      if (!n) {
        q(this, V, Q).call(this, { type: "pending", variables: t, isPaused: r }), await ((i2 = (o = L(this, F2).config).onMutate) == null ? void 0 : i2.call(
          o,
          t,
          this
        ));
        const O3 = await ((c = (s2 = this.options).onMutate) == null ? void 0 : c.call(s2, t));
        O3 !== this.state.context && q(this, V, Q).call(this, {
          type: "pending",
          context: O3,
          variables: t,
          isPaused: r
        });
      }
      const A3 = await L(this, se).start();
      return await ((l = (a = L(this, F2).config).onSuccess) == null ? void 0 : l.call(
        a,
        A3,
        t,
        this.state.context,
        this
      )), await ((d = (h = this.options).onSuccess) == null ? void 0 : d.call(h, A3, t, this.state.context)), await ((m = (p = L(this, F2).config).onSettled) == null ? void 0 : m.call(
        p,
        A3,
        null,
        this.state.variables,
        this.state.context,
        this
      )), await ((u = (v = this.options).onSettled) == null ? void 0 : u.call(v, A3, null, t, this.state.context)), q(this, V, Q).call(this, { type: "success", data: A3 }), A3;
    } catch (A3) {
      try {
        throw await ((y = (g = L(this, F2).config).onError) == null ? void 0 : y.call(
          g,
          A3,
          t,
          this.state.context,
          this
        )), await ((b2 = (w3 = this.options).onError) == null ? void 0 : b2.call(
          w3,
          A3,
          t,
          this.state.context
        )), await ((E3 = (x3 = L(this, F2).config).onSettled) == null ? void 0 : E3.call(
          x3,
          void 0,
          A3,
          this.state.variables,
          this.state.context,
          this
        )), await ((S = (C = this.options).onSettled) == null ? void 0 : S.call(
          C,
          void 0,
          A3,
          t,
          this.state.context
        )), A3;
      } finally {
        q(this, V, Q).call(this, { type: "error", error: A3 });
      }
    } finally {
      L(this, F2).runNext(this);
    }
  }
}, H2 = /* @__PURE__ */ new WeakMap(), F2 = /* @__PURE__ */ new WeakMap(), se = /* @__PURE__ */ new WeakMap(), V = /* @__PURE__ */ new WeakSet(), Q = function(t) {
  const n = (r) => {
    switch (t.type) {
      case "failed":
        return {
          ...r,
          failureCount: t.failureCount,
          failureReason: t.error
        };
      case "pause":
        return {
          ...r,
          isPaused: true
        };
      case "continue":
        return {
          ...r,
          isPaused: false
        };
      case "pending":
        return {
          ...r,
          context: t.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: t.isPaused,
          status: "pending",
          variables: t.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...r,
          data: t.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: false
        };
      case "error":
        return {
          ...r,
          data: void 0,
          error: t.error,
          failureCount: r.failureCount + 1,
          failureReason: t.error,
          isPaused: false,
          status: "error"
        };
    }
  };
  this.state = n(this.state), je.batch(() => {
    L(this, H2).forEach((r) => {
      r.onMutationUpdate(t);
    }), L(this, F2).notify({
      mutation: this,
      type: "updated",
      action: t
    });
  });
}, $t);
function Zn() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}
var bi = () => {
  const { authentication: e } = ke(), t = P(), n = typeof e < "u";
  return {
    isAuthEnabled: n,
    isPending: t.isPending,
    profile: t.profile,
    isAuthenticated: t.profile,
    login: async () => {
      if (!n)
        throw new Error("Authentication is not enabled.");
      await e.signIn();
    },
    logout: async () => {
      if (!n)
        throw new Error("Authentication is not enabled.");
      await e.signOut(), window.location.href = "/";
    }
  };
};
function Ve(e, t, { checkForDefaultPrevented: n = true } = {}) {
  return function(o) {
    if (e == null || e(o), n === false || !o.defaultPrevented)
      return t == null ? void 0 : t(o);
  };
}
function Ei(e, t) {
  const n = f.createContext(t), r = (i2) => {
    const { children: s2, ...c } = i2, a = f.useMemo(() => c, Object.values(c));
    return dr.jsx(n.Provider, { value: a, children: s2 });
  };
  r.displayName = e + "Provider";
  function o(i2) {
    const s2 = f.useContext(n);
    if (s2) return s2;
    if (t !== void 0) return t;
    throw new Error(`\`${i2}\` must be used within \`${e}\``);
  }
  return [r, o];
}
function Ci(e, t = []) {
  let n = [];
  function r(i2, s2) {
    const c = f.createContext(s2), a = n.length;
    n = [...n, s2];
    const l = (d) => {
      var y;
      const { scope: p, children: m, ...v } = d, u = ((y = p == null ? void 0 : p[e]) == null ? void 0 : y[a]) || c, g = f.useMemo(() => v, Object.values(v));
      return dr.jsx(u.Provider, { value: g, children: m });
    };
    l.displayName = i2 + "Provider";
    function h(d, p) {
      var u;
      const m = ((u = p == null ? void 0 : p[e]) == null ? void 0 : u[a]) || c, v = f.useContext(m);
      if (v) return v;
      if (s2 !== void 0) return s2;
      throw new Error(`\`${d}\` must be used within \`${i2}\``);
    }
    return [l, h];
  }
  const o = () => {
    const i2 = n.map((s2) => f.createContext(s2));
    return function(c) {
      const a = (c == null ? void 0 : c[e]) || i2;
      return f.useMemo(
        () => ({ [`__scope${e}`]: { ...c, [e]: a } }),
        [c, a]
      );
    };
  };
  return o.scopeName = e, [r, qn(o, ...t)];
}
function qn(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((o) => ({
      useScope: o(),
      scopeName: o.scopeName
    }));
    return function(i2) {
      const s2 = r.reduce((c, { useScope: a, scopeName: l }) => {
        const d = a(i2)[`__scope${l}`];
        return { ...c, ...d };
      }, {});
      return f.useMemo(() => ({ [`__scope${t.scopeName}`]: s2 }), [s2]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function ee(e) {
  const t = f.useRef(e);
  return f.useEffect(() => {
    t.current = e;
  }), f.useMemo(() => (...n) => {
    var r;
    return (r = t.current) == null ? void 0 : r.call(t, ...n);
  }, []);
}
function Si({
  prop: e,
  defaultProp: t,
  onChange: n = () => {
  }
}) {
  const [r, o] = Qn({ defaultProp: t, onChange: n }), i2 = e !== void 0, s2 = i2 ? e : r, c = ee(n), a = f.useCallback(
    (l) => {
      if (i2) {
        const d = typeof l == "function" ? l(e) : l;
        d !== e && c(d);
      } else
        o(l);
    },
    [i2, e, o, c]
  );
  return [s2, a];
}
function Qn({
  defaultProp: e,
  onChange: t
}) {
  const n = f.useState(e), [r] = n, o = f.useRef(r), i2 = ee(t);
  return f.useEffect(() => {
    o.current !== r && (i2(r), o.current = r);
  }, [r, o, i2]), n;
}
var Jn = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var oe = Jn.reduce((e, t) => {
  const n = f.forwardRef((r, o) => {
    const { asChild: i2, ...s2 } = r, c = i2 ? be : t;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = true), dr.jsx(c, { ...s2, ref: o });
  });
  return n.displayName = `Primitive.${t}`, { ...e, [t]: n };
}, {});
function er(e, t) {
  e && Ht.flushSync(() => e.dispatchEvent(t));
}
function zt(e, t = []) {
  let n = [];
  function r(i2, s2) {
    const c = f.createContext(s2), a = n.length;
    n = [...n, s2];
    function l(d) {
      const { scope: p, children: m, ...v } = d, u = (p == null ? void 0 : p[e][a]) || c, g = f.useMemo(() => v, Object.values(v));
      return dr.jsx(u.Provider, { value: g, children: m });
    }
    function h(d, p) {
      const m = (p == null ? void 0 : p[e][a]) || c, v = f.useContext(m);
      if (v) return v;
      if (s2 !== void 0) return s2;
      throw new Error(`\`${d}\` must be used within \`${i2}\``);
    }
    return l.displayName = i2 + "Provider", [l, h];
  }
  const o = () => {
    const i2 = n.map((s2) => f.createContext(s2));
    return function(c) {
      const a = (c == null ? void 0 : c[e]) || i2;
      return f.useMemo(
        () => ({ [`__scope${e}`]: { ...c, [e]: a } }),
        [c, a]
      );
    };
  };
  return o.scopeName = e, [r, tr(o, ...t)];
}
function tr(...e) {
  const t = e[0];
  if (e.length === 1) return t;
  const n = () => {
    const r = e.map((o) => ({
      useScope: o(),
      scopeName: o.scopeName
    }));
    return function(i2) {
      const s2 = r.reduce((c, { useScope: a, scopeName: l }) => {
        const d = a(i2)[`__scope${l}`];
        return { ...c, ...d };
      }, {});
      return f.useMemo(() => ({ [`__scope${t.scopeName}`]: s2 }), [s2]);
    };
  };
  return n.scopeName = t.scopeName, n;
}
function Ai(e) {
  const t = e + "CollectionProvider", [n, r] = zt(t), [o, i2] = n(
    t,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), s2 = (m) => {
    const { scope: v, children: u } = m, g = import_react2.default.useRef(null), y = import_react2.default.useRef(/* @__PURE__ */ new Map()).current;
    return dr.jsx(o, { scope: v, itemMap: y, collectionRef: g, children: u });
  };
  s2.displayName = t;
  const c = e + "CollectionSlot", a = import_react2.default.forwardRef(
    (m, v) => {
      const { scope: u, children: g } = m, y = i2(c, u), w3 = ce(v, y.collectionRef);
      return dr.jsx(be, { ref: w3, children: g });
    }
  );
  a.displayName = c;
  const l = e + "CollectionItemSlot", h = "data-radix-collection-item", d = import_react2.default.forwardRef(
    (m, v) => {
      const { scope: u, children: g, ...y } = m, w3 = import_react2.default.useRef(null), b2 = ce(v, w3), x3 = i2(l, u);
      return import_react2.default.useEffect(() => (x3.itemMap.set(w3, { ref: w3, ...y }), () => void x3.itemMap.delete(w3))), dr.jsx(be, { [h]: "", ref: b2, children: g });
    }
  );
  d.displayName = l;
  function p(m) {
    const v = i2(e + "CollectionConsumer", m);
    return import_react2.default.useCallback(() => {
      const g = v.collectionRef.current;
      if (!g) return [];
      const y = Array.from(g.querySelectorAll(`[${h}]`));
      return Array.from(v.itemMap.values()).sort(
        (x3, E3) => y.indexOf(x3.ref.current) - y.indexOf(E3.ref.current)
      );
    }, [v.collectionRef, v.itemMap]);
  }
  return [
    { Provider: s2, Slot: a, ItemSlot: d },
    p,
    r
  ];
}
var nr = f.createContext(void 0);
function Pi(e) {
  const t = f.useContext(nr);
  return e || t || "ltr";
}
function rr(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = ee(e);
  f.useEffect(() => {
    const r = (o) => {
      o.key === "Escape" && n(o);
    };
    return t.addEventListener("keydown", r, { capture: true }), () => t.removeEventListener("keydown", r, { capture: true });
  }, [n, t]);
}
var or = "DismissableLayer";
var Je = "dismissableLayer.update";
var ir = "dismissableLayer.pointerDownOutside";
var sr = "dismissableLayer.focusOutside";
var xt;
var Ut = f.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var cr = f.forwardRef(
  (e, t) => {
    const {
      disableOutsidePointerEvents: n = false,
      onEscapeKeyDown: r,
      onPointerDownOutside: o,
      onFocusOutside: i2,
      onInteractOutside: s2,
      onDismiss: c,
      ...a
    } = e, l = f.useContext(Ut), [h, d] = f.useState(null), p = (h == null ? void 0 : h.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, m] = f.useState({}), v = ce(t, (S) => d(S)), u = Array.from(l.layers), [g] = [...l.layersWithOutsidePointerEventsDisabled].slice(-1), y = u.indexOf(g), w3 = h ? u.indexOf(h) : -1, b2 = l.layersWithOutsidePointerEventsDisabled.size > 0, x3 = w3 >= y, E3 = ur((S) => {
      const A3 = S.target, O3 = [...l.branches].some((D) => D.contains(A3));
      !x3 || O3 || (o == null || o(S), s2 == null || s2(S), S.defaultPrevented || c == null || c());
    }, p), C = fr((S) => {
      const A3 = S.target;
      [...l.branches].some((D) => D.contains(A3)) || (i2 == null || i2(S), s2 == null || s2(S), S.defaultPrevented || c == null || c());
    }, p);
    return rr((S) => {
      w3 === l.layers.size - 1 && (r == null || r(S), !S.defaultPrevented && c && (S.preventDefault(), c()));
    }, p), f.useEffect(() => {
      if (h)
        return n && (l.layersWithOutsidePointerEventsDisabled.size === 0 && (xt = p.body.style.pointerEvents, p.body.style.pointerEvents = "none"), l.layersWithOutsidePointerEventsDisabled.add(h)), l.layers.add(h), bt3(), () => {
          n && l.layersWithOutsidePointerEventsDisabled.size === 1 && (p.body.style.pointerEvents = xt);
        };
    }, [h, p, n, l]), f.useEffect(() => () => {
      h && (l.layers.delete(h), l.layersWithOutsidePointerEventsDisabled.delete(h), bt3());
    }, [h, l]), f.useEffect(() => {
      const S = () => m({});
      return document.addEventListener(Je, S), () => document.removeEventListener(Je, S);
    }, []), dr.jsx(
      oe.div,
      {
        ...a,
        ref: v,
        style: {
          pointerEvents: b2 ? x3 ? "auto" : "none" : void 0,
          ...e.style
        },
        onFocusCapture: Ve(e.onFocusCapture, C.onFocusCapture),
        onBlurCapture: Ve(e.onBlurCapture, C.onBlurCapture),
        onPointerDownCapture: Ve(
          e.onPointerDownCapture,
          E3.onPointerDownCapture
        )
      }
    );
  }
);
cr.displayName = or;
var ar = "DismissableLayerBranch";
var lr = f.forwardRef((e, t) => {
  const n = f.useContext(Ut), r = f.useRef(null), o = ce(t, r);
  return f.useEffect(() => {
    const i2 = r.current;
    if (i2)
      return n.branches.add(i2), () => {
        n.branches.delete(i2);
      };
  }, [n.branches]), dr.jsx(oe.div, { ...e, ref: o });
});
lr.displayName = ar;
function ur(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = ee(e), r = f.useRef(false), o = f.useRef(() => {
  });
  return f.useEffect(() => {
    const i2 = (c) => {
      if (c.target && !r.current) {
        let a = function() {
          Yt(
            ir,
            n,
            l,
            { discrete: true }
          );
        };
        const l = { originalEvent: c };
        c.pointerType === "touch" ? (t.removeEventListener("click", o.current), o.current = a, t.addEventListener("click", o.current, { once: true })) : a();
      } else
        t.removeEventListener("click", o.current);
      r.current = false;
    }, s2 = window.setTimeout(() => {
      t.addEventListener("pointerdown", i2);
    }, 0);
    return () => {
      window.clearTimeout(s2), t.removeEventListener("pointerdown", i2), t.removeEventListener("click", o.current);
    };
  }, [t, n]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = true
  };
}
function fr(e, t = globalThis == null ? void 0 : globalThis.document) {
  const n = ee(e), r = f.useRef(false);
  return f.useEffect(() => {
    const o = (i2) => {
      i2.target && !r.current && Yt(sr, n, { originalEvent: i2 }, {
        discrete: false
      });
    };
    return t.addEventListener("focusin", o), () => t.removeEventListener("focusin", o);
  }, [t, n]), {
    onFocusCapture: () => r.current = true,
    onBlurCapture: () => r.current = false
  };
}
function bt3() {
  const e = new CustomEvent(Je);
  document.dispatchEvent(e);
}
function Yt(e, t, n, { discrete: r }) {
  const o = n.originalEvent.target, i2 = new CustomEvent(e, { bubbles: false, cancelable: true, detail: n });
  t && o.addEventListener(e, t, { once: true }), r ? er(o, i2) : o.dispatchEvent(i2);
}
var ze = 0;
function Ri() {
  f.useEffect(() => {
    const e = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e[0] ?? Et()), document.body.insertAdjacentElement("beforeend", e[1] ?? Et()), ze++, () => {
      ze === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t) => t.remove()), ze--;
    };
  }, []);
}
function Et() {
  const e = document.createElement("span");
  return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e;
}
var Ue = "focusScope.autoFocusOnMount";
var Ye = "focusScope.autoFocusOnUnmount";
var Ct = { bubbles: false, cancelable: true };
var dr2 = "FocusScope";
var hr = f.forwardRef((e, t) => {
  const {
    loop: n = false,
    trapped: r = false,
    onMountAutoFocus: o,
    onUnmountAutoFocus: i2,
    ...s2
  } = e, [c, a] = f.useState(null), l = ee(o), h = ee(i2), d = f.useRef(null), p = ce(t, (u) => a(u)), m = f.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  f.useEffect(() => {
    if (r) {
      let u = function(b2) {
        if (m.paused || !c) return;
        const x3 = b2.target;
        c.contains(x3) ? d.current = x3 : J2(d.current, { select: true });
      }, g = function(b2) {
        if (m.paused || !c) return;
        const x3 = b2.relatedTarget;
        x3 !== null && (c.contains(x3) || J2(d.current, { select: true }));
      }, y = function(b2) {
        if (document.activeElement === document.body)
          for (const E3 of b2)
            E3.removedNodes.length > 0 && J2(c);
      };
      document.addEventListener("focusin", u), document.addEventListener("focusout", g);
      const w3 = new MutationObserver(y);
      return c && w3.observe(c, { childList: true, subtree: true }), () => {
        document.removeEventListener("focusin", u), document.removeEventListener("focusout", g), w3.disconnect();
      };
    }
  }, [r, c, m.paused]), f.useEffect(() => {
    if (c) {
      At.add(m);
      const u = document.activeElement;
      if (!c.contains(u)) {
        const y = new CustomEvent(Ue, Ct);
        c.addEventListener(Ue, l), c.dispatchEvent(y), y.defaultPrevented || (mr(wr(Xt(c)), { select: true }), document.activeElement === u && J2(c));
      }
      return () => {
        c.removeEventListener(Ue, l), setTimeout(() => {
          const y = new CustomEvent(Ye, Ct);
          c.addEventListener(Ye, h), c.dispatchEvent(y), y.defaultPrevented || J2(u ?? document.body, { select: true }), c.removeEventListener(Ye, h), At.remove(m);
        }, 0);
      };
    }
  }, [c, l, h, m]);
  const v = f.useCallback(
    (u) => {
      if (!n && !r || m.paused) return;
      const g = u.key === "Tab" && !u.altKey && !u.ctrlKey && !u.metaKey, y = document.activeElement;
      if (g && y) {
        const w3 = u.currentTarget, [b2, x3] = pr(w3);
        b2 && x3 ? !u.shiftKey && y === x3 ? (u.preventDefault(), n && J2(b2, { select: true })) : u.shiftKey && y === b2 && (u.preventDefault(), n && J2(x3, { select: true })) : y === w3 && u.preventDefault();
      }
    },
    [n, r, m.paused]
  );
  return dr.jsx(oe.div, { tabIndex: -1, ...s2, ref: p, onKeyDown: v });
});
hr.displayName = dr2;
function mr(e, { select: t = false } = {}) {
  const n = document.activeElement;
  for (const r of e)
    if (J2(r, { select: t }), document.activeElement !== n) return;
}
function pr(e) {
  const t = Xt(e), n = St(t, e), r = St(t.reverse(), e);
  return [n, r];
}
function Xt(e) {
  const t = [], n = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const o = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || o ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; n.nextNode(); ) t.push(n.currentNode);
  return t;
}
function St(e, t) {
  for (const n of e)
    if (!vr(n, { upTo: t })) return n;
}
function vr(e, { upTo: t }) {
  if (getComputedStyle(e).visibility === "hidden") return true;
  for (; e; ) {
    if (t !== void 0 && e === t) return false;
    if (getComputedStyle(e).display === "none") return true;
    e = e.parentElement;
  }
  return false;
}
function gr(e) {
  return e instanceof HTMLInputElement && "select" in e;
}
function J2(e, { select: t = false } = {}) {
  if (e && e.focus) {
    const n = document.activeElement;
    e.focus({ preventScroll: true }), e !== n && gr(e) && t && e.select();
  }
}
var At = yr();
function yr() {
  let e = [];
  return {
    add(t) {
      const n = e[0];
      t !== n && (n == null || n.pause()), e = Pt(e, t), e.unshift(t);
    },
    remove(t) {
      var n;
      e = Pt(e, t), (n = e[0]) == null || n.resume();
    }
  };
}
function Pt(e, t) {
  const n = [...e], r = n.indexOf(t);
  return r !== -1 && n.splice(r, 1), n;
}
function wr(e) {
  return e.filter((t) => t.tagName !== "A");
}
var Ee = globalThis != null && globalThis.document ? f.useLayoutEffect : () => {
};
var xr = f.useId || (() => {
});
var br = 0;
function Oi(e) {
  const [t, n] = f.useState(xr());
  return Ee(() => {
    n((r) => r ?? String(br++));
  }, [e]), t ? `radix-${t}` : "";
}
var Er = ["top", "right", "bottom", "left"];
var te = Math.min;
var W = Math.max;
var Ie = Math.round;
var Oe = Math.floor;
var ne = (e) => ({
  x: e,
  y: e
});
var Cr = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var Sr = {
  start: "end",
  end: "start"
};
function et(e, t, n) {
  return W(e, te(t, n));
}
function K(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function G(e) {
  return e.split("-")[0];
}
function pe(e) {
  return e.split("-")[1];
}
function rt(e) {
  return e === "x" ? "y" : "x";
}
function ot(e) {
  return e === "y" ? "height" : "width";
}
function ve(e) {
  return ["top", "bottom"].includes(G(e)) ? "y" : "x";
}
function it(e) {
  return rt(ve(e));
}
function Ar(e, t, n) {
  n === void 0 && (n = false);
  const r = pe(e), o = it(e), i2 = ot(o);
  let s2 = o === "x" ? r === (n ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return t.reference[i2] > t.floating[i2] && (s2 = _e(s2)), [s2, _e(s2)];
}
function Pr(e) {
  const t = _e(e);
  return [tt(e), t, tt(t)];
}
function tt(e) {
  return e.replace(/start|end/g, (t) => Sr[t]);
}
function Rr(e, t, n) {
  const r = ["left", "right"], o = ["right", "left"], i2 = ["top", "bottom"], s2 = ["bottom", "top"];
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? o : r : t ? r : o;
    case "left":
    case "right":
      return t ? i2 : s2;
    default:
      return [];
  }
}
function Or(e, t, n, r) {
  const o = pe(e);
  let i2 = Rr(G(e), n === "start", r);
  return o && (i2 = i2.map((s2) => s2 + "-" + o), t && (i2 = i2.concat(i2.map(tt)))), i2;
}
function _e(e) {
  return e.replace(/left|right|bottom|top/g, (t) => Cr[t]);
}
function Mr(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function Kt(e) {
  return typeof e != "number" ? Mr(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function We(e) {
  const {
    x: t,
    y: n,
    width: r,
    height: o
  } = e;
  return {
    width: r,
    height: o,
    top: n,
    left: t,
    right: t + r,
    bottom: n + o,
    x: t,
    y: n
  };
}
function Rt(e, t, n) {
  let {
    reference: r,
    floating: o
  } = e;
  const i2 = ve(t), s2 = it(t), c = ot(s2), a = G(t), l = i2 === "y", h = r.x + r.width / 2 - o.width / 2, d = r.y + r.height / 2 - o.height / 2, p = r[c] / 2 - o[c] / 2;
  let m;
  switch (a) {
    case "top":
      m = {
        x: h,
        y: r.y - o.height
      };
      break;
    case "bottom":
      m = {
        x: h,
        y: r.y + r.height
      };
      break;
    case "right":
      m = {
        x: r.x + r.width,
        y: d
      };
      break;
    case "left":
      m = {
        x: r.x - o.width,
        y: d
      };
      break;
    default:
      m = {
        x: r.x,
        y: r.y
      };
  }
  switch (pe(t)) {
    case "start":
      m[s2] -= p * (n && l ? -1 : 1);
      break;
    case "end":
      m[s2] += p * (n && l ? -1 : 1);
      break;
  }
  return m;
}
var Tr = async (e, t, n) => {
  const {
    placement: r = "bottom",
    strategy: o = "absolute",
    middleware: i2 = [],
    platform: s2
  } = n, c = i2.filter(Boolean), a = await (s2.isRTL == null ? void 0 : s2.isRTL(t));
  let l = await s2.getElementRects({
    reference: e,
    floating: t,
    strategy: o
  }), {
    x: h,
    y: d
  } = Rt(l, r, a), p = r, m = {}, v = 0;
  for (let u = 0; u < c.length; u++) {
    const {
      name: g,
      fn: y
    } = c[u], {
      x: w3,
      y: b2,
      data: x3,
      reset: E3
    } = await y({
      x: h,
      y: d,
      initialPlacement: r,
      placement: p,
      strategy: o,
      middlewareData: m,
      rects: l,
      platform: s2,
      elements: {
        reference: e,
        floating: t
      }
    });
    h = w3 ?? h, d = b2 ?? d, m = {
      ...m,
      [g]: {
        ...m[g],
        ...x3
      }
    }, E3 && v <= 50 && (v++, typeof E3 == "object" && (E3.placement && (p = E3.placement), E3.rects && (l = E3.rects === true ? await s2.getElementRects({
      reference: e,
      floating: t,
      strategy: o
    }) : E3.rects), {
      x: h,
      y: d
    } = Rt(l, p, a)), u = -1);
  }
  return {
    x: h,
    y: d,
    placement: p,
    strategy: o,
    middlewareData: m
  };
};
async function Ce(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: r,
    y: o,
    platform: i2,
    rects: s2,
    elements: c,
    strategy: a
  } = e, {
    boundary: l = "clippingAncestors",
    rootBoundary: h = "viewport",
    elementContext: d = "floating",
    altBoundary: p = false,
    padding: m = 0
  } = K(t, e), v = Kt(m), g = c[p ? d === "floating" ? "reference" : "floating" : d], y = We(await i2.getClippingRect({
    element: (n = await (i2.isElement == null ? void 0 : i2.isElement(g))) == null || n ? g : g.contextElement || await (i2.getDocumentElement == null ? void 0 : i2.getDocumentElement(c.floating)),
    boundary: l,
    rootBoundary: h,
    strategy: a
  })), w3 = d === "floating" ? {
    x: r,
    y: o,
    width: s2.floating.width,
    height: s2.floating.height
  } : s2.reference, b2 = await (i2.getOffsetParent == null ? void 0 : i2.getOffsetParent(c.floating)), x3 = await (i2.isElement == null ? void 0 : i2.isElement(b2)) ? await (i2.getScale == null ? void 0 : i2.getScale(b2)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, E3 = We(i2.convertOffsetParentRelativeRectToViewportRelativeRect ? await i2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: c,
    rect: w3,
    offsetParent: b2,
    strategy: a
  }) : w3);
  return {
    top: (y.top - E3.top + v.top) / x3.y,
    bottom: (E3.bottom - y.bottom + v.bottom) / x3.y,
    left: (y.left - E3.left + v.left) / x3.x,
    right: (E3.right - y.right + v.right) / x3.x
  };
}
var Lr = (e) => ({
  name: "arrow",
  options: e,
  async fn(t) {
    const {
      x: n,
      y: r,
      placement: o,
      rects: i2,
      platform: s2,
      elements: c,
      middlewareData: a
    } = t, {
      element: l,
      padding: h = 0
    } = K(e, t) || {};
    if (l == null)
      return {};
    const d = Kt(h), p = {
      x: n,
      y: r
    }, m = it(o), v = ot(m), u = await s2.getDimensions(l), g = m === "y", y = g ? "top" : "left", w3 = g ? "bottom" : "right", b2 = g ? "clientHeight" : "clientWidth", x3 = i2.reference[v] + i2.reference[m] - p[m] - i2.floating[v], E3 = p[m] - i2.reference[m], C = await (s2.getOffsetParent == null ? void 0 : s2.getOffsetParent(l));
    let S = C ? C[b2] : 0;
    (!S || !await (s2.isElement == null ? void 0 : s2.isElement(C))) && (S = c.floating[b2] || i2.floating[v]);
    const A3 = x3 / 2 - E3 / 2, O3 = S / 2 - u[v] / 2 - 1, D = te(d[y], O3), j2 = te(d[w3], O3), T = D, I2 = S - u[v] - j2, N = S / 2 - u[v] / 2 + A3, M = et(T, N, I2), k3 = !a.arrow && pe(o) != null && N !== M && i2.reference[v] / 2 - (N < T ? D : j2) - u[v] / 2 < 0, P2 = k3 ? N < T ? N - T : N - I2 : 0;
    return {
      [m]: p[m] + P2,
      data: {
        [m]: M,
        centerOffset: N - M - P2,
        ...k3 && {
          alignmentOffset: P2
        }
      },
      reset: k3
    };
  }
});
var Nr = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, r;
      const {
        placement: o,
        middlewareData: i2,
        rects: s2,
        initialPlacement: c,
        platform: a,
        elements: l
      } = t, {
        mainAxis: h = true,
        crossAxis: d = true,
        fallbackPlacements: p,
        fallbackStrategy: m = "bestFit",
        fallbackAxisSideDirection: v = "none",
        flipAlignment: u = true,
        ...g
      } = K(e, t);
      if ((n = i2.arrow) != null && n.alignmentOffset)
        return {};
      const y = G(o), w3 = G(c) === c, b2 = await (a.isRTL == null ? void 0 : a.isRTL(l.floating)), x3 = p || (w3 || !u ? [_e(c)] : Pr(c));
      !p && v !== "none" && x3.push(...Or(c, u, v, b2));
      const E3 = [c, ...x3], C = await Ce(t, g), S = [];
      let A3 = ((r = i2.flip) == null ? void 0 : r.overflows) || [];
      if (h && S.push(C[y]), d) {
        const T = Ar(o, s2, b2);
        S.push(C[T[0]], C[T[1]]);
      }
      if (A3 = [...A3, {
        placement: o,
        overflows: S
      }], !S.every((T) => T <= 0)) {
        var O3, D;
        const T = (((O3 = i2.flip) == null ? void 0 : O3.index) || 0) + 1, I2 = E3[T];
        if (I2)
          return {
            data: {
              index: T,
              overflows: A3
            },
            reset: {
              placement: I2
            }
          };
        let N = (D = A3.filter((M) => M.overflows[0] <= 0).sort((M, k3) => M.overflows[1] - k3.overflows[1])[0]) == null ? void 0 : D.placement;
        if (!N)
          switch (m) {
            case "bestFit": {
              var j2;
              const M = (j2 = A3.map((k3) => [k3.placement, k3.overflows.filter((P2) => P2 > 0).reduce((P2, _2) => P2 + _2, 0)]).sort((k3, P2) => k3[1] - P2[1])[0]) == null ? void 0 : j2[0];
              M && (N = M);
              break;
            }
            case "initialPlacement":
              N = c;
              break;
          }
        if (o !== N)
          return {
            reset: {
              placement: N
            }
          };
      }
      return {};
    }
  };
};
function Ot(e, t) {
  return {
    top: e.top - t.height,
    right: e.right - t.width,
    bottom: e.bottom - t.height,
    left: e.left - t.width
  };
}
function Mt(e) {
  return Er.some((t) => e[t] >= 0);
}
var Dr = function(e) {
  return e === void 0 && (e = {}), {
    name: "hide",
    options: e,
    async fn(t) {
      const {
        rects: n
      } = t, {
        strategy: r = "referenceHidden",
        ...o
      } = K(e, t);
      switch (r) {
        case "referenceHidden": {
          const i2 = await Ce(t, {
            ...o,
            elementContext: "reference"
          }), s2 = Ot(i2, n.reference);
          return {
            data: {
              referenceHiddenOffsets: s2,
              referenceHidden: Mt(s2)
            }
          };
        }
        case "escaped": {
          const i2 = await Ce(t, {
            ...o,
            altBoundary: true
          }), s2 = Ot(i2, n.floating);
          return {
            data: {
              escapedOffsets: s2,
              escaped: Mt(s2)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function kr(e, t) {
  const {
    placement: n,
    platform: r,
    elements: o
  } = e, i2 = await (r.isRTL == null ? void 0 : r.isRTL(o.floating)), s2 = G(n), c = pe(n), a = ve(n) === "y", l = ["left", "top"].includes(s2) ? -1 : 1, h = i2 && a ? -1 : 1, d = K(t, e);
  let {
    mainAxis: p,
    crossAxis: m,
    alignmentAxis: v
  } = typeof d == "number" ? {
    mainAxis: d,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...d
  };
  return c && typeof v == "number" && (m = c === "end" ? v * -1 : v), a ? {
    x: m * h,
    y: p * l
  } : {
    x: p * l,
    y: m * h
  };
}
var Fr = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, r;
      const {
        x: o,
        y: i2,
        placement: s2,
        middlewareData: c
      } = t, a = await kr(t, e);
      return s2 === ((n = c.offset) == null ? void 0 : n.placement) && (r = c.arrow) != null && r.alignmentOffset ? {} : {
        x: o + a.x,
        y: i2 + a.y,
        data: {
          ...a,
          placement: s2
        }
      };
    }
  };
};
var Ir = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: r,
        placement: o
      } = t, {
        mainAxis: i2 = true,
        crossAxis: s2 = false,
        limiter: c = {
          fn: (g) => {
            let {
              x: y,
              y: w3
            } = g;
            return {
              x: y,
              y: w3
            };
          }
        },
        ...a
      } = K(e, t), l = {
        x: n,
        y: r
      }, h = await Ce(t, a), d = ve(G(o)), p = rt(d);
      let m = l[p], v = l[d];
      if (i2) {
        const g = p === "y" ? "top" : "left", y = p === "y" ? "bottom" : "right", w3 = m + h[g], b2 = m - h[y];
        m = et(w3, m, b2);
      }
      if (s2) {
        const g = d === "y" ? "top" : "left", y = d === "y" ? "bottom" : "right", w3 = v + h[g], b2 = v - h[y];
        v = et(w3, v, b2);
      }
      const u = c.fn({
        ...t,
        [p]: m,
        [d]: v
      });
      return {
        ...u,
        data: {
          x: u.x - n,
          y: u.y - r
        }
      };
    }
  };
};
var _r = function(e) {
  return e === void 0 && (e = {}), {
    options: e,
    fn(t) {
      const {
        x: n,
        y: r,
        placement: o,
        rects: i2,
        middlewareData: s2
      } = t, {
        offset: c = 0,
        mainAxis: a = true,
        crossAxis: l = true
      } = K(e, t), h = {
        x: n,
        y: r
      }, d = ve(o), p = rt(d);
      let m = h[p], v = h[d];
      const u = K(c, t), g = typeof u == "number" ? {
        mainAxis: u,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...u
      };
      if (a) {
        const b2 = p === "y" ? "height" : "width", x3 = i2.reference[p] - i2.floating[b2] + g.mainAxis, E3 = i2.reference[p] + i2.reference[b2] - g.mainAxis;
        m < x3 ? m = x3 : m > E3 && (m = E3);
      }
      if (l) {
        var y, w3;
        const b2 = p === "y" ? "width" : "height", x3 = ["top", "left"].includes(G(o)), E3 = i2.reference[d] - i2.floating[b2] + (x3 && ((y = s2.offset) == null ? void 0 : y[d]) || 0) + (x3 ? 0 : g.crossAxis), C = i2.reference[d] + i2.reference[b2] + (x3 ? 0 : ((w3 = s2.offset) == null ? void 0 : w3[d]) || 0) - (x3 ? g.crossAxis : 0);
        v < E3 ? v = E3 : v > C && (v = C);
      }
      return {
        [p]: m,
        [d]: v
      };
    }
  };
};
var Wr = function(e) {
  return e === void 0 && (e = {}), {
    name: "size",
    options: e,
    async fn(t) {
      const {
        placement: n,
        rects: r,
        platform: o,
        elements: i2
      } = t, {
        apply: s2 = () => {
        },
        ...c
      } = K(e, t), a = await Ce(t, c), l = G(n), h = pe(n), d = ve(n) === "y", {
        width: p,
        height: m
      } = r.floating;
      let v, u;
      l === "top" || l === "bottom" ? (v = l, u = h === (await (o.isRTL == null ? void 0 : o.isRTL(i2.floating)) ? "start" : "end") ? "left" : "right") : (u = l, v = h === "end" ? "top" : "bottom");
      const g = m - a[v], y = p - a[u], w3 = !t.middlewareData.shift;
      let b2 = g, x3 = y;
      if (d) {
        const C = p - a.left - a.right;
        x3 = h || w3 ? te(y, C) : C;
      } else {
        const C = m - a.top - a.bottom;
        b2 = h || w3 ? te(g, C) : C;
      }
      if (w3 && !h) {
        const C = W(a.left, 0), S = W(a.right, 0), A3 = W(a.top, 0), O3 = W(a.bottom, 0);
        d ? x3 = p - 2 * (C !== 0 || S !== 0 ? C + S : W(a.left, a.right)) : b2 = m - 2 * (A3 !== 0 || O3 !== 0 ? A3 + O3 : W(a.top, a.bottom));
      }
      await s2({
        ...t,
        availableWidth: x3,
        availableHeight: b2
      });
      const E3 = await o.getDimensions(i2.floating);
      return p !== E3.width || m !== E3.height ? {
        reset: {
          rects: true
        }
      } : {};
    }
  };
};
function ge(e) {
  return Gt(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function B(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function Z(e) {
  var t;
  return (t = (Gt(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Gt(e) {
  return e instanceof Node || e instanceof B(e).Node;
}
function U(e) {
  return e instanceof Element || e instanceof B(e).Element;
}
function Y(e) {
  return e instanceof HTMLElement || e instanceof B(e).HTMLElement;
}
function Tt(e) {
  return typeof ShadowRoot > "u" ? false : e instanceof ShadowRoot || e instanceof B(e).ShadowRoot;
}
function Ae(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: r,
    display: o
  } = $(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + r + n) && !["inline", "contents"].includes(o);
}
function Br(e) {
  return ["table", "td", "th"].includes(ge(e));
}
function st(e) {
  const t = ct(), n = $(e);
  return n.transform !== "none" || n.perspective !== "none" || (n.containerType ? n.containerType !== "normal" : false) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : false) || !t && (n.filter ? n.filter !== "none" : false) || ["transform", "perspective", "filter"].some((r) => (n.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (n.contain || "").includes(r));
}
function jr(e) {
  let t = re(e);
  for (; Y(t) && !me(t); ) {
    if (st(t))
      return t;
    t = re(t);
  }
  return null;
}
function ct() {
  return typeof CSS > "u" || !CSS.supports ? false : CSS.supports("-webkit-backdrop-filter", "none");
}
function me(e) {
  return ["html", "body", "#document"].includes(ge(e));
}
function $(e) {
  return B(e).getComputedStyle(e);
}
function je2(e) {
  return U(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.pageXOffset,
    scrollTop: e.pageYOffset
  };
}
function re(e) {
  if (ge(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Tt(e) && e.host || // Fallback.
    Z(e)
  );
  return Tt(t) ? t.host : t;
}
function Zt(e) {
  const t = re(e);
  return me(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : Y(t) && Ae(t) ? t : Zt(t);
}
function Se(e, t, n) {
  var r;
  t === void 0 && (t = []), n === void 0 && (n = true);
  const o = Zt(e), i2 = o === ((r = e.ownerDocument) == null ? void 0 : r.body), s2 = B(o);
  return i2 ? t.concat(s2, s2.visualViewport || [], Ae(o) ? o : [], s2.frameElement && n ? Se(s2.frameElement) : []) : t.concat(o, Se(o, [], n));
}
function qt(e) {
  const t = $(e);
  let n = parseFloat(t.width) || 0, r = parseFloat(t.height) || 0;
  const o = Y(e), i2 = o ? e.offsetWidth : n, s2 = o ? e.offsetHeight : r, c = Ie(n) !== i2 || Ie(r) !== s2;
  return c && (n = i2, r = s2), {
    width: n,
    height: r,
    $: c
  };
}
function at(e) {
  return U(e) ? e : e.contextElement;
}
function de(e) {
  const t = at(e);
  if (!Y(t))
    return ne(1);
  const n = t.getBoundingClientRect(), {
    width: r,
    height: o,
    $: i2
  } = qt(t);
  let s2 = (i2 ? Ie(n.width) : n.width) / r, c = (i2 ? Ie(n.height) : n.height) / o;
  return (!s2 || !Number.isFinite(s2)) && (s2 = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: s2,
    y: c
  };
}
var $r = ne(0);
function Qt(e) {
  const t = B(e);
  return !ct() || !t.visualViewport ? $r : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function Hr(e, t, n) {
  return t === void 0 && (t = false), !n || t && n !== B(e) ? false : t;
}
function ae(e, t, n, r) {
  t === void 0 && (t = false), n === void 0 && (n = false);
  const o = e.getBoundingClientRect(), i2 = at(e);
  let s2 = ne(1);
  t && (r ? U(r) && (s2 = de(r)) : s2 = de(e));
  const c = Hr(i2, n, r) ? Qt(i2) : ne(0);
  let a = (o.left + c.x) / s2.x, l = (o.top + c.y) / s2.y, h = o.width / s2.x, d = o.height / s2.y;
  if (i2) {
    const p = B(i2), m = r && U(r) ? B(r) : r;
    let v = p, u = v.frameElement;
    for (; u && r && m !== v; ) {
      const g = de(u), y = u.getBoundingClientRect(), w3 = $(u), b2 = y.left + (u.clientLeft + parseFloat(w3.paddingLeft)) * g.x, x3 = y.top + (u.clientTop + parseFloat(w3.paddingTop)) * g.y;
      a *= g.x, l *= g.y, h *= g.x, d *= g.y, a += b2, l += x3, v = B(u), u = v.frameElement;
    }
  }
  return We({
    width: h,
    height: d,
    x: a,
    y: l
  });
}
var Vr = [":popover-open", ":modal"];
function lt(e) {
  return Vr.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return false;
    }
  });
}
function zr(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: r,
    strategy: o
  } = e;
  const i2 = o === "fixed", s2 = Z(r), c = t ? lt(t.floating) : false;
  if (r === s2 || c && i2)
    return n;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = ne(1);
  const h = ne(0), d = Y(r);
  if ((d || !d && !i2) && ((ge(r) !== "body" || Ae(s2)) && (a = je2(r)), Y(r))) {
    const p = ae(r);
    l = de(r), h.x = p.x + r.clientLeft, h.y = p.y + r.clientTop;
  }
  return {
    width: n.width * l.x,
    height: n.height * l.y,
    x: n.x * l.x - a.scrollLeft * l.x + h.x,
    y: n.y * l.y - a.scrollTop * l.y + h.y
  };
}
function Ur(e) {
  return Array.from(e.getClientRects());
}
function Jt(e) {
  return ae(Z(e)).left + je2(e).scrollLeft;
}
function Yr(e) {
  const t = Z(e), n = je2(e), r = e.ownerDocument.body, o = W(t.scrollWidth, t.clientWidth, r.scrollWidth, r.clientWidth), i2 = W(t.scrollHeight, t.clientHeight, r.scrollHeight, r.clientHeight);
  let s2 = -n.scrollLeft + Jt(e);
  const c = -n.scrollTop;
  return $(r).direction === "rtl" && (s2 += W(t.clientWidth, r.clientWidth) - o), {
    width: o,
    height: i2,
    x: s2,
    y: c
  };
}
function Xr(e, t) {
  const n = B(e), r = Z(e), o = n.visualViewport;
  let i2 = r.clientWidth, s2 = r.clientHeight, c = 0, a = 0;
  if (o) {
    i2 = o.width, s2 = o.height;
    const l = ct();
    (!l || l && t === "fixed") && (c = o.offsetLeft, a = o.offsetTop);
  }
  return {
    width: i2,
    height: s2,
    x: c,
    y: a
  };
}
function Kr(e, t) {
  const n = ae(e, true, t === "fixed"), r = n.top + e.clientTop, o = n.left + e.clientLeft, i2 = Y(e) ? de(e) : ne(1), s2 = e.clientWidth * i2.x, c = e.clientHeight * i2.y, a = o * i2.x, l = r * i2.y;
  return {
    width: s2,
    height: c,
    x: a,
    y: l
  };
}
function Lt(e, t, n) {
  let r;
  if (t === "viewport")
    r = Xr(e, n);
  else if (t === "document")
    r = Yr(Z(e));
  else if (U(t))
    r = Kr(t, n);
  else {
    const o = Qt(e);
    r = {
      ...t,
      x: t.x - o.x,
      y: t.y - o.y
    };
  }
  return We(r);
}
function en(e, t) {
  const n = re(e);
  return n === t || !U(n) || me(n) ? false : $(n).position === "fixed" || en(n, t);
}
function Gr(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let r = Se(e, [], false).filter((c) => U(c) && ge(c) !== "body"), o = null;
  const i2 = $(e).position === "fixed";
  let s2 = i2 ? re(e) : e;
  for (; U(s2) && !me(s2); ) {
    const c = $(s2), a = st(s2);
    !a && c.position === "fixed" && (o = null), (i2 ? !a && !o : !a && c.position === "static" && !!o && ["absolute", "fixed"].includes(o.position) || Ae(s2) && !a && en(e, s2)) ? r = r.filter((h) => h !== s2) : o = c, s2 = re(s2);
  }
  return t.set(e, r), r;
}
function Zr(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: r,
    strategy: o
  } = e;
  const s2 = [...n === "clippingAncestors" ? lt(t) ? [] : Gr(t, this._c) : [].concat(n), r], c = s2[0], a = s2.reduce((l, h) => {
    const d = Lt(t, h, o);
    return l.top = W(d.top, l.top), l.right = te(d.right, l.right), l.bottom = te(d.bottom, l.bottom), l.left = W(d.left, l.left), l;
  }, Lt(t, c, o));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function qr(e) {
  const {
    width: t,
    height: n
  } = qt(e);
  return {
    width: t,
    height: n
  };
}
function Qr(e, t, n) {
  const r = Y(t), o = Z(t), i2 = n === "fixed", s2 = ae(e, true, i2, t);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = ne(0);
  if (r || !r && !i2)
    if ((ge(t) !== "body" || Ae(o)) && (c = je2(t)), r) {
      const d = ae(t, true, i2, t);
      a.x = d.x + t.clientLeft, a.y = d.y + t.clientTop;
    } else o && (a.x = Jt(o));
  const l = s2.left + c.scrollLeft - a.x, h = s2.top + c.scrollTop - a.y;
  return {
    x: l,
    y: h,
    width: s2.width,
    height: s2.height
  };
}
function Xe(e) {
  return $(e).position === "static";
}
function Nt(e, t) {
  return !Y(e) || $(e).position === "fixed" ? null : t ? t(e) : e.offsetParent;
}
function tn(e, t) {
  const n = B(e);
  if (lt(e))
    return n;
  if (!Y(e)) {
    let o = re(e);
    for (; o && !me(o); ) {
      if (U(o) && !Xe(o))
        return o;
      o = re(o);
    }
    return n;
  }
  let r = Nt(e, t);
  for (; r && Br(r) && Xe(r); )
    r = Nt(r, t);
  return r && me(r) && Xe(r) && !st(r) ? n : r || jr(e) || n;
}
var Jr = async function(e) {
  const t = this.getOffsetParent || tn, n = this.getDimensions, r = await n(e.floating);
  return {
    reference: Qr(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function eo(e) {
  return $(e).direction === "rtl";
}
var to = {
  convertOffsetParentRelativeRectToViewportRelativeRect: zr,
  getDocumentElement: Z,
  getClippingRect: Zr,
  getOffsetParent: tn,
  getElementRects: Jr,
  getClientRects: Ur,
  getDimensions: qr,
  getScale: de,
  isElement: U,
  isRTL: eo
};
function no(e, t) {
  let n = null, r;
  const o = Z(e);
  function i2() {
    var c;
    clearTimeout(r), (c = n) == null || c.disconnect(), n = null;
  }
  function s2(c, a) {
    c === void 0 && (c = false), a === void 0 && (a = 1), i2();
    const {
      left: l,
      top: h,
      width: d,
      height: p
    } = e.getBoundingClientRect();
    if (c || t(), !d || !p)
      return;
    const m = Oe(h), v = Oe(o.clientWidth - (l + d)), u = Oe(o.clientHeight - (h + p)), g = Oe(l), w3 = {
      rootMargin: -m + "px " + -v + "px " + -u + "px " + -g + "px",
      threshold: W(0, te(1, a)) || 1
    };
    let b2 = true;
    function x3(E3) {
      const C = E3[0].intersectionRatio;
      if (C !== a) {
        if (!b2)
          return s2();
        C ? s2(false, C) : r = setTimeout(() => {
          s2(false, 1e-7);
        }, 1e3);
      }
      b2 = false;
    }
    try {
      n = new IntersectionObserver(x3, {
        ...w3,
        // Handle <iframe>s
        root: o.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(x3, w3);
    }
    n.observe(e);
  }
  return s2(true), i2;
}
function ro(e, t, n, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: o = true,
    ancestorResize: i2 = true,
    elementResize: s2 = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: a = false
  } = r, l = at(e), h = o || i2 ? [...l ? Se(l) : [], ...Se(t)] : [];
  h.forEach((y) => {
    o && y.addEventListener("scroll", n, {
      passive: true
    }), i2 && y.addEventListener("resize", n);
  });
  const d = l && c ? no(l, n) : null;
  let p = -1, m = null;
  s2 && (m = new ResizeObserver((y) => {
    let [w3] = y;
    w3 && w3.target === l && m && (m.unobserve(t), cancelAnimationFrame(p), p = requestAnimationFrame(() => {
      var b2;
      (b2 = m) == null || b2.observe(t);
    })), n();
  }), l && !a && m.observe(l), m.observe(t));
  let v, u = a ? ae(e) : null;
  a && g();
  function g() {
    const y = ae(e);
    u && (y.x !== u.x || y.y !== u.y || y.width !== u.width || y.height !== u.height) && n(), u = y, v = requestAnimationFrame(g);
  }
  return n(), () => {
    var y;
    h.forEach((w3) => {
      o && w3.removeEventListener("scroll", n), i2 && w3.removeEventListener("resize", n);
    }), d == null || d(), (y = m) == null || y.disconnect(), m = null, a && cancelAnimationFrame(v);
  };
}
var oo = Fr;
var io = Ir;
var so = Nr;
var co = Wr;
var ao = Dr;
var Dt = Lr;
var lo = _r;
var uo = (e, t, n) => {
  const r = /* @__PURE__ */ new Map(), o = {
    platform: to,
    ...n
  }, i2 = {
    ...o.platform,
    _c: r
  };
  return Tr(e, t, {
    ...o,
    platform: i2
  });
};
var fo = (e) => {
  function t(n) {
    return {}.hasOwnProperty.call(n, "current");
  }
  return {
    name: "arrow",
    options: e,
    fn(n) {
      const {
        element: r,
        padding: o
      } = typeof e == "function" ? e(n) : e;
      return r && t(r) ? r.current != null ? Dt({
        element: r.current,
        padding: o
      }).fn(n) : {} : r ? Dt({
        element: r,
        padding: o
      }).fn(n) : {};
    }
  };
};
var De = typeof document < "u" ? import_react2.useLayoutEffect : import_react2.useEffect;
function Be(e, t) {
  if (e === t)
    return true;
  if (typeof e != typeof t)
    return false;
  if (typeof e == "function" && e.toString() === t.toString())
    return true;
  let n, r, o;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return false;
      for (r = n; r-- !== 0; )
        if (!Be(e[r], t[r]))
          return false;
      return true;
    }
    if (o = Object.keys(e), n = o.length, n !== Object.keys(t).length)
      return false;
    for (r = n; r-- !== 0; )
      if (!{}.hasOwnProperty.call(t, o[r]))
        return false;
    for (r = n; r-- !== 0; ) {
      const i2 = o[r];
      if (!(i2 === "_owner" && e.$$typeof) && !Be(e[i2], t[i2]))
        return false;
    }
    return true;
  }
  return e !== e && t !== t;
}
function nn(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function kt(e, t) {
  const n = nn(e);
  return Math.round(t * n) / n;
}
function Ft(e) {
  const t = f.useRef(e);
  return De(() => {
    t.current = e;
  }), t;
}
function ho(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: r = [],
    platform: o,
    elements: {
      reference: i2,
      floating: s2
    } = {},
    transform: c = true,
    whileElementsMounted: a,
    open: l
  } = e, [h, d] = f.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: false
  }), [p, m] = f.useState(r);
  Be(p, r) || m(r);
  const [v, u] = f.useState(null), [g, y] = f.useState(null), w3 = f.useCallback((P2) => {
    P2 !== C.current && (C.current = P2, u(P2));
  }, []), b2 = f.useCallback((P2) => {
    P2 !== S.current && (S.current = P2, y(P2));
  }, []), x3 = i2 || v, E3 = s2 || g, C = f.useRef(null), S = f.useRef(null), A3 = f.useRef(h), O3 = a != null, D = Ft(a), j2 = Ft(o), T = f.useCallback(() => {
    if (!C.current || !S.current)
      return;
    const P2 = {
      placement: t,
      strategy: n,
      middleware: p
    };
    j2.current && (P2.platform = j2.current), uo(C.current, S.current, P2).then((_2) => {
      const X2 = {
        ..._2,
        isPositioned: true
      };
      I2.current && !Be(A3.current, X2) && (A3.current = X2, Ht.flushSync(() => {
        d(X2);
      }));
    });
  }, [p, t, n, j2]);
  De(() => {
    l === false && A3.current.isPositioned && (A3.current.isPositioned = false, d((P2) => ({
      ...P2,
      isPositioned: false
    })));
  }, [l]);
  const I2 = f.useRef(false);
  De(() => (I2.current = true, () => {
    I2.current = false;
  }), []), De(() => {
    if (x3 && (C.current = x3), E3 && (S.current = E3), x3 && E3) {
      if (D.current)
        return D.current(x3, E3, T);
      T();
    }
  }, [x3, E3, T, D, O3]);
  const N = f.useMemo(() => ({
    reference: C,
    floating: S,
    setReference: w3,
    setFloating: b2
  }), [w3, b2]), M = f.useMemo(() => ({
    reference: x3,
    floating: E3
  }), [x3, E3]), k3 = f.useMemo(() => {
    const P2 = {
      position: n,
      left: 0,
      top: 0
    };
    if (!M.floating)
      return P2;
    const _2 = kt(M.floating, h.x), X2 = kt(M.floating, h.y);
    return c ? {
      ...P2,
      transform: "translate(" + _2 + "px, " + X2 + "px)",
      ...nn(M.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: _2,
      top: X2
    };
  }, [n, c, M.floating, h.x, h.y]);
  return f.useMemo(() => ({
    ...h,
    update: T,
    refs: N,
    elements: M,
    floatingStyles: k3
  }), [h, T, N, M, k3]);
}
var mo = "Arrow";
var rn = f.forwardRef((e, t) => {
  const { children: n, width: r = 10, height: o = 5, ...i2 } = e;
  return dr.jsx(
    oe.svg,
    {
      ...i2,
      ref: t,
      width: r,
      height: o,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: e.asChild ? n : dr.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
rn.displayName = mo;
var po = rn;
function vo(e) {
  const [t, n] = f.useState(void 0);
  return Ee(() => {
    if (e) {
      n({ width: e.offsetWidth, height: e.offsetHeight });
      const r = new ResizeObserver((o) => {
        if (!Array.isArray(o) || !o.length)
          return;
        const i2 = o[0];
        let s2, c;
        if ("borderBoxSize" in i2) {
          const a = i2.borderBoxSize, l = Array.isArray(a) ? a[0] : a;
          s2 = l.inlineSize, c = l.blockSize;
        } else
          s2 = e.offsetWidth, c = e.offsetHeight;
        n({ width: s2, height: c });
      });
      return r.observe(e, { box: "border-box" }), () => r.unobserve(e);
    } else
      n(void 0);
  }, [e]), t;
}
var ut = "Popper";
var [on, Mi] = zt(ut);
var [go, sn] = on(ut);
var cn = (e) => {
  const { __scopePopper: t, children: n } = e, [r, o] = f.useState(null);
  return dr.jsx(go, { scope: t, anchor: r, onAnchorChange: o, children: n });
};
cn.displayName = ut;
var an = "PopperAnchor";
var ln = f.forwardRef(
  (e, t) => {
    const { __scopePopper: n, virtualRef: r, ...o } = e, i2 = sn(an, n), s2 = f.useRef(null), c = ce(t, s2);
    return f.useEffect(() => {
      i2.onAnchorChange((r == null ? void 0 : r.current) || s2.current);
    }), r ? null : dr.jsx(oe.div, { ...o, ref: c });
  }
);
ln.displayName = an;
var ft = "PopperContent";
var [yo, wo] = on(ft);
var un = f.forwardRef(
  (e, t) => {
    var dt2, ht, mt2, pt2, vt2, gt3;
    const {
      __scopePopper: n,
      side: r = "bottom",
      sideOffset: o = 0,
      align: i2 = "center",
      alignOffset: s2 = 0,
      arrowPadding: c = 0,
      avoidCollisions: a = true,
      collisionBoundary: l = [],
      collisionPadding: h = 0,
      sticky: d = "partial",
      hideWhenDetached: p = false,
      updatePositionStrategy: m = "optimized",
      onPlaced: v,
      ...u
    } = e, g = sn(ft, n), [y, w3] = f.useState(null), b2 = ce(t, (ye) => w3(ye)), [x3, E3] = f.useState(null), C = vo(x3), S = (C == null ? void 0 : C.width) ?? 0, A3 = (C == null ? void 0 : C.height) ?? 0, O3 = r + (i2 !== "center" ? "-" + i2 : ""), D = typeof h == "number" ? h : { top: 0, right: 0, bottom: 0, left: 0, ...h }, j2 = Array.isArray(l) ? l : [l], T = j2.length > 0, I2 = {
      padding: D,
      boundary: j2.filter(bo),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: T
    }, { refs: N, floatingStyles: M, placement: k3, isPositioned: P2, middlewareData: _2 } = ho({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: O3,
      whileElementsMounted: (...ye) => ro(...ye, {
        animationFrame: m === "always"
      }),
      elements: {
        reference: g.anchor
      },
      middleware: [
        oo({ mainAxis: o + A3, alignmentAxis: s2 }),
        a && io({
          mainAxis: true,
          crossAxis: false,
          limiter: d === "partial" ? lo() : void 0,
          ...I2
        }),
        a && so({ ...I2 }),
        co({
          ...I2,
          apply: ({ elements: ye, rects: yt, availableWidth: On, availableHeight: Mn }) => {
            const { width: Tn, height: Ln } = yt.reference, Re = ye.floating.style;
            Re.setProperty("--radix-popper-available-width", `${On}px`), Re.setProperty("--radix-popper-available-height", `${Mn}px`), Re.setProperty("--radix-popper-anchor-width", `${Tn}px`), Re.setProperty("--radix-popper-anchor-height", `${Ln}px`);
          }
        }),
        x3 && fo({ element: x3, padding: c }),
        Eo({ arrowWidth: S, arrowHeight: A3 }),
        p && ao({ strategy: "referenceHidden", ...I2 })
      ]
    }), [X2, En] = hn(k3), Pe2 = ee(v);
    Ee(() => {
      P2 && (Pe2 == null || Pe2());
    }, [P2, Pe2]);
    const Cn = (dt2 = _2.arrow) == null ? void 0 : dt2.x, Sn = (ht = _2.arrow) == null ? void 0 : ht.y, An = ((mt2 = _2.arrow) == null ? void 0 : mt2.centerOffset) !== 0, [Pn, Rn] = f.useState();
    return Ee(() => {
      y && Rn(window.getComputedStyle(y).zIndex);
    }, [y]), dr.jsx(
      "div",
      {
        ref: N.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...M,
          transform: P2 ? M.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: Pn,
          "--radix-popper-transform-origin": [
            (pt2 = _2.transformOrigin) == null ? void 0 : pt2.x,
            (vt2 = _2.transformOrigin) == null ? void 0 : vt2.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((gt3 = _2.hide) == null ? void 0 : gt3.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: e.dir,
        children: dr.jsx(
          yo,
          {
            scope: n,
            placedSide: X2,
            onArrowChange: E3,
            arrowX: Cn,
            arrowY: Sn,
            shouldHideArrow: An,
            children: dr.jsx(
              oe.div,
              {
                "data-side": X2,
                "data-align": En,
                ...u,
                ref: b2,
                style: {
                  ...u.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: P2 ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
un.displayName = ft;
var fn = "PopperArrow";
var xo = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var dn = f.forwardRef(function(t, n) {
  const { __scopePopper: r, ...o } = t, i2 = wo(fn, r), s2 = xo[i2.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    dr.jsx(
      "span",
      {
        ref: i2.onArrowChange,
        style: {
          position: "absolute",
          left: i2.arrowX,
          top: i2.arrowY,
          [s2]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[i2.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[i2.placedSide],
          visibility: i2.shouldHideArrow ? "hidden" : void 0
        },
        children: dr.jsx(
          po,
          {
            ...o,
            ref: n,
            style: {
              ...o.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
dn.displayName = fn;
function bo(e) {
  return e !== null;
}
var Eo = (e) => ({
  name: "transformOrigin",
  options: e,
  fn(t) {
    var g, y, w3;
    const { placement: n, rects: r, middlewareData: o } = t, s2 = ((g = o.arrow) == null ? void 0 : g.centerOffset) !== 0, c = s2 ? 0 : e.arrowWidth, a = s2 ? 0 : e.arrowHeight, [l, h] = hn(n), d = { start: "0%", center: "50%", end: "100%" }[h], p = (((y = o.arrow) == null ? void 0 : y.x) ?? 0) + c / 2, m = (((w3 = o.arrow) == null ? void 0 : w3.y) ?? 0) + a / 2;
    let v = "", u = "";
    return l === "bottom" ? (v = s2 ? d : `${p}px`, u = `${-a}px`) : l === "top" ? (v = s2 ? d : `${p}px`, u = `${r.floating.height + a}px`) : l === "right" ? (v = `${-a}px`, u = s2 ? d : `${m}px`) : l === "left" && (v = `${r.floating.width + a}px`, u = s2 ? d : `${m}px`), { data: { x: v, y: u } };
  }
});
function hn(e) {
  const [t, n = "center"] = e.split("-");
  return [t, n];
}
var Ti = cn;
var Li = ln;
var Ni = un;
var Di = dn;
var Co = "Portal";
var So = f.forwardRef((e, t) => {
  var c;
  const { container: n, ...r } = e, [o, i2] = f.useState(false);
  Ee(() => i2(true), []);
  const s2 = n || o && ((c = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : c.body);
  return s2 ? import_react_dom.default.createPortal(dr.jsx(oe.div, { ...r, ref: t }), s2) : null;
});
So.displayName = Co;
var Ao = function(e) {
  if (typeof document > "u")
    return null;
  var t = Array.isArray(e) ? e[0] : e;
  return t.ownerDocument.body;
};
var le = /* @__PURE__ */ new WeakMap();
var Me = /* @__PURE__ */ new WeakMap();
var Te = {};
var Ke = 0;
var mn = function(e) {
  return e && (e.host || mn(e.parentNode));
};
var Po = function(e, t) {
  return t.map(function(n) {
    if (e.contains(n))
      return n;
    var r = mn(n);
    return r && e.contains(r) ? r : (console.error("aria-hidden", n, "in not contained inside", e, ". Doing nothing"), null);
  }).filter(function(n) {
    return !!n;
  });
};
var Ro = function(e, t, n, r) {
  var o = Po(t, Array.isArray(e) ? e : [e]);
  Te[n] || (Te[n] = /* @__PURE__ */ new WeakMap());
  var i2 = Te[n], s2 = [], c = /* @__PURE__ */ new Set(), a = new Set(o), l = function(d) {
    !d || c.has(d) || (c.add(d), l(d.parentNode));
  };
  o.forEach(l);
  var h = function(d) {
    !d || a.has(d) || Array.prototype.forEach.call(d.children, function(p) {
      if (c.has(p))
        h(p);
      else
        try {
          var m = p.getAttribute(r), v = m !== null && m !== "false", u = (le.get(p) || 0) + 1, g = (i2.get(p) || 0) + 1;
          le.set(p, u), i2.set(p, g), s2.push(p), u === 1 && v && Me.set(p, true), g === 1 && p.setAttribute(n, "true"), v || p.setAttribute(r, "true");
        } catch (y) {
          console.error("aria-hidden: cannot operate on ", p, y);
        }
    });
  };
  return h(t), c.clear(), Ke++, function() {
    s2.forEach(function(d) {
      var p = le.get(d) - 1, m = i2.get(d) - 1;
      le.set(d, p), i2.set(d, m), p || (Me.has(d) || d.removeAttribute(r), Me.delete(d)), m || d.removeAttribute(n);
    }), Ke--, Ke || (le = /* @__PURE__ */ new WeakMap(), le = /* @__PURE__ */ new WeakMap(), Me = /* @__PURE__ */ new WeakMap(), Te = {});
  };
};
var ki = function(e, t, n) {
  n === void 0 && (n = "data-aria-hidden");
  var r = Array.from(Array.isArray(e) ? e : [e]), o = Ao(e);
  return o ? (r.push.apply(r, Array.from(o.querySelectorAll("[aria-live]"))), Ro(r, o, n, "aria-hidden")) : function() {
    return null;
  };
};
var z = function() {
  return z = Object.assign || function(t) {
    for (var n, r = 1, o = arguments.length; r < o; r++) {
      n = arguments[r];
      for (var i2 in n) Object.prototype.hasOwnProperty.call(n, i2) && (t[i2] = n[i2]);
    }
    return t;
  }, z.apply(this, arguments);
};
function pn(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function Oo(e, t, n) {
  if (n || arguments.length === 2) for (var r = 0, o = t.length, i2; r < o; r++)
    (i2 || !(r in t)) && (i2 || (i2 = Array.prototype.slice.call(t, 0, r)), i2[r] = t[r]);
  return e.concat(i2 || Array.prototype.slice.call(t));
}
var ke2 = "right-scroll-bar-position";
var Fe = "width-before-scroll-bar";
var Mo = "with-scroll-bars-hidden";
var To = "--removed-body-scroll-bar-size";
function Ge(e, t) {
  return typeof e == "function" ? e(t) : e && (e.current = t), e;
}
function Lo(e, t) {
  var n = (0, import_react2.useState)(function() {
    return {
      // value
      value: e,
      // last callback
      callback: t,
      // "memoized" public interface
      facade: {
        get current() {
          return n.value;
        },
        set current(r) {
          var o = n.value;
          o !== r && (n.value = r, n.callback(r, o));
        }
      }
    };
  })[0];
  return n.callback = t, n.facade;
}
var No = typeof window < "u" ? f.useLayoutEffect : f.useEffect;
var It = /* @__PURE__ */ new WeakMap();
function Do(e, t) {
  var n = Lo(null, function(r) {
    return e.forEach(function(o) {
      return Ge(o, r);
    });
  });
  return No(function() {
    var r = It.get(n);
    if (r) {
      var o = new Set(r), i2 = new Set(e), s2 = n.current;
      o.forEach(function(c) {
        i2.has(c) || Ge(c, null);
      }), i2.forEach(function(c) {
        o.has(c) || Ge(c, s2);
      });
    }
    It.set(n, e);
  }, [e]), n;
}
function ko(e) {
  return e;
}
function Fo(e, t) {
  t === void 0 && (t = ko);
  var n = [], r = false, o = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return n.length ? n[n.length - 1] : e;
    },
    useMedium: function(i2) {
      var s2 = t(i2, r);
      return n.push(s2), function() {
        n = n.filter(function(c) {
          return c !== s2;
        });
      };
    },
    assignSyncMedium: function(i2) {
      for (r = true; n.length; ) {
        var s2 = n;
        n = [], s2.forEach(i2);
      }
      n = {
        push: function(c) {
          return i2(c);
        },
        filter: function() {
          return n;
        }
      };
    },
    assignMedium: function(i2) {
      r = true;
      var s2 = [];
      if (n.length) {
        var c = n;
        n = [], c.forEach(i2), s2 = n;
      }
      var a = function() {
        var h = s2;
        s2 = [], h.forEach(i2);
      }, l = function() {
        return Promise.resolve().then(a);
      };
      l(), n = {
        push: function(h) {
          s2.push(h), l();
        },
        filter: function(h) {
          return s2 = s2.filter(h), n;
        }
      };
    }
  };
  return o;
}
function Io(e) {
  e === void 0 && (e = {});
  var t = Fo(null);
  return t.options = z({ async: true, ssr: false }, e), t;
}
var vn = function(e) {
  var t = e.sideCar, n = pn(e, ["sideCar"]);
  if (!t)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = t.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return f.createElement(r, z({}, n));
};
vn.isSideCarExport = true;
function _o(e, t) {
  return e.useMedium(t), vn;
}
var gn = Io();
var Ze = function() {
};
var $e = f.forwardRef(function(e, t) {
  var n = f.useRef(null), r = f.useState({
    onScrollCapture: Ze,
    onWheelCapture: Ze,
    onTouchMoveCapture: Ze
  }), o = r[0], i2 = r[1], s2 = e.forwardProps, c = e.children, a = e.className, l = e.removeScrollBar, h = e.enabled, d = e.shards, p = e.sideCar, m = e.noIsolation, v = e.inert, u = e.allowPinchZoom, g = e.as, y = g === void 0 ? "div" : g, w3 = e.gapMode, b2 = pn(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), x3 = p, E3 = Do([n, t]), C = z(z({}, b2), o);
  return f.createElement(
    f.Fragment,
    null,
    h && f.createElement(x3, { sideCar: gn, removeScrollBar: l, shards: d, noIsolation: m, inert: v, setCallbacks: i2, allowPinchZoom: !!u, lockRef: n, gapMode: w3 }),
    s2 ? f.cloneElement(f.Children.only(c), z(z({}, C), { ref: E3 })) : f.createElement(y, z({}, C, { className: a, ref: E3 }), c)
  );
});
$e.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
$e.classNames = {
  fullWidth: Fe,
  zeroRight: ke2
};
var Wo = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Bo() {
  if (!document)
    return null;
  var e = document.createElement("style");
  e.type = "text/css";
  var t = Wo();
  return t && e.setAttribute("nonce", t), e;
}
function jo(e, t) {
  e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t));
}
function $o(e) {
  var t = document.head || document.getElementsByTagName("head")[0];
  t.appendChild(e);
}
var Ho = function() {
  var e = 0, t = null;
  return {
    add: function(n) {
      e == 0 && (t = Bo()) && (jo(t, n), $o(t)), e++;
    },
    remove: function() {
      e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null);
    }
  };
};
var Vo = function() {
  var e = Ho();
  return function(t, n) {
    f.useEffect(function() {
      return e.add(t), function() {
        e.remove();
      };
    }, [t && n]);
  };
};
var yn = function() {
  var e = Vo(), t = function(n) {
    var r = n.styles, o = n.dynamic;
    return e(r, o), null;
  };
  return t;
};
var zo = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var qe = function(e) {
  return parseInt(e || "", 10) || 0;
};
var Uo = function(e) {
  var t = window.getComputedStyle(document.body), n = t[e === "padding" ? "paddingLeft" : "marginLeft"], r = t[e === "padding" ? "paddingTop" : "marginTop"], o = t[e === "padding" ? "paddingRight" : "marginRight"];
  return [qe(n), qe(r), qe(o)];
};
var Yo = function(e) {
  if (e === void 0 && (e = "margin"), typeof window > "u")
    return zo;
  var t = Uo(e), n = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: t[0],
    top: t[1],
    right: t[2],
    gap: Math.max(0, r - n + t[2] - t[0])
  };
};
var Xo = yn();
var he = "data-scroll-locked";
var Ko = function(e, t, n, r) {
  var o = e.left, i2 = e.top, s2 = e.right, c = e.gap;
  return n === void 0 && (n = "margin"), `
  .`.concat(Mo, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(c, "px ").concat(r, `;
  }
  body[`).concat(he, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    t && "position: relative ".concat(r, ";"),
    n === "margin" && `
    padding-left: `.concat(o, `px;
    padding-top: `).concat(i2, `px;
    padding-right: `).concat(s2, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(c, "px ").concat(r, `;
    `),
    n === "padding" && "padding-right: ".concat(c, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(ke2, ` {
    right: `).concat(c, "px ").concat(r, `;
  }
  
  .`).concat(Fe, ` {
    margin-right: `).concat(c, "px ").concat(r, `;
  }
  
  .`).concat(ke2, " .").concat(ke2, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(Fe, " .").concat(Fe, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(he, `] {
    `).concat(To, ": ").concat(c, `px;
  }
`);
};
var _t = function() {
  var e = parseInt(document.body.getAttribute(he) || "0", 10);
  return isFinite(e) ? e : 0;
};
var Go = function() {
  f.useEffect(function() {
    return document.body.setAttribute(he, (_t() + 1).toString()), function() {
      var e = _t() - 1;
      e <= 0 ? document.body.removeAttribute(he) : document.body.setAttribute(he, e.toString());
    };
  }, []);
};
var Zo = function(e) {
  var t = e.noRelative, n = e.noImportant, r = e.gapMode, o = r === void 0 ? "margin" : r;
  Go();
  var i2 = f.useMemo(function() {
    return Yo(o);
  }, [o]);
  return f.createElement(Xo, { styles: Ko(i2, !t, o, n ? "" : "!important") });
};
var nt = false;
if (typeof window < "u")
  try {
    Le2 = Object.defineProperty({}, "passive", {
      get: function() {
        return nt = true, true;
      }
    });
    window.addEventListener("test", Le2, Le2), window.removeEventListener("test", Le2, Le2);
  } catch {
    nt = false;
  }
var Le2;
var ue = nt ? { passive: false } : false;
var qo = function(e) {
  return e.tagName === "TEXTAREA";
};
var wn = function(e, t) {
  if (!(e instanceof Element))
    return false;
  var n = window.getComputedStyle(e);
  return (
    // not-not-scrollable
    n[t] !== "hidden" && // contains scroll inside self
    !(n.overflowY === n.overflowX && !qo(e) && n[t] === "visible")
  );
};
var Qo = function(e) {
  return wn(e, "overflowY");
};
var Jo = function(e) {
  return wn(e, "overflowX");
};
var Wt = function(e, t) {
  var n = t.ownerDocument, r = t;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var o = xn(e, r);
    if (o) {
      var i2 = bn(e, r), s2 = i2[1], c = i2[2];
      if (s2 > c)
        return true;
    }
    r = r.parentNode;
  } while (r && r !== n.body);
  return false;
};
var ei = function(e) {
  var t = e.scrollTop, n = e.scrollHeight, r = e.clientHeight;
  return [
    t,
    n,
    r
  ];
};
var ti = function(e) {
  var t = e.scrollLeft, n = e.scrollWidth, r = e.clientWidth;
  return [
    t,
    n,
    r
  ];
};
var xn = function(e, t) {
  return e === "v" ? Qo(t) : Jo(t);
};
var bn = function(e, t) {
  return e === "v" ? ei(t) : ti(t);
};
var ni = function(e, t) {
  return e === "h" && t === "rtl" ? -1 : 1;
};
var ri = function(e, t, n, r, o) {
  var i2 = ni(e, window.getComputedStyle(t).direction), s2 = i2 * r, c = n.target, a = t.contains(c), l = false, h = s2 > 0, d = 0, p = 0;
  do {
    var m = bn(e, c), v = m[0], u = m[1], g = m[2], y = u - g - i2 * v;
    (v || y) && xn(e, c) && (d += y, p += v), c instanceof ShadowRoot ? c = c.host : c = c.parentNode;
  } while (
    // portaled content
    !a && c !== document.body || // self content
    a && (t.contains(c) || t === c)
  );
  return (h && (Math.abs(d) < 1 || !o) || !h && (Math.abs(p) < 1 || !o)) && (l = true), l;
};
var Ne = function(e) {
  return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0];
};
var Bt = function(e) {
  return [e.deltaX, e.deltaY];
};
var jt = function(e) {
  return e && "current" in e ? e.current : e;
};
var oi = function(e, t) {
  return e[0] === t[0] && e[1] === t[1];
};
var ii = function(e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`);
};
var si = 0;
var fe = [];
function ci(e) {
  var t = f.useRef([]), n = f.useRef([0, 0]), r = f.useRef(), o = f.useState(si++)[0], i2 = f.useState(yn)[0], s2 = f.useRef(e);
  f.useEffect(function() {
    s2.current = e;
  }, [e]), f.useEffect(function() {
    if (e.inert) {
      document.body.classList.add("block-interactivity-".concat(o));
      var u = Oo([e.lockRef.current], (e.shards || []).map(jt), true).filter(Boolean);
      return u.forEach(function(g) {
        return g.classList.add("allow-interactivity-".concat(o));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(o)), u.forEach(function(g) {
          return g.classList.remove("allow-interactivity-".concat(o));
        });
      };
    }
  }, [e.inert, e.lockRef.current, e.shards]);
  var c = f.useCallback(function(u, g) {
    if ("touches" in u && u.touches.length === 2 || u.type === "wheel" && u.ctrlKey)
      return !s2.current.allowPinchZoom;
    var y = Ne(u), w3 = n.current, b2 = "deltaX" in u ? u.deltaX : w3[0] - y[0], x3 = "deltaY" in u ? u.deltaY : w3[1] - y[1], E3, C = u.target, S = Math.abs(b2) > Math.abs(x3) ? "h" : "v";
    if ("touches" in u && S === "h" && C.type === "range")
      return false;
    var A3 = Wt(S, C);
    if (!A3)
      return true;
    if (A3 ? E3 = S : (E3 = S === "v" ? "h" : "v", A3 = Wt(S, C)), !A3)
      return false;
    if (!r.current && "changedTouches" in u && (b2 || x3) && (r.current = E3), !E3)
      return true;
    var O3 = r.current || E3;
    return ri(O3, g, u, O3 === "h" ? b2 : x3, true);
  }, []), a = f.useCallback(function(u) {
    var g = u;
    if (!(!fe.length || fe[fe.length - 1] !== i2)) {
      var y = "deltaY" in g ? Bt(g) : Ne(g), w3 = t.current.filter(function(E3) {
        return E3.name === g.type && (E3.target === g.target || g.target === E3.shadowParent) && oi(E3.delta, y);
      })[0];
      if (w3 && w3.should) {
        g.cancelable && g.preventDefault();
        return;
      }
      if (!w3) {
        var b2 = (s2.current.shards || []).map(jt).filter(Boolean).filter(function(E3) {
          return E3.contains(g.target);
        }), x3 = b2.length > 0 ? c(g, b2[0]) : !s2.current.noIsolation;
        x3 && g.cancelable && g.preventDefault();
      }
    }
  }, []), l = f.useCallback(function(u, g, y, w3) {
    var b2 = { name: u, delta: g, target: y, should: w3, shadowParent: ai(y) };
    t.current.push(b2), setTimeout(function() {
      t.current = t.current.filter(function(x3) {
        return x3 !== b2;
      });
    }, 1);
  }, []), h = f.useCallback(function(u) {
    n.current = Ne(u), r.current = void 0;
  }, []), d = f.useCallback(function(u) {
    l(u.type, Bt(u), u.target, c(u, e.lockRef.current));
  }, []), p = f.useCallback(function(u) {
    l(u.type, Ne(u), u.target, c(u, e.lockRef.current));
  }, []);
  f.useEffect(function() {
    return fe.push(i2), e.setCallbacks({
      onScrollCapture: d,
      onWheelCapture: d,
      onTouchMoveCapture: p
    }), document.addEventListener("wheel", a, ue), document.addEventListener("touchmove", a, ue), document.addEventListener("touchstart", h, ue), function() {
      fe = fe.filter(function(u) {
        return u !== i2;
      }), document.removeEventListener("wheel", a, ue), document.removeEventListener("touchmove", a, ue), document.removeEventListener("touchstart", h, ue);
    };
  }, []);
  var m = e.removeScrollBar, v = e.inert;
  return f.createElement(
    f.Fragment,
    null,
    v ? f.createElement(i2, { styles: ii(o) }) : null,
    m ? f.createElement(Zo, { gapMode: e.gapMode }) : null
  );
}
function ai(e) {
  for (var t = null; e !== null; )
    e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode;
  return t;
}
var li = _o(gn, ci);
var ui = f.forwardRef(function(e, t) {
  return f.createElement($e, z({}, e, { ref: t, sideCar: li }));
});
ui.classNames = $e.classNames;
var fi = "VisuallyHidden";
var di = f.forwardRef(
  (e, t) => dr.jsx(
    oe.span,
    {
      ...e,
      ref: t,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...e.style
      }
    }
  )
);
di.displayName = fi;

// node_modules/zudoku/lib/SidebarBadge-DmI5hT04.js
var s = __toESM(require_react(), 1);
function Pe(e, t) {
  return s.useReducer((o, n) => t[o][n] ?? o, e);
}
var w2 = (e) => {
  const { present: t, children: o } = e, n = Se2(t), r = typeof o == "function" ? o({ present: n.isPresent }) : s.Children.only(o), a = ce(n.ref, Me2(r));
  return typeof o == "function" || n.isPresent ? s.cloneElement(r, { ref: a }) : null;
};
w2.displayName = "Presence";
function Se2(e) {
  const [t, o] = s.useState(), n = s.useRef({}), r = s.useRef(e), a = s.useRef("none"), u = e ? "mounted" : "unmounted", [d, l] = Pe(u, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return s.useEffect(() => {
    const c = A2(n.current);
    a.current = d === "mounted" ? c : "none";
  }, [d]), Ee(() => {
    const c = n.current, g = r.current;
    if (g !== e) {
      const b2 = a.current, m = A2(c);
      e ? l("MOUNT") : m === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(g && b2 !== m ? "ANIMATION_OUT" : "UNMOUNT"), r.current = e;
    }
  }, [e, l]), Ee(() => {
    if (t) {
      let c;
      const g = t.ownerDocument.defaultView ?? window, v = (m) => {
        const D = A2(n.current).includes(m.animationName);
        if (m.target === t && D && (l("ANIMATION_END"), !r.current)) {
          const h = t.style.animationFillMode;
          t.style.animationFillMode = "forwards", c = g.setTimeout(() => {
            t.style.animationFillMode === "forwards" && (t.style.animationFillMode = h);
          });
        }
      }, b2 = (m) => {
        m.target === t && (a.current = A2(n.current));
      };
      return t.addEventListener("animationstart", b2), t.addEventListener("animationcancel", v), t.addEventListener("animationend", v), () => {
        g.clearTimeout(c), t.removeEventListener("animationstart", b2), t.removeEventListener("animationcancel", v), t.removeEventListener("animationend", v);
      };
    } else
      l("ANIMATION_END");
  }, [t, l]), {
    isPresent: ["mounted", "unmountSuspended"].includes(d),
    ref: s.useCallback((c) => {
      c && (n.current = getComputedStyle(c)), o(c);
    }, [])
  };
}
function A2(e) {
  return (e == null ? void 0 : e.animationName) || "none";
}
function Me2(e) {
  var n, r;
  let t = (n = Object.getOwnPropertyDescriptor(e.props, "ref")) == null ? void 0 : n.get, o = t && "isReactWarning" in t && t.isReactWarning;
  return o ? e.ref : (t = (r = Object.getOwnPropertyDescriptor(e, "ref")) == null ? void 0 : r.get, o = t && "isReactWarning" in t && t.isReactWarning, o ? e.props.ref : e.props.ref || e.ref);
}
var j = "rovingFocusGroup.onEntryFocus";
var je3 = { bubbles: false, cancelable: true };
var O2 = "RovingFocusGroup";
var [k2, Y2, ke3] = Ai(O2);
var [Le, at2] = zt(
  O2,
  [ke3]
);
var [Ge2, Ue2] = Le(O2);
var H3 = s.forwardRef(
  (e, t) => dr.jsx(k2.Provider, { scope: e.__scopeRovingFocusGroup, children: dr.jsx(k2.Slot, { scope: e.__scopeRovingFocusGroup, children: dr.jsx(We2, { ...e, ref: t }) }) })
);
H3.displayName = O2;
var We2 = s.forwardRef((e, t) => {
  const {
    __scopeRovingFocusGroup: o,
    orientation: n,
    loop: r = false,
    dir: a,
    currentTabStopId: u,
    defaultCurrentTabStopId: d,
    onCurrentTabStopIdChange: l,
    onEntryFocus: c,
    preventScrollOnEntryFocus: g = false,
    ...v
  } = e, b2 = s.useRef(null), m = ce(t, b2), f2 = Pi(a), [D = null, h] = Si({
    prop: u,
    defaultProp: d,
    onChange: l
  }), [I2, C] = s.useState(false), P2 = ee(c), ge2 = Y2(o), S = s.useRef(false), [pe2, K2] = s.useState(0);
  return s.useEffect(() => {
    const p = b2.current;
    if (p)
      return p.addEventListener(j, P2), () => p.removeEventListener(j, P2);
  }, [P2]), dr.jsx(
    Ge2,
    {
      scope: o,
      orientation: n,
      dir: f2,
      loop: r,
      currentTabStopId: D,
      onItemFocus: s.useCallback(
        (p) => h(p),
        [h]
      ),
      onItemShiftTab: s.useCallback(() => C(true), []),
      onFocusableItemAdd: s.useCallback(
        () => K2((p) => p + 1),
        []
      ),
      onFocusableItemRemove: s.useCallback(
        () => K2((p) => p - 1),
        []
      ),
      children: dr.jsx(
        oe.div,
        {
          tabIndex: I2 || pe2 === 0 ? -1 : 0,
          "data-orientation": n,
          ...v,
          ref: m,
          style: { outline: "none", ...e.style },
          onMouseDown: Ve(e.onMouseDown, () => {
            S.current = true;
          }),
          onFocus: Ve(e.onFocus, (p) => {
            const me2 = !S.current;
            if (p.target === p.currentTarget && me2 && !I2) {
              const B2 = new CustomEvent(j, je3);
              if (p.currentTarget.dispatchEvent(B2), !B2.defaultPrevented) {
                const M = ge2().filter((N) => N.focusable), ve2 = M.find((N) => N.active), Re = M.find((N) => N.id === D), xe2 = [ve2, Re, ...M].filter(
                  Boolean
                ).map((N) => N.ref.current);
                Z2(xe2, g);
              }
            }
            S.current = false;
          }),
          onBlur: Ve(e.onBlur, () => C(false))
        }
      )
    }
  );
});
var z2 = "RovingFocusGroupItem";
var q2 = s.forwardRef(
  (e, t) => {
    const {
      __scopeRovingFocusGroup: o,
      focusable: n = true,
      active: r = false,
      tabStopId: a,
      ...u
    } = e, d = Oi(), l = a || d, c = Ue2(z2, o), g = c.currentTabStopId === l, v = Y2(o), { onFocusableItemAdd: b2, onFocusableItemRemove: m } = c;
    return s.useEffect(() => {
      if (n)
        return b2(), () => m();
    }, [n, b2, m]), dr.jsx(
      k2.ItemSlot,
      {
        scope: o,
        id: l,
        focusable: n,
        active: r,
        children: dr.jsx(
          oe.span,
          {
            tabIndex: g ? 0 : -1,
            "data-orientation": c.orientation,
            ...u,
            ref: t,
            onMouseDown: Ve(e.onMouseDown, (f2) => {
              n ? c.onItemFocus(l) : f2.preventDefault();
            }),
            onFocus: Ve(e.onFocus, () => c.onItemFocus(l)),
            onKeyDown: Ve(e.onKeyDown, (f2) => {
              if (f2.key === "Tab" && f2.shiftKey) {
                c.onItemShiftTab();
                return;
              }
              if (f2.target !== f2.currentTarget) return;
              const D = $e2(f2, c.orientation, c.dir);
              if (D !== void 0) {
                if (f2.metaKey || f2.ctrlKey || f2.altKey || f2.shiftKey) return;
                f2.preventDefault();
                let I2 = v().filter((C) => C.focusable).map((C) => C.ref.current);
                if (D === "last") I2.reverse();
                else if (D === "prev" || D === "next") {
                  D === "prev" && I2.reverse();
                  const C = I2.indexOf(f2.currentTarget);
                  I2 = c.loop ? Ve2(I2, C + 1) : I2.slice(C + 1);
                }
                setTimeout(() => Z2(I2));
              }
            })
          }
        )
      }
    );
  }
);
q2.displayName = z2;
var Ke2 = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function Be2(e, t) {
  return t !== "rtl" ? e : e === "ArrowLeft" ? "ArrowRight" : e === "ArrowRight" ? "ArrowLeft" : e;
}
function $e2(e, t, o) {
  const n = Be2(e.key, o);
  if (!(t === "vertical" && ["ArrowLeft", "ArrowRight"].includes(n)) && !(t === "horizontal" && ["ArrowUp", "ArrowDown"].includes(n)))
    return Ke2[n];
}
function Z2(e, t = false) {
  const o = document.activeElement;
  for (const n of e)
    if (n === o || (n.focus({ preventScroll: t }), document.activeElement !== o)) return;
}
function Ve2(e, t) {
  return e.map((o, n) => e[(t + n) % e.length]);
}
var st2 = H3;
var it2 = q2;
var L2 = "Dialog";
var [J3, ct2] = Ci(L2);
var [Ye2, x2] = J3(L2);
var Q2 = (e) => {
  const {
    __scopeDialog: t,
    children: o,
    open: n,
    defaultOpen: r,
    onOpenChange: a,
    modal: u = true
  } = e, d = s.useRef(null), l = s.useRef(null), [c = false, g] = Si({
    prop: n,
    defaultProp: r,
    onChange: a
  });
  return dr.jsx(
    Ye2,
    {
      scope: t,
      triggerRef: d,
      contentRef: l,
      contentId: Oi(),
      titleId: Oi(),
      descriptionId: Oi(),
      open: c,
      onOpenChange: g,
      onOpenToggle: s.useCallback(() => g((v) => !v), [g]),
      modal: u,
      children: o
    }
  );
};
Q2.displayName = L2;
var X = "DialogTrigger";
var ee2 = s.forwardRef(
  (e, t) => {
    const { __scopeDialog: o, ...n } = e, r = x2(X, o), a = ce(t, r.triggerRef);
    return dr.jsx(
      oe.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": r.open,
        "aria-controls": r.contentId,
        "data-state": W2(r.open),
        ...n,
        ref: a,
        onClick: Ve(e.onClick, r.onOpenToggle)
      }
    );
  }
);
ee2.displayName = X;
var G2 = "DialogPortal";
var [He2, te2] = J3(G2, {
  forceMount: void 0
});
var ne2 = (e) => {
  const { __scopeDialog: t, forceMount: o, children: n, container: r } = e, a = x2(G2, t);
  return dr.jsx(He2, { scope: t, forceMount: o, children: s.Children.map(n, (u) => dr.jsx(w2, { present: o || a.open, children: dr.jsx(So, { asChild: true, container: r, children: u }) })) });
};
ne2.displayName = G2;
var F3 = "DialogOverlay";
var oe2 = s.forwardRef(
  (e, t) => {
    const o = te2(F3, e.__scopeDialog), { forceMount: n = o.forceMount, ...r } = e, a = x2(F3, e.__scopeDialog);
    return a.modal ? dr.jsx(w2, { present: n || a.open, children: dr.jsx(ze2, { ...r, ref: t }) }) : null;
  }
);
oe2.displayName = F3;
var ze2 = s.forwardRef(
  (e, t) => {
    const { __scopeDialog: o, ...n } = e, r = x2(F3, o);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      dr.jsx(ui, { as: be, allowPinchZoom: true, shards: [r.contentRef], children: dr.jsx(
        oe.div,
        {
          "data-state": W2(r.open),
          ...n,
          ref: t,
          style: { pointerEvents: "auto", ...n.style }
        }
      ) })
    );
  }
);
var E2 = "DialogContent";
var re2 = s.forwardRef(
  (e, t) => {
    const o = te2(E2, e.__scopeDialog), { forceMount: n = o.forceMount, ...r } = e, a = x2(E2, e.__scopeDialog);
    return dr.jsx(w2, { present: n || a.open, children: a.modal ? dr.jsx(qe2, { ...r, ref: t }) : dr.jsx(Ze2, { ...r, ref: t }) });
  }
);
re2.displayName = E2;
var qe2 = s.forwardRef(
  (e, t) => {
    const o = x2(E2, e.__scopeDialog), n = s.useRef(null), r = ce(t, o.contentRef, n);
    return s.useEffect(() => {
      const a = n.current;
      if (a) return ki(a);
    }, []), dr.jsx(
      ae2,
      {
        ...e,
        ref: r,
        trapFocus: o.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: Ve(e.onCloseAutoFocus, (a) => {
          var u;
          a.preventDefault(), (u = o.triggerRef.current) == null || u.focus();
        }),
        onPointerDownOutside: Ve(e.onPointerDownOutside, (a) => {
          const u = a.detail.originalEvent, d = u.button === 0 && u.ctrlKey === true;
          (u.button === 2 || d) && a.preventDefault();
        }),
        onFocusOutside: Ve(
          e.onFocusOutside,
          (a) => a.preventDefault()
        )
      }
    );
  }
);
var Ze2 = s.forwardRef(
  (e, t) => {
    const o = x2(E2, e.__scopeDialog), n = s.useRef(false), r = s.useRef(false);
    return dr.jsx(
      ae2,
      {
        ...e,
        ref: t,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (a) => {
          var u, d;
          (u = e.onCloseAutoFocus) == null || u.call(e, a), a.defaultPrevented || (n.current || (d = o.triggerRef.current) == null || d.focus(), a.preventDefault()), n.current = false, r.current = false;
        },
        onInteractOutside: (a) => {
          var l, c;
          (l = e.onInteractOutside) == null || l.call(e, a), a.defaultPrevented || (n.current = true, a.detail.originalEvent.type === "pointerdown" && (r.current = true));
          const u = a.target;
          ((c = o.triggerRef.current) == null ? void 0 : c.contains(u)) && a.preventDefault(), a.detail.originalEvent.type === "focusin" && r.current && a.preventDefault();
        }
      }
    );
  }
);
var ae2 = s.forwardRef(
  (e, t) => {
    const { __scopeDialog: o, trapFocus: n, onOpenAutoFocus: r, onCloseAutoFocus: a, ...u } = e, d = x2(E2, o), l = s.useRef(null), c = ce(t, l);
    return Ri(), dr.jsxs(dr.Fragment, { children: [
      dr.jsx(
        hr,
        {
          asChild: true,
          loop: true,
          trapped: n,
          onMountAutoFocus: r,
          onUnmountAutoFocus: a,
          children: dr.jsx(
            cr,
            {
              role: "dialog",
              id: d.contentId,
              "aria-describedby": d.descriptionId,
              "aria-labelledby": d.titleId,
              "data-state": W2(d.open),
              ...u,
              ref: c,
              onDismiss: () => d.onOpenChange(false)
            }
          )
        }
      ),
      dr.jsxs(dr.Fragment, { children: [
        dr.jsx(Je2, { titleId: d.titleId }),
        dr.jsx(Xe2, { contentRef: l, descriptionId: d.descriptionId })
      ] })
    ] });
  }
);
var U2 = "DialogTitle";
var se2 = s.forwardRef(
  (e, t) => {
    const { __scopeDialog: o, ...n } = e, r = x2(U2, o);
    return dr.jsx(oe.h2, { id: r.titleId, ...n, ref: t });
  }
);
se2.displayName = U2;
var ie2 = "DialogDescription";
var ce2 = s.forwardRef(
  (e, t) => {
    const { __scopeDialog: o, ...n } = e, r = x2(ie2, o);
    return dr.jsx(oe.p, { id: r.descriptionId, ...n, ref: t });
  }
);
ce2.displayName = ie2;
var ue2 = "DialogClose";
var le2 = s.forwardRef(
  (e, t) => {
    const { __scopeDialog: o, ...n } = e, r = x2(ue2, o);
    return dr.jsx(
      oe.button,
      {
        type: "button",
        ...n,
        ref: t,
        onClick: Ve(e.onClick, () => r.onOpenChange(false))
      }
    );
  }
);
le2.displayName = ue2;
function W2(e) {
  return e ? "open" : "closed";
}
var de2 = "DialogTitleWarning";
var [ut2, fe2] = Ei(de2, {
  contentName: E2,
  titleName: U2,
  docsSlug: "dialog"
});
var Je2 = ({ titleId: e }) => {
  const t = fe2(de2), o = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`;
  return s.useEffect(() => {
    e && (document.getElementById(e) || console.error(o));
  }, [o, e]), null;
};
var Qe2 = "DialogDescriptionWarning";
var Xe2 = ({ contentRef: e, descriptionId: t }) => {
  const n = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${fe2(Qe2).contentName}}.`;
  return s.useEffect(() => {
    var a;
    const r = (a = e.current) == null ? void 0 : a.getAttribute("aria-describedby");
    t && r && (document.getElementById(t) || console.warn(n));
  }, [n, e, t]), null;
};
var lt2 = Q2;
var dt = ee2;
var ft2 = ne2;
var gt2 = oe2;
var pt = re2;
var mt = se2;
var vt = ce2;
var Rt2 = le2;
var xt2 = {
  green: "text-green-600",
  blue: "text-sky-600",
  yellow: "text-yellow-600",
  red: "text-red-600",
  purple: "text-purple-600",
  indigo: "text-indigo-600",
  gray: "text-gray-600"
};
var et2 = {
  green: "bg-green-400 dark:bg-green-800",
  blue: "bg-sky-400 dark:bg-sky-800",
  yellow: "bg-yellow-400 dark:bg-yellow-800",
  red: "bg-red-400 dark:bg-red-800",
  purple: "bg-purple-400 dark:bg-purple-600",
  indigo: "bg-indigo-400 dark:bg-indigo-600",
  gray: "bg-gray-400 dark:bg-gray-600"
};
var bt4 = ({
  color: e,
  label: t,
  className: o
}) => dr.jsx(
  "span",
  {
    className: bt2(
      "mt-0.5 flex items-center duration-200 transition-opacity text-center uppercase font-mono text-[0.65rem] font-bold rounded text-background dark:text-zinc-50 h-4 px-1",
      et2[e],
      o
    ),
    children: t
  }
);

// node_modules/zudoku/lib/Spinner-3cQDBVGr.js
var i = ({ size: r = 16 }) => dr.jsx(LoaderCircle, { size: r, className: "animate-spin" });

export {
  A,
  Vt,
  ce,
  be,
  Gn,
  xi,
  Zn,
  bi,
  Ve,
  Ci,
  ee,
  Si,
  oe,
  er,
  Ai,
  Pi,
  cr,
  Ri,
  hr,
  Ee,
  Oi,
  Mi,
  Ti,
  Li,
  Ni,
  Di,
  So,
  ki,
  ui,
  di,
  w2 as w,
  at2 as at,
  st2 as st,
  it2 as it,
  lt2 as lt,
  dt,
  ft2 as ft,
  gt2 as gt,
  pt,
  mt,
  vt,
  Rt2 as Rt,
  xt2 as xt,
  bt4 as bt,
  i
};
//# sourceMappingURL=chunk-RJUI5L33.js.map
